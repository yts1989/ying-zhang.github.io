{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/doc/cobbler-setting.txt","path":"doc/cobbler-setting.txt","modified":0,"renderable":0},{"_id":"source/doc/crack_xls_vb.txt","path":"doc/crack_xls_vb.txt","modified":0,"renderable":0},{"_id":"source/doc/ifcfg-ens33","path":"doc/ifcfg-ens33","modified":0,"renderable":0},{"_id":"source/doc/win10.reg","path":"doc/win10.reg","modified":0,"renderable":0},{"_id":"source/img/ccf_sum.png","path":"img/ccf_sum.png","modified":0,"renderable":0},{"_id":"source/img/phree-structure.jpg","path":"img/phree-structure.jpg","modified":0,"renderable":0},{"_id":"source/img/pubs.png","path":"img/pubs.png","modified":0,"renderable":0},{"_id":"source/img/pxe-boot-config.png","path":"img/pxe-boot-config.png","modified":0,"renderable":0},{"_id":"source/img/pxe-boot-menu.png","path":"img/pxe-boot-menu.png","modified":0,"renderable":0},{"_id":"source/img/sftp.png","path":"img/sftp.png","modified":0,"renderable":0},{"_id":"source/img/spanner-availability.png","path":"img/spanner-availability.png","modified":0,"renderable":0},{"_id":"source/img/spotlitght-design.jpg","path":"img/spotlitght-design.jpg","modified":0,"renderable":0},{"_id":"source/img/udpn-baidu-ime.png","path":"img/udpn-baidu-ime.png","modified":0,"renderable":0},{"_id":"source/img/udpn-demo.png","path":"img/udpn-demo.png","modified":0,"renderable":0},{"_id":"source/img/vbox-headless.png","path":"img/vbox-headless.png","modified":0,"renderable":0},{"_id":"source/img/vbox-hostonly-nic.png","path":"img/vbox-hostonly-nic.png","modified":0,"renderable":0},{"_id":"source/img/vbox-snapshot.png","path":"img/vbox-snapshot.png","modified":0,"renderable":0},{"_id":"source/img/vboxconf-NatNetwork.png","path":"img/vboxconf-NatNetwork.png","modified":0,"renderable":0},{"_id":"source/img/vboxconf-hostonly.png","path":"img/vboxconf-hostonly.png","modified":0,"renderable":0},{"_id":"source/img/vboxsetting-net.png","path":"img/vboxsetting-net.png","modified":0,"renderable":0},{"_id":"source/img/vboxsetting-store.png","path":"img/vboxsetting-store.png","modified":0,"renderable":0},{"_id":"source/img/vczh-on-config.png","path":"img/vczh-on-config.png","modified":0,"renderable":0},{"_id":"source/img/vm-tty.png","path":"img/vm-tty.png","modified":0,"renderable":0},{"_id":"source/img/vmware-snapshot.png","path":"img/vmware-snapshot.png","modified":0,"renderable":0},{"_id":"source/img/vnet.png","path":"img/vnet.png","modified":0,"renderable":0},{"_id":"source/img/wifi-router.png","path":"img/wifi-router.png","modified":0,"renderable":0},{"_id":"source/img/win-mstsc-svr.png","path":"img/win-mstsc-svr.png","modified":0,"renderable":0},{"_id":"source/img/win-mstsc.png","path":"img/win-mstsc.png","modified":0,"renderable":0},{"_id":"source/img/win-share.png","path":"img/win-share.png","modified":0,"renderable":0},{"_id":"source/img/xshell-key.png","path":"img/xshell-key.png","modified":0,"renderable":0},{"_id":"source/img/xshell-prop.png","path":"img/xshell-prop.png","modified":0,"renderable":0},{"_id":"source/img/xshell-ui.png","path":"img/xshell-ui.png","modified":0,"renderable":0},{"_id":"source/img/zhuge.jpg","path":"img/zhuge.jpg","modified":0,"renderable":0},{"_id":"source/doc/ccf_all_in_one_2017-02-25.xlsx","path":"doc/ccf_all_in_one_2017-02-25.xlsx","modified":0,"renderable":0},{"_id":"source/img/osdi16-firmament-fig2.png","path":"img/osdi16-firmament-fig2.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-morpheus.png","path":"img/osdi16-morpheus.png","modified":0,"renderable":0},{"_id":"source/img/phree.jpg","path":"img/phree.jpg","modified":0,"renderable":0},{"_id":"source/img/scholar_adv.png","path":"img/scholar_adv.png","modified":0,"renderable":0},{"_id":"source/img/smb.png","path":"img/smb.png","modified":0,"renderable":0},{"_id":"source/img/sock5-proxy.png","path":"img/sock5-proxy.png","modified":0,"renderable":0},{"_id":"source/img/spotlitght-spec.png","path":"img/spotlitght-spec.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-fig2.png","path":"img/tpds15-job-taxonomy-fig2.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-group.png","path":"img/tpds15-job-taxonomy-group.png","modified":0,"renderable":0},{"_id":"source/img/udpn-ms-map.png","path":"img/udpn-ms-map.png","modified":0,"renderable":0},{"_id":"source/img/vnet-vxlan.png","path":"img/vnet-vxlan.png","modified":0,"renderable":0},{"_id":"source/doc/Spanner-TrueTime-CAP.docx","path":"doc/Spanner-TrueTime-CAP.docx","modified":0,"renderable":0},{"_id":"source/img/4books_IMG_20150328_201923.jpg","path":"img/4books_IMG_20150328_201923.jpg","modified":0,"renderable":0},{"_id":"source/img/borg-fig-12.png","path":"img/borg-fig-12.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-carbyne.png","path":"img/osdi16-carbyne.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-fig1.png","path":"img/tpds15-job-taxonomy-fig1.png","modified":0,"renderable":0},{"_id":"themes/jane/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jane/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jane/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"source/doc/ccf-all-in-one-2017-02-25.html","path":"doc/ccf-all-in-one-2017-02-25.html","modified":0,"renderable":0},{"_id":"source/doc/shuang_pin_udpn_cheetsheet.pdf","path":"doc/shuang_pin_udpn_cheetsheet.pdf","modified":0,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/hpc-feature-alg.png","path":"img/hpc-feature-alg.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-harvest.png","path":"img/osdi16-harvest.png","modified":0,"renderable":0},{"_id":"source/img/udpn-iflyrec-meeting.png","path":"img/udpn-iflyrec-meeting.png","modified":0,"renderable":0},{"_id":"source/img/udpn-iflyrec-rec.png","path":"img/udpn-iflyrec-rec.png","modified":0,"renderable":0},{"_id":"source/img/vnet-pk.png","path":"img/vnet-pk.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-firmament-blog-table.png","path":"img/osdi16-firmament-blog-table.png","modified":0,"renderable":0},{"_id":"themes/jane/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"source/img/xpen-shape.jpg","path":"img/xpen-shape.jpg","modified":0,"renderable":0},{"_id":"source/img/spanner-books.jpg","path":"img/spanner-books.jpg","modified":0,"renderable":0},{"_id":"source/doc/SCI_E_Web_of_Science.pdf","path":"doc/SCI_E_Web_of_Science.pdf","modified":0,"renderable":0},{"_id":"source/doc/Spanner-TrueTime-CAP.pdf","path":"doc/Spanner-TrueTime-CAP.pdf","modified":0,"renderable":0},{"_id":"source/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","path":"doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","modified":0,"renderable":0},{"_id":"source/img/lib.png","path":"img/lib.png","modified":0,"renderable":0},{"_id":"source/img/google_dc2.jpg","path":"img/google_dc2.jpg","modified":0,"renderable":0},{"_id":"source/img/google_dc1.jpg","path":"img/google_dc1.jpg","modified":0,"renderable":0},{"_id":"source/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","path":"doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","modified":0,"renderable":0},{"_id":"source/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","path":"doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","modified":0,"renderable":0},{"_id":"source/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","path":"doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","modified":0,"renderable":0},{"_id":"source/doc/graduate_student_huang_yihua_2011_ppt.pdf","path":"doc/graduate_student_huang_yihua_2011_ppt.pdf","modified":0,"renderable":0},{"_id":"source/doc/walden.pdf","path":"doc/walden.pdf","modified":0,"renderable":0},{"_id":"source/doc/mpich-3.2-build.tar.gz","path":"doc/mpich-3.2-build.tar.gz","modified":0,"renderable":0},{"_id":"source/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","path":"doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","modified":0,"renderable":0},{"_id":"source/img/borg-fig-04.png","path":"img/borg-fig-04.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-10.png","path":"img/borg-fig-10.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-01.png","path":"img/borg-fig-01.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-02.png","path":"img/borg-fig-02.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-03.png","path":"img/borg-fig-03.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-06.png","path":"img/borg-fig-06.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-09.png","path":"img/borg-fig-09.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-08.png","path":"img/borg-fig-08.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-05.png","path":"img/borg-fig-05.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-07.png","path":"img/borg-fig-07.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-11.png","path":"img/borg-fig-11.png","modified":1,"renderable":0},{"_id":"source/img/borg-fig-13.png","path":"img/borg-fig-13.png","modified":1,"renderable":0},{"_id":"source/doc/EuroSys15_Borg.pdf","path":"doc/EuroSys15_Borg.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"themes/jane/.gitignore","hash":"95f03058c57e530d66593f3a5feaa7e77c21a385","modified":1485230759000},{"_id":"themes/jane/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1485230759000},{"_id":"themes/jane/LICENSE","hash":"adc990ffa703c0bb86fd4a6ad4dce182f7caf0d2","modified":1485230759000},{"_id":"themes/jane/README.md","hash":"ea0c739c2241216eead290f2570d5e61c14b26c8","modified":1485230759000},{"_id":"themes/jane/_config.yml","hash":"e827d0d3c3d29763fa7a1cc6056eaaae62d2dc16","modified":1495079023776},{"_id":"themes/jane/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1485230759000},{"_id":"source/_posts/ccf-all-in-one.md","hash":"d2a3fd398c4f3a94f91ec3fca36d5e054788ea6f","modified":1509331686698},{"_id":"source/_posts/a-story-of-stylus.md","hash":"1a2b005416c5b8739677a456d2745485bf6f82d2","modified":1509334853939},{"_id":"source/_posts/cobbler-pxe.md","hash":"080d393a66e0c19940bc25f3074acbfddc0e05c0","modified":1509331683321},{"_id":"source/_posts/docker-image-spec-v1.2.md","hash":"a0510c77943e8e9bc15aab522d7ca5d73183f154","modified":1509334867104},{"_id":"source/_posts/hello-hexo.md","hash":"16de4615264eb1e1ef67131a1671c051b84e7085","modified":1509335510679},{"_id":"source/_posts/install-linpack-xhpl.md","hash":"fb34fef166f0599ee15b7e9a02f9de9bcc99e381","modified":1509334878346},{"_id":"source/_posts/install-ubuntu.md","hash":"bbb30300d3b12054b07df7c39537c4616ddfbd80","modified":1509331672591},{"_id":"source/_posts/install-win-10.md","hash":"c0bc82ee6f30299e8a7e79b9b45f0cd69afbf087","modified":1509334943339},{"_id":"source/_posts/obstinate-are-the-trammels.md","hash":"afc53ed2f5509b42a21392537ffd53fbfdc52f77","modified":1509334934856},{"_id":"source/_posts/remote.md","hash":"209f7c5dd6045d0dec33fbbcb2e2f5abb2d27ff6","modified":1509331665881},{"_id":"source/_posts/setup-nat-x-route.md","hash":"c4ff4368b485d3701cf3c70df7fbc4f144eb95c4","modified":1509334926185},{"_id":"source/_posts/setup-squid-proxy.md","hash":"43d5fbabb73fcdfa2e65f3cdc0c45c3c432af86c","modified":1509331643292},{"_id":"source/_posts/udpnuurufa.md","hash":"2076a8670cd63ca3a9a5db570f68df258e9bbf2e","modified":1509331573717},{"_id":"source/_posts/vm-disk.md","hash":"2bb1097af6a57531ef818fac93644051bd1d4923","modified":1509334910175},{"_id":"source/_posts/spanner-truetime-cap.md","hash":"8cdd3691bda2c08487830924b0d0dc030c8c9754","modified":1509334916842},{"_id":"source/_posts/vm-net.md","hash":"ae5f3ea5581e14b75af28e4305acf4ddf0f9df99","modified":1509334895085},{"_id":"source/_posts/vm-net-2.md","hash":"bd21c7791e8e9c82370a7ec14d71354aedff6f58","modified":1509334903317},{"_id":"source/_posts/win-vhd-boot.md","hash":"e2702572e322c5ee5adbb95673c6e7fa24002c5e","modified":1509335000473},{"_id":"source/_posts/we-love-paper.md","hash":"dbaee78541a5d2d2e891561fb5d5c38d806ecc96","modified":1509331596398},{"_id":"source/doc/cobbler-setting.txt","hash":"507e3403def7ed5cae195a487d7aa03c42a251d0","modified":1495089884692},{"_id":"source/doc/crack_xls_vb.txt","hash":"667c8a9b1c69a61926020a490fec259ae1a15086","modified":1495089884692},{"_id":"source/doc/ifcfg-ens33","hash":"e0641b4695e366b26423a750c1c826eed4340d5b","modified":1495089884708},{"_id":"source/doc/phd15-christ-bib.txt","hash":"70d567223741e29a2a5db47f61d1b393854f5660","modified":1495089884723},{"_id":"source/doc/win10.reg","hash":"50983212c92d0833e3139146f5e144151a9ea049","modified":1507963754955},{"_id":"source/img/ccf_sum.png","hash":"17e7753baf957a2957a618208782b331f866e7f1","modified":1495089884723},{"_id":"source/img/phree-structure.jpg","hash":"30a0f63fa34cc2347df69a4fbc46ae949a359ea4","modified":1495304733624},{"_id":"source/img/pubs.png","hash":"1fc6cddbc0c1be58c31db5e93defee407f2d3922","modified":1495089884739},{"_id":"source/img/pxe-boot-config.png","hash":"b95615d4bb5f3bddfd935bb39d8f175f7bbccc7b","modified":1495089884739},{"_id":"source/img/pxe-boot-menu.png","hash":"15933bf27545906ea1c64bb50c2c121e5d32250b","modified":1495089884739},{"_id":"source/img/sftp.png","hash":"7373204fba311d4bbc2a1304ae5100699380ca6d","modified":1495089884739},{"_id":"source/img/spanner-availability.png","hash":"b279e4c2968ec7fac756513fbcb481f58001d325","modified":1495089884739},{"_id":"source/img/spotlitght-design.jpg","hash":"2f7c5d89dea1871848d4fe4bbd2571e9ce5e60b7","modified":1508071646436},{"_id":"source/img/udpn-baidu-ime.png","hash":"6b1c7fd246ac1da9fa0f30629b67ad751385e59b","modified":1495089884754},{"_id":"source/img/udpn-demo.png","hash":"f8330f796c3ae26a4cf868198bb8c1ef109d9a3b","modified":1495089884754},{"_id":"source/img/vbox-headless.png","hash":"f80ff69fc94dae4a97e3af79be242aae83f0b38b","modified":1504250960404},{"_id":"source/img/vbox-hostonly-nic.png","hash":"cb704943d0a7cf2c96c35c466f8192280278bbbe","modified":1495089884754},{"_id":"source/img/vbox-snapshot.png","hash":"96c2748ced55acd07d6a7394240b46095eb6ca25","modified":1495089884754},{"_id":"source/img/vboxconf-NatNetwork.png","hash":"2431472e03648fc9d3a4087b79dfddf2ee7e1c4a","modified":1495089884754},{"_id":"source/img/vboxconf-hostonly.png","hash":"faaf51e8bbd50faebb98b4cb001f3fd259edfc6f","modified":1495089884754},{"_id":"source/img/vboxsetting-net.png","hash":"effe5b8616f55bad9ecea8d8d52dd79ce1aa3957","modified":1495089884754},{"_id":"source/img/vboxsetting-store.png","hash":"6886271d1e0f59245216e96c507432cbee83ccad","modified":1495089884754},{"_id":"source/img/vczh-on-config.png","hash":"bd28ac541389f4357a55f681e0bfe8022b7d2cf3","modified":1495089884754},{"_id":"source/img/vm-tty.png","hash":"b005e82faf82e8f194317913516db984cd519632","modified":1495089884754},{"_id":"source/img/vmware-snapshot.png","hash":"c9391e15ccb4f1f6542634ad4a20e90b6941ba4a","modified":1495089884754},{"_id":"source/img/vnet.png","hash":"d94f637a8d638ef044a4eb2c399c22d75ee80285","modified":1495089884754},{"_id":"source/img/wifi-router.png","hash":"7aaa176ae16e574fac4f7a7861ffd6cbe13c258c","modified":1495089884754},{"_id":"source/img/win-mstsc-svr.png","hash":"454f2246ab116191aae15f458e2b78b605e7827e","modified":1495089884754},{"_id":"source/img/win-mstsc.png","hash":"3f631d2d7653ca872508d052bb7c819d341d809b","modified":1495089884754},{"_id":"source/img/win-share.png","hash":"1f942562e7930612939a728265315b6db4f68d47","modified":1495089884754},{"_id":"source/img/xshell-key.png","hash":"18f9d471cf3de56ef325f10c6f0eb17f588a1689","modified":1495089884754},{"_id":"source/img/xshell-prop.png","hash":"637a498356615c059d19143a95a17f324fbf6b50","modified":1504248205719},{"_id":"source/img/xshell-ui.png","hash":"d60047895e00970596430de0666228ddc922d1f1","modified":1504248323853},{"_id":"source/img/zhuge.jpg","hash":"b6819904a87d60784c282c166d9dde57e28e2fde","modified":1495089884754},{"_id":"themes/jane/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1485230759000},{"_id":"themes/jane/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1485230759000},{"_id":"themes/jane/layout/layout.ejs","hash":"57a2290d59da470c618201b6d19c1805359bd6c3","modified":1485230759000},{"_id":"themes/jane/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1485230759000},{"_id":"themes/jane/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1485230759000},{"_id":"themes/jane/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1485230759000},{"_id":"themes/jane/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1485230759000},{"_id":"themes/jane/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1485230759000},{"_id":"source/doc/ccf_all_in_one_2017-02-25.xlsx","hash":"684520981f114a3907eda9c6f36f43c883479813","modified":1495089884692},{"_id":"source/img/osdi16-firmament-fig2.png","hash":"d068b6fa4329f220766c06668bc215a8709a03df","modified":1495089884739},{"_id":"source/img/osdi16-morpheus.png","hash":"0b181cf535dc99cac51a348949f6c437d633fb10","modified":1495089884739},{"_id":"source/img/phree.jpg","hash":"996fed0e72973c85df38d84f2ea1689bdfe59de4","modified":1495309307522},{"_id":"source/img/scholar_adv.png","hash":"9597042c1dae98b1da7c1b9b4cd440840ac98eb1","modified":1495089884739},{"_id":"source/img/smb.png","hash":"a2cafa61ae8bc92f4840216fc3a4c65876d1baf4","modified":1495089884739},{"_id":"source/img/sock5-proxy.png","hash":"165f6cd9972eec88507f7723bd20ab5531e6bd7d","modified":1495089884739},{"_id":"source/img/spotlitght-spec.png","hash":"eae78e4243da526a92243b471920e45ebf9fe36b","modified":1508071704737},{"_id":"source/img/tpds15-job-taxonomy-fig2.png","hash":"3d13644cee2af40c2674a9462a28f83282b8c6d6","modified":1495089884754},{"_id":"source/img/tpds15-job-taxonomy-group.png","hash":"e4b4e184d1c9675ee1447e4ffc57b36fd72fe613","modified":1495089884754},{"_id":"source/img/udpn-ms-map.png","hash":"64fdff00586fd43395714ff6e3787377b1958577","modified":1495089884754},{"_id":"source/img/vnet-vxlan.png","hash":"5547ebdd1e6899fe0d89cfc785101a8d309f0771","modified":1495089884754},{"_id":"source/_posts/.vs/ProjectSettings.json","hash":"d390b4c3a94b45bda4448735b254f33174d7a881","modified":1495457309753},{"_id":"source/_posts/.vs/VSWorkspaceState.json","hash":"f4f80ec1b233e04dd77925856230368e0e850ef7","modified":1495457311132},{"_id":"source/doc/Spanner-TrueTime-CAP.docx","hash":"6dffed178fbd971285b07b2433f4f773c13a18e5","modified":1495089884629},{"_id":"source/img/4books_IMG_20150328_201923.jpg","hash":"b385ae658704c3fae24e9fa902d9e52f389e01e0","modified":1453673640000},{"_id":"source/img/borg-fig-10-11.png","hash":"f546f8c62996a7248a6a15d15aae5dcf495c5a38","modified":1495089884723},{"_id":"source/img/borg-fig-12.png","hash":"50ed9722b529d7f4b8ad41a7267749ce57d54396","modified":1495089884723},{"_id":"source/img/osdi16-carbyne.png","hash":"ab7c6851b20f436059a3af637e52a9cb91f0f483","modified":1495089884739},{"_id":"source/img/tpds15-job-taxonomy-fig1.png","hash":"adb7741820cdb1d61adc9b441b0cf43a5c243ce3","modified":1495089884754},{"_id":"themes/jane/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1485230759000},{"_id":"themes/jane/layout/_partial/after-footer.ejs","hash":"c22cce4a6a2dd353e7f6b1249518841e943c8e3b","modified":1485230759000},{"_id":"themes/jane/layout/_partial/footer.ejs","hash":"d1c793152d40e68bf45f8df2efb3dbc96bae4b76","modified":1495078599689},{"_id":"themes/jane/layout/_partial/article.ejs","hash":"a09d83726a01a0c711315a1bda0de293e522464f","modified":1485230759000},{"_id":"themes/jane/layout/_partial/archive.ejs","hash":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1485230759000},{"_id":"themes/jane/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1485230759000},{"_id":"themes/jane/layout/_partial/head.ejs","hash":"da9a4ab32efc44c098f317fe64e2335989929b0e","modified":1485230759000},{"_id":"themes/jane/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1485230759000},{"_id":"themes/jane/layout/_partial/sidebar.ejs","hash":"21424708437807559837cfc5111533737b8fe2cb","modified":1495079485437},{"_id":"themes/jane/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1485230759000},{"_id":"themes/jane/source/css/_extend.styl","hash":"ac23ccf2c0891f1729c185787e25df026039c763","modified":1488986785616},{"_id":"themes/jane/source/css/_variables.styl","hash":"b978ba8916b5839126f4856f23e4075e18f9147a","modified":1488986835902},{"_id":"themes/jane/source/css/style.styl","hash":"07f14c2fe68257417f50e934b3ef68f1f5eda34c","modified":1488986074741},{"_id":"themes/jane/source/js/script.js","hash":"453cdbc4259e13ee09def0e26afaff146f7ad501","modified":1485230759000},{"_id":"source/_posts/.vs/slnx.sqlite","hash":"72252fef0314c197dd6dec6439516153da19f6a1","modified":1495457311408},{"_id":"source/doc/ccf-all-in-one-2017-02-25.html","hash":"d251ab8f29dca1209b29cc88d26239442967029c","modified":1495089884692},{"_id":"source/doc/shuang_pin_udpn_cheetsheet.pdf","hash":"ec6375d75961f29c59c79aac1b92c515305162c1","modified":1495089884723},{"_id":"source/img/avatar.png","hash":"c46fce9b0905d4c5bf131475bc083c6faef6edfa","modified":1495089884723},{"_id":"source/img/hpc-feature-alg.png","hash":"97d1be0e9f9d0064350e37b7ba0091b8bfa8342f","modified":1495089884739},{"_id":"source/img/osdi16-harvest.png","hash":"0ef7746a98c2012ea274816105a0f8c19497a732","modified":1495089884739},{"_id":"source/img/udpn-iflyrec-meeting.png","hash":"bd5243cbb4998673506d223abb620afca6ea5e1b","modified":1495089884754},{"_id":"source/img/udpn-iflyrec-rec.png","hash":"fd820c873189a8983bd34a325f81269e232ccb94","modified":1495089884754},{"_id":"source/img/vnet-pk.png","hash":"13ca0863dea5b1fe55fbe3bfbcf900ea949c65d8","modified":1495089884754},{"_id":"source/img/osdi16-firmament-blog-table.png","hash":"73ad6d3e8707b94b88bb26f2ab6a27fe7664728a","modified":1495089884739},{"_id":"themes/jane/layout/_partial/post/category.ejs","hash":"d636f12e4a8ef3d48284cb9ec9679faddea9158a","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/archive.styl","hash":"cc77d17b4614882a2821369d8fb668819abe3708","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/article.styl","hash":"06b6fb383cc2c33728ad30e2f0e38c5d7da6c637","modified":1488986465173},{"_id":"themes/jane/source/css/_partial/footer.styl","hash":"50f0a8c85fa225e4711fbf92989da95080efde89","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/comment.styl","hash":"d5240c7b85e225af1b91dc3847c2061f5ab3e1b7","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/highlight.styl","hash":"3cf6eba8e88a4049d5b1709eb478ba2a83267c51","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/sidebar.styl","hash":"85194254dd6cda3f325cc9373517654d84fc1371","modified":1495079503265},{"_id":"themes/jane/source/css/_partial/mobile.styl","hash":"728bf47a1542503cdc4ec080749fb5bbaf642a7f","modified":1485230759000},{"_id":"themes/jane/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1485230759000},{"_id":"themes/jane/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.svg","hash":"6ddf1044a70a0c388c9b8327cc8950d5e84e9df4","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.eot","hash":"6ba3575b2f32b5fdc491a5cbeff19ec1a2258ce0","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.ttf","hash":"0936fdc72603dd9adc5a71ae46f8c00bcba7e629","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.woff","hash":"f105bd41ff679f1faa9bebb6f618426309c7033c","modified":1485230759000},{"_id":"source/img/xpen-shape.jpg","hash":"7cda0cd632a18cdaf23d3633ccec805b2b48ef34","modified":1495301051449},{"_id":"source/_posts/.vs/_posts/v15/.suo","hash":"09bf5fff98c678b4346b7bac7dd169b78d09eaab","modified":1495457311108},{"_id":"source/img/spanner-books.jpg","hash":"ebc68d4bc51e95b292d737c79e14bd5566392481","modified":1495089884739},{"_id":"source/doc/SCI_E_Web_of_Science.pdf","hash":"c714865cb741a15ce2835b003b6f35ad207d7635","modified":1495089884629},{"_id":"source/doc/Spanner-TrueTime-CAP.pdf","hash":"939a92b3b541073a3dc8b62c0dab4a3c64c73a0a","modified":1495089884629},{"_id":"source/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","hash":"595cc33bdfb97ea09aca32864c2a94b7fba9bd1a","modified":1495089884723},{"_id":"source/img/lib.png","hash":"880d4f1a7a81eb01b2f0801e540e0cfe11452cf1","modified":1495089884739},{"_id":"source/img/google_dc2.jpg","hash":"302e62a664e1267c30ddec0e44b3d390256a2825","modified":1495089884739},{"_id":"source/img/google_dc1.jpg","hash":"6f647095c1ade1517c727885262cb2f4d6f70d83","modified":1495089884723},{"_id":"source/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","hash":"112c3ba9ec4331d5504eac59aa5bc019e0e6931e","modified":1495089884629},{"_id":"source/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","hash":"6585e262ba11c8ffe0fdb78a7cb19f53252aff45","modified":1495089884629},{"_id":"source/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","hash":"bb38ab082d8f318af46259d1f924637e2bd06379","modified":1495089884692},{"_id":"source/doc/graduate_student_huang_yihua_2011_ppt.pdf","hash":"ec8770c44b40cda40950bb8b5b0b534221228089","modified":1495089884708},{"_id":"source/doc/walden.pdf","hash":"6e3601a6d83e10019e3c9d205c37d7005044f53c","modified":1496759333281},{"_id":"source/doc/mpich-3.2-build.tar.gz","hash":"baaa16daa824b48783125161de795a667d8e91a3","modified":1495089884723},{"_id":"source/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","hash":"b7a2a7830d4779df793a52a8a7ac4c72eed28dcf","modified":1495089884676},{"_id":"public/atom.xml","hash":"9647f847ae3c29cc09895eec02f3c1efd4f07b51","modified":1509336143646},{"_id":"public/misc/2017/setup-squid-proxy/index.html","hash":"4c4c100c3fa716c769d2e1b75d41a5aac1b7b16d","modified":1509336143917},{"_id":"public/misc/2017/ccf-all-in-one/index.html","hash":"9505d65e11adb9e06e065a291e8122f9d66a14c3","modified":1509336143917},{"_id":"public/cloud/2016/win-vhd-boot/index.html","hash":"0917a7c7b461af970fd5d03d09ce6caafae3b86d","modified":1509336143917},{"_id":"public/misc/2016/udpnuurufa/index.html","hash":"75dac169b58d87dae9533eb37371a109b1f9bca0","modified":1509336143917},{"_id":"public/misc/2016/obstinate-are-the-trammels/index.html","hash":"bd3f2bc49739f70f510c7246d2bbcea84d4775e9","modified":1509336143917},{"_id":"public/categories/misc/index.html","hash":"d1d0632cd238a0defeda85ffe0f6a5fe044ab248","modified":1509336143917},{"_id":"public/categories/cloud/index.html","hash":"18f894da8d9951ffa7119f67b4419541006e5462","modified":1509336143917},{"_id":"public/archives/index.html","hash":"cec85d77d2c5a31c7455a0490bca483b54a57997","modified":1509336143917},{"_id":"public/archives/2016/index.html","hash":"0a90c5353db69fcf7781bb18bad2a3a32fa56fe3","modified":1509336143917},{"_id":"public/archives/2016/05/index.html","hash":"d2ec48e9482c8c4f0e4e3edb5a6b412813613e97","modified":1509336143917},{"_id":"public/archives/2016/06/index.html","hash":"b528a820da87584493d12e132c8a4108eb6c7be2","modified":1509336143917},{"_id":"public/archives/2016/09/index.html","hash":"5e504c4fdc6bb08fab86c6b14a8f1a6444e5b166","modified":1509336143917},{"_id":"public/archives/2017/index.html","hash":"d5711a215d611468384dbb76f229b8758c41a34c","modified":1509336143917},{"_id":"public/archives/2017/02/index.html","hash":"6ffdc76188a4b2859c234d997b061dcc8dfea717","modified":1509336143918},{"_id":"public/archives/2017/03/index.html","hash":"9ad7b2edb9e86431ccac89e73e55fda99fe05eaf","modified":1509336143918},{"_id":"public/archives/2017/04/index.html","hash":"560f89d41c2ca24d72c53a8489af4b8914326e11","modified":1509336143918},{"_id":"public/archives/2017/05/index.html","hash":"6338dd43cdb50db51e3142bca8392d6a7c7215c5","modified":1509336143918},{"_id":"public/cloud/2017/docker-image-spec-v1.2/index.html","hash":"d92c9335faff6bf787bf2d2bf83f4a4b8927ed36","modified":1509336143918},{"_id":"public/misc/2017/setup-nat-x-route/index.html","hash":"073a3e1d9dfb8569c9487dcb0bc0cbc3acf92c93","modified":1509336143918},{"_id":"public/misc/2017/install-linpack-xhpl/index.html","hash":"d68dc773a7eada9375d865b7cc3a11756c905f60","modified":1509336143918},{"_id":"public/cloud/2017/vm-net-2/index.html","hash":"866da3e924e54705f6376f1ee5ab0abe8fedde98","modified":1509336143918},{"_id":"public/misc/2017/cobbler-pxe/index.html","hash":"c3ac6a039bbe17b1b6c0caf05eaf547c125a501a","modified":1509336143918},{"_id":"public/cloud/2017/spanner-truetime-cap/index.html","hash":"d76ad4ed633d2e59553a1c4838482f187b5657f6","modified":1509336143918},{"_id":"public/misc/2016/we-love-paper/index.html","hash":"9399b0a418392514b6d04a799ddbe9a158d606ea","modified":1509336143919},{"_id":"public/cloud/2016/vm-disk/index.html","hash":"00b6c758ab529a4f5def0dbfc29b398e1fa2cee9","modified":1509336143919},{"_id":"public/cloud/2016/vm-net/index.html","hash":"b7c8d0df42e7edf26348ac83e3238bc9bf4b14e7","modified":1509336143919},{"_id":"public/misc/2016/remote/index.html","hash":"9ebfbd78a09d12f0636232a44ab054825bce36ae","modified":1509336143919},{"_id":"public/misc/2016/install-win-10/index.html","hash":"4eb770517b63234a54518f65f7690e908996851e","modified":1509336143919},{"_id":"public/misc/2016/install-ubuntu/index.html","hash":"40da5bd704bbe36d10085bc33169e9710637320f","modified":1509336143919},{"_id":"public/misc/2016/hello-hexo/index.html","hash":"1104716574d837b7a0bce784ccb23bd1177a099c","modified":1509336143919},{"_id":"public/misc/2016/a-story-of-stylus/index.html","hash":"50666b321689c8ce83283c5315668f16eb39ac33","modified":1509336143919},{"_id":"public/index.html","hash":"8cf2b9ef3ce932d6973ab433a027e4bb2f121020","modified":1509336143919},{"_id":"public/doc/crack_xls_vb.txt","hash":"667c8a9b1c69a61926020a490fec259ae1a15086","modified":1509336143958},{"_id":"public/doc/cobbler-setting.txt","hash":"507e3403def7ed5cae195a487d7aa03c42a251d0","modified":1509336143958},{"_id":"public/doc/ifcfg-ens33","hash":"e0641b4695e366b26423a750c1c826eed4340d5b","modified":1509336143958},{"_id":"public/doc/win10.reg","hash":"50983212c92d0833e3139146f5e144151a9ea049","modified":1509336143959},{"_id":"public/img/ccf_sum.png","hash":"17e7753baf957a2957a618208782b331f866e7f1","modified":1509336143960},{"_id":"public/img/phree-structure.jpg","hash":"30a0f63fa34cc2347df69a4fbc46ae949a359ea4","modified":1509336143960},{"_id":"public/img/pxe-boot-menu.png","hash":"15933bf27545906ea1c64bb50c2c121e5d32250b","modified":1509336143960},{"_id":"public/img/pxe-boot-config.png","hash":"b95615d4bb5f3bddfd935bb39d8f175f7bbccc7b","modified":1509336143960},{"_id":"public/img/pubs.png","hash":"1fc6cddbc0c1be58c31db5e93defee407f2d3922","modified":1509336143960},{"_id":"public/img/sftp.png","hash":"7373204fba311d4bbc2a1304ae5100699380ca6d","modified":1509336143960},{"_id":"public/img/spanner-availability.png","hash":"b279e4c2968ec7fac756513fbcb481f58001d325","modified":1509336143960},{"_id":"public/img/spotlitght-design.jpg","hash":"2f7c5d89dea1871848d4fe4bbd2571e9ce5e60b7","modified":1509336143960},{"_id":"public/img/udpn-baidu-ime.png","hash":"6b1c7fd246ac1da9fa0f30629b67ad751385e59b","modified":1509336143960},{"_id":"public/img/udpn-demo.png","hash":"f8330f796c3ae26a4cf868198bb8c1ef109d9a3b","modified":1509336143960},{"_id":"public/img/vbox-hostonly-nic.png","hash":"cb704943d0a7cf2c96c35c466f8192280278bbbe","modified":1509336143960},{"_id":"public/img/vbox-headless.png","hash":"f80ff69fc94dae4a97e3af79be242aae83f0b38b","modified":1509336143960},{"_id":"public/img/vbox-snapshot.png","hash":"96c2748ced55acd07d6a7394240b46095eb6ca25","modified":1509336143960},{"_id":"public/img/vboxconf-NatNetwork.png","hash":"2431472e03648fc9d3a4087b79dfddf2ee7e1c4a","modified":1509336143960},{"_id":"public/img/vboxconf-hostonly.png","hash":"faaf51e8bbd50faebb98b4cb001f3fd259edfc6f","modified":1509336143960},{"_id":"public/img/vboxsetting-store.png","hash":"6886271d1e0f59245216e96c507432cbee83ccad","modified":1509336143960},{"_id":"public/img/vboxsetting-net.png","hash":"effe5b8616f55bad9ecea8d8d52dd79ce1aa3957","modified":1509336143960},{"_id":"public/img/vczh-on-config.png","hash":"bd28ac541389f4357a55f681e0bfe8022b7d2cf3","modified":1509336143960},{"_id":"public/img/vm-tty.png","hash":"b005e82faf82e8f194317913516db984cd519632","modified":1509336143960},{"_id":"public/img/vnet.png","hash":"d94f637a8d638ef044a4eb2c399c22d75ee80285","modified":1509336143960},{"_id":"public/img/vmware-snapshot.png","hash":"c9391e15ccb4f1f6542634ad4a20e90b6941ba4a","modified":1509336143960},{"_id":"public/img/wifi-router.png","hash":"7aaa176ae16e574fac4f7a7861ffd6cbe13c258c","modified":1509336143960},{"_id":"public/img/win-mstsc-svr.png","hash":"454f2246ab116191aae15f458e2b78b605e7827e","modified":1509336143960},{"_id":"public/img/win-mstsc.png","hash":"3f631d2d7653ca872508d052bb7c819d341d809b","modified":1509336143961},{"_id":"public/img/xshell-key.png","hash":"18f9d471cf3de56ef325f10c6f0eb17f588a1689","modified":1509336143961},{"_id":"public/img/win-share.png","hash":"1f942562e7930612939a728265315b6db4f68d47","modified":1509336143961},{"_id":"public/img/xshell-prop.png","hash":"637a498356615c059d19143a95a17f324fbf6b50","modified":1509336143961},{"_id":"public/img/xshell-ui.png","hash":"d60047895e00970596430de0666228ddc922d1f1","modified":1509336143961},{"_id":"public/img/zhuge.jpg","hash":"b6819904a87d60784c282c166d9dde57e28e2fde","modified":1509336143961},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1509336143961},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1509336143961},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1509336143961},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1509336143961},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1509336143961},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1509336143961},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1509336143961},{"_id":"public/css/fonts/iconfont.svg","hash":"6ddf1044a70a0c388c9b8327cc8950d5e84e9df4","modified":1509336143961},{"_id":"public/css/fonts/iconfont.eot","hash":"6ba3575b2f32b5fdc491a5cbeff19ec1a2258ce0","modified":1509336143961},{"_id":"public/css/fonts/iconfont.woff","hash":"f105bd41ff679f1faa9bebb6f618426309c7033c","modified":1509336143961},{"_id":"public/css/fonts/iconfont.ttf","hash":"0936fdc72603dd9adc5a71ae46f8c00bcba7e629","modified":1509336143961},{"_id":"public/doc/ccf_all_in_one_2017-02-25.xlsx","hash":"684520981f114a3907eda9c6f36f43c883479813","modified":1509336144340},{"_id":"public/img/osdi16-firmament-fig2.png","hash":"d068b6fa4329f220766c06668bc215a8709a03df","modified":1509336144341},{"_id":"public/img/osdi16-morpheus.png","hash":"0b181cf535dc99cac51a348949f6c437d633fb10","modified":1509336144342},{"_id":"public/img/phree.jpg","hash":"996fed0e72973c85df38d84f2ea1689bdfe59de4","modified":1509336144343},{"_id":"public/img/scholar_adv.png","hash":"9597042c1dae98b1da7c1b9b4cd440840ac98eb1","modified":1509336144343},{"_id":"public/img/sock5-proxy.png","hash":"165f6cd9972eec88507f7723bd20ab5531e6bd7d","modified":1509336144343},{"_id":"public/img/spotlitght-spec.png","hash":"eae78e4243da526a92243b471920e45ebf9fe36b","modified":1509336144343},{"_id":"public/img/smb.png","hash":"a2cafa61ae8bc92f4840216fc3a4c65876d1baf4","modified":1509336144343},{"_id":"public/img/tpds15-job-taxonomy-fig2.png","hash":"3d13644cee2af40c2674a9462a28f83282b8c6d6","modified":1509336144343},{"_id":"public/img/tpds15-job-taxonomy-group.png","hash":"e4b4e184d1c9675ee1447e4ffc57b36fd72fe613","modified":1509336144343},{"_id":"public/img/udpn-ms-map.png","hash":"64fdff00586fd43395714ff6e3787377b1958577","modified":1509336144343},{"_id":"public/img/vnet-vxlan.png","hash":"5547ebdd1e6899fe0d89cfc785101a8d309f0771","modified":1509336144343},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1509336144349},{"_id":"public/js/script.js","hash":"453cdbc4259e13ee09def0e26afaff146f7ad501","modified":1509336144349},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1509336144349},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1509336144349},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1509336144349},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1509336144349},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1509336144349},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1509336144349},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1509336144349},{"_id":"public/css/style.css","hash":"5b437d90016e5c6b8e30785582ca0772b3de5b04","modified":1509336144350},{"_id":"public/doc/Spanner-TrueTime-CAP.docx","hash":"6dffed178fbd971285b07b2433f4f773c13a18e5","modified":1509336144350},{"_id":"public/img/4books_IMG_20150328_201923.jpg","hash":"b385ae658704c3fae24e9fa902d9e52f389e01e0","modified":1509336144350},{"_id":"public/img/borg-fig-10-11.png","hash":"f546f8c62996a7248a6a15d15aae5dcf495c5a38","modified":1509336144350},{"_id":"public/img/borg-fig-12.png","hash":"50ed9722b529d7f4b8ad41a7267749ce57d54396","modified":1509336144350},{"_id":"public/img/tpds15-job-taxonomy-fig1.png","hash":"adb7741820cdb1d61adc9b441b0cf43a5c243ce3","modified":1509336144350},{"_id":"public/img/osdi16-carbyne.png","hash":"ab7c6851b20f436059a3af637e52a9cb91f0f483","modified":1509336144350},{"_id":"public/doc/ccf-all-in-one-2017-02-25.html","hash":"d251ab8f29dca1209b29cc88d26239442967029c","modified":1509336144354},{"_id":"public/doc/shuang_pin_udpn_cheetsheet.pdf","hash":"ec6375d75961f29c59c79aac1b92c515305162c1","modified":1509336144354},{"_id":"public/img/avatar.png","hash":"c46fce9b0905d4c5bf131475bc083c6faef6edfa","modified":1509336144355},{"_id":"public/img/hpc-feature-alg.png","hash":"97d1be0e9f9d0064350e37b7ba0091b8bfa8342f","modified":1509336144355},{"_id":"public/img/osdi16-harvest.png","hash":"0ef7746a98c2012ea274816105a0f8c19497a732","modified":1509336144355},{"_id":"public/img/udpn-iflyrec-meeting.png","hash":"bd5243cbb4998673506d223abb620afca6ea5e1b","modified":1509336144355},{"_id":"public/img/udpn-iflyrec-rec.png","hash":"fd820c873189a8983bd34a325f81269e232ccb94","modified":1509336144355},{"_id":"public/img/vnet-pk.png","hash":"13ca0863dea5b1fe55fbe3bfbcf900ea949c65d8","modified":1509336144355},{"_id":"public/img/osdi16-firmament-blog-table.png","hash":"73ad6d3e8707b94b88bb26f2ab6a27fe7664728a","modified":1509336144359},{"_id":"public/img/xpen-shape.jpg","hash":"7cda0cd632a18cdaf23d3633ccec805b2b48ef34","modified":1509336144362},{"_id":"public/img/spanner-books.jpg","hash":"ebc68d4bc51e95b292d737c79e14bd5566392481","modified":1509336144372},{"_id":"public/doc/SCI_E_Web_of_Science.pdf","hash":"c714865cb741a15ce2835b003b6f35ad207d7635","modified":1509336144419},{"_id":"public/doc/Spanner-TrueTime-CAP.pdf","hash":"939a92b3b541073a3dc8b62c0dab4a3c64c73a0a","modified":1509336144494},{"_id":"public/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","hash":"595cc33bdfb97ea09aca32864c2a94b7fba9bd1a","modified":1509336144511},{"_id":"public/img/lib.png","hash":"880d4f1a7a81eb01b2f0801e540e0cfe11452cf1","modified":1509336144513},{"_id":"public/img/google_dc1.jpg","hash":"6f647095c1ade1517c727885262cb2f4d6f70d83","modified":1509336144525},{"_id":"public/img/google_dc2.jpg","hash":"302e62a664e1267c30ddec0e44b3d390256a2825","modified":1509336144525},{"_id":"public/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","hash":"112c3ba9ec4331d5504eac59aa5bc019e0e6931e","modified":1509336144529},{"_id":"public/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","hash":"6585e262ba11c8ffe0fdb78a7cb19f53252aff45","modified":1509336144541},{"_id":"public/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","hash":"bb38ab082d8f318af46259d1f924637e2bd06379","modified":1509336144546},{"_id":"public/doc/graduate_student_huang_yihua_2011_ppt.pdf","hash":"ec8770c44b40cda40950bb8b5b0b534221228089","modified":1509336144548},{"_id":"public/doc/walden.pdf","hash":"6e3601a6d83e10019e3c9d205c37d7005044f53c","modified":1509336144552},{"_id":"public/doc/mpich-3.2-build.tar.gz","hash":"baaa16daa824b48783125161de795a667d8e91a3","modified":1509336144571},{"_id":"public/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","hash":"b7a2a7830d4779df793a52a8a7ac4c72eed28dcf","modified":1509336144584},{"_id":"source/img/borg-fig-04.png","hash":"04737888441f199eb2b2682382a700c192bc2238","modified":1509540530961},{"_id":"source/img/borg-fig-10.png","hash":"5487dcb3873aed8e2fa589a84014b86f79ab6f84","modified":1509540418631},{"_id":"source/_posts/eurosys15-borg-cn.md","hash":"530e43320525150b6e0f3ef1fbbaf94060567aa6","modified":1509541009619},{"_id":"source/img/borg-fig-01.png","hash":"c085d12f87dd9f216590243ba7d96fc3bf9449ed","modified":1509540325395},{"_id":"source/img/borg-fig-02.png","hash":"bd44d8696571aca91b1cd806e2e781a613e5d0b5","modified":1509540453513},{"_id":"source/img/borg-fig-03.png","hash":"dc4c4d0cc207bb57b4708b419982c3d6837fe382","modified":1509540506296},{"_id":"source/img/borg-fig-06.png","hash":"f697b41dc44a5bf290d3cacc4a2a63382b3964ca","modified":1509540595637},{"_id":"source/img/borg-fig-09.png","hash":"b2a7ab4d1895fdb51be607a543fce1e105e419b4","modified":1509540664676},{"_id":"source/img/borg-fig-08.png","hash":"e21f2fc66a9cf786505dad770027951af79e8da3","modified":1509540644983},{"_id":"source/img/borg-fig-05.png","hash":"1b915af9703de11c65e61e9c451780169431da55","modified":1509540572139},{"_id":"source/img/borg-fig-07.png","hash":"81f7935f42da15d962a0ca3fc621b5536c0c7ce4","modified":1509540620635},{"_id":"source/img/borg-fig-11.png","hash":"96883ab2a7810cc13180ad3dc869cc3accf7da79","modified":1509540402477},{"_id":"source/img/borg-fig-13.png","hash":"b73c2e8c8c69e99237c12f4aa577976a02eaec51","modified":1509540684039},{"_id":"source/doc/EuroSys15_Borg.pdf","hash":"fb89af8a8f76615d31c5dac0e880541284341b7f","modified":1484721483119}],"Category":[{"name":"misc","_id":"cj9dmd1ms0002wo4f5thbb00a"},{"name":"cloud","_id":"cj9dmd1n5000fwo4fawkdzefn"}],"Data":[],"Page":[],"Post":[{"title":"如果有一支笔","date":"2016-05-19T16:00:00.000Z","_content":"\n这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“[就差一个软件工程师了](https://www.zhihu.com/question/22989105)”的悲伤的故事（其实还缺一个硬件工程师）。\n为了清净，把日期改了，手工置底。\n\n<!-- TOC -->\n\n    - [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n- [xPen](#xpen)\n    - [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)\n    - [结构设计](#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)\n        - [基于光电原理](#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86)\n        - [基于陀螺仪，加速度计](#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1)\n        - [xPen的设计考虑](#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91)\n        - [其它考虑](#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91)\n- [其它，四年之路](#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF)\n- [罗技的spotlight](#%E7%BD%97%E6%8A%80%E7%9A%84spotlight)\n\n<!-- /TOC -->\n\n\n\n# xPen\n[鼠标](https://en.wikipedia.org/wiki/Computer_mouse)是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种[光笔（1955年）](https://en.wikipedia.org/wiki/Light_pen)的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。\n近些年的Surface，iPad等设备也有[配套的笔](https://en.wikipedia.org/wiki/Stylus_%28computing%29)，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 **板子** 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。\n我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 **悬着保持离板子几毫米的距离**，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。\n我的想法是设计一种笔式的输入设备，暂叫 **xPen** 吧（好没创意），不再需要配套的 **板子**，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。\n\n## 应用场景\n这样说来 **xPen** 比现有的笔式设备只是少了配套的 **板子**，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。\n\n## 结构设计\n设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。\n> 说起来似乎很简单，但不清楚具体算法是如何高效实现的。\n\n比较微妙的是，\n+ 鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。\n+ 鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。\n+ 鼠标的形状设计隐含着 **前后朝向** 的区分。\n\n与鼠标不同，传统的笔式设备定位功能是靠配套的 **板子** 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。\n\n### 基于光电原理\n\n没有了 **板子** ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：\n\n（Chrome浏览器请单击一下视频，才能允许播放Flash）\n\n这是[QQ视频的一个国内产品](https://v.qq.com/x/page/o0300z5or2g.html)，有美女哦，广告也就忍了吧~~\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n\n下面的是[B站的一个视频](http://www.bilibili.com/video/av7709459/)，介绍的是国外的 [Phree](https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper)。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\nPhree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。\n\n### 基于陀螺仪，加速度计\n[姿态传感器](https://www.zhihu.com/question/28532904)有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和[平板中比较普遍](https://www.zhihu.com/question/52083051)了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。\n下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：\n+ MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；\n+ THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；\n+ 上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波\n+ 中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召\n+ 华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威\n\n### xPen的设计考虑\n既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？\n\n+ xPen主要是针对 **水平的桌面上使用的场景**，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；\n+ xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） **重置内部的位置状态，避免导航场景中误差积累的问题**；\n+ xPen有一个 **压感笔尖**。当压感笔尖存在压力输出，对应为“移动光标”；压力 **超过一定阈值**，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 **压力阈值** 是可以通过实验统计获得的，当然用户也可以修改。**压感笔尖和笔式的外形是xPen的关键**；\n+ 对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 **触摸板** 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；\n+ 如果侧面增加一小块 **触摸板** 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；\n+ 笔的形状是为了适合书写，而且一定要是 **扁的**，不能是 **圆的**，这样才能确定 **前后朝向**，所以最好是前后不对称的，比如横截面做成 **扁的水滴状**；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。\n\n![Phree](/img/phree.jpg)\n\n![Phree](/img/phree-structure.jpg)\n\n![xPen的外形参照](/img/xpen-shape.jpg)\n\n### 其它考虑\n+ 不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；\n+ 不要增加激光，同样是不能保证激光点与PC的光标同步；\n+ 不要过分强调手写识别：\n  + Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；\n  + 突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；\n+ Phree视频中，\n  + 随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；\n  + 支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；\n  + 带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；\n  + 不过，增加麦克风以支持录音应该是比较合适的；\n  + xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。\n+ 姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。\n\n# 其它，四年之路\n\n2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 **[飞鼠](http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0)**，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 **使用姿态传感器的笔式鼠标的想法**，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 **压感笔尖**。\n想法基本就是这样了，因为在复习，就放在一边了。\n考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。\n再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。\n然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。\n我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。\n其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。\n\n# 罗技的spotlight\n一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是[罗技的spotlight](https://item.jd.com/4674246.html)，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个**笔尖**，不需要用户一直按某个键就可以了！\n\nYeah！\n\n只可惜不是我把它造出来~~\n\n![](/img/spotlitght-design.jpg)\n\n![](/img/spotlitght-spec.png)","source":"_posts/a-story-of-stylus.md","raw":"title: 如果有一支笔\ncategory: [misc]\ntags: \ndate: 2016-05-20\n---\n\n这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“[就差一个软件工程师了](https://www.zhihu.com/question/22989105)”的悲伤的故事（其实还缺一个硬件工程师）。\n为了清净，把日期改了，手工置底。\n\n<!-- TOC -->\n\n    - [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n- [xPen](#xpen)\n    - [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)\n    - [结构设计](#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)\n        - [基于光电原理](#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86)\n        - [基于陀螺仪，加速度计](#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1)\n        - [xPen的设计考虑](#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91)\n        - [其它考虑](#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91)\n- [其它，四年之路](#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF)\n- [罗技的spotlight](#%E7%BD%97%E6%8A%80%E7%9A%84spotlight)\n\n<!-- /TOC -->\n\n\n\n# xPen\n[鼠标](https://en.wikipedia.org/wiki/Computer_mouse)是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种[光笔（1955年）](https://en.wikipedia.org/wiki/Light_pen)的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。\n近些年的Surface，iPad等设备也有[配套的笔](https://en.wikipedia.org/wiki/Stylus_%28computing%29)，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 **板子** 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。\n我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 **悬着保持离板子几毫米的距离**，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。\n我的想法是设计一种笔式的输入设备，暂叫 **xPen** 吧（好没创意），不再需要配套的 **板子**，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。\n\n## 应用场景\n这样说来 **xPen** 比现有的笔式设备只是少了配套的 **板子**，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。\n\n## 结构设计\n设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。\n> 说起来似乎很简单，但不清楚具体算法是如何高效实现的。\n\n比较微妙的是，\n+ 鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。\n+ 鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。\n+ 鼠标的形状设计隐含着 **前后朝向** 的区分。\n\n与鼠标不同，传统的笔式设备定位功能是靠配套的 **板子** 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。\n\n### 基于光电原理\n\n没有了 **板子** ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：\n\n（Chrome浏览器请单击一下视频，才能允许播放Flash）\n\n这是[QQ视频的一个国内产品](https://v.qq.com/x/page/o0300z5or2g.html)，有美女哦，广告也就忍了吧~~\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n\n下面的是[B站的一个视频](http://www.bilibili.com/video/av7709459/)，介绍的是国外的 [Phree](https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper)。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\nPhree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。\n\n### 基于陀螺仪，加速度计\n[姿态传感器](https://www.zhihu.com/question/28532904)有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和[平板中比较普遍](https://www.zhihu.com/question/52083051)了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。\n下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：\n+ MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；\n+ THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；\n+ 上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波\n+ 中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召\n+ 华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威\n\n### xPen的设计考虑\n既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？\n\n+ xPen主要是针对 **水平的桌面上使用的场景**，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；\n+ xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） **重置内部的位置状态，避免导航场景中误差积累的问题**；\n+ xPen有一个 **压感笔尖**。当压感笔尖存在压力输出，对应为“移动光标”；压力 **超过一定阈值**，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 **压力阈值** 是可以通过实验统计获得的，当然用户也可以修改。**压感笔尖和笔式的外形是xPen的关键**；\n+ 对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 **触摸板** 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；\n+ 如果侧面增加一小块 **触摸板** 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；\n+ 笔的形状是为了适合书写，而且一定要是 **扁的**，不能是 **圆的**，这样才能确定 **前后朝向**，所以最好是前后不对称的，比如横截面做成 **扁的水滴状**；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。\n\n![Phree](/img/phree.jpg)\n\n![Phree](/img/phree-structure.jpg)\n\n![xPen的外形参照](/img/xpen-shape.jpg)\n\n### 其它考虑\n+ 不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；\n+ 不要增加激光，同样是不能保证激光点与PC的光标同步；\n+ 不要过分强调手写识别：\n  + Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；\n  + 突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；\n+ Phree视频中，\n  + 随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；\n  + 支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；\n  + 带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；\n  + 不过，增加麦克风以支持录音应该是比较合适的；\n  + xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。\n+ 姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。\n\n# 其它，四年之路\n\n2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 **[飞鼠](http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0)**，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 **使用姿态传感器的笔式鼠标的想法**，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 **压感笔尖**。\n想法基本就是这样了，因为在复习，就放在一边了。\n考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。\n再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。\n然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。\n我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。\n其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。\n\n# 罗技的spotlight\n一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是[罗技的spotlight](https://item.jd.com/4674246.html)，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个**笔尖**，不需要用户一直按某个键就可以了！\n\nYeah！\n\n只可惜不是我把它造出来~~\n\n![](/img/spotlitght-design.jpg)\n\n![](/img/spotlitght-spec.png)","slug":"a-story-of-stylus","published":1,"updated":"2017-10-30T03:40:53.939Z","_id":"cj9dmd1ml0000wo4fqxkuxuji","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“<a href=\"https://www.zhihu.com/question/22989105\" target=\"_blank\" rel=\"external\">就差一个软件工程师了</a>”的悲伤的故事（其实还缺一个硬件工程师）。<br>为了清净，把日期改了，手工置底。</p>\n<!-- TOC -->\n<pre><code>- [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n</code></pre><ul>\n<li><a href=\"#xpen\">xPen</a><ul>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">应用场景</a></li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\">结构设计</a><ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86\">基于光电原理</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1\">基于陀螺仪，加速度计</a></li>\n<li><a href=\"#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91\">xPen的设计考虑</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91\">其它考虑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF\">其它，四年之路</a></li>\n<li><a href=\"#%E7%BD%97%E6%8A%80%E7%9A%84spotlight\">罗技的spotlight</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"xPen\"><a href=\"#xPen\" class=\"headerlink\" title=\"xPen\"></a>xPen</h1><p><a href=\"https://en.wikipedia.org/wiki/Computer_mouse\" target=\"_blank\" rel=\"external\">鼠标</a>是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种<a href=\"https://en.wikipedia.org/wiki/Light_pen\" target=\"_blank\" rel=\"external\">光笔（1955年）</a>的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。<br>近些年的Surface，iPad等设备也有<a href=\"https://en.wikipedia.org/wiki/Stylus_%28computing%29\" target=\"_blank\" rel=\"external\">配套的笔</a>，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 <strong>板子</strong> 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。<br>我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 <strong>悬着保持离板子几毫米的距离</strong>，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。<br>我的想法是设计一种笔式的输入设备，暂叫 <strong>xPen</strong> 吧（好没创意），不再需要配套的 <strong>板子</strong>，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>这样说来 <strong>xPen</strong> 比现有的笔式设备只是少了配套的 <strong>板子</strong>，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。</p>\n<h2 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h2><p>设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。</p>\n<blockquote>\n<p>说起来似乎很简单，但不清楚具体算法是如何高效实现的。</p>\n</blockquote>\n<p>比较微妙的是，</p>\n<ul>\n<li>鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。</li>\n<li>鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。</li>\n<li>鼠标的形状设计隐含着 <strong>前后朝向</strong> 的区分。</li>\n</ul>\n<p>与鼠标不同，传统的笔式设备定位功能是靠配套的 <strong>板子</strong> 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。</p>\n<h3 id=\"基于光电原理\"><a href=\"#基于光电原理\" class=\"headerlink\" title=\"基于光电原理\"></a>基于光电原理</h3><p>没有了 <strong>板子</strong> ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：</p>\n<p>（Chrome浏览器请单击一下视频，才能允许播放Flash）</p>\n<p>这是<a href=\"https://v.qq.com/x/page/o0300z5or2g.html\" target=\"_blank\" rel=\"external\">QQ视频的一个国内产品</a>，有美女哦，广告也就忍了吧~~</p>\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowfullscreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\">\n\n<p>下面的是<a href=\"http://www.bilibili.com/video/av7709459/\" target=\"_blank\" rel=\"external\">B站的一个视频</a>，介绍的是国外的 <a href=\"https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper\" target=\"_blank\" rel=\"external\">Phree</a>。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。</p>\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\">\n\n<p>Phree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。</p>\n<h3 id=\"基于陀螺仪，加速度计\"><a href=\"#基于陀螺仪，加速度计\" class=\"headerlink\" title=\"基于陀螺仪，加速度计\"></a>基于陀螺仪，加速度计</h3><p><a href=\"https://www.zhihu.com/question/28532904\" target=\"_blank\" rel=\"external\">姿态传感器</a>有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和<a href=\"https://www.zhihu.com/question/52083051\" target=\"_blank\" rel=\"external\">平板中比较普遍</a>了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。<br>下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：</p>\n<ul>\n<li>MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；</li>\n<li>THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；</li>\n<li>上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波</li>\n<li>中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召</li>\n<li>华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威</li>\n</ul>\n<h3 id=\"xPen的设计考虑\"><a href=\"#xPen的设计考虑\" class=\"headerlink\" title=\"xPen的设计考虑\"></a>xPen的设计考虑</h3><p>既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？</p>\n<ul>\n<li>xPen主要是针对 <strong>水平的桌面上使用的场景</strong>，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；</li>\n<li>xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） <strong>重置内部的位置状态，避免导航场景中误差积累的问题</strong>；</li>\n<li>xPen有一个 <strong>压感笔尖</strong>。当压感笔尖存在压力输出，对应为“移动光标”；压力 <strong>超过一定阈值</strong>，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 <strong>压力阈值</strong> 是可以通过实验统计获得的，当然用户也可以修改。<strong>压感笔尖和笔式的外形是xPen的关键</strong>；</li>\n<li>对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 <strong>触摸板</strong> 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；</li>\n<li>如果侧面增加一小块 <strong>触摸板</strong> 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；</li>\n<li>笔的形状是为了适合书写，而且一定要是 <strong>扁的</strong>，不能是 <strong>圆的</strong>，这样才能确定 <strong>前后朝向</strong>，所以最好是前后不对称的，比如横截面做成 <strong>扁的水滴状</strong>；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。</li>\n</ul>\n<p><img src=\"/img/phree.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/phree-structure.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/xpen-shape.jpg\" alt=\"xPen的外形参照\"></p>\n<h3 id=\"其它考虑\"><a href=\"#其它考虑\" class=\"headerlink\" title=\"其它考虑\"></a>其它考虑</h3><ul>\n<li>不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；</li>\n<li>不要增加激光，同样是不能保证激光点与PC的光标同步；</li>\n<li>不要过分强调手写识别：<ul>\n<li>Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；</li>\n<li>突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；</li>\n</ul>\n</li>\n<li>Phree视频中，<ul>\n<li>随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；</li>\n<li>支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；</li>\n<li>带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；</li>\n<li>不过，增加麦克风以支持录音应该是比较合适的；</li>\n<li>xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。</li>\n</ul>\n</li>\n<li>姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。</li>\n</ul>\n<h1 id=\"其它，四年之路\"><a href=\"#其它，四年之路\" class=\"headerlink\" title=\"其它，四年之路\"></a>其它，四年之路</h1><p>2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 <strong><a href=\"http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0\" target=\"_blank\" rel=\"external\">飞鼠</a></strong>，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 <strong>使用姿态传感器的笔式鼠标的想法</strong>，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 <strong>压感笔尖</strong>。<br>想法基本就是这样了，因为在复习，就放在一边了。<br>考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。<br>再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。<br>然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。<br>我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。<br>其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。</p>\n<h1 id=\"罗技的spotlight\"><a href=\"#罗技的spotlight\" class=\"headerlink\" title=\"罗技的spotlight\"></a>罗技的spotlight</h1><p>一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是<a href=\"https://item.jd.com/4674246.html\" target=\"_blank\" rel=\"external\">罗技的spotlight</a>，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个<strong>笔尖</strong>，不需要用户一直按某个键就可以了！</p>\n<p>Yeah！</p>\n<p>只可惜不是我把它造出来~~</p>\n<p><img src=\"/img/spotlitght-design.jpg\" alt=\"\"></p>\n<p><img src=\"/img/spotlitght-spec.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“<a href=\"https://www.zhihu.com/question/22989105\" target=\"_blank\" rel=\"external\">就差一个软件工程师了</a>”的悲伤的故事（其实还缺一个硬件工程师）。<br>为了清净，把日期改了，手工置底。</p>\n<!-- TOC -->\n<pre><code>- [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n</code></pre><ul>\n<li><a href=\"#xpen\">xPen</a><ul>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">应用场景</a></li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\">结构设计</a><ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86\">基于光电原理</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1\">基于陀螺仪，加速度计</a></li>\n<li><a href=\"#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91\">xPen的设计考虑</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91\">其它考虑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF\">其它，四年之路</a></li>\n<li><a href=\"#%E7%BD%97%E6%8A%80%E7%9A%84spotlight\">罗技的spotlight</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"xPen\"><a href=\"#xPen\" class=\"headerlink\" title=\"xPen\"></a>xPen</h1><p><a href=\"https://en.wikipedia.org/wiki/Computer_mouse\" target=\"_blank\" rel=\"external\">鼠标</a>是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种<a href=\"https://en.wikipedia.org/wiki/Light_pen\" target=\"_blank\" rel=\"external\">光笔（1955年）</a>的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。<br>近些年的Surface，iPad等设备也有<a href=\"https://en.wikipedia.org/wiki/Stylus_%28computing%29\" target=\"_blank\" rel=\"external\">配套的笔</a>，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 <strong>板子</strong> 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。<br>我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 <strong>悬着保持离板子几毫米的距离</strong>，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。<br>我的想法是设计一种笔式的输入设备，暂叫 <strong>xPen</strong> 吧（好没创意），不再需要配套的 <strong>板子</strong>，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>这样说来 <strong>xPen</strong> 比现有的笔式设备只是少了配套的 <strong>板子</strong>，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。</p>\n<h2 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h2><p>设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。</p>\n<blockquote>\n<p>说起来似乎很简单，但不清楚具体算法是如何高效实现的。</p>\n</blockquote>\n<p>比较微妙的是，</p>\n<ul>\n<li>鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。</li>\n<li>鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。</li>\n<li>鼠标的形状设计隐含着 <strong>前后朝向</strong> 的区分。</li>\n</ul>\n<p>与鼠标不同，传统的笔式设备定位功能是靠配套的 <strong>板子</strong> 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。</p>\n<h3 id=\"基于光电原理\"><a href=\"#基于光电原理\" class=\"headerlink\" title=\"基于光电原理\"></a>基于光电原理</h3><p>没有了 <strong>板子</strong> ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：</p>\n<p>（Chrome浏览器请单击一下视频，才能允许播放Flash）</p>\n<p>这是<a href=\"https://v.qq.com/x/page/o0300z5or2g.html\" target=\"_blank\" rel=\"external\">QQ视频的一个国内产品</a>，有美女哦，广告也就忍了吧~~</p>\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowfullscreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\">\n\n<p>下面的是<a href=\"http://www.bilibili.com/video/av7709459/\" target=\"_blank\" rel=\"external\">B站的一个视频</a>，介绍的是国外的 <a href=\"https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper\" target=\"_blank\" rel=\"external\">Phree</a>。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。</p>\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\">\n\n<p>Phree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。</p>\n<h3 id=\"基于陀螺仪，加速度计\"><a href=\"#基于陀螺仪，加速度计\" class=\"headerlink\" title=\"基于陀螺仪，加速度计\"></a>基于陀螺仪，加速度计</h3><p><a href=\"https://www.zhihu.com/question/28532904\" target=\"_blank\" rel=\"external\">姿态传感器</a>有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和<a href=\"https://www.zhihu.com/question/52083051\" target=\"_blank\" rel=\"external\">平板中比较普遍</a>了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。<br>下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：</p>\n<ul>\n<li>MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；</li>\n<li>THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；</li>\n<li>上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波</li>\n<li>中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召</li>\n<li>华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威</li>\n</ul>\n<h3 id=\"xPen的设计考虑\"><a href=\"#xPen的设计考虑\" class=\"headerlink\" title=\"xPen的设计考虑\"></a>xPen的设计考虑</h3><p>既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？</p>\n<ul>\n<li>xPen主要是针对 <strong>水平的桌面上使用的场景</strong>，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；</li>\n<li>xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） <strong>重置内部的位置状态，避免导航场景中误差积累的问题</strong>；</li>\n<li>xPen有一个 <strong>压感笔尖</strong>。当压感笔尖存在压力输出，对应为“移动光标”；压力 <strong>超过一定阈值</strong>，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 <strong>压力阈值</strong> 是可以通过实验统计获得的，当然用户也可以修改。<strong>压感笔尖和笔式的外形是xPen的关键</strong>；</li>\n<li>对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 <strong>触摸板</strong> 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；</li>\n<li>如果侧面增加一小块 <strong>触摸板</strong> 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；</li>\n<li>笔的形状是为了适合书写，而且一定要是 <strong>扁的</strong>，不能是 <strong>圆的</strong>，这样才能确定 <strong>前后朝向</strong>，所以最好是前后不对称的，比如横截面做成 <strong>扁的水滴状</strong>；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。</li>\n</ul>\n<p><img src=\"/img/phree.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/phree-structure.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/xpen-shape.jpg\" alt=\"xPen的外形参照\"></p>\n<h3 id=\"其它考虑\"><a href=\"#其它考虑\" class=\"headerlink\" title=\"其它考虑\"></a>其它考虑</h3><ul>\n<li>不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；</li>\n<li>不要增加激光，同样是不能保证激光点与PC的光标同步；</li>\n<li>不要过分强调手写识别：<ul>\n<li>Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；</li>\n<li>突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；</li>\n</ul>\n</li>\n<li>Phree视频中，<ul>\n<li>随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；</li>\n<li>支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；</li>\n<li>带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；</li>\n<li>不过，增加麦克风以支持录音应该是比较合适的；</li>\n<li>xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。</li>\n</ul>\n</li>\n<li>姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。</li>\n</ul>\n<h1 id=\"其它，四年之路\"><a href=\"#其它，四年之路\" class=\"headerlink\" title=\"其它，四年之路\"></a>其它，四年之路</h1><p>2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 <strong><a href=\"http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0\" target=\"_blank\" rel=\"external\">飞鼠</a></strong>，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 <strong>使用姿态传感器的笔式鼠标的想法</strong>，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 <strong>压感笔尖</strong>。<br>想法基本就是这样了，因为在复习，就放在一边了。<br>考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。<br>再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。<br>然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。<br>我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。<br>其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。</p>\n<h1 id=\"罗技的spotlight\"><a href=\"#罗技的spotlight\" class=\"headerlink\" title=\"罗技的spotlight\"></a>罗技的spotlight</h1><p>一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是<a href=\"https://item.jd.com/4674246.html\" target=\"_blank\" rel=\"external\">罗技的spotlight</a>，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个<strong>笔尖</strong>，不需要用户一直按某个键就可以了！</p>\n<p>Yeah！</p>\n<p>只可惜不是我把它造出来~~</p>\n<p><img src=\"/img/spotlitght-design.jpg\" alt=\"\"></p>\n<p><img src=\"/img/spotlitght-spec.png\" alt=\"\"></p>\n"},{"title":"Windows从VHD启动实现极速快照和恢复","date":"2016-09-21T16:00:00.000Z","_content":"把之前发过的[虚拟机及docker的存储，快照和镜像](/cloud/2016/vm-disk/index.html#win-vhd-boot)相关部分单独拿出来。正文无内容。\n<!--more-->\n","source":"_posts/win-vhd-boot.md","raw":"title: Windows从VHD启动实现极速快照和恢复\ncategory: [cloud]\ntags: \ndate: 2016-09-22\n---\n把之前发过的[虚拟机及docker的存储，快照和镜像](/cloud/2016/vm-disk/index.html#win-vhd-boot)相关部分单独拿出来。正文无内容。\n<!--more-->\n","slug":"win-vhd-boot","published":1,"updated":"2017-10-30T03:43:20.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn7wlx0000nw4fqs7jy8gb","content":"<p>把之前发过的<a href=\"/cloud/2016/vm-disk/index.html#win-vhd-boot\">虚拟机及docker的存储，快照和镜像</a>相关部分单独拿出来。正文无内容。<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>把之前发过的<a href=\"/cloud/2016/vm-disk/index.html#win-vhd-boot\">虚拟机及docker的存储，快照和镜像</a>相关部分单独拿出来。正文无内容。<br>","more":"</p>"},{"title":"如何收集和整理论文（面向CS专业）","date":"2016-09-27T16:00:00.000Z","_content":"\n论文（Paper）是每个研究生读研路上挥之不去的“阴云”。\n无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展(State of the art & practice）。\n本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了与相关的机构，学术会议和论文数据库。\n文末有 [**Bonus**](#hosts) 哦;-)\n\n<!--more-->\n\n---\n\n\n\n# tl;dr\n+ 从[CCF推荐目录](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)中自己感兴趣的方向的 **A类会议及期刊** 中找论文即可。\n+ 我关注的云计算，程序分析方向的[会议和期刊列表](#tldr)\n+ [**Bonus**](#hosts) 修改Hosts\n\n<!-- TOC -->\n\n    - [title: 如何收集和整理论文（面向CS专业）](#title-%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E5%92%8C%E6%95%B4%E7%90%86%E8%AE%BA%E6%96%87%EF%BC%88%E9%9D%A2%E5%90%91cs%E4%B8%93%E4%B8%9A%EF%BC%89)\n- [tl;dr](#tldr)\n- [引子](#%E5%BC%95%E5%AD%90)\n    - [论文发表的过程](#%E8%AE%BA%E6%96%87%E5%8F%91%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B)\n- [CS论文数据库](#cs%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93)\n    - [ACM, IEEE Computer等](#acm-ieee-computer%E7%AD%89)\n        - [ACM SIGs](#acm-sigs)\n    - [[USENIX](https://www.usenix.org/)](#usenixhttpswwwusenixorg)\n    - [[arXiv](http://arxiv.org/)](#arxivhttparxivorg)\n    - [EI和SCI](#ei%E5%92%8Csci)\n    - [dblp](#dblp)\n    - [DOI](#doi)\n    - [其它](#%E5%85%B6%E5%AE%83)\n- [CCF目录](#ccf%E7%9B%AE%E5%BD%95)\n- [Google Scholar（谷歌学术）](#google-scholar%EF%BC%88%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%EF%BC%89)\n    - [创建快讯](#%E5%88%9B%E5%BB%BA%E5%BF%AB%E8%AE%AF)\n- [tl,dr：链接列表](#tldr%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8)\n    - [体系结构，系统，存储，分布式系统](#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)\n    - [软件工程（软件分析）](#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%89)\n    - [云计算，网络，大数据](#%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%A4%A7%E6%95%B0%E6%8D%AE)\n    - [移动计算](#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97)\n    - [ACM DL列表](#acm-dl%E5%88%97%E8%A1%A8)\n    - [IEEE Computer列表](#ieee-computer%E5%88%97%E8%A1%A8)\n    - [[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)](#usenix%E7%BB%84%E7%BB%87%E7%9A%84%E4%BC%9A%E8%AE%AE%E5%88%97%E8%A1%A8httpswwwusenixorgconferencesbyname)\n    - [国内三个学报](#%E5%9B%BD%E5%86%85%E4%B8%89%E4%B8%AA%E5%AD%A6%E6%8A%A5)\n    - [国内论文数据库](#%E5%9B%BD%E5%86%85%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93)\n    - [其它链接](#%E5%85%B6%E5%AE%83%E9%93%BE%E6%8E%A5)\n- [如何读论文](#%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87)\n- [[Todo]辅助工具](#todo%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7)\n    - [**改hosts**](#%E6%94%B9hosts)\n    - [**hosts文件的路径**](#hosts%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84)\n- [PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)](#ps-a-survival-guide-to-a-phdhttpkarpathygithubio20160907phd)\n\n<!-- /TOC -->\n\n# 引子\n按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：\n+ 周志华老师的一篇关于[做研究与写论文的ppt](/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf)\n+ 凌晓峰和杨强的[《学术研究 - 你的成功之道》](http://item.jd.com/11127141.html)，这本书的英文原版是[Crafting Your Research Future - A Guide to Successful Master's and Ph.D. Degrees in Science & Engineering](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064)\n\n首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果(的一部分)，结果是必要的，自然也就少不了Paper或者总结报告；\n再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。\n重要的是要 *有意识地探索和总结适合自己的科研方法*，既要低头苦干，又要抬头看路，还要回头总结。\n\n## 论文发表的过程\n\n<pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n简单介绍一下发表论文的过程：\n+ 首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如[UC Berkeley 的AMPLab](https://amplab.cs.berkeley.edu/)；还有一些公司的研究院，比如[微软](https://www.microsoft.com/en-us/research/)，[谷歌](https://research.google.com/pubs/papers.html)。显然，论文的出身对质量有很大影响。\n+ 期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期(deadline)的压力。投稿后一般要经过同行评审(Peer Review)，针对审稿人的建议做大修，小修(Major，Minor Revision)等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊(Special Issue)计划，会公布一个截稿日期，审稿的进度会稍快些。\n期刊分为 **Transaction, Journal 和 Magazine** 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 *不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是* [Communications of the ACM, CACM, ACM通讯](http://dl.acm.org/citation.cfm?id=J79) *值得关注*。\n+ 对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等，所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。\n很多会议每年举行一次，时间上也是比较固定的，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。\n会议录用的所有Paper会结集出版，称为 *Proceedings* 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。\n会议分为 *Symposium , Conference 和 Workshop*。这三者的学术严肃性依次降低，大部分会议都称为 *Conference*。一般来说 *Workshop* 是随某个 *Conference* 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。\n\n通过这个过程，我们还可以知道如何**尽快**找到一篇感兴趣的文章：\n+ 对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access；\n+ 对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。\n\n# CS论文数据库\n\n## ACM, IEEE Computer等\n\n一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及[图书馆页面截图](#lib)。\n> 注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。\n\n| 机构                                     | Digital Library （DL）                              | 机构首页                   |\n|------------------------------------------|----------------------------------------------------|----------------------------|\n| Association for Computing Machinery, ACM | ACM Digital Library  https://dl.acm.org/           | https://www.acm.org/       |\n| IEEE Computer Society                    | IEEE Xplore DL http://ieeexplore.ieee.org/         | https://www.computer.org/  |\n| Elsevier ScienceDirect                   | http://www.sciencedirect.com/                      | https://www.elsevier.com/  |\n| Springer                                 | Springer Link http://link.springer.com/            | http://www.springer.com/   |\n| Wiley                                    | Wiley Online Lib http://onlinelibrary.wiley.com/   | http://www.wiley.com/      |\n\nACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 *.org*，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。\nElsevier，Springer，Wiley的网址后缀则是 *.com* ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。\n上面这几个数据库是 **主要的论文全文来源**。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。\n> ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 **元数据**，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。\n> IEEE出版的一些论文在 computer.org （实际是[CSDL](https://www.computer.org/csdl/)）和 Xplore DL 都可能搜到，但这两个数据库是 *分别* 收费的，能在Xplore DL下载的不一定能在Computer.org下载。\n\n### ACM SIGs\nACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个[ACM SIGs](http://www.acm.org/sigs/)（或参考DL的这个链接[SIGs ACM DL](http://dl.acm.org/sigs.cfm)），比如\n+ 体系结构方向的[SIGARCH](http://www.sigarch.org/)、[SIGHPC](http://www.sighpc.org/)、[SIGMETRICS](http://www.sigmetrics.org/)、[SIGMICRO](http://www.sigmicro.org/)、[SIGMOBILE](http://www.sigmobile.org/)，\n+ 网络方向的[SIGCOMM](http://www.sigcomm.org/)，\n+ 数据库方向的[SIGMOD](http://www.sigmod.org/)，\n+ 系统方向的[SIGOPS](http://www.sigops.org/)，\n+ 软件工程方向的[SIGPLAN](http://www.sigplan.org/)、[SIGSOFT](http://www.sigsoft.org/)\n\n这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 **最佳论文**，**优秀博士论文** 等(在DL中一般没有哪篇是Best Paper的信息)。此外，\n+ 有网站维护了一个[部分会议的最佳论文列表](http://jeffhuang.com/best_paper_awards.html)，\n+ 还有下面要介绍的USENIX的[各会议最佳论文](https://www.usenix.org/conferences/best-papers)。\n\n除此之外，有的SIG会选择一些高质量的文章，以Review，Newsletter 或Notes的形式重新发表。\n\n## [USENIX](https://www.usenix.org/)\n要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。\n话说**[USENIX](https://www.usenix.org/)** 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slices及演讲视频。slices是对文章的提炼，读论文时可以参考。拿slices和视频来学习做Presentation，练习英语听力和口语也不错。\n\n## [arXiv](http://arxiv.org/)\n[arXiv](http://arxiv.org/)， 是archive(归档)的意思，是一个由康乃尔大学维护的免费的多学科论文**预**出版(preprint)数据库。所谓**预**出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。\n\n<a name=\"lib\" />![图书馆电子资源](/img/lib.png)\n\n## EI和SCI\n分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，\n+ EI *Engineering Index* https://www.engineeringvillage.com/\n+ SCI *Science Citation Index* http://apps.webofknowledge.com/\n\n只看 *URL* 还以为是 *山寨网站*，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 **已知文章标题的情况下** 检索是不是被它们收录了，而 **不是** 用来收集文章的。\n\n要确定某个会议论文集或者期刊[是否被EI或SCI收录](http://www.philippe-fournier-viger.com/links.php)，\n+ 在[EI收录列表](https://www.elsevier.com/solutions/engineering-village/content) 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考[这个脚本解除保护](/doc/crack_xls_vb.txt)，还要建议把title列中每个单元格开头的`=`替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫`Computing`，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。**但是！**，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 **Compendex**。\n+ 在`webofknowledge`的网站查询之前，**一定** 要选择数据库为`检索 Web of Science 核心合集`，等自动刷新候，还要在页面下部展开“更多设置”，只选中`Science Citation Index Expanded (SCIEXPANDED) 1900年至今`这一项，然后才能查询出根正苗红的`SCI（E）`。请**务必**参考[这个截图](/doc/SCI_E_Web_of_Science.pdf)。可以在[SCI收录列表](http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K)直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：[中国科学技术信息研究所SCI（E）论文期刊分区列表(2016年)](http://scit.nju.edu.cn/Item/1162.aspx)，这是一个有13.8k多行的Excel表格，简洁粗暴。\n\n----\n上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。\n校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。\n话说只要是能花钱买到的东西，去万能的 **淘宝** 肯定能找到，就看是买 *VPN/代理*，*单篇文章*，还是 *整个数据库* 了。\n\n## dblp\ndblp [http://dblp.org] ，或[http://dblp.uni-trier.de]， 是专注于CS学科的文献 **元数据索引** 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 http://dblp.org/db/conf/sigsoft/fse2016.html 或者某个作者的全部论文列表(dblp对重名作者处理得很好)，但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。\n2015版CCF目录中的会议和期刊都是dblp的链接。\n\ndblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）\n+ [累计论文记录数量](http://dblp.dagstuhl.de/statistics/recordsindblp.html)，\n+ [每年发表的论文数量](http://dblp.dagstuhl.de/statistics/publicationsperyear.html)，\n+ [论文发表的类型](http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html)，其中会议论文占53%，\n+ 论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。\n\n另外，ACM DL也有一个[类似的统计](http://dl.acm.org/contents_guide.cfm)。\n![每年发表的CS论文数量](/img/pubs.png)\n\n而且dblp整站的数据都可以下载为一个[xml文件](http://dblp.dagstuhl.de/xml/)，以供进一步挖掘。\n\n## DOI\n在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，[wikipedia介绍DOI](https://zh.wikipedia.org/wiki/DOI)“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。\n\n## 其它\n从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。\n+ Semantic Scholar [https://www.semanticscholar.org]\n+ CiteSeerX [http://citeseerx.ist.psu.edu/]\n+ ResearchGate [https://www.researchgate.net/] ，这是一个学术社交网络\n\n# CCF目录\n\nEI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。\n更 “*不幸*” 的是，对于CS的学生，还有一个[CCF目录](http://history.ccf.org.cn/sites/ccf/paiming.jsp)（[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。\n\n首先说[中国计算机学会 CCF](http://www.ccf.org.cn/)是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然[精简得多](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)。\n考虑到对EI和SCI指标要求的实际情况，目录选取的 **大多** 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。\nA，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。\n\n> 如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 [FGCS\tFuture Generation Computer Systems](http://dblp.org/db/journals/fgcs/)上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。\n> 随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。\n\n上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的[分类系统CCS](http://dl.acm.org/ccs/ccs.cfm)，以及有重叠的[SIGs大类划分](https://www.acm.org/special-interest-groups/sigs-by-knowledge-area)，还有[wikipedia上的一个划分](https://en.wikipedia.org/wiki/Outline_of_computer_science)。\n\n# Google Scholar（谷歌学术）\n[Google Scholar](https://scholar.google.com/)非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 **高级搜索**，实在不行再去ACM DL、IEEE Xplore。\n![谷歌学术高级搜索](/img/scholar_adv.png)\n\n## 创建快讯\n与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；\n此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 **作者的个人资料页** 可以创建关于他的新文章或新引用的快讯，及时获取动态。\n\n> 话说体验一下[必应学术](http://www.bing.com/academic)、[百度学术](http://xueshu.baidu.com/)和[搜狗学术](http://scholar.sogou.com/)也未尝不可。\n\n<a name=\"tldr\" />\n\n# tl,dr：链接列表\n\n## 体系结构，系统，存储，分布式系统\n+ ASPLOS@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE178&tab=pubs) , [DBLP](http://dblp.org/db/conf/asplos/) Architectural Support for Programming Languages and Operating Systems\n+ FAST@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE425&tab=pubs) , [DBLP](http://dblp.org/db/conf/fast/) Conf. on File and Storage Technologies\n+ HPCA@**A**   [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=1000335) , [DBLP](http://dblp.org/db/conf/hpca/) High-Performance Computer Architecture\n+ ISCA@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE239&tab=pubs) , [DBLP](http://dblp.org/db/conf/isca/) Int. Symposium on Computer Architecture\n+ MICRO@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE203&tab=pubs) , [DBLP](http://dblp.org/db/conf/micro/) Microarchitecture\n+ PPoPP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE241&tab=pubs) , [DBLP](http://dblp.org/db/conf/ppopp/) Principles and Practice of Parallel Programming\n+ SC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE207&tab=pubs) , [DBLP](http://dblp.org/db/conf/sc/) Int. Conf. for High Performance Computing, Networking, Storage, and Analysis\n+ ATC@**A**   [USENIX](https://www.usenix.org/conferences/byname/131) , [DBLP](http://dblp.org/db/conf/usenix/) USENIX Annul Technical Conf.\n+ CGO@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE256&tab=pubs) , [DBLP](http://dblp.org/db/conf/cgo/) Code Generation and Optimization\n+ EuroSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE101&tab=pubs) , [DBLP](http://dblp.org/db/conf/eurosys/) European Conf. on Computer Systems\n+ HotCHIPS@**B**   [HotChips](http://www.hotchips.org/) Symposium on High Performance Chips\n+ HPDC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE300&tab=pubs) , [DBLP](http://dblp.org/db/conf/hpdc/) High-Performance Distributed Computing\n+ LISA@**B**   [USENIX](https://www.usenix.org/conferences/byname/5) , [DBLP](http://dblp.org/db/conf/lisa/) Large Installation system Administration Conf.\n+ PODC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE221&tab=pubs) , [DBLP](http://dblp.org/db/conf/podc/) Symposium on Principles of Distributed Computing\n+ SIGMETRICS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE187&tab=pubs)，[ACM](http://dl.acm.org/citation.cfm?id=J618) , [DBLP](http://dblp.org/db/conf/sigmetrics/) Int. Conf. on Measurement and Modeling of Computer Systems\n+ VEE@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE287&tab=pubs) , [DBLP](http://dblp.org/db/conf/vee/) Virtual Execution Environments\n+ TC@**A**   [IEEE](https://www.computer.org/web/tc) , [DBLP](http://dblp.org/db/journals/tc/) Trans. on Computers\n+ TOCS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J774&tab=pubs) , [DBLP](http://dblp.org/db/journals/tocs/) Trans. on Computer Systems\n+ TOS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J960&tab=pubs) , [DBLP](http://dblp.org/db/journals/tos/) Trans. on Storage\n+ TPDS@**A**   [IEEE](https://www.computer.org/web/tpds) , [DBLP](http://dblp.org/db/journals/tpds/) Trans. on Parallel and Distributed Systems\n+ ISMM   [ACM](http://dl.acm.org/event.cfm?id=RE149&tab=pubs) , [DBLP](http://dblp.org/db/conf/ismm/) Int. Conf. on Memory Management\n\n## 软件工程（软件分析）\n+ Github上的[软件工程方向会议的数据](https://github.com/tue-mdse/conferenceMetrics)\n+ UIUC的[谢涛老师](http://taoxie.cs.illinois.edu/)维护的[软件工程方向的会议统计列表](http://taoxie.cs.illinois.edu/seconferences.htm)\n+ ASE@**A**   [DBLP](http://dblp.org/db/conf/kbse/) Int. Conf. on Automated Software Engineering\n+ FSE/ESEC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE201&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigsoft/) SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.\n+ ICSE@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE228&tab=pubs) , [DBLP](http://dblp.org/db/conf/icse/) FOSE会议：七年一届的展望 Int. Conf. on Software Engineering\n+ OOPSLA/SPLASH@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE181&tab=pubs) , [DBLP](http://dblp.org/db/conf/oopsla/) Onward会议：创新(Nao Dong) Conf. on Object-Oriented Programming Systems, Languages, and Applications\n+ OSDI@**A**   [USENIX](https://www.usenix.org/conferences/byname/179) , [DBLP](http://dblp.org/db/conf/osdi/) USENIX Symposium on Operating Systems Design and Implementations，**双数** 年份召开\n+ SOSP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE208&tab=pubs) , [DBLP](http://dblp.org/db/conf/sosp/)，Symposium on Operating Systems Principles， **单数** 年份召开，另，[SOSP 2015 History Day](http://sigops.org/sosp/sosp15/history/index.html)\n+ PLDI@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE200&tab=pubs) , [DBLP](http://dblp.org/db/conf/pldi/) SIGPLAN Symposium on Programming Language Design and Implementation\n+ POPL@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE180&tab=pubs) , [DBLP](http://dblp.org/db/conf/popl/) SIGPLAN&SIGACT Symposium on Principles of Programming Languages\n+ ECOOP@**B**   [ECOOP](http://www.ecoop.org/) , [DBLP](http://dblp.org/db/conf/ecoop/) European Conf. on Object-Oriented Programming\n+ HotOS@**B**   [USENIX](https://www.usenix.org/conferences/byname/155) , [DBLP](http://dblp.org/db/conf/hotos/) USENIX Workshop on Hot Topics in Operating Systems\n+ ICSME@**B**   [IEEE](http://conferences.computer.org/icsm/) , [DBLP](http://dblp.org/db/conf/icsm/) Int. Conf. on Software Maintenance\n+ ISSTA@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE222&tab=pubs) , [DBLP](http://dblp.org/db/conf/issta/) Int. Symposium on Software Testing and Analysis\n+ TOPLAS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J783&tab=pubs) , [DBLP](http://dblp.org/db/journals/toplas/) Trans. on Programming Languages and Systems\n+ TOSEM@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J790&tab=pubs) , [DBLP](http://dblp.org/db/journals/tosem/) Trans. on Software Engineering Methodology\n+ TSE@**A**   [IEEE](https://www.computer.org/web/tse) , [DBLP](http://dblp.org/db/journals/tse/) Trans. on Software Engineering\n\n## 云计算，网络，大数据\n+ SIGMOD@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigmod/) Conf. on Management of Data\n+ SoCC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/cloud/) Symposium on Cloud Computing\n+ PODS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/pods/) SIGMOD Conf. on Principles of DB Systems\n+ VLDB Endowment@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J1174&tab=pubs) , [DBLP](http://dblp.org/db/conf/vldb/) Int. Conf. on Very Large Data Bases\n+ VLDB Journal@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J869&tab=pubs) , [DBLP](http://dblp.org/db/journals/vldb/) Int. Journal on Very Large Data Bases\n+ NSDI@**B**   [USENIX](https://www.usenix.org/conferences/byname/178) , [DBLP](http://dblp.org/db/conf/nsdi/) Network System Design and Implementation\n+ IEEE 云计算系列@**B/C**  [IEEE](http://cloudcomputing.ieee.org/conferences) , [DBLP](http://dblp.org/db/conf/IEEEcloud/)\n+ HotCloud   [USENIX](https://www.usenix.org/conferences/byname/1) , [DBLP](http://dblp.org/db/conf/hotcloud/) Hot Topics on Cloud Computing\n+ TCC   [IEEE](https://www.computer.org/web/tcc) , [DBLP](http://dblp.org/db/journals/tcc/) IEEE Trans. on Cloud Computing\n+ TSC@**B**   [IEEE](https://www.computer.org/web/tsc) , [DBLP](http://dblp.org/db/journals/tsc/) IEEE Trans. on Services Computing\n+ SigComm@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE258&tab=pubs) , [DBLP](http://dblp.org/conf/sigcomm/)\n上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。\n\n## 移动计算\n+ MobiCom@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE366&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobicom/) Mobile Computing and Networking\n+ MobiSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE191&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobisys/) Mobile Systems, Applications, and Services\n+ HotMobile   [ACM](http://dl.acm.org/event.cfm?id=RE142&tab=pubs) , [DBLP](http://dblp.org/db/conf/wmcsa/) Mobile Computing Systems and Applications\n\n## ACM DL列表\n+ [收录会议和期刊的完整列表](http://dl.acm.org/contents_dl.cfm)\n+ [会议](http://dl.acm.org/events.cfm)\n+ [会议历次论文集](http://dl.acm.org/proceedings.cfm)\n+ [期刊和学报](http://dl.acm.org/pubs.cfm)\n+ [杂志](http://dl.acm.org/mags.cfm)\n+ [ACM Conferences - past 12 months](http://dl.acm.org/conferences.cfm)\n+ [ACM Upcoming Conferences - RSS](http://dl.acm.org/UpcomingConfLocations.xml)\n\n关于ACM的杂志，特别推荐\n+ [Communications of the ACM, CACM](http://dl.acm.org/citation.cfm?id=J79)， [in dblp](http://dblp.org/db/journals/cacm/)\n+ [CACM中国版](http://dl.acm.org/toco_arch.cfm?id=J79&lang=chinese)，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去\n+ [Queue](http://dl.acm.org/citation.cfm?id=J882)也值得一看，不过它与CACM有很多重叠的文章\n\n期刊中，推荐[ACM Computing Surveys, CSUR](http://dl.acm.org/citation.cfm?id=J204)， [in dblp](http://dblp.org/db/journals/csur/)\n\n> 看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。\n\n##  IEEE Computer列表\n\n+ [会议日历](https://www.computer.org/web/conferences/calendar/)\n+ [期刊和学报](https://www.computer.org/web/publications/transactions)\n+ [杂志](https://www.computer.org/web/publications/magazines)\n\n## [USENIX组织的会议列表](https://www.usenix.org/conferences/byname)\n[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。\n\n## 国内三个学报\n\n+ [软件学报](http://www.jos.org.cn/ch/index.aspx)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS)\n+ [计算机学报](http://cjc.ict.ac.cn/)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS)\n+ [计算机研究与发展](http://crad.ict.ac.cn/CN/volumn/home.shtml) ，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS)\n\n## 国内论文数据库\n\n+ [知网CNKI](http://www.cnki.net/)\n+ [万方数据](http://www.wanfangdata.com.cn/)\n\n## 其它链接\n+ [微软研究院](https://www.microsoft.com/en-us/research/)\n+ [谷歌研究院](https://research.google.com/pubs/papers.html)\n+ [The morning paper](https://blog.acolyer.org/), an interesting-influential-important paper from the world of CS every weekday morning\n+ [IEEE Technical Committee on Data Engineering](http://sites.computer.org/debull/bull_issues.html)\n+ [YouTube](https://www.youtube.com)，\n+ **[Suggested Guidelines for Finding Materials to include in the \"Related Work\" Sections of Conference Papers](http://www1.cs.columbia.edu/~kaiser/relatedwork.htm)**\n+ [YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表](http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582)  \n\n# 如何读论文\n+ [Efficient Reading of Papers in Science and Technology(.pdf)](http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf)\n+ [How to Read a Paper(.pdf)](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)\n+ [How to Read a Technical Paper](https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html)\n+ [《学术研究 - 你的成功之道》第3章](http://item.jd.com/11127141.html)\n\n# [Todo]辅助工具\n+ [会伴](http://myhuiban.com)\n+ Trans. on BigData的学术文献处理专刊 [Vol. 2 Issue 1](https://www.computer.org/csdl/trans/bd/2016/01/index.html)，[Vol. 2 Issue 2](https://www.computer.org/csdl/trans/bd/2016/02/index.html)\n+ [Sciplore](http://www.sciplore.org/)\n+ [Scopus](https://www.scopus.com/)\n+ [Docear](http://www.docear.org/)\n+ [Mendeley](https://www.mendeley.com/)\n+ [Zotero](https://www.zotero.org/)\n+ [Teambition](https://www.teambition.com/)\n+ Todo，如何整理文献，如何管理时间，[科研小组里有哪些有效的组会形式 - 知乎](https://www.zhihu.com/question/27956707)\n\n如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，**总会觉得** 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去[wikipedia](https://en.wikipedia.org/)上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。\n如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。\n\n> PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)\n\n一些标题有`A systematic review on ...`综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。\n\n再列出知乎上的几个相关问题吧\n+ [如何总结和整理学术文献？](https://www.zhihu.com/question/26901116)\n+ [如何高效管理文献？](https://www.zhihu.com/question/26857521)\n+ [如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?](https://www.zhihu.com/question/22790506)\n\n<a name=\"hosts\" />\n# [Bonus] 如何访问Google Scholar\n\n## **改hosts**\n+ IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N\n+ IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk\n\n## **hosts文件的路径**\n+ Windows：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n+ Linux，Mac，Android(均需要root权限)：`/etc/hosts`\n\n# PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)\n\n---\n\n飞鸟集\n\n> 第83\n> 那想做好人的，在门外敲着门，那爱人的，看见门敞开着。\n\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n","source":"_posts/we-love-paper.md","raw":"title: 如何收集和整理论文（面向CS专业）\ncategory: misc\ndate: 2016-09-28\ntags:\n---\n\n论文（Paper）是每个研究生读研路上挥之不去的“阴云”。\n无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展(State of the art & practice）。\n本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了与相关的机构，学术会议和论文数据库。\n文末有 [**Bonus**](#hosts) 哦;-)\n\n<!--more-->\n\n---\n\n\n\n# tl;dr\n+ 从[CCF推荐目录](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)中自己感兴趣的方向的 **A类会议及期刊** 中找论文即可。\n+ 我关注的云计算，程序分析方向的[会议和期刊列表](#tldr)\n+ [**Bonus**](#hosts) 修改Hosts\n\n<!-- TOC -->\n\n    - [title: 如何收集和整理论文（面向CS专业）](#title-%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E5%92%8C%E6%95%B4%E7%90%86%E8%AE%BA%E6%96%87%EF%BC%88%E9%9D%A2%E5%90%91cs%E4%B8%93%E4%B8%9A%EF%BC%89)\n- [tl;dr](#tldr)\n- [引子](#%E5%BC%95%E5%AD%90)\n    - [论文发表的过程](#%E8%AE%BA%E6%96%87%E5%8F%91%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B)\n- [CS论文数据库](#cs%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93)\n    - [ACM, IEEE Computer等](#acm-ieee-computer%E7%AD%89)\n        - [ACM SIGs](#acm-sigs)\n    - [[USENIX](https://www.usenix.org/)](#usenixhttpswwwusenixorg)\n    - [[arXiv](http://arxiv.org/)](#arxivhttparxivorg)\n    - [EI和SCI](#ei%E5%92%8Csci)\n    - [dblp](#dblp)\n    - [DOI](#doi)\n    - [其它](#%E5%85%B6%E5%AE%83)\n- [CCF目录](#ccf%E7%9B%AE%E5%BD%95)\n- [Google Scholar（谷歌学术）](#google-scholar%EF%BC%88%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%EF%BC%89)\n    - [创建快讯](#%E5%88%9B%E5%BB%BA%E5%BF%AB%E8%AE%AF)\n- [tl,dr：链接列表](#tldr%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8)\n    - [体系结构，系统，存储，分布式系统](#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)\n    - [软件工程（软件分析）](#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%89)\n    - [云计算，网络，大数据](#%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%A4%A7%E6%95%B0%E6%8D%AE)\n    - [移动计算](#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97)\n    - [ACM DL列表](#acm-dl%E5%88%97%E8%A1%A8)\n    - [IEEE Computer列表](#ieee-computer%E5%88%97%E8%A1%A8)\n    - [[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)](#usenix%E7%BB%84%E7%BB%87%E7%9A%84%E4%BC%9A%E8%AE%AE%E5%88%97%E8%A1%A8httpswwwusenixorgconferencesbyname)\n    - [国内三个学报](#%E5%9B%BD%E5%86%85%E4%B8%89%E4%B8%AA%E5%AD%A6%E6%8A%A5)\n    - [国内论文数据库](#%E5%9B%BD%E5%86%85%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93)\n    - [其它链接](#%E5%85%B6%E5%AE%83%E9%93%BE%E6%8E%A5)\n- [如何读论文](#%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87)\n- [[Todo]辅助工具](#todo%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7)\n    - [**改hosts**](#%E6%94%B9hosts)\n    - [**hosts文件的路径**](#hosts%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84)\n- [PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)](#ps-a-survival-guide-to-a-phdhttpkarpathygithubio20160907phd)\n\n<!-- /TOC -->\n\n# 引子\n按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：\n+ 周志华老师的一篇关于[做研究与写论文的ppt](/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf)\n+ 凌晓峰和杨强的[《学术研究 - 你的成功之道》](http://item.jd.com/11127141.html)，这本书的英文原版是[Crafting Your Research Future - A Guide to Successful Master's and Ph.D. Degrees in Science & Engineering](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064)\n\n首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果(的一部分)，结果是必要的，自然也就少不了Paper或者总结报告；\n再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。\n重要的是要 *有意识地探索和总结适合自己的科研方法*，既要低头苦干，又要抬头看路，还要回头总结。\n\n## 论文发表的过程\n\n<pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n简单介绍一下发表论文的过程：\n+ 首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如[UC Berkeley 的AMPLab](https://amplab.cs.berkeley.edu/)；还有一些公司的研究院，比如[微软](https://www.microsoft.com/en-us/research/)，[谷歌](https://research.google.com/pubs/papers.html)。显然，论文的出身对质量有很大影响。\n+ 期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期(deadline)的压力。投稿后一般要经过同行评审(Peer Review)，针对审稿人的建议做大修，小修(Major，Minor Revision)等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊(Special Issue)计划，会公布一个截稿日期，审稿的进度会稍快些。\n期刊分为 **Transaction, Journal 和 Magazine** 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 *不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是* [Communications of the ACM, CACM, ACM通讯](http://dl.acm.org/citation.cfm?id=J79) *值得关注*。\n+ 对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等，所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。\n很多会议每年举行一次，时间上也是比较固定的，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。\n会议录用的所有Paper会结集出版，称为 *Proceedings* 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。\n会议分为 *Symposium , Conference 和 Workshop*。这三者的学术严肃性依次降低，大部分会议都称为 *Conference*。一般来说 *Workshop* 是随某个 *Conference* 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。\n\n通过这个过程，我们还可以知道如何**尽快**找到一篇感兴趣的文章：\n+ 对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access；\n+ 对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。\n\n# CS论文数据库\n\n## ACM, IEEE Computer等\n\n一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及[图书馆页面截图](#lib)。\n> 注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。\n\n| 机构                                     | Digital Library （DL）                              | 机构首页                   |\n|------------------------------------------|----------------------------------------------------|----------------------------|\n| Association for Computing Machinery, ACM | ACM Digital Library  https://dl.acm.org/           | https://www.acm.org/       |\n| IEEE Computer Society                    | IEEE Xplore DL http://ieeexplore.ieee.org/         | https://www.computer.org/  |\n| Elsevier ScienceDirect                   | http://www.sciencedirect.com/                      | https://www.elsevier.com/  |\n| Springer                                 | Springer Link http://link.springer.com/            | http://www.springer.com/   |\n| Wiley                                    | Wiley Online Lib http://onlinelibrary.wiley.com/   | http://www.wiley.com/      |\n\nACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 *.org*，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。\nElsevier，Springer，Wiley的网址后缀则是 *.com* ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。\n上面这几个数据库是 **主要的论文全文来源**。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。\n> ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 **元数据**，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。\n> IEEE出版的一些论文在 computer.org （实际是[CSDL](https://www.computer.org/csdl/)）和 Xplore DL 都可能搜到，但这两个数据库是 *分别* 收费的，能在Xplore DL下载的不一定能在Computer.org下载。\n\n### ACM SIGs\nACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个[ACM SIGs](http://www.acm.org/sigs/)（或参考DL的这个链接[SIGs ACM DL](http://dl.acm.org/sigs.cfm)），比如\n+ 体系结构方向的[SIGARCH](http://www.sigarch.org/)、[SIGHPC](http://www.sighpc.org/)、[SIGMETRICS](http://www.sigmetrics.org/)、[SIGMICRO](http://www.sigmicro.org/)、[SIGMOBILE](http://www.sigmobile.org/)，\n+ 网络方向的[SIGCOMM](http://www.sigcomm.org/)，\n+ 数据库方向的[SIGMOD](http://www.sigmod.org/)，\n+ 系统方向的[SIGOPS](http://www.sigops.org/)，\n+ 软件工程方向的[SIGPLAN](http://www.sigplan.org/)、[SIGSOFT](http://www.sigsoft.org/)\n\n这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 **最佳论文**，**优秀博士论文** 等(在DL中一般没有哪篇是Best Paper的信息)。此外，\n+ 有网站维护了一个[部分会议的最佳论文列表](http://jeffhuang.com/best_paper_awards.html)，\n+ 还有下面要介绍的USENIX的[各会议最佳论文](https://www.usenix.org/conferences/best-papers)。\n\n除此之外，有的SIG会选择一些高质量的文章，以Review，Newsletter 或Notes的形式重新发表。\n\n## [USENIX](https://www.usenix.org/)\n要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。\n话说**[USENIX](https://www.usenix.org/)** 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slices及演讲视频。slices是对文章的提炼，读论文时可以参考。拿slices和视频来学习做Presentation，练习英语听力和口语也不错。\n\n## [arXiv](http://arxiv.org/)\n[arXiv](http://arxiv.org/)， 是archive(归档)的意思，是一个由康乃尔大学维护的免费的多学科论文**预**出版(preprint)数据库。所谓**预**出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。\n\n<a name=\"lib\" />![图书馆电子资源](/img/lib.png)\n\n## EI和SCI\n分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，\n+ EI *Engineering Index* https://www.engineeringvillage.com/\n+ SCI *Science Citation Index* http://apps.webofknowledge.com/\n\n只看 *URL* 还以为是 *山寨网站*，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 **已知文章标题的情况下** 检索是不是被它们收录了，而 **不是** 用来收集文章的。\n\n要确定某个会议论文集或者期刊[是否被EI或SCI收录](http://www.philippe-fournier-viger.com/links.php)，\n+ 在[EI收录列表](https://www.elsevier.com/solutions/engineering-village/content) 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考[这个脚本解除保护](/doc/crack_xls_vb.txt)，还要建议把title列中每个单元格开头的`=`替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫`Computing`，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。**但是！**，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 **Compendex**。\n+ 在`webofknowledge`的网站查询之前，**一定** 要选择数据库为`检索 Web of Science 核心合集`，等自动刷新候，还要在页面下部展开“更多设置”，只选中`Science Citation Index Expanded (SCIEXPANDED) 1900年至今`这一项，然后才能查询出根正苗红的`SCI（E）`。请**务必**参考[这个截图](/doc/SCI_E_Web_of_Science.pdf)。可以在[SCI收录列表](http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K)直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：[中国科学技术信息研究所SCI（E）论文期刊分区列表(2016年)](http://scit.nju.edu.cn/Item/1162.aspx)，这是一个有13.8k多行的Excel表格，简洁粗暴。\n\n----\n上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。\n校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。\n话说只要是能花钱买到的东西，去万能的 **淘宝** 肯定能找到，就看是买 *VPN/代理*，*单篇文章*，还是 *整个数据库* 了。\n\n## dblp\ndblp [http://dblp.org] ，或[http://dblp.uni-trier.de]， 是专注于CS学科的文献 **元数据索引** 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 http://dblp.org/db/conf/sigsoft/fse2016.html 或者某个作者的全部论文列表(dblp对重名作者处理得很好)，但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。\n2015版CCF目录中的会议和期刊都是dblp的链接。\n\ndblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）\n+ [累计论文记录数量](http://dblp.dagstuhl.de/statistics/recordsindblp.html)，\n+ [每年发表的论文数量](http://dblp.dagstuhl.de/statistics/publicationsperyear.html)，\n+ [论文发表的类型](http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html)，其中会议论文占53%，\n+ 论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。\n\n另外，ACM DL也有一个[类似的统计](http://dl.acm.org/contents_guide.cfm)。\n![每年发表的CS论文数量](/img/pubs.png)\n\n而且dblp整站的数据都可以下载为一个[xml文件](http://dblp.dagstuhl.de/xml/)，以供进一步挖掘。\n\n## DOI\n在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，[wikipedia介绍DOI](https://zh.wikipedia.org/wiki/DOI)“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。\n\n## 其它\n从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。\n+ Semantic Scholar [https://www.semanticscholar.org]\n+ CiteSeerX [http://citeseerx.ist.psu.edu/]\n+ ResearchGate [https://www.researchgate.net/] ，这是一个学术社交网络\n\n# CCF目录\n\nEI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。\n更 “*不幸*” 的是，对于CS的学生，还有一个[CCF目录](http://history.ccf.org.cn/sites/ccf/paiming.jsp)（[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。\n\n首先说[中国计算机学会 CCF](http://www.ccf.org.cn/)是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然[精简得多](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)。\n考虑到对EI和SCI指标要求的实际情况，目录选取的 **大多** 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。\nA，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。\n\n> 如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 [FGCS\tFuture Generation Computer Systems](http://dblp.org/db/journals/fgcs/)上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。\n> 随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。\n\n上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的[分类系统CCS](http://dl.acm.org/ccs/ccs.cfm)，以及有重叠的[SIGs大类划分](https://www.acm.org/special-interest-groups/sigs-by-knowledge-area)，还有[wikipedia上的一个划分](https://en.wikipedia.org/wiki/Outline_of_computer_science)。\n\n# Google Scholar（谷歌学术）\n[Google Scholar](https://scholar.google.com/)非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 **高级搜索**，实在不行再去ACM DL、IEEE Xplore。\n![谷歌学术高级搜索](/img/scholar_adv.png)\n\n## 创建快讯\n与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；\n此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 **作者的个人资料页** 可以创建关于他的新文章或新引用的快讯，及时获取动态。\n\n> 话说体验一下[必应学术](http://www.bing.com/academic)、[百度学术](http://xueshu.baidu.com/)和[搜狗学术](http://scholar.sogou.com/)也未尝不可。\n\n<a name=\"tldr\" />\n\n# tl,dr：链接列表\n\n## 体系结构，系统，存储，分布式系统\n+ ASPLOS@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE178&tab=pubs) , [DBLP](http://dblp.org/db/conf/asplos/) Architectural Support for Programming Languages and Operating Systems\n+ FAST@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE425&tab=pubs) , [DBLP](http://dblp.org/db/conf/fast/) Conf. on File and Storage Technologies\n+ HPCA@**A**   [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=1000335) , [DBLP](http://dblp.org/db/conf/hpca/) High-Performance Computer Architecture\n+ ISCA@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE239&tab=pubs) , [DBLP](http://dblp.org/db/conf/isca/) Int. Symposium on Computer Architecture\n+ MICRO@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE203&tab=pubs) , [DBLP](http://dblp.org/db/conf/micro/) Microarchitecture\n+ PPoPP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE241&tab=pubs) , [DBLP](http://dblp.org/db/conf/ppopp/) Principles and Practice of Parallel Programming\n+ SC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE207&tab=pubs) , [DBLP](http://dblp.org/db/conf/sc/) Int. Conf. for High Performance Computing, Networking, Storage, and Analysis\n+ ATC@**A**   [USENIX](https://www.usenix.org/conferences/byname/131) , [DBLP](http://dblp.org/db/conf/usenix/) USENIX Annul Technical Conf.\n+ CGO@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE256&tab=pubs) , [DBLP](http://dblp.org/db/conf/cgo/) Code Generation and Optimization\n+ EuroSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE101&tab=pubs) , [DBLP](http://dblp.org/db/conf/eurosys/) European Conf. on Computer Systems\n+ HotCHIPS@**B**   [HotChips](http://www.hotchips.org/) Symposium on High Performance Chips\n+ HPDC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE300&tab=pubs) , [DBLP](http://dblp.org/db/conf/hpdc/) High-Performance Distributed Computing\n+ LISA@**B**   [USENIX](https://www.usenix.org/conferences/byname/5) , [DBLP](http://dblp.org/db/conf/lisa/) Large Installation system Administration Conf.\n+ PODC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE221&tab=pubs) , [DBLP](http://dblp.org/db/conf/podc/) Symposium on Principles of Distributed Computing\n+ SIGMETRICS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE187&tab=pubs)，[ACM](http://dl.acm.org/citation.cfm?id=J618) , [DBLP](http://dblp.org/db/conf/sigmetrics/) Int. Conf. on Measurement and Modeling of Computer Systems\n+ VEE@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE287&tab=pubs) , [DBLP](http://dblp.org/db/conf/vee/) Virtual Execution Environments\n+ TC@**A**   [IEEE](https://www.computer.org/web/tc) , [DBLP](http://dblp.org/db/journals/tc/) Trans. on Computers\n+ TOCS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J774&tab=pubs) , [DBLP](http://dblp.org/db/journals/tocs/) Trans. on Computer Systems\n+ TOS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J960&tab=pubs) , [DBLP](http://dblp.org/db/journals/tos/) Trans. on Storage\n+ TPDS@**A**   [IEEE](https://www.computer.org/web/tpds) , [DBLP](http://dblp.org/db/journals/tpds/) Trans. on Parallel and Distributed Systems\n+ ISMM   [ACM](http://dl.acm.org/event.cfm?id=RE149&tab=pubs) , [DBLP](http://dblp.org/db/conf/ismm/) Int. Conf. on Memory Management\n\n## 软件工程（软件分析）\n+ Github上的[软件工程方向会议的数据](https://github.com/tue-mdse/conferenceMetrics)\n+ UIUC的[谢涛老师](http://taoxie.cs.illinois.edu/)维护的[软件工程方向的会议统计列表](http://taoxie.cs.illinois.edu/seconferences.htm)\n+ ASE@**A**   [DBLP](http://dblp.org/db/conf/kbse/) Int. Conf. on Automated Software Engineering\n+ FSE/ESEC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE201&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigsoft/) SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.\n+ ICSE@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE228&tab=pubs) , [DBLP](http://dblp.org/db/conf/icse/) FOSE会议：七年一届的展望 Int. Conf. on Software Engineering\n+ OOPSLA/SPLASH@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE181&tab=pubs) , [DBLP](http://dblp.org/db/conf/oopsla/) Onward会议：创新(Nao Dong) Conf. on Object-Oriented Programming Systems, Languages, and Applications\n+ OSDI@**A**   [USENIX](https://www.usenix.org/conferences/byname/179) , [DBLP](http://dblp.org/db/conf/osdi/) USENIX Symposium on Operating Systems Design and Implementations，**双数** 年份召开\n+ SOSP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE208&tab=pubs) , [DBLP](http://dblp.org/db/conf/sosp/)，Symposium on Operating Systems Principles， **单数** 年份召开，另，[SOSP 2015 History Day](http://sigops.org/sosp/sosp15/history/index.html)\n+ PLDI@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE200&tab=pubs) , [DBLP](http://dblp.org/db/conf/pldi/) SIGPLAN Symposium on Programming Language Design and Implementation\n+ POPL@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE180&tab=pubs) , [DBLP](http://dblp.org/db/conf/popl/) SIGPLAN&SIGACT Symposium on Principles of Programming Languages\n+ ECOOP@**B**   [ECOOP](http://www.ecoop.org/) , [DBLP](http://dblp.org/db/conf/ecoop/) European Conf. on Object-Oriented Programming\n+ HotOS@**B**   [USENIX](https://www.usenix.org/conferences/byname/155) , [DBLP](http://dblp.org/db/conf/hotos/) USENIX Workshop on Hot Topics in Operating Systems\n+ ICSME@**B**   [IEEE](http://conferences.computer.org/icsm/) , [DBLP](http://dblp.org/db/conf/icsm/) Int. Conf. on Software Maintenance\n+ ISSTA@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE222&tab=pubs) , [DBLP](http://dblp.org/db/conf/issta/) Int. Symposium on Software Testing and Analysis\n+ TOPLAS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J783&tab=pubs) , [DBLP](http://dblp.org/db/journals/toplas/) Trans. on Programming Languages and Systems\n+ TOSEM@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J790&tab=pubs) , [DBLP](http://dblp.org/db/journals/tosem/) Trans. on Software Engineering Methodology\n+ TSE@**A**   [IEEE](https://www.computer.org/web/tse) , [DBLP](http://dblp.org/db/journals/tse/) Trans. on Software Engineering\n\n## 云计算，网络，大数据\n+ SIGMOD@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigmod/) Conf. on Management of Data\n+ SoCC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/cloud/) Symposium on Cloud Computing\n+ PODS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/pods/) SIGMOD Conf. on Principles of DB Systems\n+ VLDB Endowment@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J1174&tab=pubs) , [DBLP](http://dblp.org/db/conf/vldb/) Int. Conf. on Very Large Data Bases\n+ VLDB Journal@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J869&tab=pubs) , [DBLP](http://dblp.org/db/journals/vldb/) Int. Journal on Very Large Data Bases\n+ NSDI@**B**   [USENIX](https://www.usenix.org/conferences/byname/178) , [DBLP](http://dblp.org/db/conf/nsdi/) Network System Design and Implementation\n+ IEEE 云计算系列@**B/C**  [IEEE](http://cloudcomputing.ieee.org/conferences) , [DBLP](http://dblp.org/db/conf/IEEEcloud/)\n+ HotCloud   [USENIX](https://www.usenix.org/conferences/byname/1) , [DBLP](http://dblp.org/db/conf/hotcloud/) Hot Topics on Cloud Computing\n+ TCC   [IEEE](https://www.computer.org/web/tcc) , [DBLP](http://dblp.org/db/journals/tcc/) IEEE Trans. on Cloud Computing\n+ TSC@**B**   [IEEE](https://www.computer.org/web/tsc) , [DBLP](http://dblp.org/db/journals/tsc/) IEEE Trans. on Services Computing\n+ SigComm@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE258&tab=pubs) , [DBLP](http://dblp.org/conf/sigcomm/)\n上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。\n\n## 移动计算\n+ MobiCom@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE366&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobicom/) Mobile Computing and Networking\n+ MobiSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE191&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobisys/) Mobile Systems, Applications, and Services\n+ HotMobile   [ACM](http://dl.acm.org/event.cfm?id=RE142&tab=pubs) , [DBLP](http://dblp.org/db/conf/wmcsa/) Mobile Computing Systems and Applications\n\n## ACM DL列表\n+ [收录会议和期刊的完整列表](http://dl.acm.org/contents_dl.cfm)\n+ [会议](http://dl.acm.org/events.cfm)\n+ [会议历次论文集](http://dl.acm.org/proceedings.cfm)\n+ [期刊和学报](http://dl.acm.org/pubs.cfm)\n+ [杂志](http://dl.acm.org/mags.cfm)\n+ [ACM Conferences - past 12 months](http://dl.acm.org/conferences.cfm)\n+ [ACM Upcoming Conferences - RSS](http://dl.acm.org/UpcomingConfLocations.xml)\n\n关于ACM的杂志，特别推荐\n+ [Communications of the ACM, CACM](http://dl.acm.org/citation.cfm?id=J79)， [in dblp](http://dblp.org/db/journals/cacm/)\n+ [CACM中国版](http://dl.acm.org/toco_arch.cfm?id=J79&lang=chinese)，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去\n+ [Queue](http://dl.acm.org/citation.cfm?id=J882)也值得一看，不过它与CACM有很多重叠的文章\n\n期刊中，推荐[ACM Computing Surveys, CSUR](http://dl.acm.org/citation.cfm?id=J204)， [in dblp](http://dblp.org/db/journals/csur/)\n\n> 看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。\n\n##  IEEE Computer列表\n\n+ [会议日历](https://www.computer.org/web/conferences/calendar/)\n+ [期刊和学报](https://www.computer.org/web/publications/transactions)\n+ [杂志](https://www.computer.org/web/publications/magazines)\n\n## [USENIX组织的会议列表](https://www.usenix.org/conferences/byname)\n[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。\n\n## 国内三个学报\n\n+ [软件学报](http://www.jos.org.cn/ch/index.aspx)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS)\n+ [计算机学报](http://cjc.ict.ac.cn/)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS)\n+ [计算机研究与发展](http://crad.ict.ac.cn/CN/volumn/home.shtml) ，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS)\n\n## 国内论文数据库\n\n+ [知网CNKI](http://www.cnki.net/)\n+ [万方数据](http://www.wanfangdata.com.cn/)\n\n## 其它链接\n+ [微软研究院](https://www.microsoft.com/en-us/research/)\n+ [谷歌研究院](https://research.google.com/pubs/papers.html)\n+ [The morning paper](https://blog.acolyer.org/), an interesting-influential-important paper from the world of CS every weekday morning\n+ [IEEE Technical Committee on Data Engineering](http://sites.computer.org/debull/bull_issues.html)\n+ [YouTube](https://www.youtube.com)，\n+ **[Suggested Guidelines for Finding Materials to include in the \"Related Work\" Sections of Conference Papers](http://www1.cs.columbia.edu/~kaiser/relatedwork.htm)**\n+ [YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表](http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582)  \n\n# 如何读论文\n+ [Efficient Reading of Papers in Science and Technology(.pdf)](http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf)\n+ [How to Read a Paper(.pdf)](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)\n+ [How to Read a Technical Paper](https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html)\n+ [《学术研究 - 你的成功之道》第3章](http://item.jd.com/11127141.html)\n\n# [Todo]辅助工具\n+ [会伴](http://myhuiban.com)\n+ Trans. on BigData的学术文献处理专刊 [Vol. 2 Issue 1](https://www.computer.org/csdl/trans/bd/2016/01/index.html)，[Vol. 2 Issue 2](https://www.computer.org/csdl/trans/bd/2016/02/index.html)\n+ [Sciplore](http://www.sciplore.org/)\n+ [Scopus](https://www.scopus.com/)\n+ [Docear](http://www.docear.org/)\n+ [Mendeley](https://www.mendeley.com/)\n+ [Zotero](https://www.zotero.org/)\n+ [Teambition](https://www.teambition.com/)\n+ Todo，如何整理文献，如何管理时间，[科研小组里有哪些有效的组会形式 - 知乎](https://www.zhihu.com/question/27956707)\n\n如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，**总会觉得** 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去[wikipedia](https://en.wikipedia.org/)上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。\n如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。\n\n> PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)\n\n一些标题有`A systematic review on ...`综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。\n\n再列出知乎上的几个相关问题吧\n+ [如何总结和整理学术文献？](https://www.zhihu.com/question/26901116)\n+ [如何高效管理文献？](https://www.zhihu.com/question/26857521)\n+ [如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?](https://www.zhihu.com/question/22790506)\n\n<a name=\"hosts\" />\n# [Bonus] 如何访问Google Scholar\n\n## **改hosts**\n+ IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N\n+ IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk\n\n## **hosts文件的路径**\n+ Windows：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n+ Linux，Mac，Android(均需要root权限)：`/etc/hosts`\n\n# PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)\n\n---\n\n飞鸟集\n\n> 第83\n> 那想做好人的，在门外敲着门，那爱人的，看见门敞开着。\n\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n","slug":"we-love-paper","published":1,"updated":"2017-10-30T02:46:36.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn7xwj0002nw4fwze7kykl","content":"<p>论文（Paper）是每个研究生读研路上挥之不去的“阴云”。<br>无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展(State of the art &amp; practice）。<br>本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了与相关的机构，学术会议和论文数据库。<br>文末有 <a href=\"#hosts\"><strong>Bonus</strong></a> 哦;-)</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"tl-dr\"><a href=\"#tl-dr\" class=\"headerlink\" title=\"tl;dr\"></a>tl;dr</h1><ul>\n<li>从<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">CCF推荐目录</a>中自己感兴趣的方向的 <strong>A类会议及期刊</strong> 中找论文即可。</li>\n<li>我关注的云计算，程序分析方向的<a href=\"#tldr\">会议和期刊列表</a></li>\n<li><a href=\"#hosts\"><strong>Bonus</strong></a> 修改Hosts</li>\n</ul>\n<!-- TOC -->\n<pre><code>- [title: 如何收集和整理论文（面向CS专业）](#title-%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E5%92%8C%E6%95%B4%E7%90%86%E8%AE%BA%E6%96%87%EF%BC%88%E9%9D%A2%E5%90%91cs%E4%B8%93%E4%B8%9A%EF%BC%89)\n</code></pre><ul>\n<li><a href=\"#tldr\">tl;dr</a></li>\n<li><a href=\"#%E5%BC%95%E5%AD%90\">引子</a><ul>\n<li><a href=\"#%E8%AE%BA%E6%96%87%E5%8F%91%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B\">论文发表的过程</a></li>\n</ul>\n</li>\n<li><a href=\"#cs%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93\">CS论文数据库</a><ul>\n<li><a href=\"#acm-ieee-computer%E7%AD%89\">ACM, IEEE Computer等</a><ul>\n<li><a href=\"#acm-sigs\">ACM SIGs</a></li>\n</ul>\n</li>\n<li><a href=\"#usenixhttpswwwusenixorg\"><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></a></li>\n<li><a href=\"#arxivhttparxivorg\"><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></a></li>\n<li><a href=\"#ei%E5%92%8Csci\">EI和SCI</a></li>\n<li><a href=\"#dblp\">dblp</a></li>\n<li><a href=\"#doi\">DOI</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95\">CCF目录</a></li>\n<li><a href=\"#google-scholar%EF%BC%88%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%EF%BC%89\">Google Scholar（谷歌学术）</a><ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E5%BF%AB%E8%AE%AF\">创建快讯</a></li>\n</ul>\n</li>\n<li><a href=\"#tldr%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8\">tl,dr：链接列表</a><ul>\n<li><a href=\"#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F\">体系结构，系统，存储，分布式系统</a></li>\n<li><a href=\"#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%89\">软件工程（软件分析）</a></li>\n<li><a href=\"#%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%A4%A7%E6%95%B0%E6%8D%AE\">云计算，网络，大数据</a></li>\n<li><a href=\"#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97\">移动计算</a></li>\n<li><a href=\"#acm-dl%E5%88%97%E8%A1%A8\">ACM DL列表</a></li>\n<li><a href=\"#ieee-computer%E5%88%97%E8%A1%A8\">IEEE Computer列表</a></li>\n<li><a href=\"#usenix%E7%BB%84%E7%BB%87%E7%9A%84%E4%BC%9A%E8%AE%AE%E5%88%97%E8%A1%A8httpswwwusenixorgconferencesbyname\"><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></a></li>\n<li><a href=\"#%E5%9B%BD%E5%86%85%E4%B8%89%E4%B8%AA%E5%AD%A6%E6%8A%A5\">国内三个学报</a></li>\n<li><a href=\"#%E5%9B%BD%E5%86%85%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93\">国内论文数据库</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%93%BE%E6%8E%A5\">其它链接</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87\">如何读论文</a></li>\n<li><a href=\"#todo%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7\">[Todo]辅助工具</a><ul>\n<li><a href=\"#%E6%94%B9hosts\"><strong>改hosts</strong></a></li>\n<li><a href=\"#hosts%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84\"><strong>hosts文件的路径</strong></a></li>\n</ul>\n</li>\n<li><a href=\"#ps-a-survival-guide-to-a-phdhttpkarpathygithubio20160907phd\">PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：</p>\n<ul>\n<li>周志华老师的一篇关于<a href=\"/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf\">做研究与写论文的ppt</a></li>\n<li>凌晓峰和杨强的<a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》</a>，这本书的英文原版是<a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064\" target=\"_blank\" rel=\"external\">Crafting Your Research Future - A Guide to Successful Master’s and Ph.D. Degrees in Science &amp; Engineering</a></li>\n</ul>\n<p>首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果(的一部分)，结果是必要的，自然也就少不了Paper或者总结报告；<br>再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。<br>重要的是要 <em>有意识地探索和总结适合自己的科研方法</em>，既要低头苦干，又要抬头看路，还要回头总结。</p>\n<h2 id=\"论文发表的过程\"><a href=\"#论文发表的过程\" class=\"headerlink\" title=\"论文发表的过程\"></a>论文发表的过程</h2><pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n<p>简单介绍一下发表论文的过程：</p>\n<ul>\n<li>首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如<a href=\"https://amplab.cs.berkeley.edu/\" target=\"_blank\" rel=\"external\">UC Berkeley 的AMPLab</a>；还有一些公司的研究院，比如<a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软</a>，<a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌</a>。显然，论文的出身对质量有很大影响。</li>\n<li>期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期(deadline)的压力。投稿后一般要经过同行评审(Peer Review)，针对审稿人的建议做大修，小修(Major，Minor Revision)等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊(Special Issue)计划，会公布一个截稿日期，审稿的进度会稍快些。<br>期刊分为 <strong>Transaction, Journal 和 Magazine</strong> 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 <em>不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是</em> <a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM, ACM通讯</a> <em>值得关注</em>。</li>\n<li>对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等，所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。<br>很多会议每年举行一次，时间上也是比较固定的，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。<br>会议录用的所有Paper会结集出版，称为 <em>Proceedings</em> 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。<br>会议分为 <em>Symposium , Conference 和 Workshop</em>。这三者的学术严肃性依次降低，大部分会议都称为 <em>Conference</em>。一般来说 <em>Workshop</em> 是随某个 <em>Conference</em> 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。</li>\n</ul>\n<p>通过这个过程，我们还可以知道如何<strong>尽快</strong>找到一篇感兴趣的文章：</p>\n<ul>\n<li>对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access；</li>\n<li>对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。</li>\n</ul>\n<h1 id=\"CS论文数据库\"><a href=\"#CS论文数据库\" class=\"headerlink\" title=\"CS论文数据库\"></a>CS论文数据库</h1><h2 id=\"ACM-IEEE-Computer等\"><a href=\"#ACM-IEEE-Computer等\" class=\"headerlink\" title=\"ACM, IEEE Computer等\"></a>ACM, IEEE Computer等</h2><p>一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及<a href=\"#lib\">图书馆页面截图</a>。</p>\n<blockquote>\n<p>注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>机构</th>\n<th>Digital Library （DL）</th>\n<th>机构首页</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Association for Computing Machinery, ACM</td>\n<td>ACM Digital Library  <a href=\"https://dl.acm.org/\" target=\"_blank\" rel=\"external\">https://dl.acm.org/</a></td>\n<td><a href=\"https://www.acm.org/\" target=\"_blank\" rel=\"external\">https://www.acm.org/</a></td>\n</tr>\n<tr>\n<td>IEEE Computer Society</td>\n<td>IEEE Xplore DL <a href=\"http://ieeexplore.ieee.org/\" target=\"_blank\" rel=\"external\">http://ieeexplore.ieee.org/</a></td>\n<td><a href=\"https://www.computer.org/\" target=\"_blank\" rel=\"external\">https://www.computer.org/</a></td>\n</tr>\n<tr>\n<td>Elsevier ScienceDirect</td>\n<td><a href=\"http://www.sciencedirect.com/\" target=\"_blank\" rel=\"external\">http://www.sciencedirect.com/</a></td>\n<td><a href=\"https://www.elsevier.com/\" target=\"_blank\" rel=\"external\">https://www.elsevier.com/</a></td>\n</tr>\n<tr>\n<td>Springer</td>\n<td>Springer Link <a href=\"http://link.springer.com/\" target=\"_blank\" rel=\"external\">http://link.springer.com/</a></td>\n<td><a href=\"http://www.springer.com/\" target=\"_blank\" rel=\"external\">http://www.springer.com/</a></td>\n</tr>\n<tr>\n<td>Wiley</td>\n<td>Wiley Online Lib <a href=\"http://onlinelibrary.wiley.com/\" target=\"_blank\" rel=\"external\">http://onlinelibrary.wiley.com/</a></td>\n<td><a href=\"http://www.wiley.com/\" target=\"_blank\" rel=\"external\">http://www.wiley.com/</a></td>\n</tr>\n</tbody>\n</table>\n<p>ACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 <em>.org</em>，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。<br>Elsevier，Springer，Wiley的网址后缀则是 <em>.com</em> ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。<br>上面这几个数据库是 <strong>主要的论文全文来源</strong>。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。</p>\n<blockquote>\n<p>ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 <strong>元数据</strong>，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。<br>IEEE出版的一些论文在 computer.org （实际是<a href=\"https://www.computer.org/csdl/\" target=\"_blank\" rel=\"external\">CSDL</a>）和 Xplore DL 都可能搜到，但这两个数据库是 <em>分别</em> 收费的，能在Xplore DL下载的不一定能在Computer.org下载。</p>\n</blockquote>\n<h3 id=\"ACM-SIGs\"><a href=\"#ACM-SIGs\" class=\"headerlink\" title=\"ACM SIGs\"></a>ACM SIGs</h3><p>ACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个<a href=\"http://www.acm.org/sigs/\" target=\"_blank\" rel=\"external\">ACM SIGs</a>（或参考DL的这个链接<a href=\"http://dl.acm.org/sigs.cfm\" target=\"_blank\" rel=\"external\">SIGs ACM DL</a>），比如</p>\n<ul>\n<li>体系结构方向的<a href=\"http://www.sigarch.org/\" target=\"_blank\" rel=\"external\">SIGARCH</a>、<a href=\"http://www.sighpc.org/\" target=\"_blank\" rel=\"external\">SIGHPC</a>、<a href=\"http://www.sigmetrics.org/\" target=\"_blank\" rel=\"external\">SIGMETRICS</a>、<a href=\"http://www.sigmicro.org/\" target=\"_blank\" rel=\"external\">SIGMICRO</a>、<a href=\"http://www.sigmobile.org/\" target=\"_blank\" rel=\"external\">SIGMOBILE</a>，</li>\n<li>网络方向的<a href=\"http://www.sigcomm.org/\" target=\"_blank\" rel=\"external\">SIGCOMM</a>，</li>\n<li>数据库方向的<a href=\"http://www.sigmod.org/\" target=\"_blank\" rel=\"external\">SIGMOD</a>，</li>\n<li>系统方向的<a href=\"http://www.sigops.org/\" target=\"_blank\" rel=\"external\">SIGOPS</a>，</li>\n<li>软件工程方向的<a href=\"http://www.sigplan.org/\" target=\"_blank\" rel=\"external\">SIGPLAN</a>、<a href=\"http://www.sigsoft.org/\" target=\"_blank\" rel=\"external\">SIGSOFT</a></li>\n</ul>\n<p>这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 <strong>最佳论文</strong>，<strong>优秀博士论文</strong> 等(在DL中一般没有哪篇是Best Paper的信息)。此外，</p>\n<ul>\n<li>有网站维护了一个<a href=\"http://jeffhuang.com/best_paper_awards.html\" target=\"_blank\" rel=\"external\">部分会议的最佳论文列表</a>，</li>\n<li>还有下面要介绍的USENIX的<a href=\"https://www.usenix.org/conferences/best-papers\" target=\"_blank\" rel=\"external\">各会议最佳论文</a>。</li>\n</ul>\n<p>除此之外，有的SIG会选择一些高质量的文章，以Review，Newsletter 或Notes的形式重新发表。</p>\n<h2 id=\"USENIX\"><a href=\"#USENIX\" class=\"headerlink\" title=\"USENIX\"></a><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></h2><p>要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。<br>话说<strong><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></strong> 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slices及演讲视频。slices是对文章的提炼，读论文时可以参考。拿slices和视频来学习做Presentation，练习英语听力和口语也不错。</p>\n<h2 id=\"arXiv\"><a href=\"#arXiv\" class=\"headerlink\" title=\"arXiv\"></a><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></h2><p><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a>， 是archive(归档)的意思，是一个由康乃尔大学维护的免费的多学科论文<strong>预</strong>出版(preprint)数据库。所谓<strong>预</strong>出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。</p>\n<p><a name=\"lib\"><img src=\"/img/lib.png\" alt=\"图书馆电子资源\"></a></p>\n<h2 id=\"EI和SCI\"><a href=\"#EI和SCI\" class=\"headerlink\" title=\"EI和SCI\"></a>EI和SCI</h2><p>分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，</p>\n<ul>\n<li>EI <em>Engineering Index</em> <a href=\"https://www.engineeringvillage.com/\" target=\"_blank\" rel=\"external\">https://www.engineeringvillage.com/</a></li>\n<li>SCI <em>Science Citation Index</em> <a href=\"http://apps.webofknowledge.com/\" target=\"_blank\" rel=\"external\">http://apps.webofknowledge.com/</a></li>\n</ul>\n<p>只看 <em>URL</em> 还以为是 <em>山寨网站</em>，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 <strong>已知文章标题的情况下</strong> 检索是不是被它们收录了，而 <strong>不是</strong> 用来收集文章的。</p>\n<p>要确定某个会议论文集或者期刊<a href=\"http://www.philippe-fournier-viger.com/links.php\" target=\"_blank\" rel=\"external\">是否被EI或SCI收录</a>，</p>\n<ul>\n<li>在<a href=\"https://www.elsevier.com/solutions/engineering-village/content\" target=\"_blank\" rel=\"external\">EI收录列表</a> 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考<a href=\"/doc/crack_xls_vb.txt\">这个脚本解除保护</a>，还要建议把title列中每个单元格开头的<code>=</code>替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫<code>Computing</code>，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。<strong>但是！</strong>，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 <strong>Compendex</strong>。</li>\n<li>在<code>webofknowledge</code>的网站查询之前，<strong>一定</strong> 要选择数据库为<code>检索 Web of Science 核心合集</code>，等自动刷新候，还要在页面下部展开“更多设置”，只选中<code>Science Citation Index Expanded (SCIEXPANDED) 1900年至今</code>这一项，然后才能查询出根正苗红的<code>SCI（E）</code>。请<strong>务必</strong>参考<a href=\"/doc/SCI_E_Web_of_Science.pdf\">这个截图</a>。可以在<a href=\"http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K\" target=\"_blank\" rel=\"external\">SCI收录列表</a>直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：<a href=\"http://scit.nju.edu.cn/Item/1162.aspx\" target=\"_blank\" rel=\"external\">中国科学技术信息研究所SCI（E）论文期刊分区列表(2016年)</a>，这是一个有13.8k多行的Excel表格，简洁粗暴。</li>\n</ul>\n<hr>\n<p>上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。<br>校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。<br>话说只要是能花钱买到的东西，去万能的 <strong>淘宝</strong> 肯定能找到，就看是买 <em>VPN/代理</em>，<em>单篇文章</em>，还是 <em>整个数据库</em> 了。</p>\n<h2 id=\"dblp\"><a href=\"#dblp\" class=\"headerlink\" title=\"dblp\"></a>dblp</h2><p>dblp [<a href=\"http://dblp.org\" target=\"_blank\" rel=\"external\">http://dblp.org</a>] ，或[<a href=\"http://dblp.uni-trier.de]，\" target=\"_blank\" rel=\"external\">http://dblp.uni-trier.de]，</a> 是专注于CS学科的文献 <strong>元数据索引</strong> 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 <a href=\"http://dblp.org/db/conf/sigsoft/fse2016.html\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/sigsoft/fse2016.html</a> 或者某个作者的全部论文列表(dblp对重名作者处理得很好)，但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。<br>2015版CCF目录中的会议和期刊都是dblp的链接。</p>\n<p>dblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）</p>\n<ul>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/recordsindblp.html\" target=\"_blank\" rel=\"external\">累计论文记录数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/publicationsperyear.html\" target=\"_blank\" rel=\"external\">每年发表的论文数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html\" target=\"_blank\" rel=\"external\">论文发表的类型</a>，其中会议论文占53%，</li>\n<li>论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。</li>\n</ul>\n<p>另外，ACM DL也有一个<a href=\"http://dl.acm.org/contents_guide.cfm\" target=\"_blank\" rel=\"external\">类似的统计</a>。<br><img src=\"/img/pubs.png\" alt=\"每年发表的CS论文数量\"></p>\n<p>而且dblp整站的数据都可以下载为一个<a href=\"http://dblp.dagstuhl.de/xml/\" target=\"_blank\" rel=\"external\">xml文件</a>，以供进一步挖掘。</p>\n<h2 id=\"DOI\"><a href=\"#DOI\" class=\"headerlink\" title=\"DOI\"></a>DOI</h2><p>在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，<a href=\"https://zh.wikipedia.org/wiki/DOI\" target=\"_blank\" rel=\"external\">wikipedia介绍DOI</a>“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。</p>\n<ul>\n<li>Semantic Scholar [<a href=\"https://www.semanticscholar.org\" target=\"_blank\" rel=\"external\">https://www.semanticscholar.org</a>]</li>\n<li>CiteSeerX [<a href=\"http://citeseerx.ist.psu.edu/\" target=\"_blank\" rel=\"external\">http://citeseerx.ist.psu.edu/</a>]</li>\n<li>ResearchGate [<a href=\"https://www.researchgate.net/\" target=\"_blank\" rel=\"external\">https://www.researchgate.net/</a>] ，这是一个学术社交网络</li>\n</ul>\n<h1 id=\"CCF目录\"><a href=\"#CCF目录\" class=\"headerlink\" title=\"CCF目录\"></a>CCF目录</h1><p>EI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。<br>更 “<em>不幸</em>” 的是，对于CS的学生，还有一个<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">CCF目录</a>（<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。</p>\n<p>首先说<a href=\"http://www.ccf.org.cn/\" target=\"_blank\" rel=\"external\">中国计算机学会 CCF</a>是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">精简得多</a>。<br>考虑到对EI和SCI指标要求的实际情况，目录选取的 <strong>大多</strong> 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。<br>A，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。</p>\n<blockquote>\n<p>如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 <a href=\"http://dblp.org/db/journals/fgcs/\" target=\"_blank\" rel=\"external\">FGCS    Future Generation Computer Systems</a>上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。<br>随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。</p>\n</blockquote>\n<p>上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的<a href=\"http://dl.acm.org/ccs/ccs.cfm\" target=\"_blank\" rel=\"external\">分类系统CCS</a>，以及有重叠的<a href=\"https://www.acm.org/special-interest-groups/sigs-by-knowledge-area\" target=\"_blank\" rel=\"external\">SIGs大类划分</a>，还有<a href=\"https://en.wikipedia.org/wiki/Outline_of_computer_science\" target=\"_blank\" rel=\"external\">wikipedia上的一个划分</a>。</p>\n<h1 id=\"Google-Scholar（谷歌学术）\"><a href=\"#Google-Scholar（谷歌学术）\" class=\"headerlink\" title=\"Google Scholar（谷歌学术）\"></a>Google Scholar（谷歌学术）</h1><p><a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"external\">Google Scholar</a>非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 <strong>高级搜索</strong>，实在不行再去ACM DL、IEEE Xplore。<br><img src=\"/img/scholar_adv.png\" alt=\"谷歌学术高级搜索\"></p>\n<h2 id=\"创建快讯\"><a href=\"#创建快讯\" class=\"headerlink\" title=\"创建快讯\"></a>创建快讯</h2><p>与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；<br>此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 <strong>作者的个人资料页</strong> 可以创建关于他的新文章或新引用的快讯，及时获取动态。</p>\n<blockquote>\n<p>话说体验一下<a href=\"http://www.bing.com/academic\" target=\"_blank\" rel=\"external\">必应学术</a>、<a href=\"http://xueshu.baidu.com/\" target=\"_blank\" rel=\"external\">百度学术</a>和<a href=\"http://scholar.sogou.com/\" target=\"_blank\" rel=\"external\">搜狗学术</a>也未尝不可。</p>\n</blockquote>\n<p><a name=\"tldr\"></a></p>\n<h1 id=\"tl-dr：链接列表\"><a href=\"#tl-dr：链接列表\" class=\"headerlink\" title=\"tl,dr：链接列表\"></a>tl,dr：链接列表</h1><h2 id=\"体系结构，系统，存储，分布式系统\"><a href=\"#体系结构，系统，存储，分布式系统\" class=\"headerlink\" title=\"体系结构，系统，存储，分布式系统\"></a>体系结构，系统，存储，分布式系统</h2><ul>\n<li>ASPLOS@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE178&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/asplos/\" target=\"_blank\" rel=\"external\">DBLP</a> Architectural Support for Programming Languages and Operating Systems</li>\n<li>FAST@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE425&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/fast/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on File and Storage Technologies</li>\n<li>HPCA@<strong>A</strong>   <a href=\"http://ieeexplore.ieee.org/servlet/opac?punumber=1000335\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/hpca/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Computer Architecture</li>\n<li>ISCA@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE239&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/isca/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Computer Architecture</li>\n<li>MICRO@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE203&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/micro/\" target=\"_blank\" rel=\"external\">DBLP</a> Microarchitecture</li>\n<li>PPoPP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE241&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ppopp/\" target=\"_blank\" rel=\"external\">DBLP</a> Principles and Practice of Parallel Programming</li>\n<li>SC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE207&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sc/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. for High Performance Computing, Networking, Storage, and Analysis</li>\n<li>ATC@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/131\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/usenix/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Annul Technical Conf.</li>\n<li>CGO@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE256&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cgo/\" target=\"_blank\" rel=\"external\">DBLP</a> Code Generation and Optimization</li>\n<li>EuroSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE101&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/eurosys/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Computer Systems</li>\n<li>HotCHIPS@<strong>B</strong>   <a href=\"http://www.hotchips.org/\" target=\"_blank\" rel=\"external\">HotChips</a> Symposium on High Performance Chips</li>\n<li>HPDC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE300&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/hpdc/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Distributed Computing</li>\n<li>LISA@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/5\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/lisa/\" target=\"_blank\" rel=\"external\">DBLP</a> Large Installation system Administration Conf.</li>\n<li>PODC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE221&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/podc/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Principles of Distributed Computing</li>\n<li>SIGMETRICS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE187&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a>，<a href=\"http://dl.acm.org/citation.cfm?id=J618\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmetrics/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Measurement and Modeling of Computer Systems</li>\n<li>VEE@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE287&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vee/\" target=\"_blank\" rel=\"external\">DBLP</a> Virtual Execution Environments</li>\n<li>TC@<strong>A</strong>   <a href=\"https://www.computer.org/web/tc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tc/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computers</li>\n<li>TOCS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J774&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tocs/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computer Systems</li>\n<li>TOS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J960&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tos/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Storage</li>\n<li>TPDS@<strong>A</strong>   <a href=\"https://www.computer.org/web/tpds\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tpds/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Parallel and Distributed Systems</li>\n<li>ISMM   <a href=\"http://dl.acm.org/event.cfm?id=RE149&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ismm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Memory Management</li>\n</ul>\n<h2 id=\"软件工程（软件分析）\"><a href=\"#软件工程（软件分析）\" class=\"headerlink\" title=\"软件工程（软件分析）\"></a>软件工程（软件分析）</h2><ul>\n<li>Github上的<a href=\"https://github.com/tue-mdse/conferenceMetrics\" target=\"_blank\" rel=\"external\">软件工程方向会议的数据</a></li>\n<li>UIUC的<a href=\"http://taoxie.cs.illinois.edu/\" target=\"_blank\" rel=\"external\">谢涛老师</a>维护的<a href=\"http://taoxie.cs.illinois.edu/seconferences.htm\" target=\"_blank\" rel=\"external\">软件工程方向的会议统计列表</a></li>\n<li>ASE@<strong>A</strong>   <a href=\"http://dblp.org/db/conf/kbse/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Automated Software Engineering</li>\n<li>FSE/ESEC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE201&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigsoft/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.</li>\n<li>ICSE@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE228&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/icse/\" target=\"_blank\" rel=\"external\">DBLP</a> FOSE会议：七年一届的展望 Int. Conf. on Software Engineering</li>\n<li>OOPSLA/SPLASH@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE181&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/oopsla/\" target=\"_blank\" rel=\"external\">DBLP</a> Onward会议：创新(Nao Dong) Conf. on Object-Oriented Programming Systems, Languages, and Applications</li>\n<li>OSDI@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/179\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/osdi/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Symposium on Operating Systems Design and Implementations，<strong>双数</strong> 年份召开</li>\n<li>SOSP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE208&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sosp/\" target=\"_blank\" rel=\"external\">DBLP</a>，Symposium on Operating Systems Principles， <strong>单数</strong> 年份召开，另，<a href=\"http://sigops.org/sosp/sosp15/history/index.html\" target=\"_blank\" rel=\"external\">SOSP 2015 History Day</a></li>\n<li>PLDI@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE200&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pldi/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN Symposium on Programming Language Design and Implementation</li>\n<li>POPL@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE180&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/popl/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN&amp;SIGACT Symposium on Principles of Programming Languages</li>\n<li>ECOOP@<strong>B</strong>   <a href=\"http://www.ecoop.org/\" target=\"_blank\" rel=\"external\">ECOOP</a> , <a href=\"http://dblp.org/db/conf/ecoop/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Object-Oriented Programming</li>\n<li>HotOS@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/155\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotos/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Workshop on Hot Topics in Operating Systems</li>\n<li>ICSME@<strong>B</strong>   <a href=\"http://conferences.computer.org/icsm/\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/icsm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Software Maintenance</li>\n<li>ISSTA@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE222&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/issta/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Software Testing and Analysis</li>\n<li>TOPLAS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J783&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/toplas/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Programming Languages and Systems</li>\n<li>TOSEM@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J790&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tosem/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering Methodology</li>\n<li>TSE@<strong>A</strong>   <a href=\"https://www.computer.org/web/tse\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tse/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering</li>\n</ul>\n<h2 id=\"云计算，网络，大数据\"><a href=\"#云计算，网络，大数据\" class=\"headerlink\" title=\"云计算，网络，大数据\"></a>云计算，网络，大数据</h2><ul>\n<li>SIGMOD@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmod/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on Management of Data</li>\n<li>SoCC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Cloud Computing</li>\n<li>PODS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pods/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGMOD Conf. on Principles of DB Systems</li>\n<li>VLDB Endowment@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J1174&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Very Large Data Bases</li>\n<li>VLDB Journal@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J869&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Journal on Very Large Data Bases</li>\n<li>NSDI@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/178\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/nsdi/\" target=\"_blank\" rel=\"external\">DBLP</a> Network System Design and Implementation</li>\n<li>IEEE 云计算系列@<strong>B/C</strong>  <a href=\"http://cloudcomputing.ieee.org/conferences\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/IEEEcloud/\" target=\"_blank\" rel=\"external\">DBLP</a></li>\n<li>HotCloud   <a href=\"https://www.usenix.org/conferences/byname/1\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotcloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Hot Topics on Cloud Computing</li>\n<li>TCC   <a href=\"https://www.computer.org/web/tcc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tcc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Cloud Computing</li>\n<li>TSC@<strong>B</strong>   <a href=\"https://www.computer.org/web/tsc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tsc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Services Computing</li>\n<li>SigComm@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE258&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/conf/sigcomm/\" target=\"_blank\" rel=\"external\">DBLP</a><br>上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。</li>\n</ul>\n<h2 id=\"移动计算\"><a href=\"#移动计算\" class=\"headerlink\" title=\"移动计算\"></a>移动计算</h2><ul>\n<li>MobiCom@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE366&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobicom/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing and Networking</li>\n<li>MobiSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE191&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobisys/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Systems, Applications, and Services</li>\n<li>HotMobile   <a href=\"http://dl.acm.org/event.cfm?id=RE142&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/wmcsa/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing Systems and Applications</li>\n</ul>\n<h2 id=\"ACM-DL列表\"><a href=\"#ACM-DL列表\" class=\"headerlink\" title=\"ACM DL列表\"></a>ACM DL列表</h2><ul>\n<li><a href=\"http://dl.acm.org/contents_dl.cfm\" target=\"_blank\" rel=\"external\">收录会议和期刊的完整列表</a></li>\n<li><a href=\"http://dl.acm.org/events.cfm\" target=\"_blank\" rel=\"external\">会议</a></li>\n<li><a href=\"http://dl.acm.org/proceedings.cfm\" target=\"_blank\" rel=\"external\">会议历次论文集</a></li>\n<li><a href=\"http://dl.acm.org/pubs.cfm\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"http://dl.acm.org/mags.cfm\" target=\"_blank\" rel=\"external\">杂志</a></li>\n<li><a href=\"http://dl.acm.org/conferences.cfm\" target=\"_blank\" rel=\"external\">ACM Conferences - past 12 months</a></li>\n<li><a href=\"http://dl.acm.org/UpcomingConfLocations.xml\" target=\"_blank\" rel=\"external\">ACM Upcoming Conferences - RSS</a></li>\n</ul>\n<p>关于ACM的杂志，特别推荐</p>\n<ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM</a>， <a href=\"http://dblp.org/db/journals/cacm/\" target=\"_blank\" rel=\"external\">in dblp</a></li>\n<li><a href=\"http://dl.acm.org/toco_arch.cfm?id=J79&amp;lang=chinese\" target=\"_blank\" rel=\"external\">CACM中国版</a>，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去</li>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J882\" target=\"_blank\" rel=\"external\">Queue</a>也值得一看，不过它与CACM有很多重叠的文章</li>\n</ul>\n<p>期刊中，推荐<a href=\"http://dl.acm.org/citation.cfm?id=J204\" target=\"_blank\" rel=\"external\">ACM Computing Surveys, CSUR</a>， <a href=\"http://dblp.org/db/journals/csur/\" target=\"_blank\" rel=\"external\">in dblp</a></p>\n<blockquote>\n<p>看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。</p>\n</blockquote>\n<h2 id=\"IEEE-Computer列表\"><a href=\"#IEEE-Computer列表\" class=\"headerlink\" title=\"IEEE Computer列表\"></a>IEEE Computer列表</h2><ul>\n<li><a href=\"https://www.computer.org/web/conferences/calendar/\" target=\"_blank\" rel=\"external\">会议日历</a></li>\n<li><a href=\"https://www.computer.org/web/publications/transactions\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"https://www.computer.org/web/publications/magazines\" target=\"_blank\" rel=\"external\">杂志</a></li>\n</ul>\n<h2 id=\"USENIX组织的会议列表\"><a href=\"#USENIX组织的会议列表\" class=\"headerlink\" title=\"USENIX组织的会议列表\"></a><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></h2><p><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a>，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。</p>\n<h2 id=\"国内三个学报\"><a href=\"#国内三个学报\" class=\"headerlink\" title=\"国内三个学报\"></a>国内三个学报</h2><ul>\n<li><a href=\"http://www.jos.org.cn/ch/index.aspx\" target=\"_blank\" rel=\"external\">软件学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://cjc.ict.ac.cn/\" target=\"_blank\" rel=\"external\">计算机学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://crad.ict.ac.cn/CN/volumn/home.shtml\" target=\"_blank\" rel=\"external\">计算机研究与发展</a> ，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n</ul>\n<h2 id=\"国内论文数据库\"><a href=\"#国内论文数据库\" class=\"headerlink\" title=\"国内论文数据库\"></a>国内论文数据库</h2><ul>\n<li><a href=\"http://www.cnki.net/\" target=\"_blank\" rel=\"external\">知网CNKI</a></li>\n<li><a href=\"http://www.wanfangdata.com.cn/\" target=\"_blank\" rel=\"external\">万方数据</a></li>\n</ul>\n<h2 id=\"其它链接\"><a href=\"#其它链接\" class=\"headerlink\" title=\"其它链接\"></a>其它链接</h2><ul>\n<li><a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软研究院</a></li>\n<li><a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌研究院</a></li>\n<li><a href=\"https://blog.acolyer.org/\" target=\"_blank\" rel=\"external\">The morning paper</a>, an interesting-influential-important paper from the world of CS every weekday morning</li>\n<li><a href=\"http://sites.computer.org/debull/bull_issues.html\" target=\"_blank\" rel=\"external\">IEEE Technical Committee on Data Engineering</a></li>\n<li><a href=\"https://www.youtube.com\" target=\"_blank\" rel=\"external\">YouTube</a>，</li>\n<li><strong><a href=\"http://www1.cs.columbia.edu/~kaiser/relatedwork.htm\" target=\"_blank\" rel=\"external\">Suggested Guidelines for Finding Materials to include in the “Related Work” Sections of Conference Papers</a></strong></li>\n<li><a href=\"http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582\" target=\"_blank\" rel=\"external\">YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表</a>  </li>\n</ul>\n<h1 id=\"如何读论文\"><a href=\"#如何读论文\" class=\"headerlink\" title=\"如何读论文\"></a>如何读论文</h1><ul>\n<li><a href=\"http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf\" target=\"_blank\" rel=\"external\">Efficient Reading of Papers in Science and Technology(.pdf)</a></li>\n<li><a href=\"http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf\" target=\"_blank\" rel=\"external\">How to Read a Paper(.pdf)</a></li>\n<li><a href=\"https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html\" target=\"_blank\" rel=\"external\">How to Read a Technical Paper</a></li>\n<li><a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》第3章</a></li>\n</ul>\n<h1 id=\"Todo-辅助工具\"><a href=\"#Todo-辅助工具\" class=\"headerlink\" title=\"[Todo]辅助工具\"></a>[Todo]辅助工具</h1><ul>\n<li><a href=\"http://myhuiban.com\" target=\"_blank\" rel=\"external\">会伴</a></li>\n<li>Trans. on BigData的学术文献处理专刊 <a href=\"https://www.computer.org/csdl/trans/bd/2016/01/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 1</a>，<a href=\"https://www.computer.org/csdl/trans/bd/2016/02/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 2</a></li>\n<li><a href=\"http://www.sciplore.org/\" target=\"_blank\" rel=\"external\">Sciplore</a></li>\n<li><a href=\"https://www.scopus.com/\" target=\"_blank\" rel=\"external\">Scopus</a></li>\n<li><a href=\"http://www.docear.org/\" target=\"_blank\" rel=\"external\">Docear</a></li>\n<li><a href=\"https://www.mendeley.com/\" target=\"_blank\" rel=\"external\">Mendeley</a></li>\n<li><a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"external\">Zotero</a></li>\n<li><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></li>\n<li>Todo，如何整理文献，如何管理时间，<a href=\"https://www.zhihu.com/question/27956707\" target=\"_blank\" rel=\"external\">科研小组里有哪些有效的组会形式 - 知乎</a></li>\n</ul>\n<p>如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，<strong>总会觉得</strong> 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去<a href=\"https://en.wikipedia.org/\" target=\"_blank\" rel=\"external\">wikipedia</a>上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。<br>如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。</p>\n<blockquote>\n<p>PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)</p>\n</blockquote>\n<p>一些标题有<code>A systematic review on ...</code>综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。</p>\n<p>再列出知乎上的几个相关问题吧</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/26901116\" target=\"_blank\" rel=\"external\">如何总结和整理学术文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/26857521\" target=\"_blank\" rel=\"external\">如何高效管理文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/22790506\" target=\"_blank\" rel=\"external\">如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?</a></li>\n</ul>\n<p><a name=\"hosts\"></a></p>\n<h1 id=\"Bonus-如何访问Google-Scholar\"><a href=\"#Bonus-如何访问Google-Scholar\" class=\"headerlink\" title=\"[Bonus] 如何访问Google Scholar\"></a>[Bonus] 如何访问Google Scholar</h1><h2 id=\"改hosts\"><a href=\"#改hosts\" class=\"headerlink\" title=\"改hosts\"></a><strong>改hosts</strong></h2><ul>\n<li>IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N</li>\n<li>IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk</li>\n</ul>\n<h2 id=\"hosts文件的路径\"><a href=\"#hosts文件的路径\" class=\"headerlink\" title=\"hosts文件的路径\"></a><strong>hosts文件的路径</strong></h2><ul>\n<li>Windows：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux，Mac，Android(均需要root权限)：<code>/etc/hosts</code></li>\n</ul>\n<h1 id=\"PS-A-Survival-Guide-to-a-PhD\"><a href=\"#PS-A-Survival-Guide-to-a-PhD\" class=\"headerlink\" title=\"PS: A Survival Guide to a PhD\"></a>PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></h1><hr>\n<p>飞鸟集</p>\n<blockquote>\n<p>第83<br>那想做好人的，在门外敲着门，那爱人的，看见门敞开着。</p>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>论文（Paper）是每个研究生读研路上挥之不去的“阴云”。<br>无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展(State of the art &amp; practice）。<br>本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了与相关的机构，学术会议和论文数据库。<br>文末有 <a href=\"#hosts\"><strong>Bonus</strong></a> 哦;-)</p>","more":"<hr>\n<h1 id=\"tl-dr\"><a href=\"#tl-dr\" class=\"headerlink\" title=\"tl;dr\"></a>tl;dr</h1><ul>\n<li>从<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">CCF推荐目录</a>中自己感兴趣的方向的 <strong>A类会议及期刊</strong> 中找论文即可。</li>\n<li>我关注的云计算，程序分析方向的<a href=\"#tldr\">会议和期刊列表</a></li>\n<li><a href=\"#hosts\"><strong>Bonus</strong></a> 修改Hosts</li>\n</ul>\n<!-- TOC -->\n<pre><code>- [title: 如何收集和整理论文（面向CS专业）](#title-%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E5%92%8C%E6%95%B4%E7%90%86%E8%AE%BA%E6%96%87%EF%BC%88%E9%9D%A2%E5%90%91cs%E4%B8%93%E4%B8%9A%EF%BC%89)\n</code></pre><ul>\n<li><a href=\"#tldr\">tl;dr</a></li>\n<li><a href=\"#%E5%BC%95%E5%AD%90\">引子</a><ul>\n<li><a href=\"#%E8%AE%BA%E6%96%87%E5%8F%91%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B\">论文发表的过程</a></li>\n</ul>\n</li>\n<li><a href=\"#cs%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93\">CS论文数据库</a><ul>\n<li><a href=\"#acm-ieee-computer%E7%AD%89\">ACM, IEEE Computer等</a><ul>\n<li><a href=\"#acm-sigs\">ACM SIGs</a></li>\n</ul>\n</li>\n<li><a href=\"#usenixhttpswwwusenixorg\"><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></a></li>\n<li><a href=\"#arxivhttparxivorg\"><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></a></li>\n<li><a href=\"#ei%E5%92%8Csci\">EI和SCI</a></li>\n<li><a href=\"#dblp\">dblp</a></li>\n<li><a href=\"#doi\">DOI</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95\">CCF目录</a></li>\n<li><a href=\"#google-scholar%EF%BC%88%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%EF%BC%89\">Google Scholar（谷歌学术）</a><ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E5%BF%AB%E8%AE%AF\">创建快讯</a></li>\n</ul>\n</li>\n<li><a href=\"#tldr%EF%BC%9A%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8\">tl,dr：链接列表</a><ul>\n<li><a href=\"#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AD%98%E5%82%A8%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F\">体系结构，系统，存储，分布式系统</a></li>\n<li><a href=\"#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%89\">软件工程（软件分析）</a></li>\n<li><a href=\"#%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%8C%E7%BD%91%E7%BB%9C%EF%BC%8C%E5%A4%A7%E6%95%B0%E6%8D%AE\">云计算，网络，大数据</a></li>\n<li><a href=\"#%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97\">移动计算</a></li>\n<li><a href=\"#acm-dl%E5%88%97%E8%A1%A8\">ACM DL列表</a></li>\n<li><a href=\"#ieee-computer%E5%88%97%E8%A1%A8\">IEEE Computer列表</a></li>\n<li><a href=\"#usenix%E7%BB%84%E7%BB%87%E7%9A%84%E4%BC%9A%E8%AE%AE%E5%88%97%E8%A1%A8httpswwwusenixorgconferencesbyname\"><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></a></li>\n<li><a href=\"#%E5%9B%BD%E5%86%85%E4%B8%89%E4%B8%AA%E5%AD%A6%E6%8A%A5\">国内三个学报</a></li>\n<li><a href=\"#%E5%9B%BD%E5%86%85%E8%AE%BA%E6%96%87%E6%95%B0%E6%8D%AE%E5%BA%93\">国内论文数据库</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%93%BE%E6%8E%A5\">其它链接</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87\">如何读论文</a></li>\n<li><a href=\"#todo%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7\">[Todo]辅助工具</a><ul>\n<li><a href=\"#%E6%94%B9hosts\"><strong>改hosts</strong></a></li>\n<li><a href=\"#hosts%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84\"><strong>hosts文件的路径</strong></a></li>\n</ul>\n</li>\n<li><a href=\"#ps-a-survival-guide-to-a-phdhttpkarpathygithubio20160907phd\">PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：</p>\n<ul>\n<li>周志华老师的一篇关于<a href=\"/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf\">做研究与写论文的ppt</a></li>\n<li>凌晓峰和杨强的<a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》</a>，这本书的英文原版是<a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064\" target=\"_blank\" rel=\"external\">Crafting Your Research Future - A Guide to Successful Master’s and Ph.D. Degrees in Science &amp; Engineering</a></li>\n</ul>\n<p>首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果(的一部分)，结果是必要的，自然也就少不了Paper或者总结报告；<br>再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。<br>重要的是要 <em>有意识地探索和总结适合自己的科研方法</em>，既要低头苦干，又要抬头看路，还要回头总结。</p>\n<h2 id=\"论文发表的过程\"><a href=\"#论文发表的过程\" class=\"headerlink\" title=\"论文发表的过程\"></a>论文发表的过程</h2><pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n<p>简单介绍一下发表论文的过程：</p>\n<ul>\n<li>首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如<a href=\"https://amplab.cs.berkeley.edu/\" target=\"_blank\" rel=\"external\">UC Berkeley 的AMPLab</a>；还有一些公司的研究院，比如<a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软</a>，<a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌</a>。显然，论文的出身对质量有很大影响。</li>\n<li>期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期(deadline)的压力。投稿后一般要经过同行评审(Peer Review)，针对审稿人的建议做大修，小修(Major，Minor Revision)等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊(Special Issue)计划，会公布一个截稿日期，审稿的进度会稍快些。<br>期刊分为 <strong>Transaction, Journal 和 Magazine</strong> 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 <em>不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是</em> <a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM, ACM通讯</a> <em>值得关注</em>。</li>\n<li>对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等，所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。<br>很多会议每年举行一次，时间上也是比较固定的，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。<br>会议录用的所有Paper会结集出版，称为 <em>Proceedings</em> 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。<br>会议分为 <em>Symposium , Conference 和 Workshop</em>。这三者的学术严肃性依次降低，大部分会议都称为 <em>Conference</em>。一般来说 <em>Workshop</em> 是随某个 <em>Conference</em> 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。</li>\n</ul>\n<p>通过这个过程，我们还可以知道如何<strong>尽快</strong>找到一篇感兴趣的文章：</p>\n<ul>\n<li>对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access；</li>\n<li>对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。</li>\n</ul>\n<h1 id=\"CS论文数据库\"><a href=\"#CS论文数据库\" class=\"headerlink\" title=\"CS论文数据库\"></a>CS论文数据库</h1><h2 id=\"ACM-IEEE-Computer等\"><a href=\"#ACM-IEEE-Computer等\" class=\"headerlink\" title=\"ACM, IEEE Computer等\"></a>ACM, IEEE Computer等</h2><p>一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及<a href=\"#lib\">图书馆页面截图</a>。</p>\n<blockquote>\n<p>注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>机构</th>\n<th>Digital Library （DL）</th>\n<th>机构首页</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Association for Computing Machinery, ACM</td>\n<td>ACM Digital Library  <a href=\"https://dl.acm.org/\" target=\"_blank\" rel=\"external\">https://dl.acm.org/</a></td>\n<td><a href=\"https://www.acm.org/\" target=\"_blank\" rel=\"external\">https://www.acm.org/</a></td>\n</tr>\n<tr>\n<td>IEEE Computer Society</td>\n<td>IEEE Xplore DL <a href=\"http://ieeexplore.ieee.org/\" target=\"_blank\" rel=\"external\">http://ieeexplore.ieee.org/</a></td>\n<td><a href=\"https://www.computer.org/\" target=\"_blank\" rel=\"external\">https://www.computer.org/</a></td>\n</tr>\n<tr>\n<td>Elsevier ScienceDirect</td>\n<td><a href=\"http://www.sciencedirect.com/\" target=\"_blank\" rel=\"external\">http://www.sciencedirect.com/</a></td>\n<td><a href=\"https://www.elsevier.com/\" target=\"_blank\" rel=\"external\">https://www.elsevier.com/</a></td>\n</tr>\n<tr>\n<td>Springer</td>\n<td>Springer Link <a href=\"http://link.springer.com/\" target=\"_blank\" rel=\"external\">http://link.springer.com/</a></td>\n<td><a href=\"http://www.springer.com/\" target=\"_blank\" rel=\"external\">http://www.springer.com/</a></td>\n</tr>\n<tr>\n<td>Wiley</td>\n<td>Wiley Online Lib <a href=\"http://onlinelibrary.wiley.com/\" target=\"_blank\" rel=\"external\">http://onlinelibrary.wiley.com/</a></td>\n<td><a href=\"http://www.wiley.com/\" target=\"_blank\" rel=\"external\">http://www.wiley.com/</a></td>\n</tr>\n</tbody>\n</table>\n<p>ACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 <em>.org</em>，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。<br>Elsevier，Springer，Wiley的网址后缀则是 <em>.com</em> ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。<br>上面这几个数据库是 <strong>主要的论文全文来源</strong>。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。</p>\n<blockquote>\n<p>ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 <strong>元数据</strong>，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。<br>IEEE出版的一些论文在 computer.org （实际是<a href=\"https://www.computer.org/csdl/\" target=\"_blank\" rel=\"external\">CSDL</a>）和 Xplore DL 都可能搜到，但这两个数据库是 <em>分别</em> 收费的，能在Xplore DL下载的不一定能在Computer.org下载。</p>\n</blockquote>\n<h3 id=\"ACM-SIGs\"><a href=\"#ACM-SIGs\" class=\"headerlink\" title=\"ACM SIGs\"></a>ACM SIGs</h3><p>ACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个<a href=\"http://www.acm.org/sigs/\" target=\"_blank\" rel=\"external\">ACM SIGs</a>（或参考DL的这个链接<a href=\"http://dl.acm.org/sigs.cfm\" target=\"_blank\" rel=\"external\">SIGs ACM DL</a>），比如</p>\n<ul>\n<li>体系结构方向的<a href=\"http://www.sigarch.org/\" target=\"_blank\" rel=\"external\">SIGARCH</a>、<a href=\"http://www.sighpc.org/\" target=\"_blank\" rel=\"external\">SIGHPC</a>、<a href=\"http://www.sigmetrics.org/\" target=\"_blank\" rel=\"external\">SIGMETRICS</a>、<a href=\"http://www.sigmicro.org/\" target=\"_blank\" rel=\"external\">SIGMICRO</a>、<a href=\"http://www.sigmobile.org/\" target=\"_blank\" rel=\"external\">SIGMOBILE</a>，</li>\n<li>网络方向的<a href=\"http://www.sigcomm.org/\" target=\"_blank\" rel=\"external\">SIGCOMM</a>，</li>\n<li>数据库方向的<a href=\"http://www.sigmod.org/\" target=\"_blank\" rel=\"external\">SIGMOD</a>，</li>\n<li>系统方向的<a href=\"http://www.sigops.org/\" target=\"_blank\" rel=\"external\">SIGOPS</a>，</li>\n<li>软件工程方向的<a href=\"http://www.sigplan.org/\" target=\"_blank\" rel=\"external\">SIGPLAN</a>、<a href=\"http://www.sigsoft.org/\" target=\"_blank\" rel=\"external\">SIGSOFT</a></li>\n</ul>\n<p>这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 <strong>最佳论文</strong>，<strong>优秀博士论文</strong> 等(在DL中一般没有哪篇是Best Paper的信息)。此外，</p>\n<ul>\n<li>有网站维护了一个<a href=\"http://jeffhuang.com/best_paper_awards.html\" target=\"_blank\" rel=\"external\">部分会议的最佳论文列表</a>，</li>\n<li>还有下面要介绍的USENIX的<a href=\"https://www.usenix.org/conferences/best-papers\" target=\"_blank\" rel=\"external\">各会议最佳论文</a>。</li>\n</ul>\n<p>除此之外，有的SIG会选择一些高质量的文章，以Review，Newsletter 或Notes的形式重新发表。</p>\n<h2 id=\"USENIX\"><a href=\"#USENIX\" class=\"headerlink\" title=\"USENIX\"></a><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></h2><p>要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。<br>话说<strong><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></strong> 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slices及演讲视频。slices是对文章的提炼，读论文时可以参考。拿slices和视频来学习做Presentation，练习英语听力和口语也不错。</p>\n<h2 id=\"arXiv\"><a href=\"#arXiv\" class=\"headerlink\" title=\"arXiv\"></a><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></h2><p><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a>， 是archive(归档)的意思，是一个由康乃尔大学维护的免费的多学科论文<strong>预</strong>出版(preprint)数据库。所谓<strong>预</strong>出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。</p>\n<p><a name=\"lib\"><img src=\"/img/lib.png\" alt=\"图书馆电子资源\"></a></p>\n<h2 id=\"EI和SCI\"><a href=\"#EI和SCI\" class=\"headerlink\" title=\"EI和SCI\"></a>EI和SCI</h2><p>分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，</p>\n<ul>\n<li>EI <em>Engineering Index</em> <a href=\"https://www.engineeringvillage.com/\" target=\"_blank\" rel=\"external\">https://www.engineeringvillage.com/</a></li>\n<li>SCI <em>Science Citation Index</em> <a href=\"http://apps.webofknowledge.com/\" target=\"_blank\" rel=\"external\">http://apps.webofknowledge.com/</a></li>\n</ul>\n<p>只看 <em>URL</em> 还以为是 <em>山寨网站</em>，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 <strong>已知文章标题的情况下</strong> 检索是不是被它们收录了，而 <strong>不是</strong> 用来收集文章的。</p>\n<p>要确定某个会议论文集或者期刊<a href=\"http://www.philippe-fournier-viger.com/links.php\" target=\"_blank\" rel=\"external\">是否被EI或SCI收录</a>，</p>\n<ul>\n<li>在<a href=\"https://www.elsevier.com/solutions/engineering-village/content\" target=\"_blank\" rel=\"external\">EI收录列表</a> 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考<a href=\"/doc/crack_xls_vb.txt\">这个脚本解除保护</a>，还要建议把title列中每个单元格开头的<code>=</code>替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫<code>Computing</code>，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。<strong>但是！</strong>，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 <strong>Compendex</strong>。</li>\n<li>在<code>webofknowledge</code>的网站查询之前，<strong>一定</strong> 要选择数据库为<code>检索 Web of Science 核心合集</code>，等自动刷新候，还要在页面下部展开“更多设置”，只选中<code>Science Citation Index Expanded (SCIEXPANDED) 1900年至今</code>这一项，然后才能查询出根正苗红的<code>SCI（E）</code>。请<strong>务必</strong>参考<a href=\"/doc/SCI_E_Web_of_Science.pdf\">这个截图</a>。可以在<a href=\"http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K\" target=\"_blank\" rel=\"external\">SCI收录列表</a>直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：<a href=\"http://scit.nju.edu.cn/Item/1162.aspx\" target=\"_blank\" rel=\"external\">中国科学技术信息研究所SCI（E）论文期刊分区列表(2016年)</a>，这是一个有13.8k多行的Excel表格，简洁粗暴。</li>\n</ul>\n<hr>\n<p>上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。<br>校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。<br>话说只要是能花钱买到的东西，去万能的 <strong>淘宝</strong> 肯定能找到，就看是买 <em>VPN/代理</em>，<em>单篇文章</em>，还是 <em>整个数据库</em> 了。</p>\n<h2 id=\"dblp\"><a href=\"#dblp\" class=\"headerlink\" title=\"dblp\"></a>dblp</h2><p>dblp [<a href=\"http://dblp.org\" target=\"_blank\" rel=\"external\">http://dblp.org</a>] ，或[<a href=\"http://dblp.uni-trier.de]，\" target=\"_blank\" rel=\"external\">http://dblp.uni-trier.de]，</a> 是专注于CS学科的文献 <strong>元数据索引</strong> 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 <a href=\"http://dblp.org/db/conf/sigsoft/fse2016.html\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/sigsoft/fse2016.html</a> 或者某个作者的全部论文列表(dblp对重名作者处理得很好)，但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。<br>2015版CCF目录中的会议和期刊都是dblp的链接。</p>\n<p>dblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）</p>\n<ul>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/recordsindblp.html\" target=\"_blank\" rel=\"external\">累计论文记录数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/publicationsperyear.html\" target=\"_blank\" rel=\"external\">每年发表的论文数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html\" target=\"_blank\" rel=\"external\">论文发表的类型</a>，其中会议论文占53%，</li>\n<li>论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。</li>\n</ul>\n<p>另外，ACM DL也有一个<a href=\"http://dl.acm.org/contents_guide.cfm\" target=\"_blank\" rel=\"external\">类似的统计</a>。<br><img src=\"/img/pubs.png\" alt=\"每年发表的CS论文数量\"></p>\n<p>而且dblp整站的数据都可以下载为一个<a href=\"http://dblp.dagstuhl.de/xml/\" target=\"_blank\" rel=\"external\">xml文件</a>，以供进一步挖掘。</p>\n<h2 id=\"DOI\"><a href=\"#DOI\" class=\"headerlink\" title=\"DOI\"></a>DOI</h2><p>在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，<a href=\"https://zh.wikipedia.org/wiki/DOI\" target=\"_blank\" rel=\"external\">wikipedia介绍DOI</a>“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。</p>\n<ul>\n<li>Semantic Scholar [<a href=\"https://www.semanticscholar.org\" target=\"_blank\" rel=\"external\">https://www.semanticscholar.org</a>]</li>\n<li>CiteSeerX [<a href=\"http://citeseerx.ist.psu.edu/\" target=\"_blank\" rel=\"external\">http://citeseerx.ist.psu.edu/</a>]</li>\n<li>ResearchGate [<a href=\"https://www.researchgate.net/\" target=\"_blank\" rel=\"external\">https://www.researchgate.net/</a>] ，这是一个学术社交网络</li>\n</ul>\n<h1 id=\"CCF目录\"><a href=\"#CCF目录\" class=\"headerlink\" title=\"CCF目录\"></a>CCF目录</h1><p>EI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。<br>更 “<em>不幸</em>” 的是，对于CS的学生，还有一个<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">CCF目录</a>（<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。</p>\n<p>首先说<a href=\"http://www.ccf.org.cn/\" target=\"_blank\" rel=\"external\">中国计算机学会 CCF</a>是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">精简得多</a>。<br>考虑到对EI和SCI指标要求的实际情况，目录选取的 <strong>大多</strong> 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。<br>A，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。</p>\n<blockquote>\n<p>如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 <a href=\"http://dblp.org/db/journals/fgcs/\" target=\"_blank\" rel=\"external\">FGCS    Future Generation Computer Systems</a>上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。<br>随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。</p>\n</blockquote>\n<p>上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的<a href=\"http://dl.acm.org/ccs/ccs.cfm\" target=\"_blank\" rel=\"external\">分类系统CCS</a>，以及有重叠的<a href=\"https://www.acm.org/special-interest-groups/sigs-by-knowledge-area\" target=\"_blank\" rel=\"external\">SIGs大类划分</a>，还有<a href=\"https://en.wikipedia.org/wiki/Outline_of_computer_science\" target=\"_blank\" rel=\"external\">wikipedia上的一个划分</a>。</p>\n<h1 id=\"Google-Scholar（谷歌学术）\"><a href=\"#Google-Scholar（谷歌学术）\" class=\"headerlink\" title=\"Google Scholar（谷歌学术）\"></a>Google Scholar（谷歌学术）</h1><p><a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"external\">Google Scholar</a>非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 <strong>高级搜索</strong>，实在不行再去ACM DL、IEEE Xplore。<br><img src=\"/img/scholar_adv.png\" alt=\"谷歌学术高级搜索\"></p>\n<h2 id=\"创建快讯\"><a href=\"#创建快讯\" class=\"headerlink\" title=\"创建快讯\"></a>创建快讯</h2><p>与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；<br>此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 <strong>作者的个人资料页</strong> 可以创建关于他的新文章或新引用的快讯，及时获取动态。</p>\n<blockquote>\n<p>话说体验一下<a href=\"http://www.bing.com/academic\" target=\"_blank\" rel=\"external\">必应学术</a>、<a href=\"http://xueshu.baidu.com/\" target=\"_blank\" rel=\"external\">百度学术</a>和<a href=\"http://scholar.sogou.com/\" target=\"_blank\" rel=\"external\">搜狗学术</a>也未尝不可。</p>\n</blockquote>\n<p><a name=\"tldr\"></a></p>\n<h1 id=\"tl-dr：链接列表\"><a href=\"#tl-dr：链接列表\" class=\"headerlink\" title=\"tl,dr：链接列表\"></a>tl,dr：链接列表</h1><h2 id=\"体系结构，系统，存储，分布式系统\"><a href=\"#体系结构，系统，存储，分布式系统\" class=\"headerlink\" title=\"体系结构，系统，存储，分布式系统\"></a>体系结构，系统，存储，分布式系统</h2><ul>\n<li>ASPLOS@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE178&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/asplos/\" target=\"_blank\" rel=\"external\">DBLP</a> Architectural Support for Programming Languages and Operating Systems</li>\n<li>FAST@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE425&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/fast/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on File and Storage Technologies</li>\n<li>HPCA@<strong>A</strong>   <a href=\"http://ieeexplore.ieee.org/servlet/opac?punumber=1000335\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/hpca/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Computer Architecture</li>\n<li>ISCA@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE239&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/isca/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Computer Architecture</li>\n<li>MICRO@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE203&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/micro/\" target=\"_blank\" rel=\"external\">DBLP</a> Microarchitecture</li>\n<li>PPoPP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE241&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ppopp/\" target=\"_blank\" rel=\"external\">DBLP</a> Principles and Practice of Parallel Programming</li>\n<li>SC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE207&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sc/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. for High Performance Computing, Networking, Storage, and Analysis</li>\n<li>ATC@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/131\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/usenix/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Annul Technical Conf.</li>\n<li>CGO@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE256&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cgo/\" target=\"_blank\" rel=\"external\">DBLP</a> Code Generation and Optimization</li>\n<li>EuroSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE101&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/eurosys/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Computer Systems</li>\n<li>HotCHIPS@<strong>B</strong>   <a href=\"http://www.hotchips.org/\" target=\"_blank\" rel=\"external\">HotChips</a> Symposium on High Performance Chips</li>\n<li>HPDC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE300&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/hpdc/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Distributed Computing</li>\n<li>LISA@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/5\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/lisa/\" target=\"_blank\" rel=\"external\">DBLP</a> Large Installation system Administration Conf.</li>\n<li>PODC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE221&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/podc/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Principles of Distributed Computing</li>\n<li>SIGMETRICS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE187&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a>，<a href=\"http://dl.acm.org/citation.cfm?id=J618\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmetrics/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Measurement and Modeling of Computer Systems</li>\n<li>VEE@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE287&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vee/\" target=\"_blank\" rel=\"external\">DBLP</a> Virtual Execution Environments</li>\n<li>TC@<strong>A</strong>   <a href=\"https://www.computer.org/web/tc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tc/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computers</li>\n<li>TOCS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J774&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tocs/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computer Systems</li>\n<li>TOS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J960&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tos/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Storage</li>\n<li>TPDS@<strong>A</strong>   <a href=\"https://www.computer.org/web/tpds\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tpds/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Parallel and Distributed Systems</li>\n<li>ISMM   <a href=\"http://dl.acm.org/event.cfm?id=RE149&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ismm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Memory Management</li>\n</ul>\n<h2 id=\"软件工程（软件分析）\"><a href=\"#软件工程（软件分析）\" class=\"headerlink\" title=\"软件工程（软件分析）\"></a>软件工程（软件分析）</h2><ul>\n<li>Github上的<a href=\"https://github.com/tue-mdse/conferenceMetrics\" target=\"_blank\" rel=\"external\">软件工程方向会议的数据</a></li>\n<li>UIUC的<a href=\"http://taoxie.cs.illinois.edu/\" target=\"_blank\" rel=\"external\">谢涛老师</a>维护的<a href=\"http://taoxie.cs.illinois.edu/seconferences.htm\" target=\"_blank\" rel=\"external\">软件工程方向的会议统计列表</a></li>\n<li>ASE@<strong>A</strong>   <a href=\"http://dblp.org/db/conf/kbse/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Automated Software Engineering</li>\n<li>FSE/ESEC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE201&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigsoft/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.</li>\n<li>ICSE@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE228&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/icse/\" target=\"_blank\" rel=\"external\">DBLP</a> FOSE会议：七年一届的展望 Int. Conf. on Software Engineering</li>\n<li>OOPSLA/SPLASH@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE181&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/oopsla/\" target=\"_blank\" rel=\"external\">DBLP</a> Onward会议：创新(Nao Dong) Conf. on Object-Oriented Programming Systems, Languages, and Applications</li>\n<li>OSDI@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/179\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/osdi/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Symposium on Operating Systems Design and Implementations，<strong>双数</strong> 年份召开</li>\n<li>SOSP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE208&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sosp/\" target=\"_blank\" rel=\"external\">DBLP</a>，Symposium on Operating Systems Principles， <strong>单数</strong> 年份召开，另，<a href=\"http://sigops.org/sosp/sosp15/history/index.html\" target=\"_blank\" rel=\"external\">SOSP 2015 History Day</a></li>\n<li>PLDI@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE200&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pldi/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN Symposium on Programming Language Design and Implementation</li>\n<li>POPL@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE180&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/popl/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN&amp;SIGACT Symposium on Principles of Programming Languages</li>\n<li>ECOOP@<strong>B</strong>   <a href=\"http://www.ecoop.org/\" target=\"_blank\" rel=\"external\">ECOOP</a> , <a href=\"http://dblp.org/db/conf/ecoop/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Object-Oriented Programming</li>\n<li>HotOS@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/155\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotos/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Workshop on Hot Topics in Operating Systems</li>\n<li>ICSME@<strong>B</strong>   <a href=\"http://conferences.computer.org/icsm/\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/icsm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Software Maintenance</li>\n<li>ISSTA@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE222&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/issta/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Software Testing and Analysis</li>\n<li>TOPLAS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J783&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/toplas/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Programming Languages and Systems</li>\n<li>TOSEM@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J790&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tosem/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering Methodology</li>\n<li>TSE@<strong>A</strong>   <a href=\"https://www.computer.org/web/tse\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tse/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering</li>\n</ul>\n<h2 id=\"云计算，网络，大数据\"><a href=\"#云计算，网络，大数据\" class=\"headerlink\" title=\"云计算，网络，大数据\"></a>云计算，网络，大数据</h2><ul>\n<li>SIGMOD@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmod/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on Management of Data</li>\n<li>SoCC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Cloud Computing</li>\n<li>PODS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pods/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGMOD Conf. on Principles of DB Systems</li>\n<li>VLDB Endowment@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J1174&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Very Large Data Bases</li>\n<li>VLDB Journal@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J869&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Journal on Very Large Data Bases</li>\n<li>NSDI@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/178\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/nsdi/\" target=\"_blank\" rel=\"external\">DBLP</a> Network System Design and Implementation</li>\n<li>IEEE 云计算系列@<strong>B/C</strong>  <a href=\"http://cloudcomputing.ieee.org/conferences\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/IEEEcloud/\" target=\"_blank\" rel=\"external\">DBLP</a></li>\n<li>HotCloud   <a href=\"https://www.usenix.org/conferences/byname/1\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotcloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Hot Topics on Cloud Computing</li>\n<li>TCC   <a href=\"https://www.computer.org/web/tcc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tcc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Cloud Computing</li>\n<li>TSC@<strong>B</strong>   <a href=\"https://www.computer.org/web/tsc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tsc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Services Computing</li>\n<li>SigComm@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE258&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/conf/sigcomm/\" target=\"_blank\" rel=\"external\">DBLP</a><br>上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。</li>\n</ul>\n<h2 id=\"移动计算\"><a href=\"#移动计算\" class=\"headerlink\" title=\"移动计算\"></a>移动计算</h2><ul>\n<li>MobiCom@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE366&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobicom/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing and Networking</li>\n<li>MobiSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE191&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobisys/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Systems, Applications, and Services</li>\n<li>HotMobile   <a href=\"http://dl.acm.org/event.cfm?id=RE142&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/wmcsa/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing Systems and Applications</li>\n</ul>\n<h2 id=\"ACM-DL列表\"><a href=\"#ACM-DL列表\" class=\"headerlink\" title=\"ACM DL列表\"></a>ACM DL列表</h2><ul>\n<li><a href=\"http://dl.acm.org/contents_dl.cfm\" target=\"_blank\" rel=\"external\">收录会议和期刊的完整列表</a></li>\n<li><a href=\"http://dl.acm.org/events.cfm\" target=\"_blank\" rel=\"external\">会议</a></li>\n<li><a href=\"http://dl.acm.org/proceedings.cfm\" target=\"_blank\" rel=\"external\">会议历次论文集</a></li>\n<li><a href=\"http://dl.acm.org/pubs.cfm\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"http://dl.acm.org/mags.cfm\" target=\"_blank\" rel=\"external\">杂志</a></li>\n<li><a href=\"http://dl.acm.org/conferences.cfm\" target=\"_blank\" rel=\"external\">ACM Conferences - past 12 months</a></li>\n<li><a href=\"http://dl.acm.org/UpcomingConfLocations.xml\" target=\"_blank\" rel=\"external\">ACM Upcoming Conferences - RSS</a></li>\n</ul>\n<p>关于ACM的杂志，特别推荐</p>\n<ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM</a>， <a href=\"http://dblp.org/db/journals/cacm/\" target=\"_blank\" rel=\"external\">in dblp</a></li>\n<li><a href=\"http://dl.acm.org/toco_arch.cfm?id=J79&amp;lang=chinese\" target=\"_blank\" rel=\"external\">CACM中国版</a>，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去</li>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J882\" target=\"_blank\" rel=\"external\">Queue</a>也值得一看，不过它与CACM有很多重叠的文章</li>\n</ul>\n<p>期刊中，推荐<a href=\"http://dl.acm.org/citation.cfm?id=J204\" target=\"_blank\" rel=\"external\">ACM Computing Surveys, CSUR</a>， <a href=\"http://dblp.org/db/journals/csur/\" target=\"_blank\" rel=\"external\">in dblp</a></p>\n<blockquote>\n<p>看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。</p>\n</blockquote>\n<h2 id=\"IEEE-Computer列表\"><a href=\"#IEEE-Computer列表\" class=\"headerlink\" title=\"IEEE Computer列表\"></a>IEEE Computer列表</h2><ul>\n<li><a href=\"https://www.computer.org/web/conferences/calendar/\" target=\"_blank\" rel=\"external\">会议日历</a></li>\n<li><a href=\"https://www.computer.org/web/publications/transactions\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"https://www.computer.org/web/publications/magazines\" target=\"_blank\" rel=\"external\">杂志</a></li>\n</ul>\n<h2 id=\"USENIX组织的会议列表\"><a href=\"#USENIX组织的会议列表\" class=\"headerlink\" title=\"USENIX组织的会议列表\"></a><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></h2><p><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a>，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。</p>\n<h2 id=\"国内三个学报\"><a href=\"#国内三个学报\" class=\"headerlink\" title=\"国内三个学报\"></a>国内三个学报</h2><ul>\n<li><a href=\"http://www.jos.org.cn/ch/index.aspx\" target=\"_blank\" rel=\"external\">软件学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://cjc.ict.ac.cn/\" target=\"_blank\" rel=\"external\">计算机学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://crad.ict.ac.cn/CN/volumn/home.shtml\" target=\"_blank\" rel=\"external\">计算机研究与发展</a> ，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n</ul>\n<h2 id=\"国内论文数据库\"><a href=\"#国内论文数据库\" class=\"headerlink\" title=\"国内论文数据库\"></a>国内论文数据库</h2><ul>\n<li><a href=\"http://www.cnki.net/\" target=\"_blank\" rel=\"external\">知网CNKI</a></li>\n<li><a href=\"http://www.wanfangdata.com.cn/\" target=\"_blank\" rel=\"external\">万方数据</a></li>\n</ul>\n<h2 id=\"其它链接\"><a href=\"#其它链接\" class=\"headerlink\" title=\"其它链接\"></a>其它链接</h2><ul>\n<li><a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软研究院</a></li>\n<li><a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌研究院</a></li>\n<li><a href=\"https://blog.acolyer.org/\" target=\"_blank\" rel=\"external\">The morning paper</a>, an interesting-influential-important paper from the world of CS every weekday morning</li>\n<li><a href=\"http://sites.computer.org/debull/bull_issues.html\" target=\"_blank\" rel=\"external\">IEEE Technical Committee on Data Engineering</a></li>\n<li><a href=\"https://www.youtube.com\" target=\"_blank\" rel=\"external\">YouTube</a>，</li>\n<li><strong><a href=\"http://www1.cs.columbia.edu/~kaiser/relatedwork.htm\" target=\"_blank\" rel=\"external\">Suggested Guidelines for Finding Materials to include in the “Related Work” Sections of Conference Papers</a></strong></li>\n<li><a href=\"http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582\" target=\"_blank\" rel=\"external\">YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表</a>  </li>\n</ul>\n<h1 id=\"如何读论文\"><a href=\"#如何读论文\" class=\"headerlink\" title=\"如何读论文\"></a>如何读论文</h1><ul>\n<li><a href=\"http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf\" target=\"_blank\" rel=\"external\">Efficient Reading of Papers in Science and Technology(.pdf)</a></li>\n<li><a href=\"http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf\" target=\"_blank\" rel=\"external\">How to Read a Paper(.pdf)</a></li>\n<li><a href=\"https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html\" target=\"_blank\" rel=\"external\">How to Read a Technical Paper</a></li>\n<li><a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》第3章</a></li>\n</ul>\n<h1 id=\"Todo-辅助工具\"><a href=\"#Todo-辅助工具\" class=\"headerlink\" title=\"[Todo]辅助工具\"></a>[Todo]辅助工具</h1><ul>\n<li><a href=\"http://myhuiban.com\" target=\"_blank\" rel=\"external\">会伴</a></li>\n<li>Trans. on BigData的学术文献处理专刊 <a href=\"https://www.computer.org/csdl/trans/bd/2016/01/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 1</a>，<a href=\"https://www.computer.org/csdl/trans/bd/2016/02/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 2</a></li>\n<li><a href=\"http://www.sciplore.org/\" target=\"_blank\" rel=\"external\">Sciplore</a></li>\n<li><a href=\"https://www.scopus.com/\" target=\"_blank\" rel=\"external\">Scopus</a></li>\n<li><a href=\"http://www.docear.org/\" target=\"_blank\" rel=\"external\">Docear</a></li>\n<li><a href=\"https://www.mendeley.com/\" target=\"_blank\" rel=\"external\">Mendeley</a></li>\n<li><a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"external\">Zotero</a></li>\n<li><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></li>\n<li>Todo，如何整理文献，如何管理时间，<a href=\"https://www.zhihu.com/question/27956707\" target=\"_blank\" rel=\"external\">科研小组里有哪些有效的组会形式 - 知乎</a></li>\n</ul>\n<p>如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，<strong>总会觉得</strong> 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去<a href=\"https://en.wikipedia.org/\" target=\"_blank\" rel=\"external\">wikipedia</a>上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。<br>如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。</p>\n<blockquote>\n<p>PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)</p>\n</blockquote>\n<p>一些标题有<code>A systematic review on ...</code>综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。</p>\n<p>再列出知乎上的几个相关问题吧</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/26901116\" target=\"_blank\" rel=\"external\">如何总结和整理学术文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/26857521\" target=\"_blank\" rel=\"external\">如何高效管理文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/22790506\" target=\"_blank\" rel=\"external\">如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?</a></li>\n</ul>\n<p><a name=\"hosts\"></a></p>\n<h1 id=\"Bonus-如何访问Google-Scholar\"><a href=\"#Bonus-如何访问Google-Scholar\" class=\"headerlink\" title=\"[Bonus] 如何访问Google Scholar\"></a>[Bonus] 如何访问Google Scholar</h1><h2 id=\"改hosts\"><a href=\"#改hosts\" class=\"headerlink\" title=\"改hosts\"></a><strong>改hosts</strong></h2><ul>\n<li>IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N</li>\n<li>IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk</li>\n</ul>\n<h2 id=\"hosts文件的路径\"><a href=\"#hosts文件的路径\" class=\"headerlink\" title=\"hosts文件的路径\"></a><strong>hosts文件的路径</strong></h2><ul>\n<li>Windows：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux，Mac，Android(均需要root权限)：<code>/etc/hosts</code></li>\n</ul>\n<h1 id=\"PS-A-Survival-Guide-to-a-PhD\"><a href=\"#PS-A-Survival-Guide-to-a-PhD\" class=\"headerlink\" title=\"PS: A Survival Guide to a PhD\"></a>PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></h1><hr>\n<p>飞鸟集</p>\n<blockquote>\n<p>第83<br>那想做好人的，在门外敲着门，那爱人的，看见门敞开着。</p>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n</blockquote>"},{"title":"再说docker及云中的网络连接","date":"2017-04-07T16:00:00.000Z","_content":"之前写过一篇[关于虚拟机和docker网络的日志](https://ying-zhang.github.io/cloud/2016/vm-net/)，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。\n经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。\n去年[与一个大四做毕设的学弟折腾过一段时间docker网络](https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md)，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） **4.2节 Docker高级网络实战** ，整理一下相关内容。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [再说Docker桥接模式，路由器，NAT，交换机](#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [Docker跨主机的网络](#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C)\n- [跨主机网络的实现机制](#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6)\n- [macvlan](#macvlan)\n- [overlay网络](#overlay%E7%BD%91%E7%BB%9C)\n- [对容器网络的需求](#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82)\n- [其它](#%E5%85%B6%E5%AE%83)\n- [脑洞](#%E8%84%91%E6%B4%9E)\n\n<!-- /TOC -->\n\n# 再说Docker桥接模式，路由器，NAT，交换机\n[上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式](https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge)，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。\n实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 **虚拟路由器**，也是一个 **虚拟交换机**，因为（家用）路由器的一侧就包括了一个交换机。\n参考下图。\n![家用无线路由器拓扑](/img/wifi-router.png)\n+ 如果把墙上的网口用网线接到路由器的 **WAN口**，把家里的PC，手机等接到路由器的 **有线LAN口** 或 **wifi**，这是路由器的正常工作模式，即 **NAT模式**，类似于 **docker的bridge模式**。\n+ 如果稍稍开一下脑洞，把网线接到 **有线LAN口中的任意一个**，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 **交换机** 模式，这类似于 **VM的bridge模式**。其实交换机的功能就是把一个网络端口变成多个网络端口。\n\n# Docker跨主机的网络\n上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。\n多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。\n\n回顾一下docker支持的网络模式 https://docs.docker.com/engine/userguide/networking/ ：\n+ none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；\n+ host：直接使用主机的网络栈，即没有网络隔离；\n+ bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在`docker run`命令中提供`-p`参数\n+ overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。\n\n>docker还有一种`container`模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 [**史上最小的docker镜像** `pause` ](https://github.com/kubernetes/kubernetes/tree/master/build/pause)创建的。\n>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是`docker run --net container:<network-container-name> <image> <entrypoint>`\n\n# 跨主机网络的实现机制\n跨主机网络需要处理：\n+ 容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。\n+ 数据包的转发：iptables，VXLAN等。\n+ 子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 **不通**，属于不同子网的容器之间不能通讯。\n\n不同的实现机制，在功能和性能上有所区别：\n+ 将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 **外部机制** 来支持子网，一般是传统的 **VLAN**，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。\n+ 路由转发：如`calico`，仍然使用docker的bridge模式，但不再使用NAT，而是 **路由转发**；NAT的出现是解决私有子网（`10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24`），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 **虚拟交换机** 就不够用了， 需要 **虚拟路由器**，`iptables` 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。\n+ overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。\n\n>路由转发和overlay方式都有一个 **限制**：每个物理主机上的容器子网必须在 **不同** 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。\n不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如`10.0.0.0/16`），但实际上每个主机上的容器子网是更细的网段，比如主机A上是`10.0.1.0/24`，主机B上是`10.0.2.0/24`，甚至使用了`10.0.0.1/32`这样的“子网”。\n\n>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。\n\n# macvlan\nLinux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。\n目前的docker内置了macvlan支持。参考[docker的macvlan文档](https://docs.docker.com/engine/userguide/networking/get-started-macvlan/) 和 [数人云的一篇文档 - docker跨主机macvlan网络配置](https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md)，按下面的例子可以设置macvlan：\n```\n# 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式\nip link set ens33 promisc on\n\n# 创建名为macvlan_net的docker网络\ndocker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net\n\n# 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突\ndocker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash\ndocker run -ti --net macvlan_net centos:net /bin/bash\n```\n\n上面使用的`centos:net`镜像是在centos:7基础上安装了`iproute`和`net-tools`软件包，以在镜像内提供`ip`，`ifconfig`等网络管理命令。\n```\n# Dockerfile\nFROM centos:7\nRUN yum install net-tools iproute -y\n\n# docker build . -t centos:net\n```\n\n按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 **不能ping同本主机**，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考[linux 网络虚拟化： macvlan](https://cizixs.github.io/2017/02/14/network-virtualization-macvlan)、[Linux 上虚拟网络与真实网络的映射](https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/)和[Some notes on macvlan/macvtap](http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/)，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。\n使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 [基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方](http://t.cn/RXpdDrf) 和 [Virtual switching technologies and Linux bridge - ppt](/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf)。\n\n# overlay网络\nflannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。\n早期版本flannel的配置可以参考[一篇文章带你了解Flannel](http://dockone.io/article/618)。\n关于[VXLAN](https://tools.ietf.org/html/rfc7348)，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。\nVLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 **升级交换机** 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。\n![](/img/vnet-vxlan.png)。\n\nVXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。\ndocker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。\n>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。\n\nVXLAN是由VMware为主提出来的，微软提出了类似的[NVGRE](https://tools.ietf.org/html/rfc7637)。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。\n\n>参考\n+ [【华为悦读汇】技术发烧友：认识VXLAN](http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html)\n+ [【华为悦读汇】技术发烧友：闲话大二层网络](http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html)\n+ [Overlay 网络技术，最想解决什么问题？](https://www.zhihu.com/question/24393680)\n+ [基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方](http://t.cn/RXpdege)\n\n# 对容器网络的需求\n\n+ 提供类似传统网络的体验\n  + VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；\n  + 租户可以有多个子网，设置虚拟路由器；\n  + 安全组，防火墙，负载均衡，DNS；\n+ 性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。\n+ 容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。\n\n# 其它\n关于Calico，可参考[其官网](http://docs.projectcalico.org/v2.1/getting-started/docker/)和[将Docker网络方案进行到底](http://blog.dataman-inc.com/shurenyun-docker-133/)。\n关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇[Docker network on cloud 中文](https://www.douban.com/note/530365327/)或者 https://cmgs.me/life/docker-network-cloud 。这里盗个图。\n![](/img/vnet-pk.png)\n\n# 脑洞\n上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。\n**被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：[Jumpers and the Software Defined Localhost](https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html)：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。**\n隔离是肯定没问题，都不需要子网的概念了，但都只有一个`127.0.0.1`的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个[DNS（127.0.0.11）](https://www.infoq.com/news/2016/08/docker-service-load-balancing)来帮助实现服务发现。\n\n\n[DockOne微信分享（一三零）：探究PaaS网络模型设计](http://dockone.io/article/2504)","source":"_posts/vm-net-2.md","raw":"title: 再说docker及云中的网络连接\ncategory: [cloud]\ntags:\ndate: 2017-04-08\n---\n之前写过一篇[关于虚拟机和docker网络的日志](https://ying-zhang.github.io/cloud/2016/vm-net/)，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。\n经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。\n去年[与一个大四做毕设的学弟折腾过一段时间docker网络](https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md)，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） **4.2节 Docker高级网络实战** ，整理一下相关内容。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [再说Docker桥接模式，路由器，NAT，交换机](#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [Docker跨主机的网络](#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C)\n- [跨主机网络的实现机制](#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6)\n- [macvlan](#macvlan)\n- [overlay网络](#overlay%E7%BD%91%E7%BB%9C)\n- [对容器网络的需求](#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82)\n- [其它](#%E5%85%B6%E5%AE%83)\n- [脑洞](#%E8%84%91%E6%B4%9E)\n\n<!-- /TOC -->\n\n# 再说Docker桥接模式，路由器，NAT，交换机\n[上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式](https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge)，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。\n实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 **虚拟路由器**，也是一个 **虚拟交换机**，因为（家用）路由器的一侧就包括了一个交换机。\n参考下图。\n![家用无线路由器拓扑](/img/wifi-router.png)\n+ 如果把墙上的网口用网线接到路由器的 **WAN口**，把家里的PC，手机等接到路由器的 **有线LAN口** 或 **wifi**，这是路由器的正常工作模式，即 **NAT模式**，类似于 **docker的bridge模式**。\n+ 如果稍稍开一下脑洞，把网线接到 **有线LAN口中的任意一个**，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 **交换机** 模式，这类似于 **VM的bridge模式**。其实交换机的功能就是把一个网络端口变成多个网络端口。\n\n# Docker跨主机的网络\n上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。\n多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。\n\n回顾一下docker支持的网络模式 https://docs.docker.com/engine/userguide/networking/ ：\n+ none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；\n+ host：直接使用主机的网络栈，即没有网络隔离；\n+ bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在`docker run`命令中提供`-p`参数\n+ overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。\n\n>docker还有一种`container`模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 [**史上最小的docker镜像** `pause` ](https://github.com/kubernetes/kubernetes/tree/master/build/pause)创建的。\n>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是`docker run --net container:<network-container-name> <image> <entrypoint>`\n\n# 跨主机网络的实现机制\n跨主机网络需要处理：\n+ 容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。\n+ 数据包的转发：iptables，VXLAN等。\n+ 子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 **不通**，属于不同子网的容器之间不能通讯。\n\n不同的实现机制，在功能和性能上有所区别：\n+ 将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 **外部机制** 来支持子网，一般是传统的 **VLAN**，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。\n+ 路由转发：如`calico`，仍然使用docker的bridge模式，但不再使用NAT，而是 **路由转发**；NAT的出现是解决私有子网（`10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24`），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 **虚拟交换机** 就不够用了， 需要 **虚拟路由器**，`iptables` 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。\n+ overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。\n\n>路由转发和overlay方式都有一个 **限制**：每个物理主机上的容器子网必须在 **不同** 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。\n不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如`10.0.0.0/16`），但实际上每个主机上的容器子网是更细的网段，比如主机A上是`10.0.1.0/24`，主机B上是`10.0.2.0/24`，甚至使用了`10.0.0.1/32`这样的“子网”。\n\n>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。\n\n# macvlan\nLinux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。\n目前的docker内置了macvlan支持。参考[docker的macvlan文档](https://docs.docker.com/engine/userguide/networking/get-started-macvlan/) 和 [数人云的一篇文档 - docker跨主机macvlan网络配置](https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md)，按下面的例子可以设置macvlan：\n```\n# 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式\nip link set ens33 promisc on\n\n# 创建名为macvlan_net的docker网络\ndocker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net\n\n# 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突\ndocker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash\ndocker run -ti --net macvlan_net centos:net /bin/bash\n```\n\n上面使用的`centos:net`镜像是在centos:7基础上安装了`iproute`和`net-tools`软件包，以在镜像内提供`ip`，`ifconfig`等网络管理命令。\n```\n# Dockerfile\nFROM centos:7\nRUN yum install net-tools iproute -y\n\n# docker build . -t centos:net\n```\n\n按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 **不能ping同本主机**，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考[linux 网络虚拟化： macvlan](https://cizixs.github.io/2017/02/14/network-virtualization-macvlan)、[Linux 上虚拟网络与真实网络的映射](https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/)和[Some notes on macvlan/macvtap](http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/)，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。\n使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 [基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方](http://t.cn/RXpdDrf) 和 [Virtual switching technologies and Linux bridge - ppt](/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf)。\n\n# overlay网络\nflannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。\n早期版本flannel的配置可以参考[一篇文章带你了解Flannel](http://dockone.io/article/618)。\n关于[VXLAN](https://tools.ietf.org/html/rfc7348)，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。\nVLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 **升级交换机** 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。\n![](/img/vnet-vxlan.png)。\n\nVXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。\ndocker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。\n>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。\n\nVXLAN是由VMware为主提出来的，微软提出了类似的[NVGRE](https://tools.ietf.org/html/rfc7637)。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。\n\n>参考\n+ [【华为悦读汇】技术发烧友：认识VXLAN](http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html)\n+ [【华为悦读汇】技术发烧友：闲话大二层网络](http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html)\n+ [Overlay 网络技术，最想解决什么问题？](https://www.zhihu.com/question/24393680)\n+ [基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方](http://t.cn/RXpdege)\n\n# 对容器网络的需求\n\n+ 提供类似传统网络的体验\n  + VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；\n  + 租户可以有多个子网，设置虚拟路由器；\n  + 安全组，防火墙，负载均衡，DNS；\n+ 性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。\n+ 容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。\n\n# 其它\n关于Calico，可参考[其官网](http://docs.projectcalico.org/v2.1/getting-started/docker/)和[将Docker网络方案进行到底](http://blog.dataman-inc.com/shurenyun-docker-133/)。\n关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇[Docker network on cloud 中文](https://www.douban.com/note/530365327/)或者 https://cmgs.me/life/docker-network-cloud 。这里盗个图。\n![](/img/vnet-pk.png)\n\n# 脑洞\n上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。\n**被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：[Jumpers and the Software Defined Localhost](https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html)：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。**\n隔离是肯定没问题，都不需要子网的概念了，但都只有一个`127.0.0.1`的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个[DNS（127.0.0.11）](https://www.infoq.com/news/2016/08/docker-service-load-balancing)来帮助实现服务发现。\n\n\n[DockOne微信分享（一三零）：探究PaaS网络模型设计](http://dockone.io/article/2504)","slug":"vm-net-2","published":1,"updated":"2017-10-30T03:41:43.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn7z670004nw4f9nw0wzzg","content":"<p>之前写过一篇<a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/\">关于虚拟机和docker网络的日志</a>，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。<br>经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。<br>去年<a href=\"https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md\" target=\"_blank\" rel=\"external\">与一个大四做毕设的学弟折腾过一段时间docker网络</a>，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） <strong>4.2节 Docker高级网络实战</strong> ，整理一下相关内容。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">再说Docker桥接模式，路由器，NAT，交换机</a></li>\n<li><a href=\"#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C\">Docker跨主机的网络</a></li>\n<li><a href=\"#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\">跨主机网络的实现机制</a></li>\n<li><a href=\"#macvlan\">macvlan</a></li>\n<li><a href=\"#overlay%E7%BD%91%E7%BB%9C\">overlay网络</a></li>\n<li><a href=\"#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82\">对容器网络的需求</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n<li><a href=\"#%E8%84%91%E6%B4%9E\">脑洞</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"再说Docker桥接模式，路由器，NAT，交换机\"><a href=\"#再说Docker桥接模式，路由器，NAT，交换机\" class=\"headerlink\" title=\"再说Docker桥接模式，路由器，NAT，交换机\"></a>再说Docker桥接模式，路由器，NAT，交换机</h1><p><a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge\">上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式</a>，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。<br>实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 <strong>虚拟路由器</strong>，也是一个 <strong>虚拟交换机</strong>，因为（家用）路由器的一侧就包括了一个交换机。<br>参考下图。<br><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<ul>\n<li>如果把墙上的网口用网线接到路由器的 <strong>WAN口</strong>，把家里的PC，手机等接到路由器的 <strong>有线LAN口</strong> 或 <strong>wifi</strong>，这是路由器的正常工作模式，即 <strong>NAT模式</strong>，类似于 <strong>docker的bridge模式</strong>。</li>\n<li>如果稍稍开一下脑洞，把网线接到 <strong>有线LAN口中的任意一个</strong>，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 <strong>交换机</strong> 模式，这类似于 <strong>VM的bridge模式</strong>。其实交换机的功能就是把一个网络端口变成多个网络端口。</li>\n</ul>\n<h1 id=\"Docker跨主机的网络\"><a href=\"#Docker跨主机的网络\" class=\"headerlink\" title=\"Docker跨主机的网络\"></a>Docker跨主机的网络</h1><p>上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。<br>多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。</p>\n<p>回顾一下docker支持的网络模式 <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/userguide/networking/</a> ：</p>\n<ul>\n<li>none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；</li>\n<li>host：直接使用主机的网络栈，即没有网络隔离；</li>\n<li>bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在<code>docker run</code>命令中提供<code>-p</code>参数</li>\n<li>overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。</li>\n</ul>\n<blockquote>\n<p>docker还有一种<code>container</code>模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 <a href=\"https://github.com/kubernetes/kubernetes/tree/master/build/pause\" target=\"_blank\" rel=\"external\"><strong>史上最小的docker镜像</strong> <code>pause</code> </a>创建的。<br>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是<code>docker run --net container:&lt;network-container-name&gt; &lt;image&gt; &lt;entrypoint&gt;</code></p>\n</blockquote>\n<h1 id=\"跨主机网络的实现机制\"><a href=\"#跨主机网络的实现机制\" class=\"headerlink\" title=\"跨主机网络的实现机制\"></a>跨主机网络的实现机制</h1><p>跨主机网络需要处理：</p>\n<ul>\n<li>容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。</li>\n<li>数据包的转发：iptables，VXLAN等。</li>\n<li>子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 <strong>不通</strong>，属于不同子网的容器之间不能通讯。</li>\n</ul>\n<p>不同的实现机制，在功能和性能上有所区别：</p>\n<ul>\n<li>将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 <strong>外部机制</strong> 来支持子网，一般是传统的 <strong>VLAN</strong>，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。</li>\n<li>路由转发：如<code>calico</code>，仍然使用docker的bridge模式，但不再使用NAT，而是 <strong>路由转发</strong>；NAT的出现是解决私有子网（<code>10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24</code>），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 <strong>虚拟交换机</strong> 就不够用了， 需要 <strong>虚拟路由器</strong>，<code>iptables</code> 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。</li>\n<li>overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。</li>\n</ul>\n<blockquote>\n<p>路由转发和overlay方式都有一个 <strong>限制</strong>：每个物理主机上的容器子网必须在 <strong>不同</strong> 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。<br>不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如<code>10.0.0.0/16</code>），但实际上每个主机上的容器子网是更细的网段，比如主机A上是<code>10.0.1.0/24</code>，主机B上是<code>10.0.2.0/24</code>，甚至使用了<code>10.0.0.1/32</code>这样的“子网”。</p>\n<p>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。</p>\n</blockquote>\n<h1 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a>macvlan</h1><p>Linux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。<br>目前的docker内置了macvlan支持。参考<a href=\"https://docs.docker.com/engine/userguide/networking/get-started-macvlan/\" target=\"_blank\" rel=\"external\">docker的macvlan文档</a> 和 <a href=\"https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">数人云的一篇文档 - docker跨主机macvlan网络配置</a>，按下面的例子可以设置macvlan：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式</div><div class=\"line\">ip link set ens33 promisc on</div><div class=\"line\"></div><div class=\"line\"># 创建名为macvlan_net的docker网络</div><div class=\"line\">docker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net</div><div class=\"line\"></div><div class=\"line\"># 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突</div><div class=\"line\">docker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash</div><div class=\"line\">docker run -ti --net macvlan_net centos:net /bin/bash</div></pre></td></tr></table></figure></p>\n<p>上面使用的<code>centos:net</code>镜像是在centos:7基础上安装了<code>iproute</code>和<code>net-tools</code>软件包，以在镜像内提供<code>ip</code>，<code>ifconfig</code>等网络管理命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dockerfile</div><div class=\"line\">FROM centos:7</div><div class=\"line\">RUN yum install net-tools iproute -y</div><div class=\"line\"></div><div class=\"line\"># docker build . -t centos:net</div></pre></td></tr></table></figure></p>\n<p>按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 <strong>不能ping同本主机</strong>，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考<a href=\"https://cizixs.github.io/2017/02/14/network-virtualization-macvlan\" target=\"_blank\" rel=\"external\">linux 网络虚拟化： macvlan</a>、<a href=\"https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/\" target=\"_blank\" rel=\"external\">Linux 上虚拟网络与真实网络的映射</a>和<a href=\"http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/\" target=\"_blank\" rel=\"external\">Some notes on macvlan/macvtap</a>，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。<br>使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 <a href=\"http://t.cn/RXpdDrf\" target=\"_blank\" rel=\"external\">基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方</a> 和 <a href=\"/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf\">Virtual switching technologies and Linux bridge - ppt</a>。</p>\n<h1 id=\"overlay网络\"><a href=\"#overlay网络\" class=\"headerlink\" title=\"overlay网络\"></a>overlay网络</h1><p>flannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。<br>早期版本flannel的配置可以参考<a href=\"http://dockone.io/article/618\" target=\"_blank\" rel=\"external\">一篇文章带你了解Flannel</a>。<br>关于<a href=\"https://tools.ietf.org/html/rfc7348\" target=\"_blank\" rel=\"external\">VXLAN</a>，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。<br>VLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 <strong>升级交换机</strong> 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。<br><img src=\"/img/vnet-vxlan.png\" alt=\"\">。</p>\n<p>VXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。<br>docker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。</p>\n<blockquote>\n<p>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。</p>\n</blockquote>\n<p>VXLAN是由VMware为主提出来的，微软提出了类似的<a href=\"https://tools.ietf.org/html/rfc7637\" target=\"_blank\" rel=\"external\">NVGRE</a>。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：认识VXLAN</a></li>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：闲话大二层网络</a></li>\n<li><a href=\"https://www.zhihu.com/question/24393680\" target=\"_blank\" rel=\"external\">Overlay 网络技术，最想解决什么问题？</a></li>\n<li><a href=\"http://t.cn/RXpdege\" target=\"_blank\" rel=\"external\">基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方</a></li>\n</ul>\n</blockquote>\n<h1 id=\"对容器网络的需求\"><a href=\"#对容器网络的需求\" class=\"headerlink\" title=\"对容器网络的需求\"></a>对容器网络的需求</h1><ul>\n<li>提供类似传统网络的体验<ul>\n<li>VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；</li>\n<li>租户可以有多个子网，设置虚拟路由器；</li>\n<li>安全组，防火墙，负载均衡，DNS；</li>\n</ul>\n</li>\n<li>性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。</li>\n<li>容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。</li>\n</ul>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p>关于Calico，可参考<a href=\"http://docs.projectcalico.org/v2.1/getting-started/docker/\" target=\"_blank\" rel=\"external\">其官网</a>和<a href=\"http://blog.dataman-inc.com/shurenyun-docker-133/\" target=\"_blank\" rel=\"external\">将Docker网络方案进行到底</a>。<br>关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇<a href=\"https://www.douban.com/note/530365327/\" target=\"_blank\" rel=\"external\">Docker network on cloud 中文</a>或者 <a href=\"https://cmgs.me/life/docker-network-cloud\" target=\"_blank\" rel=\"external\">https://cmgs.me/life/docker-network-cloud</a> 。这里盗个图。<br><img src=\"/img/vnet-pk.png\" alt=\"\"></p>\n<h1 id=\"脑洞\"><a href=\"#脑洞\" class=\"headerlink\" title=\"脑洞\"></a>脑洞</h1><p>上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。<br><strong>被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：<a href=\"https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html\" target=\"_blank\" rel=\"external\">Jumpers and the Software Defined Localhost</a>：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。</strong><br>隔离是肯定没问题，都不需要子网的概念了，但都只有一个<code>127.0.0.1</code>的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个<a href=\"https://www.infoq.com/news/2016/08/docker-service-load-balancing\" target=\"_blank\" rel=\"external\">DNS（127.0.0.11）</a>来帮助实现服务发现。</p>\n<p><a href=\"http://dockone.io/article/2504\" target=\"_blank\" rel=\"external\">DockOne微信分享（一三零）：探究PaaS网络模型设计</a></p>\n","site":{"data":{}},"excerpt":"<p>之前写过一篇<a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/\">关于虚拟机和docker网络的日志</a>，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。<br>经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。<br>去年<a href=\"https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md\" target=\"_blank\" rel=\"external\">与一个大四做毕设的学弟折腾过一段时间docker网络</a>，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） <strong>4.2节 Docker高级网络实战</strong> ，整理一下相关内容。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">再说Docker桥接模式，路由器，NAT，交换机</a></li>\n<li><a href=\"#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C\">Docker跨主机的网络</a></li>\n<li><a href=\"#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\">跨主机网络的实现机制</a></li>\n<li><a href=\"#macvlan\">macvlan</a></li>\n<li><a href=\"#overlay%E7%BD%91%E7%BB%9C\">overlay网络</a></li>\n<li><a href=\"#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82\">对容器网络的需求</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n<li><a href=\"#%E8%84%91%E6%B4%9E\">脑洞</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"再说Docker桥接模式，路由器，NAT，交换机\"><a href=\"#再说Docker桥接模式，路由器，NAT，交换机\" class=\"headerlink\" title=\"再说Docker桥接模式，路由器，NAT，交换机\"></a>再说Docker桥接模式，路由器，NAT，交换机</h1><p><a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge\">上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式</a>，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。<br>实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 <strong>虚拟路由器</strong>，也是一个 <strong>虚拟交换机</strong>，因为（家用）路由器的一侧就包括了一个交换机。<br>参考下图。<br><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<ul>\n<li>如果把墙上的网口用网线接到路由器的 <strong>WAN口</strong>，把家里的PC，手机等接到路由器的 <strong>有线LAN口</strong> 或 <strong>wifi</strong>，这是路由器的正常工作模式，即 <strong>NAT模式</strong>，类似于 <strong>docker的bridge模式</strong>。</li>\n<li>如果稍稍开一下脑洞，把网线接到 <strong>有线LAN口中的任意一个</strong>，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 <strong>交换机</strong> 模式，这类似于 <strong>VM的bridge模式</strong>。其实交换机的功能就是把一个网络端口变成多个网络端口。</li>\n</ul>\n<h1 id=\"Docker跨主机的网络\"><a href=\"#Docker跨主机的网络\" class=\"headerlink\" title=\"Docker跨主机的网络\"></a>Docker跨主机的网络</h1><p>上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。<br>多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。</p>\n<p>回顾一下docker支持的网络模式 <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/userguide/networking/</a> ：</p>\n<ul>\n<li>none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；</li>\n<li>host：直接使用主机的网络栈，即没有网络隔离；</li>\n<li>bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在<code>docker run</code>命令中提供<code>-p</code>参数</li>\n<li>overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。</li>\n</ul>\n<blockquote>\n<p>docker还有一种<code>container</code>模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 <a href=\"https://github.com/kubernetes/kubernetes/tree/master/build/pause\" target=\"_blank\" rel=\"external\"><strong>史上最小的docker镜像</strong> <code>pause</code> </a>创建的。<br>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是<code>docker run --net container:&lt;network-container-name&gt; &lt;image&gt; &lt;entrypoint&gt;</code></p>\n</blockquote>\n<h1 id=\"跨主机网络的实现机制\"><a href=\"#跨主机网络的实现机制\" class=\"headerlink\" title=\"跨主机网络的实现机制\"></a>跨主机网络的实现机制</h1><p>跨主机网络需要处理：</p>\n<ul>\n<li>容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。</li>\n<li>数据包的转发：iptables，VXLAN等。</li>\n<li>子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 <strong>不通</strong>，属于不同子网的容器之间不能通讯。</li>\n</ul>\n<p>不同的实现机制，在功能和性能上有所区别：</p>\n<ul>\n<li>将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 <strong>外部机制</strong> 来支持子网，一般是传统的 <strong>VLAN</strong>，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。</li>\n<li>路由转发：如<code>calico</code>，仍然使用docker的bridge模式，但不再使用NAT，而是 <strong>路由转发</strong>；NAT的出现是解决私有子网（<code>10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24</code>），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 <strong>虚拟交换机</strong> 就不够用了， 需要 <strong>虚拟路由器</strong>，<code>iptables</code> 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。</li>\n<li>overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。</li>\n</ul>\n<blockquote>\n<p>路由转发和overlay方式都有一个 <strong>限制</strong>：每个物理主机上的容器子网必须在 <strong>不同</strong> 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。<br>不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如<code>10.0.0.0/16</code>），但实际上每个主机上的容器子网是更细的网段，比如主机A上是<code>10.0.1.0/24</code>，主机B上是<code>10.0.2.0/24</code>，甚至使用了<code>10.0.0.1/32</code>这样的“子网”。</p>\n<p>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。</p>\n</blockquote>\n<h1 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a>macvlan</h1><p>Linux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。<br>目前的docker内置了macvlan支持。参考<a href=\"https://docs.docker.com/engine/userguide/networking/get-started-macvlan/\" target=\"_blank\" rel=\"external\">docker的macvlan文档</a> 和 <a href=\"https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">数人云的一篇文档 - docker跨主机macvlan网络配置</a>，按下面的例子可以设置macvlan：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式</div><div class=\"line\">ip link set ens33 promisc on</div><div class=\"line\"></div><div class=\"line\"># 创建名为macvlan_net的docker网络</div><div class=\"line\">docker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net</div><div class=\"line\"></div><div class=\"line\"># 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突</div><div class=\"line\">docker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash</div><div class=\"line\">docker run -ti --net macvlan_net centos:net /bin/bash</div></pre></td></tr></table></figure></p>\n<p>上面使用的<code>centos:net</code>镜像是在centos:7基础上安装了<code>iproute</code>和<code>net-tools</code>软件包，以在镜像内提供<code>ip</code>，<code>ifconfig</code>等网络管理命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dockerfile</div><div class=\"line\">FROM centos:7</div><div class=\"line\">RUN yum install net-tools iproute -y</div><div class=\"line\"></div><div class=\"line\"># docker build . -t centos:net</div></pre></td></tr></table></figure></p>\n<p>按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 <strong>不能ping同本主机</strong>，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考<a href=\"https://cizixs.github.io/2017/02/14/network-virtualization-macvlan\" target=\"_blank\" rel=\"external\">linux 网络虚拟化： macvlan</a>、<a href=\"https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/\" target=\"_blank\" rel=\"external\">Linux 上虚拟网络与真实网络的映射</a>和<a href=\"http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/\" target=\"_blank\" rel=\"external\">Some notes on macvlan/macvtap</a>，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。<br>使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 <a href=\"http://t.cn/RXpdDrf\" target=\"_blank\" rel=\"external\">基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方</a> 和 <a href=\"/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf\">Virtual switching technologies and Linux bridge - ppt</a>。</p>\n<h1 id=\"overlay网络\"><a href=\"#overlay网络\" class=\"headerlink\" title=\"overlay网络\"></a>overlay网络</h1><p>flannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。<br>早期版本flannel的配置可以参考<a href=\"http://dockone.io/article/618\" target=\"_blank\" rel=\"external\">一篇文章带你了解Flannel</a>。<br>关于<a href=\"https://tools.ietf.org/html/rfc7348\" target=\"_blank\" rel=\"external\">VXLAN</a>，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。<br>VLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 <strong>升级交换机</strong> 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。<br><img src=\"/img/vnet-vxlan.png\" alt=\"\">。</p>\n<p>VXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。<br>docker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。</p>\n<blockquote>\n<p>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。</p>\n</blockquote>\n<p>VXLAN是由VMware为主提出来的，微软提出了类似的<a href=\"https://tools.ietf.org/html/rfc7637\" target=\"_blank\" rel=\"external\">NVGRE</a>。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：认识VXLAN</a></li>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：闲话大二层网络</a></li>\n<li><a href=\"https://www.zhihu.com/question/24393680\" target=\"_blank\" rel=\"external\">Overlay 网络技术，最想解决什么问题？</a></li>\n<li><a href=\"http://t.cn/RXpdege\" target=\"_blank\" rel=\"external\">基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方</a></li>\n</ul>\n</blockquote>\n<h1 id=\"对容器网络的需求\"><a href=\"#对容器网络的需求\" class=\"headerlink\" title=\"对容器网络的需求\"></a>对容器网络的需求</h1><ul>\n<li>提供类似传统网络的体验<ul>\n<li>VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；</li>\n<li>租户可以有多个子网，设置虚拟路由器；</li>\n<li>安全组，防火墙，负载均衡，DNS；</li>\n</ul>\n</li>\n<li>性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。</li>\n<li>容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。</li>\n</ul>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p>关于Calico，可参考<a href=\"http://docs.projectcalico.org/v2.1/getting-started/docker/\" target=\"_blank\" rel=\"external\">其官网</a>和<a href=\"http://blog.dataman-inc.com/shurenyun-docker-133/\" target=\"_blank\" rel=\"external\">将Docker网络方案进行到底</a>。<br>关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇<a href=\"https://www.douban.com/note/530365327/\" target=\"_blank\" rel=\"external\">Docker network on cloud 中文</a>或者 <a href=\"https://cmgs.me/life/docker-network-cloud\" target=\"_blank\" rel=\"external\">https://cmgs.me/life/docker-network-cloud</a> 。这里盗个图。<br><img src=\"/img/vnet-pk.png\" alt=\"\"></p>\n<h1 id=\"脑洞\"><a href=\"#脑洞\" class=\"headerlink\" title=\"脑洞\"></a>脑洞</h1><p>上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。<br><strong>被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：<a href=\"https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html\" target=\"_blank\" rel=\"external\">Jumpers and the Software Defined Localhost</a>：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。</strong><br>隔离是肯定没问题，都不需要子网的概念了，但都只有一个<code>127.0.0.1</code>的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个<a href=\"https://www.infoq.com/news/2016/08/docker-service-load-balancing\" target=\"_blank\" rel=\"external\">DNS（127.0.0.11）</a>来帮助实现服务发现。</p>\n<p><a href=\"http://dockone.io/article/2504\" target=\"_blank\" rel=\"external\">DockOne微信分享（一三零）：探究PaaS网络模型设计</a></p>"},{"title":"虚拟机及docker的网络连接","date":"2016-09-19T16:00:00.000Z","_content":"网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。\n\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [路由器，NAT，交换机](#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [单机的网络地址转换（NAT）](#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89)\n- [NAT网络](#nat%E7%BD%91%E7%BB%9C)\n- [Host-Only 仅主机](#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA)\n- [桥接](#%E6%A1%A5%E6%8E%A5)\n- [Docker的桥接模式](#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F)\n- [内部网络/LAN区段](#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5)\n- [选择哪种连接方式？](#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F)\n- [Bonus](#bonus)\n\n<!-- /TOC -->\n\n# 路由器，NAT，交换机\n\n先简单介绍一下[NAT](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)。\n家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。\n\n接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问[ip.cn](http://ip.cn)，显示的IP跟当前计算机的IP是不同的。\n\n网络基础课上讲到IP v4有三类私有IP地址：\n\n+ 10.0.0.0 ~ 10.255.255.255      （A类）；\n+ 172.16.0.0 ~ 172.31.255.255    （B类）；\n+ 192.168.0.0 ~ 192.168.255.255  （C类）；\n\n\n![家用无线路由器拓扑](/img/wifi-router.png)\n\n接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。\n\n在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问[ip.cn](http://ip.cn) 或者在ubuntu上执行 `curl ip.cn` 可以查到这个公网IP，也可以执行`ip a` 、`ifconfig` 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 **发起** 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。\n曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。\n\n>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。\n\n另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。\n\n那么问题来了：\n1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？\n2、外网怎么区分路由器LAN的不同设备呢？\n\n实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。\n\n如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。\n\n把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。\n网络基础课上会介绍交换机是二层设备，路由器是三层设备。**所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。** 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。\n另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。\n\n<center>~</center>\n\n下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。\n\n![几种虚拟机的网络连接方式](/img/vnet.png)\n\n>注：**NAT网络**，Host->VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。\n\n# 单机的网络地址转换（NAT）\n 只有vbox支持 **单机NAT** 方式。这种方式与下面的 **NAT网络** 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。\n 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是`10.0.2.2`，一个DHCP服务器，也是`10.0.2.2`，VM的IP一般是`10.0.2.15`。\n 不管使用NAT的有多少个VM，它们的IP都是一样的。\n\n 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为`10.0.2.0/24`，`10.0.3.0/24`等。不过同一个VM设置多个NAT网卡并没有什么必要。\n\n VM可以直接访问Host，默认IP也是`10.0.2.2`，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。\n Host要想访问VM，需要设置端口映射，即设置`HostIP:HostPort`与`VM-IP:VM-Port`的关联，这样Host就可以通过`HostIP:HostPort`来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过`HostIP:Host-Port`来访问VM的指定端口。\n 可以添加多个映射规则来暴露不同的端口。\n\n# NAT网络\n 在VMware中则直接称为 **NAT** 。vbox刻意把这 **NAT** 和 **NAT网络** 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。\n vbox需要在 **全局配置->网络** 中增加一个 **NAT网络** 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是`10.0.2.0/24`，网关是`10.0.2.1`，DHCP服务器是`10.0.2.3`，Host是`10.0.2.2`，VM的IP是由DHCP自动分配的。\n 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。\n\n >外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 **公网** 上是不可路由的。\n >这里 **外网** 是Host之外的网络，它可能是一个Internet IP（**公网**），也可能是某个公司内部的私有IP地址的网络。\n >如果可以修改 **外网** 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。\n\n 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。\n vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段`10.0.2.0/24`，这不会彼此产生冲突，当然也可将其网段改为其它地址，如`10.0.3.0/24`，或`192.168.2.0/24`这样的，但`192.168.x.x`网段的DHCP可能不能正常工作，需设置静态IP。\n\n VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。\n\n VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 **NAT**、**仅主机** 和 **桥接** 三种不同的模式之一，但又 **限制只能有一个虚拟网卡工作在NAT模式** （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 **默认网关的IP**，及DHCP、DNS的设置。\n\n>注意，vbox在两种NAT模式下都有一个坑：\n>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，**即便这些值与DHCP分配到的值一模一样，也不能访问外网！**\n>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。\n>\n>在这个[博客](http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/) 中介绍了同样的问题（博客里的DNS IP `10.0.2.3`和`/etc/resolve.conf`设置在ubuntu上不能工作）。\n>对Ubuntu，需在 `/etc/network/interfaces` 设置网卡\n\n```\nauto eth0\niface eth0 inet static\naddress 10.0.2.15\nnetmask 255.255.255.0\ngateway 10.0.2.2\n\ndns-nameservers 10.0.2.1\n```\n\n>**设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！**\n>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。\n\n```\nVBoxManage modifyvm \"VM-Name\" --natdnsproxy1 on\nVBoxManage modifyvm \"VM-Name\" --natdnshostresolver1 on\n```\n\n>其中`VBoxManage`是vbox的命令行管理工具，在vbox的安装目录下，默认位置是`C:\\Program Files\\Oracle\\VirtualBox\\`。\n>\n>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，**NAT网络** 方式已经不需要执行上面2条命令了，但`/etc/network/interfaces`里dns-nameservers的设置还是需要的。\n>另外，经过实验发现gateway设置为`10.0.2.1` 或 `10.0.2.2`都可以连网，但DNS必须是`10.0.2.1`。\n>\n>VMware没有这个坑。\n\n# Host-Only 仅主机\n 这种连接方式是4种VMM都支持的，它的使用很简单。\n Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。\n 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 **虚拟 数据中心** 了。一个现实的数据中心里，除了多台服务器，还有 **交换机**，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。\n 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。\n Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：**内部交换机** 是很贴切的。\n\n 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。\n \n 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为`192.168.137.1`，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是`192.168.137.0/24`。\n 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考[Set up a NAT network for Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network)文档，在Powershell下以管理员权限执行\n```\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n```\n\n查看interfere index：`Get-NetAdapter`，即下面命令中虚拟网卡的`-InterfaceIndex 38`。\n```\nNew-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38\nNew-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24\n```\n\n这样就创建了一个可以通过Host以NAT方式访问外网的 **内部交换机**，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。\n\n# 桥接\n 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。\n 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。\n 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。\n\n 另外，虽然名叫 **桥接**，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。\n KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 **已有的** Linux的bridge-utils，TUN/TAP，iptables等功能。\n\n<a name=\"docker-bridge\">\n\n# Docker的桥接模式\n\n >注意：docker的网络连接方式也有 **桥接**，但实际上它的工作模式是 **NAT网络**。docker在添加了一个docker0网桥，IP网段在`172.17.0.0`，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，**不同Host** 的容器是不能直接通信的，这是个很大的局限。\n 实际上docker也可以实现KVM那样的真正的 **桥接** ，具体可参考文章 [桥接模式构建 docker 网络](http://my.oschina.net/astute/blog/293944) 和[Four ways to connect a docker container to a local network](http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/) 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。\n\n# 内部网络/LAN区段\n 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。\n 一个内部网络是由网络名来区分的。\n VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。\n 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。\n\n# 选择哪种连接方式？\n + **NAT网络**\t\t\t：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 **实验环境** 。\n + **Host-Only仅主机**\t：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。\n + **桥接**\t\t\t\t：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。\n\n 在 **数据中心** 里，网络环境不经常变化，**桥接** 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。\n 此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。\n\n\n# Bonus\n\n**[The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013](/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf)**\n\n![AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq](http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret)\n\n![Google的数据中心](/img/google_dc1.jpg)\n\n![Google的数据中心](/img/google_dc2.jpg)","source":"_posts/vm-net.md","raw":"title: 虚拟机及docker的网络连接\ncategory: [cloud]\ntags:\ndate: 2016-09-20\n---\n网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。\n\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [路由器，NAT，交换机](#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [单机的网络地址转换（NAT）](#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89)\n- [NAT网络](#nat%E7%BD%91%E7%BB%9C)\n- [Host-Only 仅主机](#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA)\n- [桥接](#%E6%A1%A5%E6%8E%A5)\n- [Docker的桥接模式](#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F)\n- [内部网络/LAN区段](#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5)\n- [选择哪种连接方式？](#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F)\n- [Bonus](#bonus)\n\n<!-- /TOC -->\n\n# 路由器，NAT，交换机\n\n先简单介绍一下[NAT](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)。\n家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。\n\n接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问[ip.cn](http://ip.cn)，显示的IP跟当前计算机的IP是不同的。\n\n网络基础课上讲到IP v4有三类私有IP地址：\n\n+ 10.0.0.0 ~ 10.255.255.255      （A类）；\n+ 172.16.0.0 ~ 172.31.255.255    （B类）；\n+ 192.168.0.0 ~ 192.168.255.255  （C类）；\n\n\n![家用无线路由器拓扑](/img/wifi-router.png)\n\n接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。\n\n在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问[ip.cn](http://ip.cn) 或者在ubuntu上执行 `curl ip.cn` 可以查到这个公网IP，也可以执行`ip a` 、`ifconfig` 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 **发起** 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。\n曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。\n\n>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。\n\n另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。\n\n那么问题来了：\n1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？\n2、外网怎么区分路由器LAN的不同设备呢？\n\n实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。\n\n如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。\n\n把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。\n网络基础课上会介绍交换机是二层设备，路由器是三层设备。**所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。** 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。\n另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。\n\n<center>~</center>\n\n下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。\n\n![几种虚拟机的网络连接方式](/img/vnet.png)\n\n>注：**NAT网络**，Host->VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。\n\n# 单机的网络地址转换（NAT）\n 只有vbox支持 **单机NAT** 方式。这种方式与下面的 **NAT网络** 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。\n 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是`10.0.2.2`，一个DHCP服务器，也是`10.0.2.2`，VM的IP一般是`10.0.2.15`。\n 不管使用NAT的有多少个VM，它们的IP都是一样的。\n\n 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为`10.0.2.0/24`，`10.0.3.0/24`等。不过同一个VM设置多个NAT网卡并没有什么必要。\n\n VM可以直接访问Host，默认IP也是`10.0.2.2`，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。\n Host要想访问VM，需要设置端口映射，即设置`HostIP:HostPort`与`VM-IP:VM-Port`的关联，这样Host就可以通过`HostIP:HostPort`来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过`HostIP:Host-Port`来访问VM的指定端口。\n 可以添加多个映射规则来暴露不同的端口。\n\n# NAT网络\n 在VMware中则直接称为 **NAT** 。vbox刻意把这 **NAT** 和 **NAT网络** 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。\n vbox需要在 **全局配置->网络** 中增加一个 **NAT网络** 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是`10.0.2.0/24`，网关是`10.0.2.1`，DHCP服务器是`10.0.2.3`，Host是`10.0.2.2`，VM的IP是由DHCP自动分配的。\n 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。\n\n >外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 **公网** 上是不可路由的。\n >这里 **外网** 是Host之外的网络，它可能是一个Internet IP（**公网**），也可能是某个公司内部的私有IP地址的网络。\n >如果可以修改 **外网** 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。\n\n 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。\n vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段`10.0.2.0/24`，这不会彼此产生冲突，当然也可将其网段改为其它地址，如`10.0.3.0/24`，或`192.168.2.0/24`这样的，但`192.168.x.x`网段的DHCP可能不能正常工作，需设置静态IP。\n\n VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。\n\n VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 **NAT**、**仅主机** 和 **桥接** 三种不同的模式之一，但又 **限制只能有一个虚拟网卡工作在NAT模式** （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 **默认网关的IP**，及DHCP、DNS的设置。\n\n>注意，vbox在两种NAT模式下都有一个坑：\n>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，**即便这些值与DHCP分配到的值一模一样，也不能访问外网！**\n>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。\n>\n>在这个[博客](http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/) 中介绍了同样的问题（博客里的DNS IP `10.0.2.3`和`/etc/resolve.conf`设置在ubuntu上不能工作）。\n>对Ubuntu，需在 `/etc/network/interfaces` 设置网卡\n\n```\nauto eth0\niface eth0 inet static\naddress 10.0.2.15\nnetmask 255.255.255.0\ngateway 10.0.2.2\n\ndns-nameservers 10.0.2.1\n```\n\n>**设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！**\n>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。\n\n```\nVBoxManage modifyvm \"VM-Name\" --natdnsproxy1 on\nVBoxManage modifyvm \"VM-Name\" --natdnshostresolver1 on\n```\n\n>其中`VBoxManage`是vbox的命令行管理工具，在vbox的安装目录下，默认位置是`C:\\Program Files\\Oracle\\VirtualBox\\`。\n>\n>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，**NAT网络** 方式已经不需要执行上面2条命令了，但`/etc/network/interfaces`里dns-nameservers的设置还是需要的。\n>另外，经过实验发现gateway设置为`10.0.2.1` 或 `10.0.2.2`都可以连网，但DNS必须是`10.0.2.1`。\n>\n>VMware没有这个坑。\n\n# Host-Only 仅主机\n 这种连接方式是4种VMM都支持的，它的使用很简单。\n Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。\n 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 **虚拟 数据中心** 了。一个现实的数据中心里，除了多台服务器，还有 **交换机**，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。\n 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。\n Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：**内部交换机** 是很贴切的。\n\n 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。\n \n 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为`192.168.137.1`，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是`192.168.137.0/24`。\n 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考[Set up a NAT network for Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network)文档，在Powershell下以管理员权限执行\n```\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n```\n\n查看interfere index：`Get-NetAdapter`，即下面命令中虚拟网卡的`-InterfaceIndex 38`。\n```\nNew-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38\nNew-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24\n```\n\n这样就创建了一个可以通过Host以NAT方式访问外网的 **内部交换机**，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。\n\n# 桥接\n 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。\n 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。\n 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。\n\n 另外，虽然名叫 **桥接**，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。\n KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 **已有的** Linux的bridge-utils，TUN/TAP，iptables等功能。\n\n<a name=\"docker-bridge\">\n\n# Docker的桥接模式\n\n >注意：docker的网络连接方式也有 **桥接**，但实际上它的工作模式是 **NAT网络**。docker在添加了一个docker0网桥，IP网段在`172.17.0.0`，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，**不同Host** 的容器是不能直接通信的，这是个很大的局限。\n 实际上docker也可以实现KVM那样的真正的 **桥接** ，具体可参考文章 [桥接模式构建 docker 网络](http://my.oschina.net/astute/blog/293944) 和[Four ways to connect a docker container to a local network](http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/) 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。\n\n# 内部网络/LAN区段\n 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。\n 一个内部网络是由网络名来区分的。\n VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。\n 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。\n\n# 选择哪种连接方式？\n + **NAT网络**\t\t\t：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 **实验环境** 。\n + **Host-Only仅主机**\t：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。\n + **桥接**\t\t\t\t：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。\n\n 在 **数据中心** 里，网络环境不经常变化，**桥接** 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。\n 此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。\n\n\n# Bonus\n\n**[The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013](/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf)**\n\n![AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq](http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret)\n\n![Google的数据中心](/img/google_dc1.jpg)\n\n![Google的数据中心](/img/google_dc2.jpg)","slug":"vm-net","published":1,"updated":"2017-10-30T03:41:35.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn80i40006nw4fwl23neyr","content":"<p>网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">路由器，NAT，交换机</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89\">单机的网络地址转换（NAT）</a></li>\n<li><a href=\"#nat%E7%BD%91%E7%BB%9C\">NAT网络</a></li>\n<li><a href=\"#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA\">Host-Only 仅主机</a></li>\n<li><a href=\"#%E6%A1%A5%E6%8E%A5\">桥接</a></li>\n<li><a href=\"#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\">Docker的桥接模式</a></li>\n<li><a href=\"#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5\">内部网络/LAN区段</a></li>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F\">选择哪种连接方式？</a></li>\n<li><a href=\"#bonus\">Bonus</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"路由器，NAT，交换机\"><a href=\"#路由器，NAT，交换机\" class=\"headerlink\" title=\"路由器，NAT，交换机\"></a>路由器，NAT，交换机</h1><p>先简单介绍一下<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"external\">NAT</a>。<br>家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。</p>\n<p>接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a>，显示的IP跟当前计算机的IP是不同的。</p>\n<p>网络基础课上讲到IP v4有三类私有IP地址：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255      （A类）；</li>\n<li>172.16.0.0 ~ 172.31.255.255    （B类）；</li>\n<li>192.168.0.0 ~ 192.168.255.255  （C类）；</li>\n</ul>\n<p><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<p>接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。</p>\n<p>在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a> 或者在ubuntu上执行 <code>curl ip.cn</code> 可以查到这个公网IP，也可以执行<code>ip a</code> 、<code>ifconfig</code> 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 <strong>发起</strong> 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。<br>曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。</p>\n<blockquote>\n<p>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。</p>\n</blockquote>\n<p>另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。</p>\n<p>那么问题来了：<br>1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？<br>2、外网怎么区分路由器LAN的不同设备呢？</p>\n<p>实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。</p>\n<p>如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。</p>\n<p>把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。<br>网络基础课上会介绍交换机是二层设备，路由器是三层设备。<strong>所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。</strong> 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。<br>另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。</p>\n<center>~</center>\n\n<p>下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。</p>\n<p><img src=\"/img/vnet.png\" alt=\"几种虚拟机的网络连接方式\"></p>\n<blockquote>\n<p>注：<strong>NAT网络</strong>，Host-&gt;VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。</p>\n</blockquote>\n<h1 id=\"单机的网络地址转换（NAT）\"><a href=\"#单机的网络地址转换（NAT）\" class=\"headerlink\" title=\"单机的网络地址转换（NAT）\"></a>单机的网络地址转换（NAT）</h1><p> 只有vbox支持 <strong>单机NAT</strong> 方式。这种方式与下面的 <strong>NAT网络</strong> 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。<br> 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是<code>10.0.2.2</code>，一个DHCP服务器，也是<code>10.0.2.2</code>，VM的IP一般是<code>10.0.2.15</code>。<br> 不管使用NAT的有多少个VM，它们的IP都是一样的。</p>\n<p> 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为<code>10.0.2.0/24</code>，<code>10.0.3.0/24</code>等。不过同一个VM设置多个NAT网卡并没有什么必要。</p>\n<p> VM可以直接访问Host，默认IP也是<code>10.0.2.2</code>，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。<br> Host要想访问VM，需要设置端口映射，即设置<code>HostIP:HostPort</code>与<code>VM-IP:VM-Port</code>的关联，这样Host就可以通过<code>HostIP:HostPort</code>来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过<code>HostIP:Host-Port</code>来访问VM的指定端口。<br> 可以添加多个映射规则来暴露不同的端口。</p>\n<h1 id=\"NAT网络\"><a href=\"#NAT网络\" class=\"headerlink\" title=\"NAT网络\"></a>NAT网络</h1><p> 在VMware中则直接称为 <strong>NAT</strong> 。vbox刻意把这 <strong>NAT</strong> 和 <strong>NAT网络</strong> 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。<br> vbox需要在 <strong>全局配置-&gt;网络</strong> 中增加一个 <strong>NAT网络</strong> 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是<code>10.0.2.0/24</code>，网关是<code>10.0.2.1</code>，DHCP服务器是<code>10.0.2.3</code>，Host是<code>10.0.2.2</code>，VM的IP是由DHCP自动分配的。<br> 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。</p>\n<blockquote>\n<p>外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 <strong>公网</strong> 上是不可路由的。<br>这里 <strong>外网</strong> 是Host之外的网络，它可能是一个Internet IP（<strong>公网</strong>），也可能是某个公司内部的私有IP地址的网络。<br>如果可以修改 <strong>外网</strong> 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。</p>\n</blockquote>\n<p> 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。<br> vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段<code>10.0.2.0/24</code>，这不会彼此产生冲突，当然也可将其网段改为其它地址，如<code>10.0.3.0/24</code>，或<code>192.168.2.0/24</code>这样的，但<code>192.168.x.x</code>网段的DHCP可能不能正常工作，需设置静态IP。</p>\n<p> VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。</p>\n<p> VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 <strong>NAT</strong>、<strong>仅主机</strong> 和 <strong>桥接</strong> 三种不同的模式之一，但又 <strong>限制只能有一个虚拟网卡工作在NAT模式</strong> （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 <strong>默认网关的IP</strong>，及DHCP、DNS的设置。</p>\n<blockquote>\n<p>注意，vbox在两种NAT模式下都有一个坑：<br>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，<strong>即便这些值与DHCP分配到的值一模一样，也不能访问外网！</strong><br>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。</p>\n<p>在这个<a href=\"http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/\" target=\"_blank\" rel=\"external\">博客</a> 中介绍了同样的问题（博客里的DNS IP <code>10.0.2.3</code>和<code>/etc/resolve.conf</code>设置在ubuntu上不能工作）。<br>对Ubuntu，需在 <code>/etc/network/interfaces</code> 设置网卡</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto eth0</div><div class=\"line\">iface eth0 inet static</div><div class=\"line\">address 10.0.2.15</div><div class=\"line\">netmask 255.255.255.0</div><div class=\"line\">gateway 10.0.2.2</div><div class=\"line\"></div><div class=\"line\">dns-nameservers 10.0.2.1</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！</strong><br>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnsproxy1 on</div><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnshostresolver1 on</div></pre></td></tr></table></figure>\n<blockquote>\n<p>其中<code>VBoxManage</code>是vbox的命令行管理工具，在vbox的安装目录下，默认位置是<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>。</p>\n<p>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，<strong>NAT网络</strong> 方式已经不需要执行上面2条命令了，但<code>/etc/network/interfaces</code>里dns-nameservers的设置还是需要的。<br>另外，经过实验发现gateway设置为<code>10.0.2.1</code> 或 <code>10.0.2.2</code>都可以连网，但DNS必须是<code>10.0.2.1</code>。</p>\n<p>VMware没有这个坑。</p>\n</blockquote>\n<h1 id=\"Host-Only-仅主机\"><a href=\"#Host-Only-仅主机\" class=\"headerlink\" title=\"Host-Only 仅主机\"></a>Host-Only 仅主机</h1><p> 这种连接方式是4种VMM都支持的，它的使用很简单。<br> Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。<br> 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 <strong>虚拟 数据中心</strong> 了。一个现实的数据中心里，除了多台服务器，还有 <strong>交换机</strong>，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。<br> 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。<br> Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：<strong>内部交换机</strong> 是很贴切的。</p>\n<p> 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。</p>\n<p> 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为<code>192.168.137.1</code>，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是<code>192.168.137.0/24</code>。<br> 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考<a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network\" target=\"_blank\" rel=\"external\">Set up a NAT network for Hyper-V</a>文档，在Powershell下以管理员权限执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-VMSwitch -SwitchName &quot;NAT&quot; -SwitchType Internal</div></pre></td></tr></table></figure></p>\n<p>查看interfere index：<code>Get-NetAdapter</code>，即下面命令中虚拟网卡的<code>-InterfaceIndex 38</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38</div><div class=\"line\">New-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24</div></pre></td></tr></table></figure></p>\n<p>这样就创建了一个可以通过Host以NAT方式访问外网的 <strong>内部交换机</strong>，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。</p>\n<h1 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h1><p> 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。<br> 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。<br> 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。</p>\n<p> 另外，虽然名叫 <strong>桥接</strong>，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。<br> KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 <strong>已有的</strong> Linux的bridge-utils，TUN/TAP，iptables等功能。</p>\n<p><a name=\"docker-bridge\"></a></p>\n<h1 id=\"Docker的桥接模式\"><a href=\"#Docker的桥接模式\" class=\"headerlink\" title=\"Docker的桥接模式\"></a>Docker的桥接模式</h1><blockquote>\n<p>注意：docker的网络连接方式也有 <strong>桥接</strong>，但实际上它的工作模式是 <strong>NAT网络</strong>。docker在添加了一个docker0网桥，IP网段在<code>172.17.0.0</code>，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，<strong>不同Host</strong> 的容器是不能直接通信的，这是个很大的局限。<br> 实际上docker也可以实现KVM那样的真正的 <strong>桥接</strong> ，具体可参考文章 <a href=\"http://my.oschina.net/astute/blog/293944\" target=\"_blank\" rel=\"external\">桥接模式构建 docker 网络</a> 和<a href=\"http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/\" target=\"_blank\" rel=\"external\">Four ways to connect a docker container to a local network</a> 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。</p>\n</blockquote>\n<h1 id=\"内部网络-LAN区段\"><a href=\"#内部网络-LAN区段\" class=\"headerlink\" title=\"内部网络/LAN区段\"></a>内部网络/LAN区段</h1><p> 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。<br> 一个内部网络是由网络名来区分的。<br> VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。<br> 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。</p>\n<h1 id=\"选择哪种连接方式？\"><a href=\"#选择哪种连接方式？\" class=\"headerlink\" title=\"选择哪种连接方式？\"></a>选择哪种连接方式？</h1><ul>\n<li><strong>NAT网络</strong>            ：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 <strong>实验环境</strong> 。</li>\n<li><strong>Host-Only仅主机</strong>    ：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。</li>\n<li><p><strong>桥接</strong>                ：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。</p>\n<p>在 <strong>数据中心</strong> 里，网络环境不经常变化，<strong>桥接</strong> 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。<br>此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。</p>\n</li>\n</ul>\n<h1 id=\"Bonus\"><a href=\"#Bonus\" class=\"headerlink\" title=\"Bonus\"></a>Bonus</h1><p><strong><a href=\"/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf\">The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013</a></strong></p>\n<p><img src=\"http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret\" alt=\"AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq\"></p>\n<p><img src=\"/img/google_dc1.jpg\" alt=\"Google的数据中心\"></p>\n<p><img src=\"/img/google_dc2.jpg\" alt=\"Google的数据中心\"></p>\n","site":{"data":{}},"excerpt":"<p>网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">路由器，NAT，交换机</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89\">单机的网络地址转换（NAT）</a></li>\n<li><a href=\"#nat%E7%BD%91%E7%BB%9C\">NAT网络</a></li>\n<li><a href=\"#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA\">Host-Only 仅主机</a></li>\n<li><a href=\"#%E6%A1%A5%E6%8E%A5\">桥接</a></li>\n<li><a href=\"#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\">Docker的桥接模式</a></li>\n<li><a href=\"#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5\">内部网络/LAN区段</a></li>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F\">选择哪种连接方式？</a></li>\n<li><a href=\"#bonus\">Bonus</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"路由器，NAT，交换机\"><a href=\"#路由器，NAT，交换机\" class=\"headerlink\" title=\"路由器，NAT，交换机\"></a>路由器，NAT，交换机</h1><p>先简单介绍一下<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"external\">NAT</a>。<br>家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。</p>\n<p>接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a>，显示的IP跟当前计算机的IP是不同的。</p>\n<p>网络基础课上讲到IP v4有三类私有IP地址：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255      （A类）；</li>\n<li>172.16.0.0 ~ 172.31.255.255    （B类）；</li>\n<li>192.168.0.0 ~ 192.168.255.255  （C类）；</li>\n</ul>\n<p><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<p>接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。</p>\n<p>在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a> 或者在ubuntu上执行 <code>curl ip.cn</code> 可以查到这个公网IP，也可以执行<code>ip a</code> 、<code>ifconfig</code> 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 <strong>发起</strong> 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。<br>曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。</p>\n<blockquote>\n<p>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。</p>\n</blockquote>\n<p>另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。</p>\n<p>那么问题来了：<br>1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？<br>2、外网怎么区分路由器LAN的不同设备呢？</p>\n<p>实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。</p>\n<p>如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。</p>\n<p>把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。<br>网络基础课上会介绍交换机是二层设备，路由器是三层设备。<strong>所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。</strong> 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。<br>另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。</p>\n<center>~</center>\n\n<p>下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。</p>\n<p><img src=\"/img/vnet.png\" alt=\"几种虚拟机的网络连接方式\"></p>\n<blockquote>\n<p>注：<strong>NAT网络</strong>，Host-&gt;VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。</p>\n</blockquote>\n<h1 id=\"单机的网络地址转换（NAT）\"><a href=\"#单机的网络地址转换（NAT）\" class=\"headerlink\" title=\"单机的网络地址转换（NAT）\"></a>单机的网络地址转换（NAT）</h1><p> 只有vbox支持 <strong>单机NAT</strong> 方式。这种方式与下面的 <strong>NAT网络</strong> 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。<br> 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是<code>10.0.2.2</code>，一个DHCP服务器，也是<code>10.0.2.2</code>，VM的IP一般是<code>10.0.2.15</code>。<br> 不管使用NAT的有多少个VM，它们的IP都是一样的。</p>\n<p> 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为<code>10.0.2.0/24</code>，<code>10.0.3.0/24</code>等。不过同一个VM设置多个NAT网卡并没有什么必要。</p>\n<p> VM可以直接访问Host，默认IP也是<code>10.0.2.2</code>，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。<br> Host要想访问VM，需要设置端口映射，即设置<code>HostIP:HostPort</code>与<code>VM-IP:VM-Port</code>的关联，这样Host就可以通过<code>HostIP:HostPort</code>来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过<code>HostIP:Host-Port</code>来访问VM的指定端口。<br> 可以添加多个映射规则来暴露不同的端口。</p>\n<h1 id=\"NAT网络\"><a href=\"#NAT网络\" class=\"headerlink\" title=\"NAT网络\"></a>NAT网络</h1><p> 在VMware中则直接称为 <strong>NAT</strong> 。vbox刻意把这 <strong>NAT</strong> 和 <strong>NAT网络</strong> 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。<br> vbox需要在 <strong>全局配置-&gt;网络</strong> 中增加一个 <strong>NAT网络</strong> 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是<code>10.0.2.0/24</code>，网关是<code>10.0.2.1</code>，DHCP服务器是<code>10.0.2.3</code>，Host是<code>10.0.2.2</code>，VM的IP是由DHCP自动分配的。<br> 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。</p>\n<blockquote>\n<p>外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 <strong>公网</strong> 上是不可路由的。<br>这里 <strong>外网</strong> 是Host之外的网络，它可能是一个Internet IP（<strong>公网</strong>），也可能是某个公司内部的私有IP地址的网络。<br>如果可以修改 <strong>外网</strong> 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。</p>\n</blockquote>\n<p> 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。<br> vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段<code>10.0.2.0/24</code>，这不会彼此产生冲突，当然也可将其网段改为其它地址，如<code>10.0.3.0/24</code>，或<code>192.168.2.0/24</code>这样的，但<code>192.168.x.x</code>网段的DHCP可能不能正常工作，需设置静态IP。</p>\n<p> VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。</p>\n<p> VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 <strong>NAT</strong>、<strong>仅主机</strong> 和 <strong>桥接</strong> 三种不同的模式之一，但又 <strong>限制只能有一个虚拟网卡工作在NAT模式</strong> （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 <strong>默认网关的IP</strong>，及DHCP、DNS的设置。</p>\n<blockquote>\n<p>注意，vbox在两种NAT模式下都有一个坑：<br>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，<strong>即便这些值与DHCP分配到的值一模一样，也不能访问外网！</strong><br>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。</p>\n<p>在这个<a href=\"http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/\" target=\"_blank\" rel=\"external\">博客</a> 中介绍了同样的问题（博客里的DNS IP <code>10.0.2.3</code>和<code>/etc/resolve.conf</code>设置在ubuntu上不能工作）。<br>对Ubuntu，需在 <code>/etc/network/interfaces</code> 设置网卡</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto eth0</div><div class=\"line\">iface eth0 inet static</div><div class=\"line\">address 10.0.2.15</div><div class=\"line\">netmask 255.255.255.0</div><div class=\"line\">gateway 10.0.2.2</div><div class=\"line\"></div><div class=\"line\">dns-nameservers 10.0.2.1</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！</strong><br>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnsproxy1 on</div><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnshostresolver1 on</div></pre></td></tr></table></figure>\n<blockquote>\n<p>其中<code>VBoxManage</code>是vbox的命令行管理工具，在vbox的安装目录下，默认位置是<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>。</p>\n<p>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，<strong>NAT网络</strong> 方式已经不需要执行上面2条命令了，但<code>/etc/network/interfaces</code>里dns-nameservers的设置还是需要的。<br>另外，经过实验发现gateway设置为<code>10.0.2.1</code> 或 <code>10.0.2.2</code>都可以连网，但DNS必须是<code>10.0.2.1</code>。</p>\n<p>VMware没有这个坑。</p>\n</blockquote>\n<h1 id=\"Host-Only-仅主机\"><a href=\"#Host-Only-仅主机\" class=\"headerlink\" title=\"Host-Only 仅主机\"></a>Host-Only 仅主机</h1><p> 这种连接方式是4种VMM都支持的，它的使用很简单。<br> Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。<br> 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 <strong>虚拟 数据中心</strong> 了。一个现实的数据中心里，除了多台服务器，还有 <strong>交换机</strong>，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。<br> 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。<br> Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：<strong>内部交换机</strong> 是很贴切的。</p>\n<p> 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。</p>\n<p> 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为<code>192.168.137.1</code>，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是<code>192.168.137.0/24</code>。<br> 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考<a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network\" target=\"_blank\" rel=\"external\">Set up a NAT network for Hyper-V</a>文档，在Powershell下以管理员权限执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-VMSwitch -SwitchName &quot;NAT&quot; -SwitchType Internal</div></pre></td></tr></table></figure></p>\n<p>查看interfere index：<code>Get-NetAdapter</code>，即下面命令中虚拟网卡的<code>-InterfaceIndex 38</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38</div><div class=\"line\">New-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24</div></pre></td></tr></table></figure></p>\n<p>这样就创建了一个可以通过Host以NAT方式访问外网的 <strong>内部交换机</strong>，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。</p>\n<h1 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h1><p> 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。<br> 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。<br> 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。</p>\n<p> 另外，虽然名叫 <strong>桥接</strong>，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。<br> KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 <strong>已有的</strong> Linux的bridge-utils，TUN/TAP，iptables等功能。</p>\n<p><a name=\"docker-bridge\"></a></p>\n<h1 id=\"Docker的桥接模式\"><a href=\"#Docker的桥接模式\" class=\"headerlink\" title=\"Docker的桥接模式\"></a>Docker的桥接模式</h1><blockquote>\n<p>注意：docker的网络连接方式也有 <strong>桥接</strong>，但实际上它的工作模式是 <strong>NAT网络</strong>。docker在添加了一个docker0网桥，IP网段在<code>172.17.0.0</code>，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，<strong>不同Host</strong> 的容器是不能直接通信的，这是个很大的局限。<br> 实际上docker也可以实现KVM那样的真正的 <strong>桥接</strong> ，具体可参考文章 <a href=\"http://my.oschina.net/astute/blog/293944\" target=\"_blank\" rel=\"external\">桥接模式构建 docker 网络</a> 和<a href=\"http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/\" target=\"_blank\" rel=\"external\">Four ways to connect a docker container to a local network</a> 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。</p>\n</blockquote>\n<h1 id=\"内部网络-LAN区段\"><a href=\"#内部网络-LAN区段\" class=\"headerlink\" title=\"内部网络/LAN区段\"></a>内部网络/LAN区段</h1><p> 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。<br> 一个内部网络是由网络名来区分的。<br> VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。<br> 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。</p>\n<h1 id=\"选择哪种连接方式？\"><a href=\"#选择哪种连接方式？\" class=\"headerlink\" title=\"选择哪种连接方式？\"></a>选择哪种连接方式？</h1><ul>\n<li><strong>NAT网络</strong>            ：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 <strong>实验环境</strong> 。</li>\n<li><strong>Host-Only仅主机</strong>    ：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。</li>\n<li><p><strong>桥接</strong>                ：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。</p>\n<p>在 <strong>数据中心</strong> 里，网络环境不经常变化，<strong>桥接</strong> 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。<br>此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。</p>\n</li>\n</ul>\n<h1 id=\"Bonus\"><a href=\"#Bonus\" class=\"headerlink\" title=\"Bonus\"></a>Bonus</h1><p><strong><a href=\"/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf\">The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013</a></strong></p>\n<p><img src=\"http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret\" alt=\"AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq\"></p>\n<p><img src=\"/img/google_dc1.jpg\" alt=\"Google的数据中心\"></p>\n<p><img src=\"/img/google_dc2.jpg\" alt=\"Google的数据中心\"></p>"},{"title":"虚拟机及docker的存储，快照和镜像","date":"2016-09-20T16:00:00.000Z","_content":"VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 **封装** 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 **差分硬盘** 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n- [虚拟硬盘](#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98)\n- [部署和迁移](#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB)\n- [差分硬盘](#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98)\n- [**快照和克隆**](#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86)\n- [镜像管理](#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86)\n- [docker的镜像，容器](#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8)\n- [**Windows的diskpart工具**](#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7)\n- [**Windows从VHD启动实现极速快照和恢复**](#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D)\n\n<!-- /TOC -->\n\n# 虚拟硬盘\n\n硬盘被称为 **块设备**，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。\n\n虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。\n虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。\n\n下面是几种VMM的虚拟硬盘格式。\n\n| VMM        | 虚拟硬盘格式                          | 备注                            |\n|-           |-                                      |-                                |\n| VirtualBox | **vdi** , virtual disk image          | 还支持vmdk，vhd，qcow等多种格式 |\n| VMware     | **vmdk** , vm disk                    | vmdk有单文件和多文件2种方式     |\n| Hyper-V    | **vhd** / **vhdx**, virutal hard disk |                                 |\n| KVM        | **qcow**, qemu copy on write          | 还支持vmdk，raw格式             |\n\n各种虚拟硬盘格式大同小异，其中[vhd格式](https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;)不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的`diskpart`工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。\n\nVMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。\n重置一个虚拟硬盘GUID可以执行下面的命令\n\n{% codeblock line_number:false%}\nVBoxManage internalcommands sethduuid \"/path/file.vhd\"\n{% endcodeblock %}\n\n> vbox支持多种虚拟硬盘格式，使用`VBoxManage.exe`这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。\n> VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM->VM）。\n> VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。\n\n虚拟硬盘有固定和动态大小两种：\n + 前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；\n + 而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。\n\n\n# 部署和迁移\n\n在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法\n+ 使用OS本身支持的`应答文件`\n+ 比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。\n这两种方法效率上相差不多。\n\nVM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。\n\n基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 **在线** 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。\n\nVM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。\n\n# 差分硬盘\n\n虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。\n\n差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。\n\n子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 **纵向** 延续下去。比如vhd可以支持创建127代，而且 **每代差分硬盘的性能基本一致，不受代数层次的影响**。另外，一个父盘还可以有多个子盘，也就是 **横向** 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。![](/img/vmware-snapshot.png)\n\n差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的[性能测试的文档](http://go.microsoft.com/fwlink/p/?LinkId=186519)，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。\n\n创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。\n理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。\n\n# **快照和克隆**\n\n上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中\n>“删除”：会将选中快照对应的虚拟硬盘数据 **合并** 到它的差分子盘上，然后删除该差分盘。**不会改变** VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。\n>“转到”：将当前位置恢复到选中的快照。\n\nvbox的也有类似的快照功能，不过用起来不太直观。\n\n![vbox快照](/img/vbox-snapshot.png)\n\n>注：快照工具栏中的按钮分别是\n> `快照`：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。\n> `恢复`：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作\n> `删除`：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 **“合并快照”** 比 **删除快照** 更合适些。\n> `明细`：查看创建快照时写的备注和VM的参数变化。\n> `克隆`：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。\n\n# 镜像管理\n\n“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。\n所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。\n\n随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。\n\nOpenstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。\n\n# docker的镜像，容器\ndocker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及`build`，`pull`，`push`命令内置了镜像管理功能。\n\ndocker为实现镜像管理采用了类似于差分硬盘的[aufs文件系统](http://coolshell.cn/articles/17061.html)。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。\ndocker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。\n通过`docker commit`命令，可以将容器固化成镜像。\n<a name=\"docker-image\"></a>\ndocker的镜像管理还有一些不足：\n+ 虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。[FAST16 - Slacker: Fast Distribution with Lazy Docker Containers](https://www.usenix.org/node/194431) 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。\n+ 从dockerfile构造镜像时，每行`RUN`命令对应一层镜像，需要注意避免分层太多，而一个`RUN`命令太复杂又会限制了重用镜像的可能，如果能够 **显示地指定分层点** 可能会好些，这也算是镜像分层结构精细化的一部分。\n+ 从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如`apt`安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。\n\n`docker run`命令基于镜像创建并运行一个容器。新手容易通过`docker run`创建很多临时的容器，占用过多物理硬盘空间，这需要在执行`docker run`命令时加上`--rm`参数，容器退出后就会被docker删除掉。\n\ndocker官方建议开发人员应尽量避免通过`docker exec`或`ssh`进入容器执行操作，而应通过dockerfile将所有操作`build`到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。\n有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。\n\n<a name=\"win-vhd-boot\"></a>\n# **Windows的diskpart工具**\n\n因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的`diskpart`来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令\n\n{% codeblock line_number:false%}\nC:\\>diskpart\n\nDISKPART> create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd\n{% endcodeblock %}\n\n# **Windows从VHD启动实现极速快照和恢复**\n\nWindows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。\n+ 一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。\n+ 另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。\n+ 还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。\n\nvhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为`Current.vhd`和`Recovery.vhd`，分别添加这两个差分vhd的启动项为 **Current** 和 **Recovery**，这样就相当于已经安装了两个windows系统。正常使用 **Current** 系统，需要恢复时重启到 **Recovery** 系统，删除原来的`Current.vhd`，然后再基于父vhd创建一个新的差分vhd并命名为`Current.vhd`，再重启到 **Current** 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。\n\n系统盘的文件布局如下：\n{% codeblock line_number:false%}\nC:.\n│  Win8-Current.vhd    #正常工作系统\n│  Win8-Recovery.vhd   #恢复用系统\n│  Win8.vhd            #父vhd\n│  bootmgr             #启动管理器  \n└─boot                #系统启动相关文件\n        bcd\n        memtest.exe\n        ...\n\n{% endcodeblock %}\n\n`bootice`是一个操作vhd和系统启动项的小工具。此外还有`EasyBCD`和一些PE工具。当然，可以直接使用Windows内置的命令行工具`bcdboot`和`bcdedit`。\n\nLinux **还没有** 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。\n最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。\n\n前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -> VM；而 vhd native boot则相当于从 VM -> PM。\n\n---\n这个介绍数据中心的[视频](http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html) 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。\n","source":"_posts/vm-disk.md","raw":"title: 虚拟机及docker的存储，快照和镜像\ncategory: [cloud]\ntags:\ndate: 2016-09-21\n---\nVM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 **封装** 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 **差分硬盘** 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n- [虚拟硬盘](#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98)\n- [部署和迁移](#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB)\n- [差分硬盘](#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98)\n- [**快照和克隆**](#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86)\n- [镜像管理](#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86)\n- [docker的镜像，容器](#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8)\n- [**Windows的diskpart工具**](#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7)\n- [**Windows从VHD启动实现极速快照和恢复**](#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D)\n\n<!-- /TOC -->\n\n# 虚拟硬盘\n\n硬盘被称为 **块设备**，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。\n\n虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。\n虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。\n\n下面是几种VMM的虚拟硬盘格式。\n\n| VMM        | 虚拟硬盘格式                          | 备注                            |\n|-           |-                                      |-                                |\n| VirtualBox | **vdi** , virtual disk image          | 还支持vmdk，vhd，qcow等多种格式 |\n| VMware     | **vmdk** , vm disk                    | vmdk有单文件和多文件2种方式     |\n| Hyper-V    | **vhd** / **vhdx**, virutal hard disk |                                 |\n| KVM        | **qcow**, qemu copy on write          | 还支持vmdk，raw格式             |\n\n各种虚拟硬盘格式大同小异，其中[vhd格式](https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;)不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的`diskpart`工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。\n\nVMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。\n重置一个虚拟硬盘GUID可以执行下面的命令\n\n{% codeblock line_number:false%}\nVBoxManage internalcommands sethduuid \"/path/file.vhd\"\n{% endcodeblock %}\n\n> vbox支持多种虚拟硬盘格式，使用`VBoxManage.exe`这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。\n> VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM->VM）。\n> VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。\n\n虚拟硬盘有固定和动态大小两种：\n + 前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；\n + 而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。\n\n\n# 部署和迁移\n\n在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法\n+ 使用OS本身支持的`应答文件`\n+ 比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。\n这两种方法效率上相差不多。\n\nVM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。\n\n基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 **在线** 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。\n\nVM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。\n\n# 差分硬盘\n\n虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。\n\n差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。\n\n子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 **纵向** 延续下去。比如vhd可以支持创建127代，而且 **每代差分硬盘的性能基本一致，不受代数层次的影响**。另外，一个父盘还可以有多个子盘，也就是 **横向** 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。![](/img/vmware-snapshot.png)\n\n差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的[性能测试的文档](http://go.microsoft.com/fwlink/p/?LinkId=186519)，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。\n\n创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。\n理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。\n\n# **快照和克隆**\n\n上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中\n>“删除”：会将选中快照对应的虚拟硬盘数据 **合并** 到它的差分子盘上，然后删除该差分盘。**不会改变** VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。\n>“转到”：将当前位置恢复到选中的快照。\n\nvbox的也有类似的快照功能，不过用起来不太直观。\n\n![vbox快照](/img/vbox-snapshot.png)\n\n>注：快照工具栏中的按钮分别是\n> `快照`：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。\n> `恢复`：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作\n> `删除`：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 **“合并快照”** 比 **删除快照** 更合适些。\n> `明细`：查看创建快照时写的备注和VM的参数变化。\n> `克隆`：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。\n\n# 镜像管理\n\n“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。\n所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。\n\n随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。\n\nOpenstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。\n\n# docker的镜像，容器\ndocker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及`build`，`pull`，`push`命令内置了镜像管理功能。\n\ndocker为实现镜像管理采用了类似于差分硬盘的[aufs文件系统](http://coolshell.cn/articles/17061.html)。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。\ndocker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。\n通过`docker commit`命令，可以将容器固化成镜像。\n<a name=\"docker-image\"></a>\ndocker的镜像管理还有一些不足：\n+ 虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。[FAST16 - Slacker: Fast Distribution with Lazy Docker Containers](https://www.usenix.org/node/194431) 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。\n+ 从dockerfile构造镜像时，每行`RUN`命令对应一层镜像，需要注意避免分层太多，而一个`RUN`命令太复杂又会限制了重用镜像的可能，如果能够 **显示地指定分层点** 可能会好些，这也算是镜像分层结构精细化的一部分。\n+ 从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如`apt`安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。\n\n`docker run`命令基于镜像创建并运行一个容器。新手容易通过`docker run`创建很多临时的容器，占用过多物理硬盘空间，这需要在执行`docker run`命令时加上`--rm`参数，容器退出后就会被docker删除掉。\n\ndocker官方建议开发人员应尽量避免通过`docker exec`或`ssh`进入容器执行操作，而应通过dockerfile将所有操作`build`到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。\n有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。\n\n<a name=\"win-vhd-boot\"></a>\n# **Windows的diskpart工具**\n\n因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的`diskpart`来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令\n\n{% codeblock line_number:false%}\nC:\\>diskpart\n\nDISKPART> create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd\n{% endcodeblock %}\n\n# **Windows从VHD启动实现极速快照和恢复**\n\nWindows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。\n+ 一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。\n+ 另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。\n+ 还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。\n\nvhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为`Current.vhd`和`Recovery.vhd`，分别添加这两个差分vhd的启动项为 **Current** 和 **Recovery**，这样就相当于已经安装了两个windows系统。正常使用 **Current** 系统，需要恢复时重启到 **Recovery** 系统，删除原来的`Current.vhd`，然后再基于父vhd创建一个新的差分vhd并命名为`Current.vhd`，再重启到 **Current** 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。\n\n系统盘的文件布局如下：\n{% codeblock line_number:false%}\nC:.\n│  Win8-Current.vhd    #正常工作系统\n│  Win8-Recovery.vhd   #恢复用系统\n│  Win8.vhd            #父vhd\n│  bootmgr             #启动管理器  \n└─boot                #系统启动相关文件\n        bcd\n        memtest.exe\n        ...\n\n{% endcodeblock %}\n\n`bootice`是一个操作vhd和系统启动项的小工具。此外还有`EasyBCD`和一些PE工具。当然，可以直接使用Windows内置的命令行工具`bcdboot`和`bcdedit`。\n\nLinux **还没有** 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。\n最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。\n\n前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -> VM；而 vhd native boot则相当于从 VM -> PM。\n\n---\n这个介绍数据中心的[视频](http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html) 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。\n","slug":"vm-disk","published":1,"updated":"2017-10-30T03:41:50.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn82600008nw4fxavhc3ah","content":"<p>VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 <strong>封装</strong> 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 <strong>差分硬盘</strong> 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n</code></pre><ul>\n<li><a href=\"#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98\">虚拟硬盘</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB\">部署和迁移</a></li>\n<li><a href=\"#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98\">差分硬盘</a></li>\n<li><a href=\"#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86\"><strong>快照和克隆</strong></a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86\">镜像管理</a></li>\n<li><a href=\"#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8\">docker的镜像，容器</a></li>\n<li><a href=\"#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7\"><strong>Windows的diskpart工具</strong></a></li>\n<li><a href=\"#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D\"><strong>Windows从VHD启动实现极速快照和恢复</strong></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"虚拟硬盘\"><a href=\"#虚拟硬盘\" class=\"headerlink\" title=\"虚拟硬盘\"></a>虚拟硬盘</h1><p>硬盘被称为 <strong>块设备</strong>，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。</p>\n<p>虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。<br>虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。</p>\n<p>下面是几种VMM的虚拟硬盘格式。</p>\n<table>\n<thead>\n<tr>\n<th>VMM</th>\n<th>虚拟硬盘格式</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VirtualBox</td>\n<td><strong>vdi</strong> , virtual disk image</td>\n<td>还支持vmdk，vhd，qcow等多种格式</td>\n</tr>\n<tr>\n<td>VMware</td>\n<td><strong>vmdk</strong> , vm disk</td>\n<td>vmdk有单文件和多文件2种方式</td>\n</tr>\n<tr>\n<td>Hyper-V</td>\n<td><strong>vhd</strong> / <strong>vhdx</strong>, virutal hard disk</td>\n<td></td>\n</tr>\n<tr>\n<td>KVM</td>\n<td><strong>qcow</strong>, qemu copy on write</td>\n<td>还支持vmdk，raw格式</td>\n</tr>\n</tbody>\n</table>\n<p>各种虚拟硬盘格式大同小异，其中<a href=\"https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;\" target=\"_blank\" rel=\"external\">vhd格式</a>不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的<code>diskpart</code>工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。</p>\n<p>VMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。<br>重置一个虚拟硬盘GUID可以执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">VBoxManage internalcommands sethduuid &quot;/path/file.vhd&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>vbox支持多种虚拟硬盘格式，使用<code>VBoxManage.exe</code>这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。<br>VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM-&gt;VM）。<br>VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。</p>\n</blockquote>\n<p>虚拟硬盘有固定和动态大小两种：</p>\n<ul>\n<li>前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；</li>\n<li>而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。</li>\n</ul>\n<h1 id=\"部署和迁移\"><a href=\"#部署和迁移\" class=\"headerlink\" title=\"部署和迁移\"></a>部署和迁移</h1><p>在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法</p>\n<ul>\n<li>使用OS本身支持的<code>应答文件</code></li>\n<li>比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。<br>这两种方法效率上相差不多。</li>\n</ul>\n<p>VM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。</p>\n<p>基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 <strong>在线</strong> 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。</p>\n<p>VM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。</p>\n<h1 id=\"差分硬盘\"><a href=\"#差分硬盘\" class=\"headerlink\" title=\"差分硬盘\"></a>差分硬盘</h1><p>虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。</p>\n<p>差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。</p>\n<p>子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 <strong>纵向</strong> 延续下去。比如vhd可以支持创建127代，而且 <strong>每代差分硬盘的性能基本一致，不受代数层次的影响</strong>。另外，一个父盘还可以有多个子盘，也就是 <strong>横向</strong> 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。<img src=\"/img/vmware-snapshot.png\" alt=\"\"></p>\n<p>差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的<a href=\"http://go.microsoft.com/fwlink/p/?LinkId=186519\" target=\"_blank\" rel=\"external\">性能测试的文档</a>，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。</p>\n<p>创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。<br>理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。</p>\n<h1 id=\"快照和克隆\"><a href=\"#快照和克隆\" class=\"headerlink\" title=\"快照和克隆\"></a><strong>快照和克隆</strong></h1><p>上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中</p>\n<blockquote>\n<p>“删除”：会将选中快照对应的虚拟硬盘数据 <strong>合并</strong> 到它的差分子盘上，然后删除该差分盘。<strong>不会改变</strong> VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。<br>“转到”：将当前位置恢复到选中的快照。</p>\n</blockquote>\n<p>vbox的也有类似的快照功能，不过用起来不太直观。</p>\n<p><img src=\"/img/vbox-snapshot.png\" alt=\"vbox快照\"></p>\n<blockquote>\n<p>注：快照工具栏中的按钮分别是<br><code>快照</code>：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。<br><code>恢复</code>：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作<br><code>删除</code>：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 <strong>“合并快照”</strong> 比 <strong>删除快照</strong> 更合适些。<br><code>明细</code>：查看创建快照时写的备注和VM的参数变化。<br><code>克隆</code>：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。</p>\n</blockquote>\n<h1 id=\"镜像管理\"><a href=\"#镜像管理\" class=\"headerlink\" title=\"镜像管理\"></a>镜像管理</h1><p>“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。<br>所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。</p>\n<p>随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。</p>\n<p>Openstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。</p>\n<h1 id=\"docker的镜像，容器\"><a href=\"#docker的镜像，容器\" class=\"headerlink\" title=\"docker的镜像，容器\"></a>docker的镜像，容器</h1><p>docker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及<code>build</code>，<code>pull</code>，<code>push</code>命令内置了镜像管理功能。</p>\n<p>docker为实现镜像管理采用了类似于差分硬盘的<a href=\"http://coolshell.cn/articles/17061.html\" target=\"_blank\" rel=\"external\">aufs文件系统</a>。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。<br>docker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。<br>通过<code>docker commit</code>命令，可以将容器固化成镜像。<br><a name=\"docker-image\"></a><br>docker的镜像管理还有一些不足：</p>\n<ul>\n<li>虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。<a href=\"https://www.usenix.org/node/194431\" target=\"_blank\" rel=\"external\">FAST16 - Slacker: Fast Distribution with Lazy Docker Containers</a> 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。</li>\n<li>从dockerfile构造镜像时，每行<code>RUN</code>命令对应一层镜像，需要注意避免分层太多，而一个<code>RUN</code>命令太复杂又会限制了重用镜像的可能，如果能够 <strong>显示地指定分层点</strong> 可能会好些，这也算是镜像分层结构精细化的一部分。</li>\n<li>从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如<code>apt</code>安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。</li>\n</ul>\n<p><code>docker run</code>命令基于镜像创建并运行一个容器。新手容易通过<code>docker run</code>创建很多临时的容器，占用过多物理硬盘空间，这需要在执行<code>docker run</code>命令时加上<code>--rm</code>参数，容器退出后就会被docker删除掉。</p>\n<p>docker官方建议开发人员应尽量避免通过<code>docker exec</code>或<code>ssh</code>进入容器执行操作，而应通过dockerfile将所有操作<code>build</code>到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。<br>有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。</p>\n<p><a name=\"win-vhd-boot\"></a></p>\n<h1 id=\"Windows的diskpart工具\"><a href=\"#Windows的diskpart工具\" class=\"headerlink\" title=\"Windows的diskpart工具\"></a><strong>Windows的diskpart工具</strong></h1><p>因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的<code>diskpart</code>来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:\\&gt;diskpart</div><div class=\"line\"></div><div class=\"line\">DISKPART&gt; create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd</div></pre></td></tr></table></figure>\n<h1 id=\"Windows从VHD启动实现极速快照和恢复\"><a href=\"#Windows从VHD启动实现极速快照和恢复\" class=\"headerlink\" title=\"Windows从VHD启动实现极速快照和恢复\"></a><strong>Windows从VHD启动实现极速快照和恢复</strong></h1><p>Windows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。</p>\n<ul>\n<li>一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。</li>\n<li>另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。</li>\n<li>还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。</li>\n</ul>\n<p>vhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为<code>Current.vhd</code>和<code>Recovery.vhd</code>，分别添加这两个差分vhd的启动项为 <strong>Current</strong> 和 <strong>Recovery</strong>，这样就相当于已经安装了两个windows系统。正常使用 <strong>Current</strong> 系统，需要恢复时重启到 <strong>Recovery</strong> 系统，删除原来的<code>Current.vhd</code>，然后再基于父vhd创建一个新的差分vhd并命名为<code>Current.vhd</code>，再重启到 <strong>Current</strong> 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。</p>\n<p>系统盘的文件布局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:.</div><div class=\"line\">│  Win8-Current.vhd    #正常工作系统</div><div class=\"line\">│  Win8-Recovery.vhd   #恢复用系统</div><div class=\"line\">│  Win8.vhd            #父vhd</div><div class=\"line\">│  bootmgr             #启动管理器  </div><div class=\"line\">└─boot                #系统启动相关文件</div><div class=\"line\">        bcd</div><div class=\"line\">        memtest.exe</div><div class=\"line\">        ...</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p><code>bootice</code>是一个操作vhd和系统启动项的小工具。此外还有<code>EasyBCD</code>和一些PE工具。当然，可以直接使用Windows内置的命令行工具<code>bcdboot</code>和<code>bcdedit</code>。</p>\n<p>Linux <strong>还没有</strong> 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。<br>最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。</p>\n<p>前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -&gt; VM；而 vhd native boot则相当于从 VM -&gt; PM。</p>\n<hr>\n<p>这个介绍数据中心的<a href=\"http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html\" target=\"_blank\" rel=\"external\">视频</a> 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。</p>\n","site":{"data":{}},"excerpt":"<p>VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 <strong>封装</strong> 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 <strong>差分硬盘</strong> 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n</code></pre><ul>\n<li><a href=\"#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98\">虚拟硬盘</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB\">部署和迁移</a></li>\n<li><a href=\"#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98\">差分硬盘</a></li>\n<li><a href=\"#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86\"><strong>快照和克隆</strong></a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86\">镜像管理</a></li>\n<li><a href=\"#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8\">docker的镜像，容器</a></li>\n<li><a href=\"#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7\"><strong>Windows的diskpart工具</strong></a></li>\n<li><a href=\"#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D\"><strong>Windows从VHD启动实现极速快照和恢复</strong></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"虚拟硬盘\"><a href=\"#虚拟硬盘\" class=\"headerlink\" title=\"虚拟硬盘\"></a>虚拟硬盘</h1><p>硬盘被称为 <strong>块设备</strong>，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。</p>\n<p>虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。<br>虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。</p>\n<p>下面是几种VMM的虚拟硬盘格式。</p>\n<table>\n<thead>\n<tr>\n<th>VMM</th>\n<th>虚拟硬盘格式</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VirtualBox</td>\n<td><strong>vdi</strong> , virtual disk image</td>\n<td>还支持vmdk，vhd，qcow等多种格式</td>\n</tr>\n<tr>\n<td>VMware</td>\n<td><strong>vmdk</strong> , vm disk</td>\n<td>vmdk有单文件和多文件2种方式</td>\n</tr>\n<tr>\n<td>Hyper-V</td>\n<td><strong>vhd</strong> / <strong>vhdx</strong>, virutal hard disk</td>\n<td></td>\n</tr>\n<tr>\n<td>KVM</td>\n<td><strong>qcow</strong>, qemu copy on write</td>\n<td>还支持vmdk，raw格式</td>\n</tr>\n</tbody>\n</table>\n<p>各种虚拟硬盘格式大同小异，其中<a href=\"https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;\" target=\"_blank\" rel=\"external\">vhd格式</a>不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的<code>diskpart</code>工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。</p>\n<p>VMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。<br>重置一个虚拟硬盘GUID可以执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">VBoxManage internalcommands sethduuid &quot;/path/file.vhd&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>vbox支持多种虚拟硬盘格式，使用<code>VBoxManage.exe</code>这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。<br>VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM-&gt;VM）。<br>VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。</p>\n</blockquote>\n<p>虚拟硬盘有固定和动态大小两种：</p>\n<ul>\n<li>前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；</li>\n<li>而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。</li>\n</ul>\n<h1 id=\"部署和迁移\"><a href=\"#部署和迁移\" class=\"headerlink\" title=\"部署和迁移\"></a>部署和迁移</h1><p>在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法</p>\n<ul>\n<li>使用OS本身支持的<code>应答文件</code></li>\n<li>比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。<br>这两种方法效率上相差不多。</li>\n</ul>\n<p>VM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。</p>\n<p>基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 <strong>在线</strong> 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。</p>\n<p>VM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。</p>\n<h1 id=\"差分硬盘\"><a href=\"#差分硬盘\" class=\"headerlink\" title=\"差分硬盘\"></a>差分硬盘</h1><p>虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。</p>\n<p>差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。</p>\n<p>子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 <strong>纵向</strong> 延续下去。比如vhd可以支持创建127代，而且 <strong>每代差分硬盘的性能基本一致，不受代数层次的影响</strong>。另外，一个父盘还可以有多个子盘，也就是 <strong>横向</strong> 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。<img src=\"/img/vmware-snapshot.png\" alt=\"\"></p>\n<p>差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的<a href=\"http://go.microsoft.com/fwlink/p/?LinkId=186519\" target=\"_blank\" rel=\"external\">性能测试的文档</a>，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。</p>\n<p>创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。<br>理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。</p>\n<h1 id=\"快照和克隆\"><a href=\"#快照和克隆\" class=\"headerlink\" title=\"快照和克隆\"></a><strong>快照和克隆</strong></h1><p>上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中</p>\n<blockquote>\n<p>“删除”：会将选中快照对应的虚拟硬盘数据 <strong>合并</strong> 到它的差分子盘上，然后删除该差分盘。<strong>不会改变</strong> VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。<br>“转到”：将当前位置恢复到选中的快照。</p>\n</blockquote>\n<p>vbox的也有类似的快照功能，不过用起来不太直观。</p>\n<p><img src=\"/img/vbox-snapshot.png\" alt=\"vbox快照\"></p>\n<blockquote>\n<p>注：快照工具栏中的按钮分别是<br><code>快照</code>：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。<br><code>恢复</code>：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作<br><code>删除</code>：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 <strong>“合并快照”</strong> 比 <strong>删除快照</strong> 更合适些。<br><code>明细</code>：查看创建快照时写的备注和VM的参数变化。<br><code>克隆</code>：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。</p>\n</blockquote>\n<h1 id=\"镜像管理\"><a href=\"#镜像管理\" class=\"headerlink\" title=\"镜像管理\"></a>镜像管理</h1><p>“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。<br>所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。</p>\n<p>随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。</p>\n<p>Openstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。</p>\n<h1 id=\"docker的镜像，容器\"><a href=\"#docker的镜像，容器\" class=\"headerlink\" title=\"docker的镜像，容器\"></a>docker的镜像，容器</h1><p>docker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及<code>build</code>，<code>pull</code>，<code>push</code>命令内置了镜像管理功能。</p>\n<p>docker为实现镜像管理采用了类似于差分硬盘的<a href=\"http://coolshell.cn/articles/17061.html\" target=\"_blank\" rel=\"external\">aufs文件系统</a>。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。<br>docker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。<br>通过<code>docker commit</code>命令，可以将容器固化成镜像。<br><a name=\"docker-image\"></a><br>docker的镜像管理还有一些不足：</p>\n<ul>\n<li>虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。<a href=\"https://www.usenix.org/node/194431\" target=\"_blank\" rel=\"external\">FAST16 - Slacker: Fast Distribution with Lazy Docker Containers</a> 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。</li>\n<li>从dockerfile构造镜像时，每行<code>RUN</code>命令对应一层镜像，需要注意避免分层太多，而一个<code>RUN</code>命令太复杂又会限制了重用镜像的可能，如果能够 <strong>显示地指定分层点</strong> 可能会好些，这也算是镜像分层结构精细化的一部分。</li>\n<li>从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如<code>apt</code>安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。</li>\n</ul>\n<p><code>docker run</code>命令基于镜像创建并运行一个容器。新手容易通过<code>docker run</code>创建很多临时的容器，占用过多物理硬盘空间，这需要在执行<code>docker run</code>命令时加上<code>--rm</code>参数，容器退出后就会被docker删除掉。</p>\n<p>docker官方建议开发人员应尽量避免通过<code>docker exec</code>或<code>ssh</code>进入容器执行操作，而应通过dockerfile将所有操作<code>build</code>到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。<br>有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。</p>\n<p><a name=\"win-vhd-boot\"></a></p>\n<h1 id=\"Windows的diskpart工具\"><a href=\"#Windows的diskpart工具\" class=\"headerlink\" title=\"Windows的diskpart工具\"></a><strong>Windows的diskpart工具</strong></h1><p>因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的<code>diskpart</code>来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:\\&gt;diskpart</div><div class=\"line\"></div><div class=\"line\">DISKPART&gt; create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd</div></pre></td></tr></table></figure>\n<h1 id=\"Windows从VHD启动实现极速快照和恢复\"><a href=\"#Windows从VHD启动实现极速快照和恢复\" class=\"headerlink\" title=\"Windows从VHD启动实现极速快照和恢复\"></a><strong>Windows从VHD启动实现极速快照和恢复</strong></h1><p>Windows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。</p>\n<ul>\n<li>一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。</li>\n<li>另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。</li>\n<li>还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。</li>\n</ul>\n<p>vhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为<code>Current.vhd</code>和<code>Recovery.vhd</code>，分别添加这两个差分vhd的启动项为 <strong>Current</strong> 和 <strong>Recovery</strong>，这样就相当于已经安装了两个windows系统。正常使用 <strong>Current</strong> 系统，需要恢复时重启到 <strong>Recovery</strong> 系统，删除原来的<code>Current.vhd</code>，然后再基于父vhd创建一个新的差分vhd并命名为<code>Current.vhd</code>，再重启到 <strong>Current</strong> 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。</p>\n<p>系统盘的文件布局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:.</div><div class=\"line\">│  Win8-Current.vhd    #正常工作系统</div><div class=\"line\">│  Win8-Recovery.vhd   #恢复用系统</div><div class=\"line\">│  Win8.vhd            #父vhd</div><div class=\"line\">│  bootmgr             #启动管理器  </div><div class=\"line\">└─boot                #系统启动相关文件</div><div class=\"line\">        bcd</div><div class=\"line\">        memtest.exe</div><div class=\"line\">        ...</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p><code>bootice</code>是一个操作vhd和系统启动项的小工具。此外还有<code>EasyBCD</code>和一些PE工具。当然，可以直接使用Windows内置的命令行工具<code>bcdboot</code>和<code>bcdedit</code>。</p>\n<p>Linux <strong>还没有</strong> 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。<br>最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。</p>\n<p>前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -&gt; VM；而 vhd native boot则相当于从 VM -&gt; PM。</p>\n<hr>\n<p>这个介绍数据中心的<a href=\"http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html\" target=\"_blank\" rel=\"external\">视频</a> 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。</p>"},{"title":"双拼输入法","date":"2016-09-18T16:00:00.000Z","_content":"双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。\n除了介绍双拼输入法，还有一点关于语音输入的杂想。\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n- [双拼方案](#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88)\n    - [声母](#%E5%A3%B0%E6%AF%8D)\n    - [韵母](#%E9%9F%B5%E6%AF%8D)\n- [双拼输入法的软件](#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6)\n- [关于语音输入的杂想](#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3)\n\n<!-- /TOC -->\n\n[双拼](https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC)输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。\n双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 **不会太慢**，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。\n\n> 本文主要内容的[一页纸PDF文件，亦称Cheetsheet](/doc/shuang_pin_udpn_cheetsheet.pdf)\n\n# 双拼方案\n将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。\n\n## 声母\n`b p m f d t n l g k h j q x r z c s y w`这些单声母都是直接与各自的字母键对应的，对`zh ch sh`这三个，对应关系是`i：ch`，`u：sh`，`v：zh`；有的拼音不需要声母，比如`爱 ai`，只有韵母`ai`，为了保持编码规律，指定它们为 **零声母**，并对应为按键`o`。\n\n## 韵母\n韵母的对应关系稍微复杂一点，\n+ `a e i o u`这几个元音的对应比较简单；\n+ 对于复杂韵母，\n    - `u o`相关的多在第一行键位，\n    - `a e`相关的多在第二行键位，\n    - `i`  相关的多在第三行键位。\n\n下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按`Win+D`显示桌面即可。一般练习一两天就记住了。\n\n![微软双拼韵母键位](/img/udpn-ms-map.png)\n\n例如，输入“我爱双拼输入法”，对应的击键如下表，\n\n![微软双拼示例](/img/udpn-demo.png)\n\n说明：\n1.\t大部分声母都有直接对应的键位，只有`zh ch sh`需特别记忆一下。有的拼音没有声母，如`爱`，这时就需要零声母，即字母`o`，以表明后面的键是韵母；\n2.\t韵母`a  e  i  o  u`直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母`ing`对应分号键` ; `。\n\n双拼下也可以使用简拼，但需要用 `'` 作为分隔符划分音节。如果你刚才 **整句** 地输入过“我爱双拼输入法”，那么试试`w'i'u'p'u'r'f` ，看看你的输入法软件够不够智能。说实话，简拼用`'`实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。\n\n# 双拼输入法的软件\n好像没有专门支持双拼的输入法软件啊？\n其实Windows及Android上常见的 **拼音输入法软件**，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 **双拼展开提示**，初学时有所帮助。\n\n一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母`ing` 对应的是 **`,`**。\n\n![百度拼音设置](/img/udpn-baidu-ime.png)\n\n---\n# 关于语音输入的杂想\niPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：\n+ 首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。\n+ 语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。\n+ 提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。\n\n> 手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；\n> 但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。\n> 想到这里，可能淘宝客服最适合用语音识别了;-)\n> 要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。\n> 话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。\n> 弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于`Sensor offloading`，而且已经有了这样的App：[WO Mic](http://wirelessorange.com/womic-zh/)，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。\n\n再到[讯飞听见](http://www.iflyrec.com/)的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看[别人的体验](http://cn.technode.com/post/2016-01-13/iflyrec-examination/)了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？\n\n<a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\">![讯飞录音笔](/img/udpn-iflyrec-rec.png)</a>\n\n![讯飞智能会议系统](/img/udpn-iflyrec-meeting.png)\n","source":"_posts/udpnuurufa.md","raw":"title: 双拼输入法\ncategory: [misc]\ntags: \ndate: 2016-09-19\n---\n双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。\n除了介绍双拼输入法，还有一点关于语音输入的杂想。\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n- [双拼方案](#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88)\n    - [声母](#%E5%A3%B0%E6%AF%8D)\n    - [韵母](#%E9%9F%B5%E6%AF%8D)\n- [双拼输入法的软件](#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6)\n- [关于语音输入的杂想](#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3)\n\n<!-- /TOC -->\n\n[双拼](https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC)输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。\n双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 **不会太慢**，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。\n\n> 本文主要内容的[一页纸PDF文件，亦称Cheetsheet](/doc/shuang_pin_udpn_cheetsheet.pdf)\n\n# 双拼方案\n将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。\n\n## 声母\n`b p m f d t n l g k h j q x r z c s y w`这些单声母都是直接与各自的字母键对应的，对`zh ch sh`这三个，对应关系是`i：ch`，`u：sh`，`v：zh`；有的拼音不需要声母，比如`爱 ai`，只有韵母`ai`，为了保持编码规律，指定它们为 **零声母**，并对应为按键`o`。\n\n## 韵母\n韵母的对应关系稍微复杂一点，\n+ `a e i o u`这几个元音的对应比较简单；\n+ 对于复杂韵母，\n    - `u o`相关的多在第一行键位，\n    - `a e`相关的多在第二行键位，\n    - `i`  相关的多在第三行键位。\n\n下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按`Win+D`显示桌面即可。一般练习一两天就记住了。\n\n![微软双拼韵母键位](/img/udpn-ms-map.png)\n\n例如，输入“我爱双拼输入法”，对应的击键如下表，\n\n![微软双拼示例](/img/udpn-demo.png)\n\n说明：\n1.\t大部分声母都有直接对应的键位，只有`zh ch sh`需特别记忆一下。有的拼音没有声母，如`爱`，这时就需要零声母，即字母`o`，以表明后面的键是韵母；\n2.\t韵母`a  e  i  o  u`直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母`ing`对应分号键` ; `。\n\n双拼下也可以使用简拼，但需要用 `'` 作为分隔符划分音节。如果你刚才 **整句** 地输入过“我爱双拼输入法”，那么试试`w'i'u'p'u'r'f` ，看看你的输入法软件够不够智能。说实话，简拼用`'`实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。\n\n# 双拼输入法的软件\n好像没有专门支持双拼的输入法软件啊？\n其实Windows及Android上常见的 **拼音输入法软件**，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 **双拼展开提示**，初学时有所帮助。\n\n一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母`ing` 对应的是 **`,`**。\n\n![百度拼音设置](/img/udpn-baidu-ime.png)\n\n---\n# 关于语音输入的杂想\niPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：\n+ 首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。\n+ 语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。\n+ 提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。\n\n> 手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；\n> 但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。\n> 想到这里，可能淘宝客服最适合用语音识别了;-)\n> 要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。\n> 话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。\n> 弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于`Sensor offloading`，而且已经有了这样的App：[WO Mic](http://wirelessorange.com/womic-zh/)，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。\n\n再到[讯飞听见](http://www.iflyrec.com/)的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看[别人的体验](http://cn.technode.com/post/2016-01-13/iflyrec-examination/)了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？\n\n<a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\">![讯飞录音笔](/img/udpn-iflyrec-rec.png)</a>\n\n![讯飞智能会议系统](/img/udpn-iflyrec-meeting.png)\n","slug":"udpnuurufa","published":1,"updated":"2017-10-30T02:46:13.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8ewb0000n84fz67ajj30","content":"<p>双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。<br>除了介绍双拼输入法，还有一点关于语音输入的杂想。<br><a id=\"more\"></a></p>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n</code></pre><ul>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88\">双拼方案</a><ul>\n<li><a href=\"#%E5%A3%B0%E6%AF%8D\">声母</a></li>\n<li><a href=\"#%E9%9F%B5%E6%AF%8D\">韵母</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6\">双拼输入法的软件</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3\">关于语音输入的杂想</a></li>\n</ul>\n<!-- /TOC -->\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC\" target=\"_blank\" rel=\"external\">双拼</a>输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。<br>双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 <strong>不会太慢</strong>，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。</p>\n<blockquote>\n<p>本文主要内容的<a href=\"/doc/shuang_pin_udpn_cheetsheet.pdf\">一页纸PDF文件，亦称Cheetsheet</a></p>\n</blockquote>\n<h1 id=\"双拼方案\"><a href=\"#双拼方案\" class=\"headerlink\" title=\"双拼方案\"></a>双拼方案</h1><p>将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。</p>\n<h2 id=\"声母\"><a href=\"#声母\" class=\"headerlink\" title=\"声母\"></a>声母</h2><p><code>b p m f d t n l g k h j q x r z c s y w</code>这些单声母都是直接与各自的字母键对应的，对<code>zh ch sh</code>这三个，对应关系是<code>i：ch</code>，<code>u：sh</code>，<code>v：zh</code>；有的拼音不需要声母，比如<code>爱 ai</code>，只有韵母<code>ai</code>，为了保持编码规律，指定它们为 <strong>零声母</strong>，并对应为按键<code>o</code>。</p>\n<h2 id=\"韵母\"><a href=\"#韵母\" class=\"headerlink\" title=\"韵母\"></a>韵母</h2><p>韵母的对应关系稍微复杂一点，</p>\n<ul>\n<li><code>a e i o u</code>这几个元音的对应比较简单；</li>\n<li>对于复杂韵母，<ul>\n<li><code>u o</code>相关的多在第一行键位，</li>\n<li><code>a e</code>相关的多在第二行键位，</li>\n<li><code>i</code>  相关的多在第三行键位。</li>\n</ul>\n</li>\n</ul>\n<p>下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按<code>Win+D</code>显示桌面即可。一般练习一两天就记住了。</p>\n<p><img src=\"/img/udpn-ms-map.png\" alt=\"微软双拼韵母键位\"></p>\n<p>例如，输入“我爱双拼输入法”，对应的击键如下表，</p>\n<p><img src=\"/img/udpn-demo.png\" alt=\"微软双拼示例\"></p>\n<p>说明：</p>\n<ol>\n<li>大部分声母都有直接对应的键位，只有<code>zh ch sh</code>需特别记忆一下。有的拼音没有声母，如<code>爱</code>，这时就需要零声母，即字母<code>o</code>，以表明后面的键是韵母；</li>\n<li>韵母<code>a  e  i  o  u</code>直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母<code>ing</code>对应分号键<code>;</code>。</li>\n</ol>\n<p>双拼下也可以使用简拼，但需要用 <code>&#39;</code> 作为分隔符划分音节。如果你刚才 <strong>整句</strong> 地输入过“我爱双拼输入法”，那么试试<code>w&#39;i&#39;u&#39;p&#39;u&#39;r&#39;f</code> ，看看你的输入法软件够不够智能。说实话，简拼用<code>&#39;</code>实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。</p>\n<h1 id=\"双拼输入法的软件\"><a href=\"#双拼输入法的软件\" class=\"headerlink\" title=\"双拼输入法的软件\"></a>双拼输入法的软件</h1><p>好像没有专门支持双拼的输入法软件啊？<br>其实Windows及Android上常见的 <strong>拼音输入法软件</strong>，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 <strong>双拼展开提示</strong>，初学时有所帮助。</p>\n<p>一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母<code>ing</code> 对应的是 <strong><code>,</code></strong>。</p>\n<p><img src=\"/img/udpn-baidu-ime.png\" alt=\"百度拼音设置\"></p>\n<hr>\n<h1 id=\"关于语音输入的杂想\"><a href=\"#关于语音输入的杂想\" class=\"headerlink\" title=\"关于语音输入的杂想\"></a>关于语音输入的杂想</h1><p>iPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：</p>\n<ul>\n<li>首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。</li>\n<li>语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。</li>\n<li>提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。</li>\n</ul>\n<blockquote>\n<p>手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；<br>但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。<br>想到这里，可能淘宝客服最适合用语音识别了;-)<br>要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。<br>话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。<br>弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于<code>Sensor offloading</code>，而且已经有了这样的App：<a href=\"http://wirelessorange.com/womic-zh/\" target=\"_blank\" rel=\"external\">WO Mic</a>，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。</p>\n</blockquote>\n<p>再到<a href=\"http://www.iflyrec.com/\" target=\"_blank\" rel=\"external\">讯飞听见</a>的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看<a href=\"http://cn.technode.com/post/2016-01-13/iflyrec-examination/\" target=\"_blank\" rel=\"external\">别人的体验</a>了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？</p>\n<p><a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\" target=\"_blank\" rel=\"external\"><img src=\"/img/udpn-iflyrec-rec.png\" alt=\"讯飞录音笔\"></a></p>\n<p><img src=\"/img/udpn-iflyrec-meeting.png\" alt=\"讯飞智能会议系统\"></p>\n","site":{"data":{}},"excerpt":"<p>双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。<br>除了介绍双拼输入法，还有一点关于语音输入的杂想。<br>","more":"</p>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n</code></pre><ul>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88\">双拼方案</a><ul>\n<li><a href=\"#%E5%A3%B0%E6%AF%8D\">声母</a></li>\n<li><a href=\"#%E9%9F%B5%E6%AF%8D\">韵母</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6\">双拼输入法的软件</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3\">关于语音输入的杂想</a></li>\n</ul>\n<!-- /TOC -->\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC\" target=\"_blank\" rel=\"external\">双拼</a>输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。<br>双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 <strong>不会太慢</strong>，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。</p>\n<blockquote>\n<p>本文主要内容的<a href=\"/doc/shuang_pin_udpn_cheetsheet.pdf\">一页纸PDF文件，亦称Cheetsheet</a></p>\n</blockquote>\n<h1 id=\"双拼方案\"><a href=\"#双拼方案\" class=\"headerlink\" title=\"双拼方案\"></a>双拼方案</h1><p>将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。</p>\n<h2 id=\"声母\"><a href=\"#声母\" class=\"headerlink\" title=\"声母\"></a>声母</h2><p><code>b p m f d t n l g k h j q x r z c s y w</code>这些单声母都是直接与各自的字母键对应的，对<code>zh ch sh</code>这三个，对应关系是<code>i：ch</code>，<code>u：sh</code>，<code>v：zh</code>；有的拼音不需要声母，比如<code>爱 ai</code>，只有韵母<code>ai</code>，为了保持编码规律，指定它们为 <strong>零声母</strong>，并对应为按键<code>o</code>。</p>\n<h2 id=\"韵母\"><a href=\"#韵母\" class=\"headerlink\" title=\"韵母\"></a>韵母</h2><p>韵母的对应关系稍微复杂一点，</p>\n<ul>\n<li><code>a e i o u</code>这几个元音的对应比较简单；</li>\n<li>对于复杂韵母，<ul>\n<li><code>u o</code>相关的多在第一行键位，</li>\n<li><code>a e</code>相关的多在第二行键位，</li>\n<li><code>i</code>  相关的多在第三行键位。</li>\n</ul>\n</li>\n</ul>\n<p>下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按<code>Win+D</code>显示桌面即可。一般练习一两天就记住了。</p>\n<p><img src=\"/img/udpn-ms-map.png\" alt=\"微软双拼韵母键位\"></p>\n<p>例如，输入“我爱双拼输入法”，对应的击键如下表，</p>\n<p><img src=\"/img/udpn-demo.png\" alt=\"微软双拼示例\"></p>\n<p>说明：</p>\n<ol>\n<li>大部分声母都有直接对应的键位，只有<code>zh ch sh</code>需特别记忆一下。有的拼音没有声母，如<code>爱</code>，这时就需要零声母，即字母<code>o</code>，以表明后面的键是韵母；</li>\n<li>韵母<code>a  e  i  o  u</code>直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母<code>ing</code>对应分号键<code>;</code>。</li>\n</ol>\n<p>双拼下也可以使用简拼，但需要用 <code>&#39;</code> 作为分隔符划分音节。如果你刚才 <strong>整句</strong> 地输入过“我爱双拼输入法”，那么试试<code>w&#39;i&#39;u&#39;p&#39;u&#39;r&#39;f</code> ，看看你的输入法软件够不够智能。说实话，简拼用<code>&#39;</code>实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。</p>\n<h1 id=\"双拼输入法的软件\"><a href=\"#双拼输入法的软件\" class=\"headerlink\" title=\"双拼输入法的软件\"></a>双拼输入法的软件</h1><p>好像没有专门支持双拼的输入法软件啊？<br>其实Windows及Android上常见的 <strong>拼音输入法软件</strong>，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 <strong>双拼展开提示</strong>，初学时有所帮助。</p>\n<p>一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母<code>ing</code> 对应的是 <strong><code>,</code></strong>。</p>\n<p><img src=\"/img/udpn-baidu-ime.png\" alt=\"百度拼音设置\"></p>\n<hr>\n<h1 id=\"关于语音输入的杂想\"><a href=\"#关于语音输入的杂想\" class=\"headerlink\" title=\"关于语音输入的杂想\"></a>关于语音输入的杂想</h1><p>iPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：</p>\n<ul>\n<li>首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。</li>\n<li>语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。</li>\n<li>提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。</li>\n</ul>\n<blockquote>\n<p>手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；<br>但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。<br>想到这里，可能淘宝客服最适合用语音识别了;-)<br>要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。<br>话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。<br>弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于<code>Sensor offloading</code>，而且已经有了这样的App：<a href=\"http://wirelessorange.com/womic-zh/\" target=\"_blank\" rel=\"external\">WO Mic</a>，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。</p>\n</blockquote>\n<p>再到<a href=\"http://www.iflyrec.com/\" target=\"_blank\" rel=\"external\">讯飞听见</a>的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看<a href=\"http://cn.technode.com/post/2016-01-13/iflyrec-examination/\" target=\"_blank\" rel=\"external\">别人的体验</a>了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？</p>\n<p><a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\" target=\"_blank\" rel=\"external\"><img src=\"/img/udpn-iflyrec-rec.png\" alt=\"讯飞录音笔\"></a></p>\n<p><img src=\"/img/udpn-iflyrec-meeting.png\" alt=\"讯飞智能会议系统\"></p>"},{"title":"【译文】Spanner, TrueTime 和CAP理论","date":"2017-03-05T16:00:00.000Z","_content":"作者：[Eric Brewer，VP, Infrastructure, Google](https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29)\n2017-02-14\n英文原文：[Spanner, TrueTime and the CAP Theorem](https://research.google.com/pubs/pub45855.html) ,[英文全文 PDF](https://research.google.com/pubs/archive/45855.pdf)\n[译文全文PDF](/doc/Spanner-TrueTime-CAP.pdf)\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n- [译者注](#%E8%AF%91%E8%80%85%E6%B3%A8)\n    - [CAP定理和一致性相关文章](#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0)\n    - [关于物理时间](#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4)\n    - [Cloud Spanner的相关报道](#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93)\n    - [分布式系统课程](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B)\n- [译文](#%E8%AF%91%E6%96%87)\n    - [Spanner声称同时达到了CA](#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca)\n    - [可用性的统计数据](#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE)\n    - [这就是网络](#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C)\n    - [网络分区时会发生什么](#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n    - [关于TrueTime](#%E5%85%B3%E4%BA%8Etruetime)\n    - [结论](#%E7%BB%93%E8%AE%BA)\n    - [致谢](#%E8%87%B4%E8%B0%A2)\n    - [参考文献](#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)\n\n<!-- /TOC -->\n\n# 译者注\n[CAP定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer's theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “[哥德尔不完备性定理](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86)”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。\n实际上 **这个定理的重要性被高估了**。注意到 **就是本文的作者（Eric Brewer）提出了CAP定理**，而他还在2012年发表了一篇文章 “[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 的文章，再加上这篇 **借Spanner来讨论CAP定理** 的文章，实际上是委婉地承认了这一点。\n\nCAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。\n**网络总是可能会断的**。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 **在正常情况下并没有什么作用**。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 **准备预案**，可能是 **技术上的**，也可能是 **公关** 预案）。 **AC** 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。\nCAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：\n+ 对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？\n+ 对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ **12306.cn** 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。\n+ 对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 这篇文章中也有讨论。\n\n## CAP定理和一致性相关文章\nBlog\n+ [不懂点CAP理论，你好意思说你是做分布式的吗？](http://www.yunweipai.com/archives/8432.html)\n+ [You Can’t Sacrifice Partition Tolerance](https://codahale.com/you-cant-sacrifice-partition-tolerance/)\n+ [Please stop calling databases CP or AP](http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n+ [关于网络分区的一篇blog](https://github.com/aphyr/partitions-post)\n\nPaper\n+ [Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305](http://queue.acm.org/detail.cfm?id=2462076)\n+ [Replicated Data Consistency Explained Through Baseball - CACM1312](https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/)，译文[以棒球赛为例解释复制数据的一致性问题](/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf)\n+ [Quantifying Eventual Consistency with PBS - CACM1408](www.bailis.org/papers/pbs-vldbj2014.pd)，译文[利用PBS 量化最终一致性](/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf)；作者[Peter Bailis](http://www.bailis.org/)也是一位大牛。\n+ [Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems](http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf)， [IEEE Xplore上的版本](http://ieeexplore.ieee.org/document/7547362/)\n+ [PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach](https://www.ksp.kit.edu/9783731501862)\n+ [IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem's Growing Impact](http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638)\n+ [A Critique of the CAP Theorem](https://arxiv.org/abs/1509.05393)\n> The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a \"delay-sensitivity\" framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.\n\n## 关于物理时间\n+ [Toward higher precision - PTP协议 - CACM-2012-10](http://dl.acm.org/citation.cfm?id=2347750)\n+ [Time for Data Centers to Consider Time as a Service](https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf)\n+ [GPS - Global Positioning System - wiki](https://en.wikipedia.org/wiki/Global_Positioning_System)\n+ [中国北斗卫星导航系统白皮书](http://www.beidou.gov.cn/attach/beidou/China's%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf)\n> 正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，**授时精度优于50纳秒**。\n\n+ [Time Scales](http://www.ucolick.org/~sla/leapsecs/timescales.html)\n+ [长短波授时系统](http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html)\n\n如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）\n高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。\n通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 **固有的通信延迟不确定性**。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。\n+ [西安同步电子科技有限公司](http://www.syn029.com/h-index.html)，[他们的淘宝店](https://shop102437782.taobao.com/index.htm)\n+ [西安景驰电子科技有限公司](http://www.jingtech.cn/col.jsp?id=130)，[TS3200 系列GPS/BD 同步时钟 - 知乎专栏](https://zhuanlan.zhihu.com/p/21596625)\n+ [广州邦正电力科技有限公司](http://www.bonzn.cn/col.jsp?id=105)，\n\n为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。\n只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。\n\n## Cloud Spanner的相关报道\n[Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？](http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP)\n[Infoq - 谷歌对外发布了云Spanner Beta版](http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta)\n\n## 分布式系统课程\n+ [Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013](https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html)\n+ [MIT 6.824: Distributed Systems - Spring 2016](http://nil.csail.mit.edu/6.824/2016/schedule.html)\n+ [分布式算法入门](http://www.bigoh.net/wiki/index.php/Dis-alg)\n+ [Notes on Distributed Systems for Young Bloods](https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/)\n\n-----\n\n# 译文\n\nSpanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。\nCAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：\n+ C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；\n+ A：读取和更新的100％可用性（Availability）；\n+ P：对网络分区（Partitions）的容忍。\n\n舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。\n对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。\n\n## Spanner声称同时达到了CA\n尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。\n纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。\n考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。\n第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。\n第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。\n\n## 可用性的统计数据\n在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。\n对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，**目前的广域分布的Chubby集群能提供99.99958％的平均可用性**（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。\n在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。\n![Spanner可用性数据](/img/spanner-availability.png)\n上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。\n+ 大量的事件（**用户事件**）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。\n+ **集群事件** 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。\n+ **运维事件** 是由SRE引起的事故，例如配置错误。\n+ **Bug事件** 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。\n+ **其它事件** 是各种大多只发生一次的问题。\n\n**网络事件** （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。\n总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：\n1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；\n2）由网络分区造成的运行中断应只占很小一部分。\nSpanner同时满足两者。\n\n## 这就是网络\n许多人认为，Spanner通过使用`TrueTime` 可以绕过CAP。`TrueTime` 是一个提供全局同步时钟的服务。`TrueTime` 是非比寻常的，但为实现CA，`TrueTime` 的作用并不显著。后面的小节会介绍`TrueTime` 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。\n首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。\n因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。\n虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。\n具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。\n\n## 网络分区时会发生什么\n为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。\n前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：\n+ 使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；\n+ 对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。\n\n在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。\n只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。\n除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。\n因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：\n1. 对于发起读操作的一侧网络分区，每个组至少存在一个副本\n2. 对于这些副本，读时间戳是过去的。\n\n如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。\n\n## 关于TrueTime\n通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，`TrueTime` 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。\nSpanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用`TrueTime` 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），** 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。**\n引自Liskov [Lis91，第7节]：\n> 同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。\n> ...\n> 该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。\n\nSpanner使用`TrueTime` 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。\nSpanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。\n然而，`TrueTime` 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。\n例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。\n`TrueTime` 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）`TrueTime` 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。\n你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。\n快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。\n`TrueTime` 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于`TrueTime` 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。\n\n## 结论\nSpanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。\nSpanner使用两阶段提交来实现顺序一致性，它使用`TrueTime` 实现外部一致性、无锁的一致性读取、以及一致性快照。\n \n## 致谢\n特别感谢Spanner 和`TrueTime` 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。\n\n## 参考文献\n[BK14] P. Bailis and K. Kingsbury. [The Network is Reliable](http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract), Communications of the ACM. Vol. 57 No. 9,\nPages 48-55. September 2014. Also: [https://aphyr.com/posts/288-the-network-is-reliable]\n[Bre12] E. Brewer. [CAP Twelve Years Later: How the “Rules” Have Changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed), IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23--29. [CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)（译注：这是本文作者之前的一篇文章）\n[Bur06] M. Burrows. [The Chubby lock service for loosely-coupled distributed systems](https://research.google.com/archive/chubby-osdi06.pdf). Proceedings of OSDI \\`06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.\n[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. [厦门大学计算机系 林子雨 老师的译文](http://dblab.xmu.edu.cn/post/google-spanner/)\n[Hel16] P. Helland. [Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!](http://queue.acm.org/detail.cfm?id=2953944) ACM Queue, Vol. 14, Issue 2, March-April 2016.\n[Lis91] B. Liskov. [Practical Uses of Synchronized Clocks in Distributed Systems](http://dl.acm.org/citation.cfm?id=112601). ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.\n[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. [ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging](http://dl.acm.org/citation.cfm?id=128770). ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.\n[Ree78] D. Reed. [Naming and Synchronization in a Decentralized Computer System](http://publications.csail.mit.edu/lcs/specpub.php?id=773), PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]\n\n\n-----\n\n![](/img/spanner-books.jpg)\n\n","source":"_posts/spanner-truetime-cap.md","raw":"title: 【译文】Spanner, TrueTime 和CAP理论\ncategory: [cloud]\ntags:\ndate: 2017-3-6\n---\n作者：[Eric Brewer，VP, Infrastructure, Google](https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29)\n2017-02-14\n英文原文：[Spanner, TrueTime and the CAP Theorem](https://research.google.com/pubs/pub45855.html) ,[英文全文 PDF](https://research.google.com/pubs/archive/45855.pdf)\n[译文全文PDF](/doc/Spanner-TrueTime-CAP.pdf)\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n- [译者注](#%E8%AF%91%E8%80%85%E6%B3%A8)\n    - [CAP定理和一致性相关文章](#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0)\n    - [关于物理时间](#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4)\n    - [Cloud Spanner的相关报道](#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93)\n    - [分布式系统课程](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B)\n- [译文](#%E8%AF%91%E6%96%87)\n    - [Spanner声称同时达到了CA](#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca)\n    - [可用性的统计数据](#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE)\n    - [这就是网络](#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C)\n    - [网络分区时会发生什么](#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n    - [关于TrueTime](#%E5%85%B3%E4%BA%8Etruetime)\n    - [结论](#%E7%BB%93%E8%AE%BA)\n    - [致谢](#%E8%87%B4%E8%B0%A2)\n    - [参考文献](#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)\n\n<!-- /TOC -->\n\n# 译者注\n[CAP定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer's theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “[哥德尔不完备性定理](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86)”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。\n实际上 **这个定理的重要性被高估了**。注意到 **就是本文的作者（Eric Brewer）提出了CAP定理**，而他还在2012年发表了一篇文章 “[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 的文章，再加上这篇 **借Spanner来讨论CAP定理** 的文章，实际上是委婉地承认了这一点。\n\nCAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。\n**网络总是可能会断的**。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 **在正常情况下并没有什么作用**。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 **准备预案**，可能是 **技术上的**，也可能是 **公关** 预案）。 **AC** 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。\nCAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：\n+ 对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？\n+ 对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ **12306.cn** 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。\n+ 对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 这篇文章中也有讨论。\n\n## CAP定理和一致性相关文章\nBlog\n+ [不懂点CAP理论，你好意思说你是做分布式的吗？](http://www.yunweipai.com/archives/8432.html)\n+ [You Can’t Sacrifice Partition Tolerance](https://codahale.com/you-cant-sacrifice-partition-tolerance/)\n+ [Please stop calling databases CP or AP](http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n+ [关于网络分区的一篇blog](https://github.com/aphyr/partitions-post)\n\nPaper\n+ [Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305](http://queue.acm.org/detail.cfm?id=2462076)\n+ [Replicated Data Consistency Explained Through Baseball - CACM1312](https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/)，译文[以棒球赛为例解释复制数据的一致性问题](/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf)\n+ [Quantifying Eventual Consistency with PBS - CACM1408](www.bailis.org/papers/pbs-vldbj2014.pd)，译文[利用PBS 量化最终一致性](/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf)；作者[Peter Bailis](http://www.bailis.org/)也是一位大牛。\n+ [Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems](http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf)， [IEEE Xplore上的版本](http://ieeexplore.ieee.org/document/7547362/)\n+ [PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach](https://www.ksp.kit.edu/9783731501862)\n+ [IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem's Growing Impact](http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638)\n+ [A Critique of the CAP Theorem](https://arxiv.org/abs/1509.05393)\n> The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a \"delay-sensitivity\" framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.\n\n## 关于物理时间\n+ [Toward higher precision - PTP协议 - CACM-2012-10](http://dl.acm.org/citation.cfm?id=2347750)\n+ [Time for Data Centers to Consider Time as a Service](https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf)\n+ [GPS - Global Positioning System - wiki](https://en.wikipedia.org/wiki/Global_Positioning_System)\n+ [中国北斗卫星导航系统白皮书](http://www.beidou.gov.cn/attach/beidou/China's%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf)\n> 正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，**授时精度优于50纳秒**。\n\n+ [Time Scales](http://www.ucolick.org/~sla/leapsecs/timescales.html)\n+ [长短波授时系统](http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html)\n\n如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）\n高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。\n通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 **固有的通信延迟不确定性**。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。\n+ [西安同步电子科技有限公司](http://www.syn029.com/h-index.html)，[他们的淘宝店](https://shop102437782.taobao.com/index.htm)\n+ [西安景驰电子科技有限公司](http://www.jingtech.cn/col.jsp?id=130)，[TS3200 系列GPS/BD 同步时钟 - 知乎专栏](https://zhuanlan.zhihu.com/p/21596625)\n+ [广州邦正电力科技有限公司](http://www.bonzn.cn/col.jsp?id=105)，\n\n为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。\n只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。\n\n## Cloud Spanner的相关报道\n[Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？](http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP)\n[Infoq - 谷歌对外发布了云Spanner Beta版](http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta)\n\n## 分布式系统课程\n+ [Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013](https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html)\n+ [MIT 6.824: Distributed Systems - Spring 2016](http://nil.csail.mit.edu/6.824/2016/schedule.html)\n+ [分布式算法入门](http://www.bigoh.net/wiki/index.php/Dis-alg)\n+ [Notes on Distributed Systems for Young Bloods](https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/)\n\n-----\n\n# 译文\n\nSpanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。\nCAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：\n+ C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；\n+ A：读取和更新的100％可用性（Availability）；\n+ P：对网络分区（Partitions）的容忍。\n\n舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。\n对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。\n\n## Spanner声称同时达到了CA\n尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。\n纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。\n考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。\n第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。\n第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。\n\n## 可用性的统计数据\n在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。\n对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，**目前的广域分布的Chubby集群能提供99.99958％的平均可用性**（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。\n在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。\n![Spanner可用性数据](/img/spanner-availability.png)\n上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。\n+ 大量的事件（**用户事件**）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。\n+ **集群事件** 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。\n+ **运维事件** 是由SRE引起的事故，例如配置错误。\n+ **Bug事件** 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。\n+ **其它事件** 是各种大多只发生一次的问题。\n\n**网络事件** （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。\n总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：\n1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；\n2）由网络分区造成的运行中断应只占很小一部分。\nSpanner同时满足两者。\n\n## 这就是网络\n许多人认为，Spanner通过使用`TrueTime` 可以绕过CAP。`TrueTime` 是一个提供全局同步时钟的服务。`TrueTime` 是非比寻常的，但为实现CA，`TrueTime` 的作用并不显著。后面的小节会介绍`TrueTime` 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。\n首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。\n因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。\n虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。\n具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。\n\n## 网络分区时会发生什么\n为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。\n前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：\n+ 使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；\n+ 对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。\n\n在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。\n只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。\n除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。\n因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：\n1. 对于发起读操作的一侧网络分区，每个组至少存在一个副本\n2. 对于这些副本，读时间戳是过去的。\n\n如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。\n\n## 关于TrueTime\n通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，`TrueTime` 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。\nSpanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用`TrueTime` 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），** 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。**\n引自Liskov [Lis91，第7节]：\n> 同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。\n> ...\n> 该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。\n\nSpanner使用`TrueTime` 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。\nSpanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。\n然而，`TrueTime` 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。\n例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。\n`TrueTime` 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）`TrueTime` 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。\n你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。\n快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。\n`TrueTime` 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于`TrueTime` 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。\n\n## 结论\nSpanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。\nSpanner使用两阶段提交来实现顺序一致性，它使用`TrueTime` 实现外部一致性、无锁的一致性读取、以及一致性快照。\n \n## 致谢\n特别感谢Spanner 和`TrueTime` 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。\n\n## 参考文献\n[BK14] P. Bailis and K. Kingsbury. [The Network is Reliable](http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract), Communications of the ACM. Vol. 57 No. 9,\nPages 48-55. September 2014. Also: [https://aphyr.com/posts/288-the-network-is-reliable]\n[Bre12] E. Brewer. [CAP Twelve Years Later: How the “Rules” Have Changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed), IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23--29. [CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)（译注：这是本文作者之前的一篇文章）\n[Bur06] M. Burrows. [The Chubby lock service for loosely-coupled distributed systems](https://research.google.com/archive/chubby-osdi06.pdf). Proceedings of OSDI \\`06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.\n[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. [厦门大学计算机系 林子雨 老师的译文](http://dblab.xmu.edu.cn/post/google-spanner/)\n[Hel16] P. Helland. [Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!](http://queue.acm.org/detail.cfm?id=2953944) ACM Queue, Vol. 14, Issue 2, March-April 2016.\n[Lis91] B. Liskov. [Practical Uses of Synchronized Clocks in Distributed Systems](http://dl.acm.org/citation.cfm?id=112601). ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.\n[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. [ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging](http://dl.acm.org/citation.cfm?id=128770). ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.\n[Ree78] D. Reed. [Naming and Synchronization in a Decentralized Computer System](http://publications.csail.mit.edu/lcs/specpub.php?id=773), PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]\n\n\n-----\n\n![](/img/spanner-books.jpg)\n\n","slug":"spanner-truetime-cap","published":1,"updated":"2017-10-30T03:41:56.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8g7e0002n84fo34yqd7e","content":"<p>作者：<a href=\"https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29\" target=\"_blank\" rel=\"external\">Eric Brewer，VP, Infrastructure, Google</a><br>2017-02-14<br>英文原文：<a href=\"https://research.google.com/pubs/pub45855.html\" target=\"_blank\" rel=\"external\">Spanner, TrueTime and the CAP Theorem</a> ,<a href=\"https://research.google.com/pubs/archive/45855.pdf\" target=\"_blank\" rel=\"external\">英文全文 PDF</a><br><a href=\"/doc/Spanner-TrueTime-CAP.pdf\">译文全文PDF</a></p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<pre><code>- [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n</code></pre><ul>\n<li><a href=\"#%E8%AF%91%E8%80%85%E6%B3%A8\">译者注</a><ul>\n<li><a href=\"#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0\">CAP定理和一致性相关文章</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4\">关于物理时间</a></li>\n<li><a href=\"#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93\">Cloud Spanner的相关报道</a></li>\n<li><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B\">分布式系统课程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%91%E6%96%87\">译文</a><ul>\n<li><a href=\"#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca\">Spanner声称同时达到了CA</a></li>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE\">可用性的统计数据</a></li>\n<li><a href=\"#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C\">这就是网络</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\">网络分区时会发生什么</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8Etruetime\">关于TrueTime</a></li>\n<li><a href=\"#%E7%BB%93%E8%AE%BA\">结论</a></li>\n<li><a href=\"#%E8%87%B4%E8%B0%A2\">致谢</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"译者注\"><a href=\"#译者注\" class=\"headerlink\" title=\"译者注\"></a>译者注</h1><p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">CAP定理</a>是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer’s theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “<a href=\"https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">哥德尔不完备性定理</a>”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。<br>实际上 <strong>这个定理的重要性被高估了</strong>。注意到 <strong>就是本文的作者（Eric Brewer）提出了CAP定理</strong>，而他还在2012年发表了一篇文章 “<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 的文章，再加上这篇 <strong>借Spanner来讨论CAP定理</strong> 的文章，实际上是委婉地承认了这一点。</p>\n<p>CAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。<br><strong>网络总是可能会断的</strong>。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 <strong>在正常情况下并没有什么作用</strong>。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 <strong>准备预案</strong>，可能是 <strong>技术上的</strong>，也可能是 <strong>公关</strong> 预案）。 <strong>AC</strong> 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。<br>CAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：</p>\n<ul>\n<li>对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？</li>\n<li>对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ <strong>12306.cn</strong> 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。</li>\n<li>对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 这篇文章中也有讨论。</li>\n</ul>\n<h2 id=\"CAP定理和一致性相关文章\"><a href=\"#CAP定理和一致性相关文章\" class=\"headerlink\" title=\"CAP定理和一致性相关文章\"></a>CAP定理和一致性相关文章</h2><p>Blog</p>\n<ul>\n<li><a href=\"http://www.yunweipai.com/archives/8432.html\" target=\"_blank\" rel=\"external\">不懂点CAP理论，你好意思说你是做分布式的吗？</a></li>\n<li><a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" target=\"_blank\" rel=\"external\">You Can’t Sacrifice Partition Tolerance</a></li>\n<li><a href=\"http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"external\">Please stop calling databases CP or AP</a></li>\n<li><a href=\"https://github.com/aphyr/partitions-post\" target=\"_blank\" rel=\"external\">关于网络分区的一篇blog</a></li>\n</ul>\n<p>Paper</p>\n<ul>\n<li><a href=\"http://queue.acm.org/detail.cfm?id=2462076\" target=\"_blank\" rel=\"external\">Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/\" target=\"_blank\" rel=\"external\">Replicated Data Consistency Explained Through Baseball - CACM1312</a>，译文<a href=\"/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf\">以棒球赛为例解释复制数据的一致性问题</a></li>\n<li><a href=\"www.bailis.org/papers/pbs-vldbj2014.pd\">Quantifying Eventual Consistency with PBS - CACM1408</a>，译文<a href=\"/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf\">利用PBS 量化最终一致性</a>；作者<a href=\"http://www.bailis.org/\" target=\"_blank\" rel=\"external\">Peter Bailis</a>也是一位大牛。</li>\n<li><a href=\"http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf\" target=\"_blank\" rel=\"external\">Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems</a>， <a href=\"http://ieeexplore.ieee.org/document/7547362/\" target=\"_blank\" rel=\"external\">IEEE Xplore上的版本</a></li>\n<li><a href=\"https://www.ksp.kit.edu/9783731501862\" target=\"_blank\" rel=\"external\">PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach</a></li>\n<li><a href=\"http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638\" target=\"_blank\" rel=\"external\">IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem’s Growing Impact</a></li>\n<li><a href=\"https://arxiv.org/abs/1509.05393\" target=\"_blank\" rel=\"external\">A Critique of the CAP Theorem</a><blockquote>\n<p>The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a “delay-sensitivity” framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"关于物理时间\"><a href=\"#关于物理时间\" class=\"headerlink\" title=\"关于物理时间\"></a>关于物理时间</h2><ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=2347750\" target=\"_blank\" rel=\"external\">Toward higher precision - PTP协议 - CACM-2012-10</a></li>\n<li><a href=\"https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf\" target=\"_blank\" rel=\"external\">Time for Data Centers to Consider Time as a Service</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Global_Positioning_System\" target=\"_blank\" rel=\"external\">GPS - Global Positioning System - wiki</a></li>\n<li><p><a href=\"http://www.beidou.gov.cn/attach/beidou/China&#39;s%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf\" target=\"_blank\" rel=\"external\">中国北斗卫星导航系统白皮书</a></p>\n<blockquote>\n<p>正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，<strong>授时精度优于50纳秒</strong>。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.ucolick.org/~sla/leapsecs/timescales.html\" target=\"_blank\" rel=\"external\">Time Scales</a></p>\n</li>\n<li><a href=\"http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html\" target=\"_blank\" rel=\"external\">长短波授时系统</a></li>\n</ul>\n<p>如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）<br>高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。<br>通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 <strong>固有的通信延迟不确定性</strong>。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。</p>\n<ul>\n<li><a href=\"http://www.syn029.com/h-index.html\" target=\"_blank\" rel=\"external\">西安同步电子科技有限公司</a>，<a href=\"https://shop102437782.taobao.com/index.htm\" target=\"_blank\" rel=\"external\">他们的淘宝店</a></li>\n<li><a href=\"http://www.jingtech.cn/col.jsp?id=130\" target=\"_blank\" rel=\"external\">西安景驰电子科技有限公司</a>，<a href=\"https://zhuanlan.zhihu.com/p/21596625\" target=\"_blank\" rel=\"external\">TS3200 系列GPS/BD 同步时钟 - 知乎专栏</a></li>\n<li><a href=\"http://www.bonzn.cn/col.jsp?id=105\" target=\"_blank\" rel=\"external\">广州邦正电力科技有限公司</a>，</li>\n</ul>\n<p>为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。<br>只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。</p>\n<h2 id=\"Cloud-Spanner的相关报道\"><a href=\"#Cloud-Spanner的相关报道\" class=\"headerlink\" title=\"Cloud Spanner的相关报道\"></a>Cloud Spanner的相关报道</h2><p><a href=\"http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP\" target=\"_blank\" rel=\"external\">Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？</a><br><a href=\"http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta\" target=\"_blank\" rel=\"external\">Infoq - 谷歌对外发布了云Spanner Beta版</a></p>\n<h2 id=\"分布式系统课程\"><a href=\"#分布式系统课程\" class=\"headerlink\" title=\"分布式系统课程\"></a>分布式系统课程</h2><ul>\n<li><a href=\"https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html\" target=\"_blank\" rel=\"external\">Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013</a></li>\n<li><a href=\"http://nil.csail.mit.edu/6.824/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.824: Distributed Systems - Spring 2016</a></li>\n<li><a href=\"http://www.bigoh.net/wiki/index.php/Dis-alg\" target=\"_blank\" rel=\"external\">分布式算法入门</a></li>\n<li><a href=\"https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/\" target=\"_blank\" rel=\"external\">Notes on Distributed Systems for Young Bloods</a></li>\n</ul>\n<hr>\n<h1 id=\"译文\"><a href=\"#译文\" class=\"headerlink\" title=\"译文\"></a>译文</h1><p>Spanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。<br>CAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：</p>\n<ul>\n<li>C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；</li>\n<li>A：读取和更新的100％可用性（Availability）；</li>\n<li>P：对网络分区（Partitions）的容忍。</li>\n</ul>\n<p>舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。<br>对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。</p>\n<h2 id=\"Spanner声称同时达到了CA\"><a href=\"#Spanner声称同时达到了CA\" class=\"headerlink\" title=\"Spanner声称同时达到了CA\"></a>Spanner声称同时达到了CA</h2><p>尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。<br>纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。<br>考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。<br>第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。<br>第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。</p>\n<h2 id=\"可用性的统计数据\"><a href=\"#可用性的统计数据\" class=\"headerlink\" title=\"可用性的统计数据\"></a>可用性的统计数据</h2><p>在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。<br>对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，<strong>目前的广域分布的Chubby集群能提供99.99958％的平均可用性</strong>（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。<br>在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。<br><img src=\"/img/spanner-availability.png\" alt=\"Spanner可用性数据\"><br>上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。</p>\n<ul>\n<li>大量的事件（<strong>用户事件</strong>）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。</li>\n<li><strong>集群事件</strong> 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。</li>\n<li><strong>运维事件</strong> 是由SRE引起的事故，例如配置错误。</li>\n<li><strong>Bug事件</strong> 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。</li>\n<li><strong>其它事件</strong> 是各种大多只发生一次的问题。</li>\n</ul>\n<p><strong>网络事件</strong> （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。<br>总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：<br>1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；<br>2）由网络分区造成的运行中断应只占很小一部分。<br>Spanner同时满足两者。</p>\n<h2 id=\"这就是网络\"><a href=\"#这就是网络\" class=\"headerlink\" title=\"这就是网络\"></a>这就是网络</h2><p>许多人认为，Spanner通过使用<code>TrueTime</code> 可以绕过CAP。<code>TrueTime</code> 是一个提供全局同步时钟的服务。<code>TrueTime</code> 是非比寻常的，但为实现CA，<code>TrueTime</code> 的作用并不显著。后面的小节会介绍<code>TrueTime</code> 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。<br>首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。<br>因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。<br>虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。<br>具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。</p>\n<h2 id=\"网络分区时会发生什么\"><a href=\"#网络分区时会发生什么\" class=\"headerlink\" title=\"网络分区时会发生什么\"></a>网络分区时会发生什么</h2><p>为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。<br>前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：</p>\n<ul>\n<li>使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；</li>\n<li>对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。</li>\n</ul>\n<p>在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。<br>只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。<br>除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。<br>因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：</p>\n<ol>\n<li>对于发起读操作的一侧网络分区，每个组至少存在一个副本</li>\n<li>对于这些副本，读时间戳是过去的。</li>\n</ol>\n<p>如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。</p>\n<h2 id=\"关于TrueTime\"><a href=\"#关于TrueTime\" class=\"headerlink\" title=\"关于TrueTime\"></a>关于TrueTime</h2><p>通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，<code>TrueTime</code> 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。<br>Spanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用<code>TrueTime</code> 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），<strong> 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。</strong><br>引自Liskov [Lis91，第7节]：</p>\n<blockquote>\n<p>同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。<br>…<br>该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。</p>\n</blockquote>\n<p>Spanner使用<code>TrueTime</code> 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。<br>Spanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。<br>然而，<code>TrueTime</code> 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。<br>例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。<br><code>TrueTime</code> 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）<code>TrueTime</code> 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。<br>你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。<br>快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。<br><code>TrueTime</code> 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于<code>TrueTime</code> 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Spanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。<br>Spanner使用两阶段提交来实现顺序一致性，它使用<code>TrueTime</code> 实现外部一致性、无锁的一致性读取、以及一致性快照。\n </p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>特别感谢Spanner 和<code>TrueTime</code> 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[BK14] P. Bailis and K. Kingsbury. <a href=\"http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract\" target=\"_blank\" rel=\"external\">The Network is Reliable</a>, Communications of the ACM. Vol. 57 No. 9,<br>Pages 48-55. September 2014. Also: [<a href=\"https://aphyr.com/posts/288-the-network-is-reliable\" target=\"_blank\" rel=\"external\">https://aphyr.com/posts/288-the-network-is-reliable</a>]<br>[Bre12] E. Brewer. <a href=\"https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP Twelve Years Later: How the “Rules” Have Changed</a>, IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23–29. <a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>（译注：这是本文作者之前的一篇文章）<br>[Bur06] M. Burrows. <a href=\"https://research.google.com/archive/chubby-osdi06.pdf\" target=\"_blank\" rel=\"external\">The Chubby lock service for loosely-coupled distributed systems</a>. Proceedings of OSDI `06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.<br>[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. <a href=\"http://dblab.xmu.edu.cn/post/google-spanner/\" target=\"_blank\" rel=\"external\">厦门大学计算机系 林子雨 老师的译文</a><br>[Hel16] P. Helland. <a href=\"http://queue.acm.org/detail.cfm?id=2953944\" target=\"_blank\" rel=\"external\">Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!</a> ACM Queue, Vol. 14, Issue 2, March-April 2016.<br>[Lis91] B. Liskov. <a href=\"http://dl.acm.org/citation.cfm?id=112601\" target=\"_blank\" rel=\"external\">Practical Uses of Synchronized Clocks in Distributed Systems</a>. ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.<br>[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. <a href=\"http://dl.acm.org/citation.cfm?id=128770\" target=\"_blank\" rel=\"external\">ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>. ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.<br>[Ree78] D. Reed. <a href=\"http://publications.csail.mit.edu/lcs/specpub.php?id=773\" target=\"_blank\" rel=\"external\">Naming and Synchronization in a Decentralized Computer System</a>, PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]</p>\n<hr>\n<p><img src=\"/img/spanner-books.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>作者：<a href=\"https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29\" target=\"_blank\" rel=\"external\">Eric Brewer，VP, Infrastructure, Google</a><br>2017-02-14<br>英文原文：<a href=\"https://research.google.com/pubs/pub45855.html\" target=\"_blank\" rel=\"external\">Spanner, TrueTime and the CAP Theorem</a> ,<a href=\"https://research.google.com/pubs/archive/45855.pdf\" target=\"_blank\" rel=\"external\">英文全文 PDF</a><br><a href=\"/doc/Spanner-TrueTime-CAP.pdf\">译文全文PDF</a></p>","more":"<!-- TOC -->\n<pre><code>- [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n</code></pre><ul>\n<li><a href=\"#%E8%AF%91%E8%80%85%E6%B3%A8\">译者注</a><ul>\n<li><a href=\"#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0\">CAP定理和一致性相关文章</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4\">关于物理时间</a></li>\n<li><a href=\"#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93\">Cloud Spanner的相关报道</a></li>\n<li><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B\">分布式系统课程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%91%E6%96%87\">译文</a><ul>\n<li><a href=\"#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca\">Spanner声称同时达到了CA</a></li>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE\">可用性的统计数据</a></li>\n<li><a href=\"#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C\">这就是网络</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\">网络分区时会发生什么</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8Etruetime\">关于TrueTime</a></li>\n<li><a href=\"#%E7%BB%93%E8%AE%BA\">结论</a></li>\n<li><a href=\"#%E8%87%B4%E8%B0%A2\">致谢</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"译者注\"><a href=\"#译者注\" class=\"headerlink\" title=\"译者注\"></a>译者注</h1><p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">CAP定理</a>是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer’s theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “<a href=\"https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">哥德尔不完备性定理</a>”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。<br>实际上 <strong>这个定理的重要性被高估了</strong>。注意到 <strong>就是本文的作者（Eric Brewer）提出了CAP定理</strong>，而他还在2012年发表了一篇文章 “<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 的文章，再加上这篇 <strong>借Spanner来讨论CAP定理</strong> 的文章，实际上是委婉地承认了这一点。</p>\n<p>CAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。<br><strong>网络总是可能会断的</strong>。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 <strong>在正常情况下并没有什么作用</strong>。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 <strong>准备预案</strong>，可能是 <strong>技术上的</strong>，也可能是 <strong>公关</strong> 预案）。 <strong>AC</strong> 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。<br>CAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：</p>\n<ul>\n<li>对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？</li>\n<li>对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ <strong>12306.cn</strong> 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。</li>\n<li>对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 这篇文章中也有讨论。</li>\n</ul>\n<h2 id=\"CAP定理和一致性相关文章\"><a href=\"#CAP定理和一致性相关文章\" class=\"headerlink\" title=\"CAP定理和一致性相关文章\"></a>CAP定理和一致性相关文章</h2><p>Blog</p>\n<ul>\n<li><a href=\"http://www.yunweipai.com/archives/8432.html\" target=\"_blank\" rel=\"external\">不懂点CAP理论，你好意思说你是做分布式的吗？</a></li>\n<li><a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" target=\"_blank\" rel=\"external\">You Can’t Sacrifice Partition Tolerance</a></li>\n<li><a href=\"http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"external\">Please stop calling databases CP or AP</a></li>\n<li><a href=\"https://github.com/aphyr/partitions-post\" target=\"_blank\" rel=\"external\">关于网络分区的一篇blog</a></li>\n</ul>\n<p>Paper</p>\n<ul>\n<li><a href=\"http://queue.acm.org/detail.cfm?id=2462076\" target=\"_blank\" rel=\"external\">Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/\" target=\"_blank\" rel=\"external\">Replicated Data Consistency Explained Through Baseball - CACM1312</a>，译文<a href=\"/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf\">以棒球赛为例解释复制数据的一致性问题</a></li>\n<li><a href=\"www.bailis.org/papers/pbs-vldbj2014.pd\">Quantifying Eventual Consistency with PBS - CACM1408</a>，译文<a href=\"/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf\">利用PBS 量化最终一致性</a>；作者<a href=\"http://www.bailis.org/\" target=\"_blank\" rel=\"external\">Peter Bailis</a>也是一位大牛。</li>\n<li><a href=\"http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf\" target=\"_blank\" rel=\"external\">Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems</a>， <a href=\"http://ieeexplore.ieee.org/document/7547362/\" target=\"_blank\" rel=\"external\">IEEE Xplore上的版本</a></li>\n<li><a href=\"https://www.ksp.kit.edu/9783731501862\" target=\"_blank\" rel=\"external\">PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach</a></li>\n<li><a href=\"http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638\" target=\"_blank\" rel=\"external\">IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem’s Growing Impact</a></li>\n<li><a href=\"https://arxiv.org/abs/1509.05393\" target=\"_blank\" rel=\"external\">A Critique of the CAP Theorem</a><blockquote>\n<p>The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a “delay-sensitivity” framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"关于物理时间\"><a href=\"#关于物理时间\" class=\"headerlink\" title=\"关于物理时间\"></a>关于物理时间</h2><ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=2347750\" target=\"_blank\" rel=\"external\">Toward higher precision - PTP协议 - CACM-2012-10</a></li>\n<li><a href=\"https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf\" target=\"_blank\" rel=\"external\">Time for Data Centers to Consider Time as a Service</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Global_Positioning_System\" target=\"_blank\" rel=\"external\">GPS - Global Positioning System - wiki</a></li>\n<li><p><a href=\"http://www.beidou.gov.cn/attach/beidou/China&#39;s%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf\" target=\"_blank\" rel=\"external\">中国北斗卫星导航系统白皮书</a></p>\n<blockquote>\n<p>正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，<strong>授时精度优于50纳秒</strong>。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.ucolick.org/~sla/leapsecs/timescales.html\" target=\"_blank\" rel=\"external\">Time Scales</a></p>\n</li>\n<li><a href=\"http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html\" target=\"_blank\" rel=\"external\">长短波授时系统</a></li>\n</ul>\n<p>如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）<br>高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。<br>通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 <strong>固有的通信延迟不确定性</strong>。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。</p>\n<ul>\n<li><a href=\"http://www.syn029.com/h-index.html\" target=\"_blank\" rel=\"external\">西安同步电子科技有限公司</a>，<a href=\"https://shop102437782.taobao.com/index.htm\" target=\"_blank\" rel=\"external\">他们的淘宝店</a></li>\n<li><a href=\"http://www.jingtech.cn/col.jsp?id=130\" target=\"_blank\" rel=\"external\">西安景驰电子科技有限公司</a>，<a href=\"https://zhuanlan.zhihu.com/p/21596625\" target=\"_blank\" rel=\"external\">TS3200 系列GPS/BD 同步时钟 - 知乎专栏</a></li>\n<li><a href=\"http://www.bonzn.cn/col.jsp?id=105\" target=\"_blank\" rel=\"external\">广州邦正电力科技有限公司</a>，</li>\n</ul>\n<p>为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。<br>只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。</p>\n<h2 id=\"Cloud-Spanner的相关报道\"><a href=\"#Cloud-Spanner的相关报道\" class=\"headerlink\" title=\"Cloud Spanner的相关报道\"></a>Cloud Spanner的相关报道</h2><p><a href=\"http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP\" target=\"_blank\" rel=\"external\">Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？</a><br><a href=\"http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta\" target=\"_blank\" rel=\"external\">Infoq - 谷歌对外发布了云Spanner Beta版</a></p>\n<h2 id=\"分布式系统课程\"><a href=\"#分布式系统课程\" class=\"headerlink\" title=\"分布式系统课程\"></a>分布式系统课程</h2><ul>\n<li><a href=\"https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html\" target=\"_blank\" rel=\"external\">Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013</a></li>\n<li><a href=\"http://nil.csail.mit.edu/6.824/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.824: Distributed Systems - Spring 2016</a></li>\n<li><a href=\"http://www.bigoh.net/wiki/index.php/Dis-alg\" target=\"_blank\" rel=\"external\">分布式算法入门</a></li>\n<li><a href=\"https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/\" target=\"_blank\" rel=\"external\">Notes on Distributed Systems for Young Bloods</a></li>\n</ul>\n<hr>\n<h1 id=\"译文\"><a href=\"#译文\" class=\"headerlink\" title=\"译文\"></a>译文</h1><p>Spanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。<br>CAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：</p>\n<ul>\n<li>C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；</li>\n<li>A：读取和更新的100％可用性（Availability）；</li>\n<li>P：对网络分区（Partitions）的容忍。</li>\n</ul>\n<p>舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。<br>对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。</p>\n<h2 id=\"Spanner声称同时达到了CA\"><a href=\"#Spanner声称同时达到了CA\" class=\"headerlink\" title=\"Spanner声称同时达到了CA\"></a>Spanner声称同时达到了CA</h2><p>尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。<br>纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。<br>考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。<br>第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。<br>第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。</p>\n<h2 id=\"可用性的统计数据\"><a href=\"#可用性的统计数据\" class=\"headerlink\" title=\"可用性的统计数据\"></a>可用性的统计数据</h2><p>在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。<br>对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，<strong>目前的广域分布的Chubby集群能提供99.99958％的平均可用性</strong>（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。<br>在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。<br><img src=\"/img/spanner-availability.png\" alt=\"Spanner可用性数据\"><br>上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。</p>\n<ul>\n<li>大量的事件（<strong>用户事件</strong>）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。</li>\n<li><strong>集群事件</strong> 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。</li>\n<li><strong>运维事件</strong> 是由SRE引起的事故，例如配置错误。</li>\n<li><strong>Bug事件</strong> 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。</li>\n<li><strong>其它事件</strong> 是各种大多只发生一次的问题。</li>\n</ul>\n<p><strong>网络事件</strong> （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。<br>总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：<br>1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；<br>2）由网络分区造成的运行中断应只占很小一部分。<br>Spanner同时满足两者。</p>\n<h2 id=\"这就是网络\"><a href=\"#这就是网络\" class=\"headerlink\" title=\"这就是网络\"></a>这就是网络</h2><p>许多人认为，Spanner通过使用<code>TrueTime</code> 可以绕过CAP。<code>TrueTime</code> 是一个提供全局同步时钟的服务。<code>TrueTime</code> 是非比寻常的，但为实现CA，<code>TrueTime</code> 的作用并不显著。后面的小节会介绍<code>TrueTime</code> 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。<br>首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。<br>因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。<br>虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。<br>具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。</p>\n<h2 id=\"网络分区时会发生什么\"><a href=\"#网络分区时会发生什么\" class=\"headerlink\" title=\"网络分区时会发生什么\"></a>网络分区时会发生什么</h2><p>为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。<br>前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：</p>\n<ul>\n<li>使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；</li>\n<li>对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。</li>\n</ul>\n<p>在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。<br>只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。<br>除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。<br>因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：</p>\n<ol>\n<li>对于发起读操作的一侧网络分区，每个组至少存在一个副本</li>\n<li>对于这些副本，读时间戳是过去的。</li>\n</ol>\n<p>如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。</p>\n<h2 id=\"关于TrueTime\"><a href=\"#关于TrueTime\" class=\"headerlink\" title=\"关于TrueTime\"></a>关于TrueTime</h2><p>通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，<code>TrueTime</code> 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。<br>Spanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用<code>TrueTime</code> 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），<strong> 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。</strong><br>引自Liskov [Lis91，第7节]：</p>\n<blockquote>\n<p>同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。<br>…<br>该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。</p>\n</blockquote>\n<p>Spanner使用<code>TrueTime</code> 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。<br>Spanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。<br>然而，<code>TrueTime</code> 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。<br>例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。<br><code>TrueTime</code> 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）<code>TrueTime</code> 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。<br>你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。<br>快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。<br><code>TrueTime</code> 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于<code>TrueTime</code> 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Spanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。<br>Spanner使用两阶段提交来实现顺序一致性，它使用<code>TrueTime</code> 实现外部一致性、无锁的一致性读取、以及一致性快照。\n </p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>特别感谢Spanner 和<code>TrueTime</code> 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[BK14] P. Bailis and K. Kingsbury. <a href=\"http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract\" target=\"_blank\" rel=\"external\">The Network is Reliable</a>, Communications of the ACM. Vol. 57 No. 9,<br>Pages 48-55. September 2014. Also: [<a href=\"https://aphyr.com/posts/288-the-network-is-reliable\" target=\"_blank\" rel=\"external\">https://aphyr.com/posts/288-the-network-is-reliable</a>]<br>[Bre12] E. Brewer. <a href=\"https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP Twelve Years Later: How the “Rules” Have Changed</a>, IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23–29. <a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>（译注：这是本文作者之前的一篇文章）<br>[Bur06] M. Burrows. <a href=\"https://research.google.com/archive/chubby-osdi06.pdf\" target=\"_blank\" rel=\"external\">The Chubby lock service for loosely-coupled distributed systems</a>. Proceedings of OSDI `06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.<br>[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. <a href=\"http://dblab.xmu.edu.cn/post/google-spanner/\" target=\"_blank\" rel=\"external\">厦门大学计算机系 林子雨 老师的译文</a><br>[Hel16] P. Helland. <a href=\"http://queue.acm.org/detail.cfm?id=2953944\" target=\"_blank\" rel=\"external\">Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!</a> ACM Queue, Vol. 14, Issue 2, March-April 2016.<br>[Lis91] B. Liskov. <a href=\"http://dl.acm.org/citation.cfm?id=112601\" target=\"_blank\" rel=\"external\">Practical Uses of Synchronized Clocks in Distributed Systems</a>. ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.<br>[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. <a href=\"http://dl.acm.org/citation.cfm?id=128770\" target=\"_blank\" rel=\"external\">ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>. ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.<br>[Ree78] D. Reed. <a href=\"http://publications.csail.mit.edu/lcs/specpub.php?id=773\" target=\"_blank\" rel=\"external\">Naming and Synchronization in a Decentralized Computer System</a>, PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]</p>\n<hr>\n<p><img src=\"/img/spanner-books.jpg\" alt=\"\"></p>"},{"title":"设置及使用HTTP代理","date":"2017-04-13T16:00:00.000Z","_content":"记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。\n<!--more-->\n\n<!-- TOC -->\n\n- [使用Squid提供HTTP代理](#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86)\n    - [主机上安装和设置Squid](#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid)\n    - [以Docker容器的方式运行Squid](#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid)\n- [使用HTTP代理](#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86)\n    - [全局的环境变量](#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n    - [Docker](#docker)\n    - [yum](#yum)\n    - [apt](#apt)\n\n<!-- /TOC -->\n\n# 使用Squid提供HTTP代理\n\n## 主机上安装和设置Squid\n作为网关的`n147`机器，公网IP是`2.2.2.147`。安装Squid，然后修改配置，启用服务。\n```\nyum install -y squid # CentOS\napt install -y squid # Ubuntu\napk add squid     # Alpine\n\n# squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile\n\n# 修改配置后，初始化squid的工作目录\nsquid -z\n\n# 启动服务\nsystemctl enable squid\nsystemctl start  squid\n```\n\n## 以Docker容器的方式运行Squid\nDockerfile内容如下：\n```\nFROM alpine:latest\n\nRUN apk update --no-cache; \\\n    apk add squid --no-cache\n\n# 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问\nRUN sed  -i \"/RFC 4291/a acl ics src 2.2.2.0/24\" squid.conf; \\\n    sed  -i \"/RFC 4291/a acl ics src 2.2.3.3/32\" squid.conf\n\n# 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分\nRUN sed -i \"/http_port/c http_port 8888\" squid.conf\n\n# 开启cache\nRUN sed -i '/cache_dir/s/#//g' /etc/squid/squid.conf\n\n# 或者直接使用修改过的配置文件\n# ADD squid.conf /etc/squid/squid.conf\n\n# squid -z用于初始化，创建cache目录，但直接在Dockerfile中\n# RUN squid -z\n# 却无法创建cache目录，导致squid无法启动\n# 故将初始化和启动命令写入脚本中\n\nRUN echo -e '#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N' >/squid.sh; \\\n    chmod +x /squid.sh\n\nEXPOSE 3128\nCMD [\"/squid.sh\"]\n```\n\n构造镜像：`docker build ./ -t squid:latest`\n启动容器：`docker run -d -p 3128:3128 --name squid squid:latest`\n\n\n# 使用HTTP代理\n内网其它不能直接访问外网的机器可以设置使用`n147`提供的代理服务。\n\n## 全局的环境变量\n在`/etc/environment`（不需要`export`），`/etc/profile`或`/etc/profile.d/http_proxy.sh`导出`http_proxy`和`https_proxy`\n```\nexport http_proxy=http://2.2.2.147:3128\nexport https_proxy=http://2.2.2.147:3128\n```\n\n`squid`可以作为https代理，只要设置 `https_proxy=http://2.2.2.147:3128`， 即这个环境变量以`http://`开头。\n\n## Docker\nDocker需要[单独设置代理](https://docs.docker.com/engine/admin/systemd/)，新建文件`/etc/systemd/system/docker.service.d/http-proxy.conf`，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：\n```\n[Service]\nEnvironment=\"HTTP_PROXY=http://2.2.2.147:3128\" \"HTTPS_PROXY=http://2.2.2.147:3128\"  \"NO_PROXY=localhost,10.0.0.147\"\n```\n重启docker daemon： `systemctl restart docker`，执行`docker info`查看是否生效。\n\n## yum\nyum 会使用全局代理设置，也可以单独设置代理，在`/etc/yum.conf`中增加：\n```\nproxy=http://2.2.2.147:3128\n```\n\n## apt\n在文件`/etc/apt/apt.conf`中增加：\n```\nAcquire::http::proxy  \"http://2.2.2.147:3128\";\nAcquire::https::proxy \"http://2.2.2.147:3128\";\n```\n","source":"_posts/setup-squid-proxy.md","raw":"title: 设置及使用HTTP代理\ndate: 2017-04-14\ncategory: [misc]\ntags:\n\n---\n记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。\n<!--more-->\n\n<!-- TOC -->\n\n- [使用Squid提供HTTP代理](#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86)\n    - [主机上安装和设置Squid](#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid)\n    - [以Docker容器的方式运行Squid](#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid)\n- [使用HTTP代理](#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86)\n    - [全局的环境变量](#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n    - [Docker](#docker)\n    - [yum](#yum)\n    - [apt](#apt)\n\n<!-- /TOC -->\n\n# 使用Squid提供HTTP代理\n\n## 主机上安装和设置Squid\n作为网关的`n147`机器，公网IP是`2.2.2.147`。安装Squid，然后修改配置，启用服务。\n```\nyum install -y squid # CentOS\napt install -y squid # Ubuntu\napk add squid     # Alpine\n\n# squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile\n\n# 修改配置后，初始化squid的工作目录\nsquid -z\n\n# 启动服务\nsystemctl enable squid\nsystemctl start  squid\n```\n\n## 以Docker容器的方式运行Squid\nDockerfile内容如下：\n```\nFROM alpine:latest\n\nRUN apk update --no-cache; \\\n    apk add squid --no-cache\n\n# 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问\nRUN sed  -i \"/RFC 4291/a acl ics src 2.2.2.0/24\" squid.conf; \\\n    sed  -i \"/RFC 4291/a acl ics src 2.2.3.3/32\" squid.conf\n\n# 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分\nRUN sed -i \"/http_port/c http_port 8888\" squid.conf\n\n# 开启cache\nRUN sed -i '/cache_dir/s/#//g' /etc/squid/squid.conf\n\n# 或者直接使用修改过的配置文件\n# ADD squid.conf /etc/squid/squid.conf\n\n# squid -z用于初始化，创建cache目录，但直接在Dockerfile中\n# RUN squid -z\n# 却无法创建cache目录，导致squid无法启动\n# 故将初始化和启动命令写入脚本中\n\nRUN echo -e '#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N' >/squid.sh; \\\n    chmod +x /squid.sh\n\nEXPOSE 3128\nCMD [\"/squid.sh\"]\n```\n\n构造镜像：`docker build ./ -t squid:latest`\n启动容器：`docker run -d -p 3128:3128 --name squid squid:latest`\n\n\n# 使用HTTP代理\n内网其它不能直接访问外网的机器可以设置使用`n147`提供的代理服务。\n\n## 全局的环境变量\n在`/etc/environment`（不需要`export`），`/etc/profile`或`/etc/profile.d/http_proxy.sh`导出`http_proxy`和`https_proxy`\n```\nexport http_proxy=http://2.2.2.147:3128\nexport https_proxy=http://2.2.2.147:3128\n```\n\n`squid`可以作为https代理，只要设置 `https_proxy=http://2.2.2.147:3128`， 即这个环境变量以`http://`开头。\n\n## Docker\nDocker需要[单独设置代理](https://docs.docker.com/engine/admin/systemd/)，新建文件`/etc/systemd/system/docker.service.d/http-proxy.conf`，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：\n```\n[Service]\nEnvironment=\"HTTP_PROXY=http://2.2.2.147:3128\" \"HTTPS_PROXY=http://2.2.2.147:3128\"  \"NO_PROXY=localhost,10.0.0.147\"\n```\n重启docker daemon： `systemctl restart docker`，执行`docker info`查看是否生效。\n\n## yum\nyum 会使用全局代理设置，也可以单独设置代理，在`/etc/yum.conf`中增加：\n```\nproxy=http://2.2.2.147:3128\n```\n\n## apt\n在文件`/etc/apt/apt.conf`中增加：\n```\nAcquire::http::proxy  \"http://2.2.2.147:3128\";\nAcquire::https::proxy \"http://2.2.2.147:3128\";\n```\n","slug":"setup-squid-proxy","published":1,"updated":"2017-10-30T02:47:23.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8h180004n84foej5oi5z","content":"<p>记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86\">使用Squid提供HTTP代理</a><ul>\n<li><a href=\"#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid\">主机上安装和设置Squid</a></li>\n<li><a href=\"#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid\">以Docker容器的方式运行Squid</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86\">使用HTTP代理</a><ul>\n<li><a href=\"#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">全局的环境变量</a></li>\n<li><a href=\"#docker\">Docker</a></li>\n<li><a href=\"#yum\">yum</a></li>\n<li><a href=\"#apt\">apt</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"使用Squid提供HTTP代理\"><a href=\"#使用Squid提供HTTP代理\" class=\"headerlink\" title=\"使用Squid提供HTTP代理\"></a>使用Squid提供HTTP代理</h1><h2 id=\"主机上安装和设置Squid\"><a href=\"#主机上安装和设置Squid\" class=\"headerlink\" title=\"主机上安装和设置Squid\"></a>主机上安装和设置Squid</h2><p>作为网关的<code>n147</code>机器，公网IP是<code>2.2.2.147</code>。安装Squid，然后修改配置，启用服务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y squid # CentOS</div><div class=\"line\">apt install -y squid # Ubuntu</div><div class=\"line\">apk add squid     # Alpine</div><div class=\"line\"></div><div class=\"line\"># squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile</div><div class=\"line\"></div><div class=\"line\"># 修改配置后，初始化squid的工作目录</div><div class=\"line\">squid -z</div><div class=\"line\"></div><div class=\"line\"># 启动服务</div><div class=\"line\">systemctl enable squid</div><div class=\"line\">systemctl start  squid</div></pre></td></tr></table></figure></p>\n<h2 id=\"以Docker容器的方式运行Squid\"><a href=\"#以Docker容器的方式运行Squid\" class=\"headerlink\" title=\"以Docker容器的方式运行Squid\"></a>以Docker容器的方式运行Squid</h2><p>Dockerfile内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM alpine:latest</div><div class=\"line\"></div><div class=\"line\">RUN apk update --no-cache; \\</div><div class=\"line\">    apk add squid --no-cache</div><div class=\"line\"></div><div class=\"line\"># 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问</div><div class=\"line\">RUN sed  -i &quot;/RFC 4291/a acl ics src 2.2.2.0/24&quot; squid.conf; \\</div><div class=\"line\">    sed  -i &quot;/RFC 4291/a acl ics src 2.2.3.3/32&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分</div><div class=\"line\">RUN sed -i &quot;/http_port/c http_port 8888&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 开启cache</div><div class=\"line\">RUN sed -i &apos;/cache_dir/s/#//g&apos; /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># 或者直接使用修改过的配置文件</div><div class=\"line\"># ADD squid.conf /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># squid -z用于初始化，创建cache目录，但直接在Dockerfile中</div><div class=\"line\"># RUN squid -z</div><div class=\"line\"># 却无法创建cache目录，导致squid无法启动</div><div class=\"line\"># 故将初始化和启动命令写入脚本中</div><div class=\"line\"></div><div class=\"line\">RUN echo -e &apos;#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N&apos; &gt;/squid.sh; \\</div><div class=\"line\">    chmod +x /squid.sh</div><div class=\"line\"></div><div class=\"line\">EXPOSE 3128</div><div class=\"line\">CMD [&quot;/squid.sh&quot;]</div></pre></td></tr></table></figure></p>\n<p>构造镜像：<code>docker build ./ -t squid:latest</code><br>启动容器：<code>docker run -d -p 3128:3128 --name squid squid:latest</code></p>\n<h1 id=\"使用HTTP代理\"><a href=\"#使用HTTP代理\" class=\"headerlink\" title=\"使用HTTP代理\"></a>使用HTTP代理</h1><p>内网其它不能直接访问外网的机器可以设置使用<code>n147</code>提供的代理服务。</p>\n<h2 id=\"全局的环境变量\"><a href=\"#全局的环境变量\" class=\"headerlink\" title=\"全局的环境变量\"></a>全局的环境变量</h2><p>在<code>/etc/environment</code>（不需要<code>export</code>），<code>/etc/profile</code>或<code>/etc/profile.d/http_proxy.sh</code>导出<code>http_proxy</code>和<code>https_proxy</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export http_proxy=http://2.2.2.147:3128</div><div class=\"line\">export https_proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<p><code>squid</code>可以作为https代理，只要设置 <code>https_proxy=http://2.2.2.147:3128</code>， 即这个环境变量以<code>http://</code>开头。</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>Docker需要<a href=\"https://docs.docker.com/engine/admin/systemd/\" target=\"_blank\" rel=\"external\">单独设置代理</a>，新建文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Service]</div><div class=\"line\">Environment=&quot;HTTP_PROXY=http://2.2.2.147:3128&quot; &quot;HTTPS_PROXY=http://2.2.2.147:3128&quot;  &quot;NO_PROXY=localhost,10.0.0.147&quot;</div></pre></td></tr></table></figure></p>\n<p>重启docker daemon： <code>systemctl restart docker</code>，执行<code>docker info</code>查看是否生效。</p>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>yum 会使用全局代理设置，也可以单独设置代理，在<code>/etc/yum.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<h2 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h2><p>在文件<code>/etc/apt/apt.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Acquire::http::proxy  &quot;http://2.2.2.147:3128&quot;;</div><div class=\"line\">Acquire::https::proxy &quot;http://2.2.2.147:3128&quot;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86\">使用Squid提供HTTP代理</a><ul>\n<li><a href=\"#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid\">主机上安装和设置Squid</a></li>\n<li><a href=\"#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid\">以Docker容器的方式运行Squid</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86\">使用HTTP代理</a><ul>\n<li><a href=\"#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">全局的环境变量</a></li>\n<li><a href=\"#docker\">Docker</a></li>\n<li><a href=\"#yum\">yum</a></li>\n<li><a href=\"#apt\">apt</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"使用Squid提供HTTP代理\"><a href=\"#使用Squid提供HTTP代理\" class=\"headerlink\" title=\"使用Squid提供HTTP代理\"></a>使用Squid提供HTTP代理</h1><h2 id=\"主机上安装和设置Squid\"><a href=\"#主机上安装和设置Squid\" class=\"headerlink\" title=\"主机上安装和设置Squid\"></a>主机上安装和设置Squid</h2><p>作为网关的<code>n147</code>机器，公网IP是<code>2.2.2.147</code>。安装Squid，然后修改配置，启用服务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y squid # CentOS</div><div class=\"line\">apt install -y squid # Ubuntu</div><div class=\"line\">apk add squid     # Alpine</div><div class=\"line\"></div><div class=\"line\"># squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile</div><div class=\"line\"></div><div class=\"line\"># 修改配置后，初始化squid的工作目录</div><div class=\"line\">squid -z</div><div class=\"line\"></div><div class=\"line\"># 启动服务</div><div class=\"line\">systemctl enable squid</div><div class=\"line\">systemctl start  squid</div></pre></td></tr></table></figure></p>\n<h2 id=\"以Docker容器的方式运行Squid\"><a href=\"#以Docker容器的方式运行Squid\" class=\"headerlink\" title=\"以Docker容器的方式运行Squid\"></a>以Docker容器的方式运行Squid</h2><p>Dockerfile内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM alpine:latest</div><div class=\"line\"></div><div class=\"line\">RUN apk update --no-cache; \\</div><div class=\"line\">    apk add squid --no-cache</div><div class=\"line\"></div><div class=\"line\"># 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问</div><div class=\"line\">RUN sed  -i &quot;/RFC 4291/a acl ics src 2.2.2.0/24&quot; squid.conf; \\</div><div class=\"line\">    sed  -i &quot;/RFC 4291/a acl ics src 2.2.3.3/32&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分</div><div class=\"line\">RUN sed -i &quot;/http_port/c http_port 8888&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 开启cache</div><div class=\"line\">RUN sed -i &apos;/cache_dir/s/#//g&apos; /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># 或者直接使用修改过的配置文件</div><div class=\"line\"># ADD squid.conf /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># squid -z用于初始化，创建cache目录，但直接在Dockerfile中</div><div class=\"line\"># RUN squid -z</div><div class=\"line\"># 却无法创建cache目录，导致squid无法启动</div><div class=\"line\"># 故将初始化和启动命令写入脚本中</div><div class=\"line\"></div><div class=\"line\">RUN echo -e &apos;#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N&apos; &gt;/squid.sh; \\</div><div class=\"line\">    chmod +x /squid.sh</div><div class=\"line\"></div><div class=\"line\">EXPOSE 3128</div><div class=\"line\">CMD [&quot;/squid.sh&quot;]</div></pre></td></tr></table></figure></p>\n<p>构造镜像：<code>docker build ./ -t squid:latest</code><br>启动容器：<code>docker run -d -p 3128:3128 --name squid squid:latest</code></p>\n<h1 id=\"使用HTTP代理\"><a href=\"#使用HTTP代理\" class=\"headerlink\" title=\"使用HTTP代理\"></a>使用HTTP代理</h1><p>内网其它不能直接访问外网的机器可以设置使用<code>n147</code>提供的代理服务。</p>\n<h2 id=\"全局的环境变量\"><a href=\"#全局的环境变量\" class=\"headerlink\" title=\"全局的环境变量\"></a>全局的环境变量</h2><p>在<code>/etc/environment</code>（不需要<code>export</code>），<code>/etc/profile</code>或<code>/etc/profile.d/http_proxy.sh</code>导出<code>http_proxy</code>和<code>https_proxy</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export http_proxy=http://2.2.2.147:3128</div><div class=\"line\">export https_proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<p><code>squid</code>可以作为https代理，只要设置 <code>https_proxy=http://2.2.2.147:3128</code>， 即这个环境变量以<code>http://</code>开头。</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>Docker需要<a href=\"https://docs.docker.com/engine/admin/systemd/\" target=\"_blank\" rel=\"external\">单独设置代理</a>，新建文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Service]</div><div class=\"line\">Environment=&quot;HTTP_PROXY=http://2.2.2.147:3128&quot; &quot;HTTPS_PROXY=http://2.2.2.147:3128&quot;  &quot;NO_PROXY=localhost,10.0.0.147&quot;</div></pre></td></tr></table></figure></p>\n<p>重启docker daemon： <code>systemctl restart docker</code>，执行<code>docker info</code>查看是否生效。</p>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>yum 会使用全局代理设置，也可以单独设置代理，在<code>/etc/yum.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<h2 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h2><p>在文件<code>/etc/apt/apt.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Acquire::http::proxy  &quot;http://2.2.2.147:3128&quot;;</div><div class=\"line\">Acquire::https::proxy &quot;http://2.2.2.147:3128&quot;;</div></pre></td></tr></table></figure></p>"},{"title":"CentOS 7 及 Ubuntu 16.04 设置 NAT 网络","date":"2017-04-14T16:00:00.000Z","_content":"记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。\n<!--more-->\n\n<!-- TOC -->\n\n- [CentOS 7 设置和使用NAT](#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [NAT网关的设置](#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置`iptables`规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它 CentOS 7 机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n        - [切换默认网关](#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3)\n        - [为`em1`添加静态路由](#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1)\n- [Ubuntu 16.04 设置和使用NAT](#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [设置NAT](#%E8%AE%BE%E7%BD%AEnat)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置iptables规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n- [其它问题](#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98)\n    - [禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题](#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [取消原来设置的http代理](#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86)\n- [PS: 使用 SSH 隧道](#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93)\n\n<!-- /TOC -->\n\n小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。\n+ 一个LAN是学校的公网IP（下文记为`2.2.2.0/24`网段）。装好CentOS 7系统后，`em1`网卡在公网LAN，可以在校内直接访问`em1`的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。\n+ 另一个LAN是用于远程管理的机房内私网IP（下文记为`10.0.0.0/24`网段），`em2`网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是`10.0.0.1`。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。\n\n一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。\n\n# CentOS 7 设置和使用NAT\n虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个`147`的公网IP（记对应的机器是`n147`）直通校外网。\n之前是通过在`n147`上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将`n147`的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，`n147`就像一个软件实现的家用路由器。\n## NAT网关的设置\n作为网关的机器名是`n147`，公网IP是`2.2.2.147/24`，对应`em1`网卡；私网IP是`10.0.0.147/24`，对应`em2`网卡。\n\n### 允许IP转发\n其它机器从`10.0.0.0/24`网段发送的数据包会被`em2`网卡接收，如果目标IP是外网，需要交给`em1`网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：\n```\n# 查看是否启用IP转发，如果是0则没有开启，是1则已经开启\ncat /proc/sys/net/ipv4/ip_forward\n\n# 可以修改上述文件的值来改变设置，但重启后会恢复默认值。\n# 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf\n# 内容为\nnet.ipv4.ip_forward = 1\n```\n\n### 设置`iptables`规则\n安装必要软件并启用服务：\n```\nyum install -y net-tools iproute iptables iptables-services\nsystemctl disable firewalld\nsystemctl stop firewalld\nsystemctl enable iptables\n```\n\n>`net-tools`这个程序包有 `ifconfig`，`netstat`，`route`等命令，而`iproute2`（rpm包名为`iproute`）包括`tc`，`ip`，`ss`等命令，是`net-tools`的改进。\n\n通过`iptables`命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用`iptables-save`命令输出，然后保存起来。\n这里直接使用`iptables-save`生成的配置项，保存到配置文件 `/etc/sysconfig/iptables`，内容如下：\n```\n# Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017\n*nat\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n-A POSTROUTING -o em1 -j MASQUERADE  \nCOMMIT\n\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT\n-A FORWARD -i em2 -j ACCEPT\nCOMMIT\n```\n\n其中涉及NAT转发的是`-A POSTROUTING -o em1 -j MASQUERADE ` 和 `-A FORWARD -i em2 -j ACCEPT`。\n此外还删除了原来禁止`ping`的规则：\n`-A INPUT -j REJECT --reject-with icmp-host-prohibited`\n`\u000b-A FORWARD -j REJECT --reject-with icmp-host-prohibited`\n\n重启`iptables`服务`systemctl restart iptables`。\n\n>可以修改`/etc/sysconfig/iptables-config` 配置文件，设置下面三个选项均为`yes`来自动保存`iptables`规则\n+ `IPTABLES_MODULES_UNLOAD=\"yes\"`\n+ `IPTABLES_SAVE_ON_STOP=\"yes\"`\n+ `IPTABLES_SAVE_ON_RESTART=\"yes\"`\n\n>参考\n+ [保存iptable规则并开机自动加载](http://salogs.com/news/2015/08/20/iptables-save/)\n+ [iptables用法初解](http://blog.csdn.net/hepeng597/article/details/8270138)\n\n## 设置其它 CentOS 7 机器使用NAT网络\n### 切换默认网关\n安装系统后，默认网关是`em1`所在LAN的`2.2.2.1`，需要将其更改为`em2`所在LAN的`10.0.0.147`，修改如下的网卡配置文件：\n```\n# /etc/sysconfig/network-scripts/ifcfg-em1\nDEFROUTE=no\n\n# /etc/sysconfig/network-scripts/ifcfg-em2\nDEFROUTE=yes\n# ...\nGATEWAY=10.0.0.147\nDNS1=233.5.5.5\nDNS2=223.6.6.6\n```\n\n其中`em2`的网关即刚才配置的`n147`的私网IP，由于没有在`n147`上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置`dnsmasq`等DNS服务器。\n### 为`em1`添加静态路由\n修改默认网关后，查看路由表，\n```\n# route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2\n10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2\n2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n发现从`em1`收发的数据包也要经过默认网关`10.0.0.147`，而这个网关在机房的私网内，**外部不能直接访问，导致外部无法公网IP访问服务器**。为此，需要为`em1`添加静态路由，不走`10.0.0.147`，新建文件`/etc/sysconfig/network-scripts/route-em1`，内容如下：\n```\n2.2.0.0/16    via 2.2.2.1\n172.0.0.0/8   via 2.2.2.1\n```\n\n其中\n+ `2.2.0.0/16`网段是学校 **有线** 网络的IP网段\n+ `172.0.0.0/8`网段是学校 **无线** 网络的IP网段。\n>注意\n+ `docker0`网桥默认也是B类私网的`172.x.0.0/16`网段，但其路由项更具体，所以[不会造成冲突](http://answ.me/post/configure-docker-subnet/)。\n+ `docker0`网桥实际也工作在NAT模式，也需要开启IP转发。\n\n重启网络，更新配置，`systemctl restart network`。\n\n> 参考：[Two Default Gateways on One System](https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System)\n\n# Ubuntu 16.04 设置和使用NAT\n\nUbuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！\n因为用到的工具都是`net-tools`，`iproute`和`iptables`这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。\n## 设置NAT\n\n### 允许IP转发\n直接修改系统配置文件 `/etc/sysctl.conf`，里面已经有支持的配置项，取消`net.ipv4.ip_forward = 1`的注释即可。\n\n### 设置iptables规则\n还是使用的`iptables`，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是`em1`，`em2`，Ubuntu 16.04下是`eno1`，`eno2`，所以要把规则中对应的网卡名改过来。\n\n然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考[IptablesHowTo - Ubuntu wiki](https://help.ubuntu.com/community/IptablesHowTo)，，**随便把规则保存到哪，反正系统不会自动加载**，需要自己添加一个启动脚本。\n因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 `/etc/network/if-pre-up.d/iptablesload`，内容如下，\n```\n#!/bin/sh\niptables-restore < /etc/iptables.rules\nexit 0\n```\n\n可见`/etc/iptables.rules`是保存的`iptables`规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。**但是，你要自己来写这个脚本**。\n\n编辑好`/etc/iptables.rules` 和 `/etc/network/if-pre-up.d/iptablesload`之后，重启网络服务。\n\n虽然都是用`systemd`来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是`network.service`，而Ubuntu则是`networking.service`。\n执行命令`sudo systemctl restart networking`，重启网络服务。不过，其实我们是用`iptables`来实现的NAT，而不是`networking.service`相关服务，不过由于上面的那个脚本`iptablesload`会在网卡启动之前被执行，所以顺便完成了我们的目标。\n\n## 设置其它机器使用NAT网络\n\n同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在`/etc/network/interface`这个文件里，这个倒是方便了—— **[如果面对空空的配置文件，你能猜到各配置项是什么的时候](https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server)**。\n好在安装系统的时候设置了网卡，给`eno2`生成了一些配置项可以参考。修改后的内容如下。\n```\nauto lo\niface lo inet loopback\n\nauto eno1\niface eno1 inet static\n  address 2.2.2.140\n  netmask 255.255.255.0\n  network 2.2.2.0\n  broadcast 2.2.2.255\n  # gateway 2.2.2.1\n  up ip route add 2.2.0.0/16   via 2.2.2.1 || true\n  up ip route add 2.2.2.0/24   via 2.2.2.1 || true\n  up ip route add 172.0.0.0/8  via 2.2.2.1 || true\n\n# The primary network interface\nauto eno2\niface eno2 inet static\n  address 10.0.0.140\n  netmask 255.255.255.0\n  network 10.0.0.0\n  broadcast 10.0.0.255\n  gateway 10.0.0.147\n  # dns-* options are implemented by the resolvconf package, if installed\n  dns-nameservers 233.5.5.5\n```\n>注意\n+ 不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了`gateway`就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个`gateway`项。\n+ `up ip route add 2.2.0.0/16   via 2.2.2.1 || true`其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句`up echo helloworld`也没问题。后面的`|| true`是让脚本执行时忽略可能的错误，继续执行。这里使用的是`ip`命令，如果使用`route`命令，效果也是一样的，前提是已经安装了`net-tools`或`iproute`软件包。使用`netmask`和`CIDR`格式都可以。\n+ 哪个网卡的路由就写到对应的网卡下，这样执行`ifup eno1`这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。\n\n执行命令`sudo systemctl restart networking`，重启网络服务。\n查看一下更新后的路由表，\n```\n# route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2\n10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2\n2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1\n2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1\n172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1\n```\n\n注意倒数第二行：`2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1`，这个是自动添加的。\n它的网关并不是`2.2.2.1`，即便在`interface`中强制器网关为`2.2.2.1`，也会被改为`0.0.0.0`。因为`2.2.2.0/24`是本LAN的数据包，经`ARP`协议获得目标的`MAC`地址后，会被直接发到目标地址，而不会经网关`2.2.2.1`转发，虽然路由表中默认网关是`0.0.0.0`，也不会按路由表转发到`10.0.0.147`。\n\n# 其它问题\n下面的问题是在除NAT网关外的其它机器上设置的。\n\n## 禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\n修改默认网关，添加路由之后，虽然可以从外部通过公网IP `ping`通机房内的机器，但`ssh`登录过程需要等待很长时间。\n参考[ssh连接的时候很慢，ping的速度非常好](http://blog.itpub.net/7345798/viewspace-1055461/)这篇文章，修改各机器上`sshd`的选项如下：\n```\nsed -i \"'s/.*UseDNS.*/UseDNS no/g'\" /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## 取消原来设置的http代理\n注释掉配置文件中`http_proxy`和`https_proxy`环境变量的声明，并执行\n```\nunset http_proxy\nunset https_proxy\n```\n\n# PS: 使用 SSH 隧道\n一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。\n以Windows客户端为例，安装了Windows版的`git`后，会附带一些`mingw`命令程序（不是完整的`mingw`），首先将这些命令的可执行文件所在路径添加到`Path`环境变量，比如是`E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin`，然后就可以在Windows命令行使用这些命令了。其中就有`ssh.exe`。\n在Windows命令行窗口执行\n```\nssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147\n```\n\n这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口`127.0.0.1:1088`。**如果需要停止SSH隧道，关闭该命令窗口即可**。\n因为我在Windows的`C:\\Windows\\System32\\drivers\\etc\\hosts`文件中添加了`n147`的项，所以可以直接输入名字而不必是IP地址。\n\n在IE或控制面板打开`Internet选项`，\n+ 在`连接`选项卡单击`局域网设置`按钮，\n+ 在弹出的对话框勾选`为LAN使用代理服务器`，然后单击`高级`，\n+ 在弹出的对话框取消勾选`对所有协议使用相同的代理服务器`，然后在`套接字`对应的文本框填入`127.0.0.1`和上面命令中监听的端口号`1088`，\n+ 在`例外`文本框中删掉`10.*0;`的内容，然后一路确定关闭所有对话框。\n这时应该可以用IE或Chrome访问机房内网的iDRAC。**如果需要正常访问网页，需要取消勾选`为LAN使用代理服务器`**。\n\n![](/img/sock5-proxy.png)\n","source":"_posts/setup-nat-x-route.md","raw":"title: CentOS 7 及 Ubuntu 16.04 设置 NAT 网络\ndate: 2017-04-15\ncategory: [misc]\ntags:\n\n---\n记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。\n<!--more-->\n\n<!-- TOC -->\n\n- [CentOS 7 设置和使用NAT](#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [NAT网关的设置](#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置`iptables`规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它 CentOS 7 机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n        - [切换默认网关](#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3)\n        - [为`em1`添加静态路由](#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1)\n- [Ubuntu 16.04 设置和使用NAT](#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [设置NAT](#%E8%AE%BE%E7%BD%AEnat)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置iptables规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n- [其它问题](#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98)\n    - [禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题](#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [取消原来设置的http代理](#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86)\n- [PS: 使用 SSH 隧道](#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93)\n\n<!-- /TOC -->\n\n小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。\n+ 一个LAN是学校的公网IP（下文记为`2.2.2.0/24`网段）。装好CentOS 7系统后，`em1`网卡在公网LAN，可以在校内直接访问`em1`的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。\n+ 另一个LAN是用于远程管理的机房内私网IP（下文记为`10.0.0.0/24`网段），`em2`网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是`10.0.0.1`。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。\n\n一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。\n\n# CentOS 7 设置和使用NAT\n虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个`147`的公网IP（记对应的机器是`n147`）直通校外网。\n之前是通过在`n147`上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将`n147`的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，`n147`就像一个软件实现的家用路由器。\n## NAT网关的设置\n作为网关的机器名是`n147`，公网IP是`2.2.2.147/24`，对应`em1`网卡；私网IP是`10.0.0.147/24`，对应`em2`网卡。\n\n### 允许IP转发\n其它机器从`10.0.0.0/24`网段发送的数据包会被`em2`网卡接收，如果目标IP是外网，需要交给`em1`网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：\n```\n# 查看是否启用IP转发，如果是0则没有开启，是1则已经开启\ncat /proc/sys/net/ipv4/ip_forward\n\n# 可以修改上述文件的值来改变设置，但重启后会恢复默认值。\n# 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf\n# 内容为\nnet.ipv4.ip_forward = 1\n```\n\n### 设置`iptables`规则\n安装必要软件并启用服务：\n```\nyum install -y net-tools iproute iptables iptables-services\nsystemctl disable firewalld\nsystemctl stop firewalld\nsystemctl enable iptables\n```\n\n>`net-tools`这个程序包有 `ifconfig`，`netstat`，`route`等命令，而`iproute2`（rpm包名为`iproute`）包括`tc`，`ip`，`ss`等命令，是`net-tools`的改进。\n\n通过`iptables`命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用`iptables-save`命令输出，然后保存起来。\n这里直接使用`iptables-save`生成的配置项，保存到配置文件 `/etc/sysconfig/iptables`，内容如下：\n```\n# Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017\n*nat\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n-A POSTROUTING -o em1 -j MASQUERADE  \nCOMMIT\n\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT\n-A FORWARD -i em2 -j ACCEPT\nCOMMIT\n```\n\n其中涉及NAT转发的是`-A POSTROUTING -o em1 -j MASQUERADE ` 和 `-A FORWARD -i em2 -j ACCEPT`。\n此外还删除了原来禁止`ping`的规则：\n`-A INPUT -j REJECT --reject-with icmp-host-prohibited`\n`\u000b-A FORWARD -j REJECT --reject-with icmp-host-prohibited`\n\n重启`iptables`服务`systemctl restart iptables`。\n\n>可以修改`/etc/sysconfig/iptables-config` 配置文件，设置下面三个选项均为`yes`来自动保存`iptables`规则\n+ `IPTABLES_MODULES_UNLOAD=\"yes\"`\n+ `IPTABLES_SAVE_ON_STOP=\"yes\"`\n+ `IPTABLES_SAVE_ON_RESTART=\"yes\"`\n\n>参考\n+ [保存iptable规则并开机自动加载](http://salogs.com/news/2015/08/20/iptables-save/)\n+ [iptables用法初解](http://blog.csdn.net/hepeng597/article/details/8270138)\n\n## 设置其它 CentOS 7 机器使用NAT网络\n### 切换默认网关\n安装系统后，默认网关是`em1`所在LAN的`2.2.2.1`，需要将其更改为`em2`所在LAN的`10.0.0.147`，修改如下的网卡配置文件：\n```\n# /etc/sysconfig/network-scripts/ifcfg-em1\nDEFROUTE=no\n\n# /etc/sysconfig/network-scripts/ifcfg-em2\nDEFROUTE=yes\n# ...\nGATEWAY=10.0.0.147\nDNS1=233.5.5.5\nDNS2=223.6.6.6\n```\n\n其中`em2`的网关即刚才配置的`n147`的私网IP，由于没有在`n147`上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置`dnsmasq`等DNS服务器。\n### 为`em1`添加静态路由\n修改默认网关后，查看路由表，\n```\n# route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2\n10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2\n2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n发现从`em1`收发的数据包也要经过默认网关`10.0.0.147`，而这个网关在机房的私网内，**外部不能直接访问，导致外部无法公网IP访问服务器**。为此，需要为`em1`添加静态路由，不走`10.0.0.147`，新建文件`/etc/sysconfig/network-scripts/route-em1`，内容如下：\n```\n2.2.0.0/16    via 2.2.2.1\n172.0.0.0/8   via 2.2.2.1\n```\n\n其中\n+ `2.2.0.0/16`网段是学校 **有线** 网络的IP网段\n+ `172.0.0.0/8`网段是学校 **无线** 网络的IP网段。\n>注意\n+ `docker0`网桥默认也是B类私网的`172.x.0.0/16`网段，但其路由项更具体，所以[不会造成冲突](http://answ.me/post/configure-docker-subnet/)。\n+ `docker0`网桥实际也工作在NAT模式，也需要开启IP转发。\n\n重启网络，更新配置，`systemctl restart network`。\n\n> 参考：[Two Default Gateways on One System](https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System)\n\n# Ubuntu 16.04 设置和使用NAT\n\nUbuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！\n因为用到的工具都是`net-tools`，`iproute`和`iptables`这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。\n## 设置NAT\n\n### 允许IP转发\n直接修改系统配置文件 `/etc/sysctl.conf`，里面已经有支持的配置项，取消`net.ipv4.ip_forward = 1`的注释即可。\n\n### 设置iptables规则\n还是使用的`iptables`，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是`em1`，`em2`，Ubuntu 16.04下是`eno1`，`eno2`，所以要把规则中对应的网卡名改过来。\n\n然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考[IptablesHowTo - Ubuntu wiki](https://help.ubuntu.com/community/IptablesHowTo)，，**随便把规则保存到哪，反正系统不会自动加载**，需要自己添加一个启动脚本。\n因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 `/etc/network/if-pre-up.d/iptablesload`，内容如下，\n```\n#!/bin/sh\niptables-restore < /etc/iptables.rules\nexit 0\n```\n\n可见`/etc/iptables.rules`是保存的`iptables`规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。**但是，你要自己来写这个脚本**。\n\n编辑好`/etc/iptables.rules` 和 `/etc/network/if-pre-up.d/iptablesload`之后，重启网络服务。\n\n虽然都是用`systemd`来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是`network.service`，而Ubuntu则是`networking.service`。\n执行命令`sudo systemctl restart networking`，重启网络服务。不过，其实我们是用`iptables`来实现的NAT，而不是`networking.service`相关服务，不过由于上面的那个脚本`iptablesload`会在网卡启动之前被执行，所以顺便完成了我们的目标。\n\n## 设置其它机器使用NAT网络\n\n同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在`/etc/network/interface`这个文件里，这个倒是方便了—— **[如果面对空空的配置文件，你能猜到各配置项是什么的时候](https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server)**。\n好在安装系统的时候设置了网卡，给`eno2`生成了一些配置项可以参考。修改后的内容如下。\n```\nauto lo\niface lo inet loopback\n\nauto eno1\niface eno1 inet static\n  address 2.2.2.140\n  netmask 255.255.255.0\n  network 2.2.2.0\n  broadcast 2.2.2.255\n  # gateway 2.2.2.1\n  up ip route add 2.2.0.0/16   via 2.2.2.1 || true\n  up ip route add 2.2.2.0/24   via 2.2.2.1 || true\n  up ip route add 172.0.0.0/8  via 2.2.2.1 || true\n\n# The primary network interface\nauto eno2\niface eno2 inet static\n  address 10.0.0.140\n  netmask 255.255.255.0\n  network 10.0.0.0\n  broadcast 10.0.0.255\n  gateway 10.0.0.147\n  # dns-* options are implemented by the resolvconf package, if installed\n  dns-nameservers 233.5.5.5\n```\n>注意\n+ 不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了`gateway`就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个`gateway`项。\n+ `up ip route add 2.2.0.0/16   via 2.2.2.1 || true`其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句`up echo helloworld`也没问题。后面的`|| true`是让脚本执行时忽略可能的错误，继续执行。这里使用的是`ip`命令，如果使用`route`命令，效果也是一样的，前提是已经安装了`net-tools`或`iproute`软件包。使用`netmask`和`CIDR`格式都可以。\n+ 哪个网卡的路由就写到对应的网卡下，这样执行`ifup eno1`这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。\n\n执行命令`sudo systemctl restart networking`，重启网络服务。\n查看一下更新后的路由表，\n```\n# route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2\n10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2\n2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1\n2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1\n172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1\n```\n\n注意倒数第二行：`2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1`，这个是自动添加的。\n它的网关并不是`2.2.2.1`，即便在`interface`中强制器网关为`2.2.2.1`，也会被改为`0.0.0.0`。因为`2.2.2.0/24`是本LAN的数据包，经`ARP`协议获得目标的`MAC`地址后，会被直接发到目标地址，而不会经网关`2.2.2.1`转发，虽然路由表中默认网关是`0.0.0.0`，也不会按路由表转发到`10.0.0.147`。\n\n# 其它问题\n下面的问题是在除NAT网关外的其它机器上设置的。\n\n## 禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\n修改默认网关，添加路由之后，虽然可以从外部通过公网IP `ping`通机房内的机器，但`ssh`登录过程需要等待很长时间。\n参考[ssh连接的时候很慢，ping的速度非常好](http://blog.itpub.net/7345798/viewspace-1055461/)这篇文章，修改各机器上`sshd`的选项如下：\n```\nsed -i \"'s/.*UseDNS.*/UseDNS no/g'\" /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## 取消原来设置的http代理\n注释掉配置文件中`http_proxy`和`https_proxy`环境变量的声明，并执行\n```\nunset http_proxy\nunset https_proxy\n```\n\n# PS: 使用 SSH 隧道\n一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。\n以Windows客户端为例，安装了Windows版的`git`后，会附带一些`mingw`命令程序（不是完整的`mingw`），首先将这些命令的可执行文件所在路径添加到`Path`环境变量，比如是`E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin`，然后就可以在Windows命令行使用这些命令了。其中就有`ssh.exe`。\n在Windows命令行窗口执行\n```\nssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147\n```\n\n这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口`127.0.0.1:1088`。**如果需要停止SSH隧道，关闭该命令窗口即可**。\n因为我在Windows的`C:\\Windows\\System32\\drivers\\etc\\hosts`文件中添加了`n147`的项，所以可以直接输入名字而不必是IP地址。\n\n在IE或控制面板打开`Internet选项`，\n+ 在`连接`选项卡单击`局域网设置`按钮，\n+ 在弹出的对话框勾选`为LAN使用代理服务器`，然后单击`高级`，\n+ 在弹出的对话框取消勾选`对所有协议使用相同的代理服务器`，然后在`套接字`对应的文本框填入`127.0.0.1`和上面命令中监听的端口号`1088`，\n+ 在`例外`文本框中删掉`10.*0;`的内容，然后一路确定关闭所有对话框。\n这时应该可以用IE或Chrome访问机房内网的iDRAC。**如果需要正常访问网页，需要取消勾选`为LAN使用代理服务器`**。\n\n![](/img/sock5-proxy.png)\n","slug":"setup-nat-x-route","published":1,"updated":"2017-10-30T03:42:06.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8uaz0000344ft0eq2ti0","content":"<p>记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">CentOS 7 设置和使用NAT</a><ul>\n<li><a href=\"#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE\">NAT网关的设置</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置<code>iptables</code>规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它 CentOS 7 机器使用NAT网络</a><ul>\n<li><a href=\"#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3\">切换默认网关</a></li>\n<li><a href=\"#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1\">为<code>em1</code>添加静态路由</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">Ubuntu 16.04 设置和使用NAT</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEnat\">设置NAT</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置iptables规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它机器使用NAT网络</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98\">其它问题</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98\">禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</a></li>\n<li><a href=\"#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86\">取消原来设置的http代理</a></li>\n</ul>\n</li>\n<li><a href=\"#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93\">PS: 使用 SSH 隧道</a></li>\n</ul>\n<!-- /TOC -->\n<p>小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。</p>\n<ul>\n<li>一个LAN是学校的公网IP（下文记为<code>2.2.2.0/24</code>网段）。装好CentOS 7系统后，<code>em1</code>网卡在公网LAN，可以在校内直接访问<code>em1</code>的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。</li>\n<li>另一个LAN是用于远程管理的机房内私网IP（下文记为<code>10.0.0.0/24</code>网段），<code>em2</code>网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是<code>10.0.0.1</code>。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。</li>\n</ul>\n<p>一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。</p>\n<h1 id=\"CentOS-7-设置和使用NAT\"><a href=\"#CentOS-7-设置和使用NAT\" class=\"headerlink\" title=\"CentOS 7 设置和使用NAT\"></a>CentOS 7 设置和使用NAT</h1><p>虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个<code>147</code>的公网IP（记对应的机器是<code>n147</code>）直通校外网。<br>之前是通过在<code>n147</code>上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将<code>n147</code>的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，<code>n147</code>就像一个软件实现的家用路由器。</p>\n<h2 id=\"NAT网关的设置\"><a href=\"#NAT网关的设置\" class=\"headerlink\" title=\"NAT网关的设置\"></a>NAT网关的设置</h2><p>作为网关的机器名是<code>n147</code>，公网IP是<code>2.2.2.147/24</code>，对应<code>em1</code>网卡；私网IP是<code>10.0.0.147/24</code>，对应<code>em2</code>网卡。</p>\n<h3 id=\"允许IP转发\"><a href=\"#允许IP转发\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>其它机器从<code>10.0.0.0/24</code>网段发送的数据包会被<code>em2</code>网卡接收，如果目标IP是外网，需要交给<code>em1</code>网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 查看是否启用IP转发，如果是0则没有开启，是1则已经开启</div><div class=\"line\">cat /proc/sys/net/ipv4/ip_forward</div><div class=\"line\"></div><div class=\"line\"># 可以修改上述文件的值来改变设置，但重启后会恢复默认值。</div><div class=\"line\"># 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf</div><div class=\"line\"># 内容为</div><div class=\"line\">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"设置iptables规则\"><a href=\"#设置iptables规则\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置<code>iptables</code>规则</h3><p>安装必要软件并启用服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y net-tools iproute iptables iptables-services</div><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div><div class=\"line\">systemctl enable iptables</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>net-tools</code>这个程序包有 <code>ifconfig</code>，<code>netstat</code>，<code>route</code>等命令，而<code>iproute2</code>（rpm包名为<code>iproute</code>）包括<code>tc</code>，<code>ip</code>，<code>ss</code>等命令，是<code>net-tools</code>的改进。</p>\n</blockquote>\n<p>通过<code>iptables</code>命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用<code>iptables-save</code>命令输出，然后保存起来。<br>这里直接使用<code>iptables-save</code>生成的配置项，保存到配置文件 <code>/etc/sysconfig/iptables</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017</div><div class=\"line\">*nat</div><div class=\"line\">:PREROUTING ACCEPT [0:0]</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">:POSTROUTING ACCEPT [0:0]</div><div class=\"line\">-A POSTROUTING -o em1 -j MASQUERADE  </div><div class=\"line\">COMMIT</div><div class=\"line\"></div><div class=\"line\">*filter</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:FORWARD ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class=\"line\">-A INPUT -p icmp -j ACCEPT</div><div class=\"line\">-A INPUT -i lo -j ACCEPT</div><div class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class=\"line\">-A FORWARD -i em2 -j ACCEPT</div><div class=\"line\">COMMIT</div></pre></td></tr></table></figure></p>\n<p>其中涉及NAT转发的是<code>-A POSTROUTING -o em1 -j MASQUERADE</code> 和 <code>-A FORWARD -i em2 -j ACCEPT</code>。<br>此外还删除了原来禁止<code>ping</code>的规则：<br><code>-A INPUT -j REJECT --reject-with icmp-host-prohibited</code><br><code>-A FORWARD -j REJECT --reject-with icmp-host-prohibited</code></p>\n<p>重启<code>iptables</code>服务<code>systemctl restart iptables</code>。</p>\n<blockquote>\n<p>可以修改<code>/etc/sysconfig/iptables-config</code> 配置文件，设置下面三个选项均为<code>yes</code>来自动保存<code>iptables</code>规则</p>\n<ul>\n<li><code>IPTABLES_MODULES_UNLOAD=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_STOP=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_RESTART=&quot;yes&quot;</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li><a href=\"http://salogs.com/news/2015/08/20/iptables-save/\" target=\"_blank\" rel=\"external\">保存iptable规则并开机自动加载</a></li>\n<li><a href=\"http://blog.csdn.net/hepeng597/article/details/8270138\" target=\"_blank\" rel=\"external\">iptables用法初解</a></li>\n</ul>\n</blockquote>\n<h2 id=\"设置其它-CentOS-7-机器使用NAT网络\"><a href=\"#设置其它-CentOS-7-机器使用NAT网络\" class=\"headerlink\" title=\"设置其它 CentOS 7 机器使用NAT网络\"></a>设置其它 CentOS 7 机器使用NAT网络</h2><h3 id=\"切换默认网关\"><a href=\"#切换默认网关\" class=\"headerlink\" title=\"切换默认网关\"></a>切换默认网关</h3><p>安装系统后，默认网关是<code>em1</code>所在LAN的<code>2.2.2.1</code>，需要将其更改为<code>em2</code>所在LAN的<code>10.0.0.147</code>，修改如下的网卡配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em1</div><div class=\"line\">DEFROUTE=no</div><div class=\"line\"></div><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em2</div><div class=\"line\">DEFROUTE=yes</div><div class=\"line\"># ...</div><div class=\"line\">GATEWAY=10.0.0.147</div><div class=\"line\">DNS1=233.5.5.5</div><div class=\"line\">DNS2=223.6.6.6</div></pre></td></tr></table></figure></p>\n<p>其中<code>em2</code>的网关即刚才配置的<code>n147</code>的私网IP，由于没有在<code>n147</code>上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置<code>dnsmasq</code>等DNS服务器。</p>\n<h3 id=\"为em1添加静态路由\"><a href=\"#为em1添加静态路由\" class=\"headerlink\" title=\"为em1添加静态路由\"></a>为<code>em1</code>添加静态路由</h3><p>修改默认网关后，查看路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1</div><div class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div></pre></td></tr></table></figure></p>\n<p>发现从<code>em1</code>收发的数据包也要经过默认网关<code>10.0.0.147</code>，而这个网关在机房的私网内，<strong>外部不能直接访问，导致外部无法公网IP访问服务器</strong>。为此，需要为<code>em1</code>添加静态路由，不走<code>10.0.0.147</code>，新建文件<code>/etc/sysconfig/network-scripts/route-em1</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2.2.0.0/16    via 2.2.2.1</div><div class=\"line\">172.0.0.0/8   via 2.2.2.1</div></pre></td></tr></table></figure></p>\n<p>其中</p>\n<ul>\n<li><code>2.2.0.0/16</code>网段是学校 <strong>有线</strong> 网络的IP网段</li>\n<li><code>172.0.0.0/8</code>网段是学校 <strong>无线</strong> 网络的IP网段。<blockquote>\n<p>注意</p>\n</blockquote>\n</li>\n<li><code>docker0</code>网桥默认也是B类私网的<code>172.x.0.0/16</code>网段，但其路由项更具体，所以<a href=\"http://answ.me/post/configure-docker-subnet/\" target=\"_blank\" rel=\"external\">不会造成冲突</a>。</li>\n<li><code>docker0</code>网桥实际也工作在NAT模式，也需要开启IP转发。</li>\n</ul>\n<p>重启网络，更新配置，<code>systemctl restart network</code>。</p>\n<blockquote>\n<p>参考：<a href=\"https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System\" target=\"_blank\" rel=\"external\">Two Default Gateways on One System</a></p>\n</blockquote>\n<h1 id=\"Ubuntu-16-04-设置和使用NAT\"><a href=\"#Ubuntu-16-04-设置和使用NAT\" class=\"headerlink\" title=\"Ubuntu 16.04 设置和使用NAT\"></a>Ubuntu 16.04 设置和使用NAT</h1><p>Ubuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！<br>因为用到的工具都是<code>net-tools</code>，<code>iproute</code>和<code>iptables</code>这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。</p>\n<h2 id=\"设置NAT\"><a href=\"#设置NAT\" class=\"headerlink\" title=\"设置NAT\"></a>设置NAT</h2><h3 id=\"允许IP转发-1\"><a href=\"#允许IP转发-1\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>直接修改系统配置文件 <code>/etc/sysctl.conf</code>，里面已经有支持的配置项，取消<code>net.ipv4.ip_forward = 1</code>的注释即可。</p>\n<h3 id=\"设置iptables规则-1\"><a href=\"#设置iptables规则-1\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置iptables规则</h3><p>还是使用的<code>iptables</code>，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是<code>em1</code>，<code>em2</code>，Ubuntu 16.04下是<code>eno1</code>，<code>eno2</code>，所以要把规则中对应的网卡名改过来。</p>\n<p>然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考<a href=\"https://help.ubuntu.com/community/IptablesHowTo\" target=\"_blank\" rel=\"external\">IptablesHowTo - Ubuntu wiki</a>，，<strong>随便把规则保存到哪，反正系统不会自动加载</strong>，需要自己添加一个启动脚本。<br>因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 <code>/etc/network/if-pre-up.d/iptablesload</code>，内容如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">iptables-restore &lt; /etc/iptables.rules</div><div class=\"line\">exit 0</div></pre></td></tr></table></figure></p>\n<p>可见<code>/etc/iptables.rules</code>是保存的<code>iptables</code>规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。<strong>但是，你要自己来写这个脚本</strong>。</p>\n<p>编辑好<code>/etc/iptables.rules</code> 和 <code>/etc/network/if-pre-up.d/iptablesload</code>之后，重启网络服务。</p>\n<p>虽然都是用<code>systemd</code>来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是<code>network.service</code>，而Ubuntu则是<code>networking.service</code>。<br>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。不过，其实我们是用<code>iptables</code>来实现的NAT，而不是<code>networking.service</code>相关服务，不过由于上面的那个脚本<code>iptablesload</code>会在网卡启动之前被执行，所以顺便完成了我们的目标。</p>\n<h2 id=\"设置其它机器使用NAT网络\"><a href=\"#设置其它机器使用NAT网络\" class=\"headerlink\" title=\"设置其它机器使用NAT网络\"></a>设置其它机器使用NAT网络</h2><p>同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在<code>/etc/network/interface</code>这个文件里，这个倒是方便了—— <strong><a href=\"https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server\" target=\"_blank\" rel=\"external\">如果面对空空的配置文件，你能猜到各配置项是什么的时候</a></strong>。<br>好在安装系统的时候设置了网卡，给<code>eno2</code>生成了一些配置项可以参考。修改后的内容如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto lo</div><div class=\"line\">iface lo inet loopback</div><div class=\"line\"></div><div class=\"line\">auto eno1</div><div class=\"line\">iface eno1 inet static</div><div class=\"line\">  address 2.2.2.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 2.2.2.0</div><div class=\"line\">  broadcast 2.2.2.255</div><div class=\"line\">  # gateway 2.2.2.1</div><div class=\"line\">  up ip route add 2.2.0.0/16   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 2.2.2.0/24   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 172.0.0.0/8  via 2.2.2.1 || true</div><div class=\"line\"></div><div class=\"line\"># The primary network interface</div><div class=\"line\">auto eno2</div><div class=\"line\">iface eno2 inet static</div><div class=\"line\">  address 10.0.0.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 10.0.0.0</div><div class=\"line\">  broadcast 10.0.0.255</div><div class=\"line\">  gateway 10.0.0.147</div><div class=\"line\">  # dns-* options are implemented by the resolvconf package, if installed</div><div class=\"line\">  dns-nameservers 233.5.5.5</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了<code>gateway</code>就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个<code>gateway</code>项。</li>\n<li><code>up ip route add 2.2.0.0/16   via 2.2.2.1 || true</code>其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句<code>up echo helloworld</code>也没问题。后面的<code>|| true</code>是让脚本执行时忽略可能的错误，继续执行。这里使用的是<code>ip</code>命令，如果使用<code>route</code>命令，效果也是一样的，前提是已经安装了<code>net-tools</code>或<code>iproute</code>软件包。使用<code>netmask</code>和<code>CIDR</code>格式都可以。</li>\n<li>哪个网卡的路由就写到对应的网卡下，这样执行<code>ifup eno1</code>这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。</li>\n</ul>\n</blockquote>\n<p>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。<br>查看一下更新后的路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Kernel IP routing table</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2</div><div class=\"line\">2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1</div><div class=\"line\">172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1</div></pre></td></tr></table></figure></p>\n<p>注意倒数第二行：<code>2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1</code>，这个是自动添加的。<br>它的网关并不是<code>2.2.2.1</code>，即便在<code>interface</code>中强制器网关为<code>2.2.2.1</code>，也会被改为<code>0.0.0.0</code>。因为<code>2.2.2.0/24</code>是本LAN的数据包，经<code>ARP</code>协议获得目标的<code>MAC</code>地址后，会被直接发到目标地址，而不会经网关<code>2.2.2.1</code>转发，虽然路由表中默认网关是<code>0.0.0.0</code>，也不会按路由表转发到<code>10.0.0.147</code>。</p>\n<h1 id=\"其它问题\"><a href=\"#其它问题\" class=\"headerlink\" title=\"其它问题\"></a>其它问题</h1><p>下面的问题是在除NAT网关外的其它机器上设置的。</p>\n<h2 id=\"禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\"><a href=\"#禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\" class=\"headerlink\" title=\"禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\"></a>禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</h2><p>修改默认网关，添加路由之后，虽然可以从外部通过公网IP <code>ping</code>通机房内的机器，但<code>ssh</code>登录过程需要等待很长时间。<br>参考<a href=\"http://blog.itpub.net/7345798/viewspace-1055461/\" target=\"_blank\" rel=\"external\">ssh连接的时候很慢，ping的速度非常好</a>这篇文章，修改各机器上<code>sshd</code>的选项如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &quot;&apos;s/.*UseDNS.*/UseDNS no/g&apos;&quot; /etc/ssh/sshd_config</div><div class=\"line\">systemctl restart sshd</div></pre></td></tr></table></figure></p>\n<h2 id=\"取消原来设置的http代理\"><a href=\"#取消原来设置的http代理\" class=\"headerlink\" title=\"取消原来设置的http代理\"></a>取消原来设置的http代理</h2><p>注释掉配置文件中<code>http_proxy</code>和<code>https_proxy</code>环境变量的声明，并执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unset http_proxy</div><div class=\"line\">unset https_proxy</div></pre></td></tr></table></figure></p>\n<h1 id=\"PS-使用-SSH-隧道\"><a href=\"#PS-使用-SSH-隧道\" class=\"headerlink\" title=\"PS: 使用 SSH 隧道\"></a>PS: 使用 SSH 隧道</h1><p>一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。<br>以Windows客户端为例，安装了Windows版的<code>git</code>后，会附带一些<code>mingw</code>命令程序（不是完整的<code>mingw</code>），首先将这些命令的可执行文件所在路径添加到<code>Path</code>环境变量，比如是<code>E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin</code>，然后就可以在Windows命令行使用这些命令了。其中就有<code>ssh.exe</code>。<br>在Windows命令行窗口执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147</div></pre></td></tr></table></figure></p>\n<p>这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口<code>127.0.0.1:1088</code>。<strong>如果需要停止SSH隧道，关闭该命令窗口即可</strong>。<br>因为我在Windows的<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>文件中添加了<code>n147</code>的项，所以可以直接输入名字而不必是IP地址。</p>\n<p>在IE或控制面板打开<code>Internet选项</code>，</p>\n<ul>\n<li>在<code>连接</code>选项卡单击<code>局域网设置</code>按钮，</li>\n<li>在弹出的对话框勾选<code>为LAN使用代理服务器</code>，然后单击<code>高级</code>，</li>\n<li>在弹出的对话框取消勾选<code>对所有协议使用相同的代理服务器</code>，然后在<code>套接字</code>对应的文本框填入<code>127.0.0.1</code>和上面命令中监听的端口号<code>1088</code>，</li>\n<li>在<code>例外</code>文本框中删掉<code>10.*0;</code>的内容，然后一路确定关闭所有对话框。<br>这时应该可以用IE或Chrome访问机房内网的iDRAC。<strong>如果需要正常访问网页，需要取消勾选<code>为LAN使用代理服务器</code></strong>。</li>\n</ul>\n<p><img src=\"/img/sock5-proxy.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">CentOS 7 设置和使用NAT</a><ul>\n<li><a href=\"#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE\">NAT网关的设置</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置<code>iptables</code>规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它 CentOS 7 机器使用NAT网络</a><ul>\n<li><a href=\"#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3\">切换默认网关</a></li>\n<li><a href=\"#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1\">为<code>em1</code>添加静态路由</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">Ubuntu 16.04 设置和使用NAT</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEnat\">设置NAT</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置iptables规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它机器使用NAT网络</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98\">其它问题</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98\">禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</a></li>\n<li><a href=\"#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86\">取消原来设置的http代理</a></li>\n</ul>\n</li>\n<li><a href=\"#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93\">PS: 使用 SSH 隧道</a></li>\n</ul>\n<!-- /TOC -->\n<p>小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。</p>\n<ul>\n<li>一个LAN是学校的公网IP（下文记为<code>2.2.2.0/24</code>网段）。装好CentOS 7系统后，<code>em1</code>网卡在公网LAN，可以在校内直接访问<code>em1</code>的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。</li>\n<li>另一个LAN是用于远程管理的机房内私网IP（下文记为<code>10.0.0.0/24</code>网段），<code>em2</code>网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是<code>10.0.0.1</code>。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。</li>\n</ul>\n<p>一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。</p>\n<h1 id=\"CentOS-7-设置和使用NAT\"><a href=\"#CentOS-7-设置和使用NAT\" class=\"headerlink\" title=\"CentOS 7 设置和使用NAT\"></a>CentOS 7 设置和使用NAT</h1><p>虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个<code>147</code>的公网IP（记对应的机器是<code>n147</code>）直通校外网。<br>之前是通过在<code>n147</code>上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将<code>n147</code>的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，<code>n147</code>就像一个软件实现的家用路由器。</p>\n<h2 id=\"NAT网关的设置\"><a href=\"#NAT网关的设置\" class=\"headerlink\" title=\"NAT网关的设置\"></a>NAT网关的设置</h2><p>作为网关的机器名是<code>n147</code>，公网IP是<code>2.2.2.147/24</code>，对应<code>em1</code>网卡；私网IP是<code>10.0.0.147/24</code>，对应<code>em2</code>网卡。</p>\n<h3 id=\"允许IP转发\"><a href=\"#允许IP转发\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>其它机器从<code>10.0.0.0/24</code>网段发送的数据包会被<code>em2</code>网卡接收，如果目标IP是外网，需要交给<code>em1</code>网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 查看是否启用IP转发，如果是0则没有开启，是1则已经开启</div><div class=\"line\">cat /proc/sys/net/ipv4/ip_forward</div><div class=\"line\"></div><div class=\"line\"># 可以修改上述文件的值来改变设置，但重启后会恢复默认值。</div><div class=\"line\"># 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf</div><div class=\"line\"># 内容为</div><div class=\"line\">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"设置iptables规则\"><a href=\"#设置iptables规则\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置<code>iptables</code>规则</h3><p>安装必要软件并启用服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y net-tools iproute iptables iptables-services</div><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div><div class=\"line\">systemctl enable iptables</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>net-tools</code>这个程序包有 <code>ifconfig</code>，<code>netstat</code>，<code>route</code>等命令，而<code>iproute2</code>（rpm包名为<code>iproute</code>）包括<code>tc</code>，<code>ip</code>，<code>ss</code>等命令，是<code>net-tools</code>的改进。</p>\n</blockquote>\n<p>通过<code>iptables</code>命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用<code>iptables-save</code>命令输出，然后保存起来。<br>这里直接使用<code>iptables-save</code>生成的配置项，保存到配置文件 <code>/etc/sysconfig/iptables</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017</div><div class=\"line\">*nat</div><div class=\"line\">:PREROUTING ACCEPT [0:0]</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">:POSTROUTING ACCEPT [0:0]</div><div class=\"line\">-A POSTROUTING -o em1 -j MASQUERADE  </div><div class=\"line\">COMMIT</div><div class=\"line\"></div><div class=\"line\">*filter</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:FORWARD ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class=\"line\">-A INPUT -p icmp -j ACCEPT</div><div class=\"line\">-A INPUT -i lo -j ACCEPT</div><div class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class=\"line\">-A FORWARD -i em2 -j ACCEPT</div><div class=\"line\">COMMIT</div></pre></td></tr></table></figure></p>\n<p>其中涉及NAT转发的是<code>-A POSTROUTING -o em1 -j MASQUERADE</code> 和 <code>-A FORWARD -i em2 -j ACCEPT</code>。<br>此外还删除了原来禁止<code>ping</code>的规则：<br><code>-A INPUT -j REJECT --reject-with icmp-host-prohibited</code><br><code>-A FORWARD -j REJECT --reject-with icmp-host-prohibited</code></p>\n<p>重启<code>iptables</code>服务<code>systemctl restart iptables</code>。</p>\n<blockquote>\n<p>可以修改<code>/etc/sysconfig/iptables-config</code> 配置文件，设置下面三个选项均为<code>yes</code>来自动保存<code>iptables</code>规则</p>\n<ul>\n<li><code>IPTABLES_MODULES_UNLOAD=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_STOP=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_RESTART=&quot;yes&quot;</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li><a href=\"http://salogs.com/news/2015/08/20/iptables-save/\" target=\"_blank\" rel=\"external\">保存iptable规则并开机自动加载</a></li>\n<li><a href=\"http://blog.csdn.net/hepeng597/article/details/8270138\" target=\"_blank\" rel=\"external\">iptables用法初解</a></li>\n</ul>\n</blockquote>\n<h2 id=\"设置其它-CentOS-7-机器使用NAT网络\"><a href=\"#设置其它-CentOS-7-机器使用NAT网络\" class=\"headerlink\" title=\"设置其它 CentOS 7 机器使用NAT网络\"></a>设置其它 CentOS 7 机器使用NAT网络</h2><h3 id=\"切换默认网关\"><a href=\"#切换默认网关\" class=\"headerlink\" title=\"切换默认网关\"></a>切换默认网关</h3><p>安装系统后，默认网关是<code>em1</code>所在LAN的<code>2.2.2.1</code>，需要将其更改为<code>em2</code>所在LAN的<code>10.0.0.147</code>，修改如下的网卡配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em1</div><div class=\"line\">DEFROUTE=no</div><div class=\"line\"></div><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em2</div><div class=\"line\">DEFROUTE=yes</div><div class=\"line\"># ...</div><div class=\"line\">GATEWAY=10.0.0.147</div><div class=\"line\">DNS1=233.5.5.5</div><div class=\"line\">DNS2=223.6.6.6</div></pre></td></tr></table></figure></p>\n<p>其中<code>em2</code>的网关即刚才配置的<code>n147</code>的私网IP，由于没有在<code>n147</code>上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置<code>dnsmasq</code>等DNS服务器。</p>\n<h3 id=\"为em1添加静态路由\"><a href=\"#为em1添加静态路由\" class=\"headerlink\" title=\"为em1添加静态路由\"></a>为<code>em1</code>添加静态路由</h3><p>修改默认网关后，查看路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1</div><div class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div></pre></td></tr></table></figure></p>\n<p>发现从<code>em1</code>收发的数据包也要经过默认网关<code>10.0.0.147</code>，而这个网关在机房的私网内，<strong>外部不能直接访问，导致外部无法公网IP访问服务器</strong>。为此，需要为<code>em1</code>添加静态路由，不走<code>10.0.0.147</code>，新建文件<code>/etc/sysconfig/network-scripts/route-em1</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2.2.0.0/16    via 2.2.2.1</div><div class=\"line\">172.0.0.0/8   via 2.2.2.1</div></pre></td></tr></table></figure></p>\n<p>其中</p>\n<ul>\n<li><code>2.2.0.0/16</code>网段是学校 <strong>有线</strong> 网络的IP网段</li>\n<li><code>172.0.0.0/8</code>网段是学校 <strong>无线</strong> 网络的IP网段。<blockquote>\n<p>注意</p>\n</blockquote>\n</li>\n<li><code>docker0</code>网桥默认也是B类私网的<code>172.x.0.0/16</code>网段，但其路由项更具体，所以<a href=\"http://answ.me/post/configure-docker-subnet/\" target=\"_blank\" rel=\"external\">不会造成冲突</a>。</li>\n<li><code>docker0</code>网桥实际也工作在NAT模式，也需要开启IP转发。</li>\n</ul>\n<p>重启网络，更新配置，<code>systemctl restart network</code>。</p>\n<blockquote>\n<p>参考：<a href=\"https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System\" target=\"_blank\" rel=\"external\">Two Default Gateways on One System</a></p>\n</blockquote>\n<h1 id=\"Ubuntu-16-04-设置和使用NAT\"><a href=\"#Ubuntu-16-04-设置和使用NAT\" class=\"headerlink\" title=\"Ubuntu 16.04 设置和使用NAT\"></a>Ubuntu 16.04 设置和使用NAT</h1><p>Ubuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！<br>因为用到的工具都是<code>net-tools</code>，<code>iproute</code>和<code>iptables</code>这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。</p>\n<h2 id=\"设置NAT\"><a href=\"#设置NAT\" class=\"headerlink\" title=\"设置NAT\"></a>设置NAT</h2><h3 id=\"允许IP转发-1\"><a href=\"#允许IP转发-1\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>直接修改系统配置文件 <code>/etc/sysctl.conf</code>，里面已经有支持的配置项，取消<code>net.ipv4.ip_forward = 1</code>的注释即可。</p>\n<h3 id=\"设置iptables规则-1\"><a href=\"#设置iptables规则-1\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置iptables规则</h3><p>还是使用的<code>iptables</code>，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是<code>em1</code>，<code>em2</code>，Ubuntu 16.04下是<code>eno1</code>，<code>eno2</code>，所以要把规则中对应的网卡名改过来。</p>\n<p>然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考<a href=\"https://help.ubuntu.com/community/IptablesHowTo\" target=\"_blank\" rel=\"external\">IptablesHowTo - Ubuntu wiki</a>，，<strong>随便把规则保存到哪，反正系统不会自动加载</strong>，需要自己添加一个启动脚本。<br>因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 <code>/etc/network/if-pre-up.d/iptablesload</code>，内容如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">iptables-restore &lt; /etc/iptables.rules</div><div class=\"line\">exit 0</div></pre></td></tr></table></figure></p>\n<p>可见<code>/etc/iptables.rules</code>是保存的<code>iptables</code>规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。<strong>但是，你要自己来写这个脚本</strong>。</p>\n<p>编辑好<code>/etc/iptables.rules</code> 和 <code>/etc/network/if-pre-up.d/iptablesload</code>之后，重启网络服务。</p>\n<p>虽然都是用<code>systemd</code>来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是<code>network.service</code>，而Ubuntu则是<code>networking.service</code>。<br>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。不过，其实我们是用<code>iptables</code>来实现的NAT，而不是<code>networking.service</code>相关服务，不过由于上面的那个脚本<code>iptablesload</code>会在网卡启动之前被执行，所以顺便完成了我们的目标。</p>\n<h2 id=\"设置其它机器使用NAT网络\"><a href=\"#设置其它机器使用NAT网络\" class=\"headerlink\" title=\"设置其它机器使用NAT网络\"></a>设置其它机器使用NAT网络</h2><p>同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在<code>/etc/network/interface</code>这个文件里，这个倒是方便了—— <strong><a href=\"https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server\" target=\"_blank\" rel=\"external\">如果面对空空的配置文件，你能猜到各配置项是什么的时候</a></strong>。<br>好在安装系统的时候设置了网卡，给<code>eno2</code>生成了一些配置项可以参考。修改后的内容如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto lo</div><div class=\"line\">iface lo inet loopback</div><div class=\"line\"></div><div class=\"line\">auto eno1</div><div class=\"line\">iface eno1 inet static</div><div class=\"line\">  address 2.2.2.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 2.2.2.0</div><div class=\"line\">  broadcast 2.2.2.255</div><div class=\"line\">  # gateway 2.2.2.1</div><div class=\"line\">  up ip route add 2.2.0.0/16   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 2.2.2.0/24   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 172.0.0.0/8  via 2.2.2.1 || true</div><div class=\"line\"></div><div class=\"line\"># The primary network interface</div><div class=\"line\">auto eno2</div><div class=\"line\">iface eno2 inet static</div><div class=\"line\">  address 10.0.0.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 10.0.0.0</div><div class=\"line\">  broadcast 10.0.0.255</div><div class=\"line\">  gateway 10.0.0.147</div><div class=\"line\">  # dns-* options are implemented by the resolvconf package, if installed</div><div class=\"line\">  dns-nameservers 233.5.5.5</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了<code>gateway</code>就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个<code>gateway</code>项。</li>\n<li><code>up ip route add 2.2.0.0/16   via 2.2.2.1 || true</code>其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句<code>up echo helloworld</code>也没问题。后面的<code>|| true</code>是让脚本执行时忽略可能的错误，继续执行。这里使用的是<code>ip</code>命令，如果使用<code>route</code>命令，效果也是一样的，前提是已经安装了<code>net-tools</code>或<code>iproute</code>软件包。使用<code>netmask</code>和<code>CIDR</code>格式都可以。</li>\n<li>哪个网卡的路由就写到对应的网卡下，这样执行<code>ifup eno1</code>这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。</li>\n</ul>\n</blockquote>\n<p>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。<br>查看一下更新后的路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Kernel IP routing table</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2</div><div class=\"line\">2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1</div><div class=\"line\">172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1</div></pre></td></tr></table></figure></p>\n<p>注意倒数第二行：<code>2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1</code>，这个是自动添加的。<br>它的网关并不是<code>2.2.2.1</code>，即便在<code>interface</code>中强制器网关为<code>2.2.2.1</code>，也会被改为<code>0.0.0.0</code>。因为<code>2.2.2.0/24</code>是本LAN的数据包，经<code>ARP</code>协议获得目标的<code>MAC</code>地址后，会被直接发到目标地址，而不会经网关<code>2.2.2.1</code>转发，虽然路由表中默认网关是<code>0.0.0.0</code>，也不会按路由表转发到<code>10.0.0.147</code>。</p>\n<h1 id=\"其它问题\"><a href=\"#其它问题\" class=\"headerlink\" title=\"其它问题\"></a>其它问题</h1><p>下面的问题是在除NAT网关外的其它机器上设置的。</p>\n<h2 id=\"禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\"><a href=\"#禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\" class=\"headerlink\" title=\"禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\"></a>禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</h2><p>修改默认网关，添加路由之后，虽然可以从外部通过公网IP <code>ping</code>通机房内的机器，但<code>ssh</code>登录过程需要等待很长时间。<br>参考<a href=\"http://blog.itpub.net/7345798/viewspace-1055461/\" target=\"_blank\" rel=\"external\">ssh连接的时候很慢，ping的速度非常好</a>这篇文章，修改各机器上<code>sshd</code>的选项如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &quot;&apos;s/.*UseDNS.*/UseDNS no/g&apos;&quot; /etc/ssh/sshd_config</div><div class=\"line\">systemctl restart sshd</div></pre></td></tr></table></figure></p>\n<h2 id=\"取消原来设置的http代理\"><a href=\"#取消原来设置的http代理\" class=\"headerlink\" title=\"取消原来设置的http代理\"></a>取消原来设置的http代理</h2><p>注释掉配置文件中<code>http_proxy</code>和<code>https_proxy</code>环境变量的声明，并执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unset http_proxy</div><div class=\"line\">unset https_proxy</div></pre></td></tr></table></figure></p>\n<h1 id=\"PS-使用-SSH-隧道\"><a href=\"#PS-使用-SSH-隧道\" class=\"headerlink\" title=\"PS: 使用 SSH 隧道\"></a>PS: 使用 SSH 隧道</h1><p>一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。<br>以Windows客户端为例，安装了Windows版的<code>git</code>后，会附带一些<code>mingw</code>命令程序（不是完整的<code>mingw</code>），首先将这些命令的可执行文件所在路径添加到<code>Path</code>环境变量，比如是<code>E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin</code>，然后就可以在Windows命令行使用这些命令了。其中就有<code>ssh.exe</code>。<br>在Windows命令行窗口执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147</div></pre></td></tr></table></figure></p>\n<p>这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口<code>127.0.0.1:1088</code>。<strong>如果需要停止SSH隧道，关闭该命令窗口即可</strong>。<br>因为我在Windows的<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>文件中添加了<code>n147</code>的项，所以可以直接输入名字而不必是IP地址。</p>\n<p>在IE或控制面板打开<code>Internet选项</code>，</p>\n<ul>\n<li>在<code>连接</code>选项卡单击<code>局域网设置</code>按钮，</li>\n<li>在弹出的对话框勾选<code>为LAN使用代理服务器</code>，然后单击<code>高级</code>，</li>\n<li>在弹出的对话框取消勾选<code>对所有协议使用相同的代理服务器</code>，然后在<code>套接字</code>对应的文本框填入<code>127.0.0.1</code>和上面命令中监听的端口号<code>1088</code>，</li>\n<li>在<code>例外</code>文本框中删掉<code>10.*0;</code>的内容，然后一路确定关闭所有对话框。<br>这时应该可以用IE或Chrome访问机房内网的iDRAC。<strong>如果需要正常访问网页，需要取消勾选<code>为LAN使用代理服务器</code></strong>。</li>\n</ul>\n<p><img src=\"/img/sock5-proxy.png\" alt=\"\"></p>"},{"title":"局域网内的远程操作","date":"2016-09-17T16:00:00.000Z","_content":"一些基础的远程操作，包括ssh，共享文件，远程桌面。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [Linux远程执行命令（ssh）](#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89)\n    - [Linux下设置和使用ssh](#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh)\n    - [Windows安装和设置xshell，使用密码ssh登录](#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95)\n    - [scp](#scp)\n    - [sftp](#sftp)\n    - [设置ssh使用密钥登录](#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95)\n        - [生成密钥对](#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9)\n        - [分发密钥对](#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9)\n            - [ssh-copy-id](#ssh-copy-id)\n            - [复制密钥文本](#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC)\n        - [ssh config设置](#ssh-config%E8%AE%BE%E7%BD%AE)\n        - [踢出ssh会话](#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D)\n- [远程共享文件（SMB/CIFS）](#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89)\n    - [Samba访问Windows提供的共享文件](#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [Windows访问Samba的共享文件](#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [更改Samba的默认端口号](#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7)\n- [远程桌面](#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2)\n    - [mstsc](#mstsc)\n    - [vnc](#vnc)\n    - [其它](#%E5%85%B6%E5%AE%83)\n\n<!-- /TOC -->\n\n这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（`ssh`），共享文件（`Samba`）和远程桌面（`mstsc`和`vnc`）。\n远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。\n\n为了方便配置，**建议关闭系统的防火墙**。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是`10.1.1.5`，用户名`ying`；Windows的IP是`10.1.1.1`，用户名也是`ying`。\n\n# Linux远程执行命令（ssh）\nssh（[Secure Shell](https://en.wikipedia.org/wiki/Secure_Shell)）通过加密的网络通道在客户端和服务器之间传递命令及其输出。\n在ssh之前，远程执行命令是通过`telnet`或`rsh`等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。\n可以在ssh提供的加密通道上完成其它网络通信：如`scp`是在ssh加密通道上实现的远程拷贝（`rcp`）；`sftp`是在ssh加密通道上实现的`ftp`；`git`也有使用ssh加密通道传输文件的模式。\n对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。\n\n## Linux下设置和使用ssh\nLinux系统的ssh服务程序是`OpenSSH Server`，执行命令`sudo apt install openssh-server`。\n安装过程中会将ssh服务程序（`sshd`）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。\n\n> 查看SSH Server状态，执行`systemctl status sshd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart sshd`\n\n一般Linux系统都内置了ssh客户端，执行\n`ssh 用户名@主机名或IP`\n登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。\n登录到本机的命令是`ssh localhost`\n第一次登录某个主机会提示是否 **信任** 该主机，需要输入`yes`，之后才会提示输入远程主机的登录密码。\n\n>修改`/etc/ssh/ssh_config`，将其中`#   StrictHostKeyChecking ask` 改为 `StrictHostKeyChecking no`，这样在第一次登录时就不会询问是否要信任该主机了。\n\n如果登录到远程主机只是执行一两条命令，可执行\n`ssh 用户名@主机名或IP 命令`\n当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。\n\n## Windows安装和设置xshell，使用密码ssh登录\nWindows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。\n\n> Windows版的`git`包含一个简化版`MinGW`，将`<git安装目录>\\usr\\bin`这个路径添加到Windows的`Path`环境变量，就可以在Windows的命令窗口执行`ssh`，`scp`及其它很多Linux命令了。\n> `MinGW` 中也包含SSH Server程序`sshd`，不过估计很少会登录到Windows执行命令行操作吧。\n\n从官网下载并安装 [xshell](http://www.netsarang.com/download/down_xsh.html) （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 **普通下载**。\n\n启动xshell后，可以直接执行`ssh ying@10.1.1.5`，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。\n![](/img/xshell-ui.png)\n\n> 工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行`open <会话名>`。\n> 工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。\n> 每个会话即`<用户文档>\\NetSarang\\Xshell\\Sessions`下的一个配置文件，会话也可以复制后修改。\n\n为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 **“会话属性”** 对话框中\n+ 在“连接” 输入主机 `10.1.1.5`，在用户身份验证中选择方法为Password，输入用户名 `ying` 和 密码；\n+ 在“终端” 修改“编码”为UTF-8；\n+ 在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。\n\n![](/img/xshell-prop.png)\n\n> 注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”`Ctrl+C`对应的是中断当前命令。\n> xshell中默认“复制”、“粘贴”的快捷键是`Ctrl+Ins`，`Shift+Ins`，而不是`Ctrl+C`，`Ctrl+V`。\n可以打开 “工具”->“选项”，“键盘和鼠标”选项卡，“按键对应”->“编辑”，将其修改为`Ctrl+C`，`Ctrl+V`，而原来Linux终端的快捷键需要加`Shift`，如中断当前命令的`Ctrl+C`变成了`Ctrl+Shift+C`。\n\n## scp\n通过ssh加密的通道传输文件。文件路径格式为`用户名@主机名或IP:主机上的路径`。注意，Windows文件路径中的盘符`C:\\`变成了`/c/`。\n{% codeblock line_number:false%}\nscp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/\n{% endcodeblock %}\n\n## sftp\n`OpenSSH Server`内置了一个`sftp`服务器，会随`sshd`服务自动启动。我们还需要一个`sftp`的客户端即可传送文件。\n这里使用图形界面的，跨平台的，免费的，开源的[Filezilla](https://filezilla-project.org/download.php?type=client)。下载并安装后，在“快速连接”工具栏输入主机`sftp://10.1.1.5`，及用户名 `ying` 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。\n![](/img/sftp.png)\n\nAndroid上的`ES文件浏览器`也支持`sftp`（还支持下面介绍的smb局域网文件共享）。\n\n## 设置ssh使用密钥登录\n更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用`rsa`算法，公钥和私钥分别保存在两个 **文本** 文件`id_rsa.pub`和`id_rsa`中。\n+ 公钥`id_rsa.pub`保存在要登录的目标机器上（服务器，Github等），\n+ 私钥`id_rsa`保存在 **发起** 登录的机器上（客户端），私钥要妥善保管，防止泄露。\n\nLinux主机的密钥对默认保存在`~/.ssh/`目录。\nWindows是`C:\\Users\\<Win用户名>\\.ssh\\`目录。在图形界面的文件管理器中不能创建以`.`开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（`Win键+X，C`），执行命令`mkdir C:\\Users\\<Win用户名>\\.ssh`。\n\n### 生成密钥对\n因为加密算法是公开的，有多种工具可以生成密钥。\n对Linux或MinGW，执行`ssh-keygen -t rsa -P \"\"` ，会在`~/.ssh/`生成密钥对`id_rsa.pub`和`id_rsa`。\n\nxshell也可以生成密钥对：\n+ 打开 “工具”-> “新建用户密钥生成向导” 或 “工具”-> “用户密钥管理者” -> “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；\n+ 选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；\n+ 选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。\n\n![](/img/xshell-key.png)\n\n### 分发密钥对\n要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的`.ssh/authorized_keys`文件中。\n分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的`scp`和`sftp`，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行`wget`或`curl`命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。\n\n#### ssh-copy-id\n执行命令`ssh-copy-id -i 公钥文件 用户名@主机名或IP`，将公钥拷贝到远程Linux主机的`/home/<用户名>/.ssh/authorized_keys`文件中。当然，这个命令需要用密码访问远程主机。\n\n#### 复制密钥文本\n如将Linux主机上生成的私钥`id_rsa`拷贝到Windows上：\n+ 使用xshell用密码登录到Linux，执行`cat ~/.ssh/id_rsa`，输出私钥的内容，复制输出的文字。\n+ 在Windows文件管理器中打开路径`C:\\Users\\<Win用户名>\\.ssh`，在其中创建一个名为`id_rsa.txt`的文本文件，将上一步复制的文字粘贴进去，然后把文件名的`.txt`扩展名去掉，即改为`id_rsa`。\n\n可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行`git`、`ssh`等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。\n\n### ssh config设置\n在`~/.ssh/config`文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。\n{% codeblock line_number:false%}\nHost   别名\n    HostName 主机名或IP\n    Port     端口\n    User     用户名\n    IdentityFile   私钥文件\n\nHost u\n    Hostname  10.1.1.5\n    Port      22\n    User      ying\n\nHost          10.1.1.6\nPort          2222\n\n{% endcodeblock %}\n\n这样就可以直接执行`ssh 别名`登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在`scp`的路径中。\n\n### 踢出ssh会话\n查看在线用户：`w` 或 `who`，两者输出格式有所不同。\n查看自己的连接信息：`who am i`。\n踢出其它会话：`pkill -9 -t pts/1 `，其中`pts/1`是被踢会话的终端。\n\n# 远程共享文件（SMB/CIFS）\n“共享文件”（[Server Message Block，SMB](https://en.wikipedia.org/wiki/Server_Message_Block) )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。\nSamba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。\nLinux上与SMB/CIFS功能是类似的是“网络文件系统”（[Network File System，NFS](https://en.wikipedia.org/wiki/Network_File_System) ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过`控制面板→程序和功能→启用或关闭Windows功能`来添加NFS客户端和服务端软件。\n\n> 注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。\n> 共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。\n\nLinux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行`sudo apt install cifs-utils`来安装。\n\n## Samba访问Windows提供的共享文件\nWindows上启用共享文件夹只要在文件夹的`属性对话框→共享选项卡→高级共享`中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加`$`，就表示是隐藏的，必须通过输入完整路径才能打开。\n![Windows上启用共享文件夹](/img/win-share.png)\n\n创建挂载点`mkdir ~/z`，并在`/etc/fstab`中添加\n{% codeblock line_number:false%}\n//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0\n{% endcodeblock %}\n\n执行`sudo mount -a`，挂载`/etc/fstab`中新增的设置。\n执行`ls ~/z`，应列出共享文件夹中的内容，确认挂载成功。\n\n> 上面的命令将共享文件夹`文档`挂载到Ubuntu的`/home/ying/z`，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。\n> 其中uid是Ubuntu中用户`ying`的，具体的值可执行命令`id`，或在`/etc/passwd`中查看。\n\n## Windows访问Samba的共享文件\n先要安装`Samba File Server`，执行`sudo apt install samba samba-common`。\n> 查看Samba Server的运行状态，执行`systemctl status smbd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart smbd`\n\n添加共享文件夹：执行 `sudo nano /etc/samba/smb.conf`，在末尾添加如下内容，添加了只读的根目录`/`和可读写的`/home/ying`目录，但显示为`all`和`ying`。\n{% codeblock line_number:false%}\n[all]\n    comment = fs root directory\n    path = /\n;   writeable = no\n;   browseable = yes\n    valid users = ying\n\n[ying]\n    comment = ying's home\n    path = /home/ying\n    writeable = yes\n    create mask = 0664\n    directory mask = 0775\n;   browseable = yes\n    valid users = ying\n{% endcodeblock %}\n\n将`ying`添加为smb的共享用户：`sudo smbpasswd -a ying`， 按提示设置`ying`的smb密码，**可以与系统密码不同**。\n重启smbd，使设置生效：`sudo systemctl restart smbd`。\n\n> Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。\n\n从Windows的文件管理器的地址栏访问 `\\\\10.1.1.5` ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 **“映射网络驱动器”** 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为`\\\\u` 。\n\n从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是`smb://10.1.1.5`或`smb://u`。macOS会自动把共享文件挂载到`/Volumes`下。\n\n> Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的`WINS`名字服务。\n> 另一种方法是在`hosts`文件中为IP地址指定名字。\n\n![](/img/smb.png)\n\n> Samba共享文件与`sftp`的区别在于，`sftp`不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。\n> PS, `testparm`命令可以用来检查`smb.conf`的配置是否正确。\n\n> 参考\n+ [Setting up Samba as a Standalone Server - samba wiki](https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server)\n+ [在CentOS 7中Samba服务安装和配置](http://lybing.blog.51cto.com/3286625/1676515)\n\n## 更改Samba的默认端口号\n2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。\n估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是`smb://10.1.1.5:4455/home/`，其中4455是修改后的端口号。\n\n修改Samba的端口号只需在`/etc/samba/smb.conf`中增加\n{% codeblock line_number:false%}\n[global]\n   smb ports = 4455 445  # 可以同时监听多个端口号\n...\n{% endcodeblock %}\n\n# 远程桌面\n## mstsc\nWindows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议[Remote Desktop Protocol，RDP](https://en.wikipedia.org/wiki/Remote_Desktop_Protocol)。\n\n+ 客户端在`所有程序→Windows附件→远程桌面连接`，或直接执行命令`mstsc`。\n+ 服务程序：依次打开`控制面板→所有控制面板项→系统`，或`Win+X，Y`，然后单击左侧的`高级系统设置`，打开`系统属性`对话框，在`远程`选项卡中的`远程桌面`部分选中`允许远程连接到此计算机`，并选择某个用户。\n![Windows上的远程桌面客户端](/img/win-mstsc.png)\n![Windows上启用远程桌面](/img/win-mstsc-svr.png)\n\nUbuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。\n如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。\n\nWindows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。\n\n## vnc\nVNC（[Virtual Network Computing](https://en.wikipedia.org/wiki/Virtual_Network_Computing)）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了`远程共享`程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。\nVNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。\n\n可以参考教程[https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。\n\nWindows上没有内置的VNC客户端，有一些免费的`VNC-Viewer`程序。\n\n> 注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，\n> 默认的 `Tab` 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-> Window Manager -> Keyboard”中清除 `Switch Window from same application` 关联的快捷键\n> 还可以在 “Settings-> Keyboard -> application shortcut” 中设置打开终端的快捷键 `exo-open --launch TerminalEmulator ~ Ctrl+Alt+T`\n\n## 其它\n在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 **[TeamViewer](https://www.teamviewer.com)**，[向日葵](http://sunlogin.oray.com/zh_CN/)等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。\n","source":"_posts/remote.md","raw":"title: 局域网内的远程操作\ndate: 2016-09-18\ncategory: [misc]\ntags:\n\n---\n一些基础的远程操作，包括ssh，共享文件，远程桌面。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [Linux远程执行命令（ssh）](#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89)\n    - [Linux下设置和使用ssh](#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh)\n    - [Windows安装和设置xshell，使用密码ssh登录](#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95)\n    - [scp](#scp)\n    - [sftp](#sftp)\n    - [设置ssh使用密钥登录](#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95)\n        - [生成密钥对](#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9)\n        - [分发密钥对](#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9)\n            - [ssh-copy-id](#ssh-copy-id)\n            - [复制密钥文本](#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC)\n        - [ssh config设置](#ssh-config%E8%AE%BE%E7%BD%AE)\n        - [踢出ssh会话](#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D)\n- [远程共享文件（SMB/CIFS）](#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89)\n    - [Samba访问Windows提供的共享文件](#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [Windows访问Samba的共享文件](#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [更改Samba的默认端口号](#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7)\n- [远程桌面](#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2)\n    - [mstsc](#mstsc)\n    - [vnc](#vnc)\n    - [其它](#%E5%85%B6%E5%AE%83)\n\n<!-- /TOC -->\n\n这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（`ssh`），共享文件（`Samba`）和远程桌面（`mstsc`和`vnc`）。\n远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。\n\n为了方便配置，**建议关闭系统的防火墙**。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是`10.1.1.5`，用户名`ying`；Windows的IP是`10.1.1.1`，用户名也是`ying`。\n\n# Linux远程执行命令（ssh）\nssh（[Secure Shell](https://en.wikipedia.org/wiki/Secure_Shell)）通过加密的网络通道在客户端和服务器之间传递命令及其输出。\n在ssh之前，远程执行命令是通过`telnet`或`rsh`等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。\n可以在ssh提供的加密通道上完成其它网络通信：如`scp`是在ssh加密通道上实现的远程拷贝（`rcp`）；`sftp`是在ssh加密通道上实现的`ftp`；`git`也有使用ssh加密通道传输文件的模式。\n对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。\n\n## Linux下设置和使用ssh\nLinux系统的ssh服务程序是`OpenSSH Server`，执行命令`sudo apt install openssh-server`。\n安装过程中会将ssh服务程序（`sshd`）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。\n\n> 查看SSH Server状态，执行`systemctl status sshd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart sshd`\n\n一般Linux系统都内置了ssh客户端，执行\n`ssh 用户名@主机名或IP`\n登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。\n登录到本机的命令是`ssh localhost`\n第一次登录某个主机会提示是否 **信任** 该主机，需要输入`yes`，之后才会提示输入远程主机的登录密码。\n\n>修改`/etc/ssh/ssh_config`，将其中`#   StrictHostKeyChecking ask` 改为 `StrictHostKeyChecking no`，这样在第一次登录时就不会询问是否要信任该主机了。\n\n如果登录到远程主机只是执行一两条命令，可执行\n`ssh 用户名@主机名或IP 命令`\n当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。\n\n## Windows安装和设置xshell，使用密码ssh登录\nWindows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。\n\n> Windows版的`git`包含一个简化版`MinGW`，将`<git安装目录>\\usr\\bin`这个路径添加到Windows的`Path`环境变量，就可以在Windows的命令窗口执行`ssh`，`scp`及其它很多Linux命令了。\n> `MinGW` 中也包含SSH Server程序`sshd`，不过估计很少会登录到Windows执行命令行操作吧。\n\n从官网下载并安装 [xshell](http://www.netsarang.com/download/down_xsh.html) （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 **普通下载**。\n\n启动xshell后，可以直接执行`ssh ying@10.1.1.5`，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。\n![](/img/xshell-ui.png)\n\n> 工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行`open <会话名>`。\n> 工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。\n> 每个会话即`<用户文档>\\NetSarang\\Xshell\\Sessions`下的一个配置文件，会话也可以复制后修改。\n\n为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 **“会话属性”** 对话框中\n+ 在“连接” 输入主机 `10.1.1.5`，在用户身份验证中选择方法为Password，输入用户名 `ying` 和 密码；\n+ 在“终端” 修改“编码”为UTF-8；\n+ 在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。\n\n![](/img/xshell-prop.png)\n\n> 注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”`Ctrl+C`对应的是中断当前命令。\n> xshell中默认“复制”、“粘贴”的快捷键是`Ctrl+Ins`，`Shift+Ins`，而不是`Ctrl+C`，`Ctrl+V`。\n可以打开 “工具”->“选项”，“键盘和鼠标”选项卡，“按键对应”->“编辑”，将其修改为`Ctrl+C`，`Ctrl+V`，而原来Linux终端的快捷键需要加`Shift`，如中断当前命令的`Ctrl+C`变成了`Ctrl+Shift+C`。\n\n## scp\n通过ssh加密的通道传输文件。文件路径格式为`用户名@主机名或IP:主机上的路径`。注意，Windows文件路径中的盘符`C:\\`变成了`/c/`。\n{% codeblock line_number:false%}\nscp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/\n{% endcodeblock %}\n\n## sftp\n`OpenSSH Server`内置了一个`sftp`服务器，会随`sshd`服务自动启动。我们还需要一个`sftp`的客户端即可传送文件。\n这里使用图形界面的，跨平台的，免费的，开源的[Filezilla](https://filezilla-project.org/download.php?type=client)。下载并安装后，在“快速连接”工具栏输入主机`sftp://10.1.1.5`，及用户名 `ying` 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。\n![](/img/sftp.png)\n\nAndroid上的`ES文件浏览器`也支持`sftp`（还支持下面介绍的smb局域网文件共享）。\n\n## 设置ssh使用密钥登录\n更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用`rsa`算法，公钥和私钥分别保存在两个 **文本** 文件`id_rsa.pub`和`id_rsa`中。\n+ 公钥`id_rsa.pub`保存在要登录的目标机器上（服务器，Github等），\n+ 私钥`id_rsa`保存在 **发起** 登录的机器上（客户端），私钥要妥善保管，防止泄露。\n\nLinux主机的密钥对默认保存在`~/.ssh/`目录。\nWindows是`C:\\Users\\<Win用户名>\\.ssh\\`目录。在图形界面的文件管理器中不能创建以`.`开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（`Win键+X，C`），执行命令`mkdir C:\\Users\\<Win用户名>\\.ssh`。\n\n### 生成密钥对\n因为加密算法是公开的，有多种工具可以生成密钥。\n对Linux或MinGW，执行`ssh-keygen -t rsa -P \"\"` ，会在`~/.ssh/`生成密钥对`id_rsa.pub`和`id_rsa`。\n\nxshell也可以生成密钥对：\n+ 打开 “工具”-> “新建用户密钥生成向导” 或 “工具”-> “用户密钥管理者” -> “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；\n+ 选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；\n+ 选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。\n\n![](/img/xshell-key.png)\n\n### 分发密钥对\n要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的`.ssh/authorized_keys`文件中。\n分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的`scp`和`sftp`，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行`wget`或`curl`命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。\n\n#### ssh-copy-id\n执行命令`ssh-copy-id -i 公钥文件 用户名@主机名或IP`，将公钥拷贝到远程Linux主机的`/home/<用户名>/.ssh/authorized_keys`文件中。当然，这个命令需要用密码访问远程主机。\n\n#### 复制密钥文本\n如将Linux主机上生成的私钥`id_rsa`拷贝到Windows上：\n+ 使用xshell用密码登录到Linux，执行`cat ~/.ssh/id_rsa`，输出私钥的内容，复制输出的文字。\n+ 在Windows文件管理器中打开路径`C:\\Users\\<Win用户名>\\.ssh`，在其中创建一个名为`id_rsa.txt`的文本文件，将上一步复制的文字粘贴进去，然后把文件名的`.txt`扩展名去掉，即改为`id_rsa`。\n\n可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行`git`、`ssh`等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。\n\n### ssh config设置\n在`~/.ssh/config`文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。\n{% codeblock line_number:false%}\nHost   别名\n    HostName 主机名或IP\n    Port     端口\n    User     用户名\n    IdentityFile   私钥文件\n\nHost u\n    Hostname  10.1.1.5\n    Port      22\n    User      ying\n\nHost          10.1.1.6\nPort          2222\n\n{% endcodeblock %}\n\n这样就可以直接执行`ssh 别名`登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在`scp`的路径中。\n\n### 踢出ssh会话\n查看在线用户：`w` 或 `who`，两者输出格式有所不同。\n查看自己的连接信息：`who am i`。\n踢出其它会话：`pkill -9 -t pts/1 `，其中`pts/1`是被踢会话的终端。\n\n# 远程共享文件（SMB/CIFS）\n“共享文件”（[Server Message Block，SMB](https://en.wikipedia.org/wiki/Server_Message_Block) )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。\nSamba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。\nLinux上与SMB/CIFS功能是类似的是“网络文件系统”（[Network File System，NFS](https://en.wikipedia.org/wiki/Network_File_System) ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过`控制面板→程序和功能→启用或关闭Windows功能`来添加NFS客户端和服务端软件。\n\n> 注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。\n> 共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。\n\nLinux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行`sudo apt install cifs-utils`来安装。\n\n## Samba访问Windows提供的共享文件\nWindows上启用共享文件夹只要在文件夹的`属性对话框→共享选项卡→高级共享`中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加`$`，就表示是隐藏的，必须通过输入完整路径才能打开。\n![Windows上启用共享文件夹](/img/win-share.png)\n\n创建挂载点`mkdir ~/z`，并在`/etc/fstab`中添加\n{% codeblock line_number:false%}\n//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0\n{% endcodeblock %}\n\n执行`sudo mount -a`，挂载`/etc/fstab`中新增的设置。\n执行`ls ~/z`，应列出共享文件夹中的内容，确认挂载成功。\n\n> 上面的命令将共享文件夹`文档`挂载到Ubuntu的`/home/ying/z`，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。\n> 其中uid是Ubuntu中用户`ying`的，具体的值可执行命令`id`，或在`/etc/passwd`中查看。\n\n## Windows访问Samba的共享文件\n先要安装`Samba File Server`，执行`sudo apt install samba samba-common`。\n> 查看Samba Server的运行状态，执行`systemctl status smbd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart smbd`\n\n添加共享文件夹：执行 `sudo nano /etc/samba/smb.conf`，在末尾添加如下内容，添加了只读的根目录`/`和可读写的`/home/ying`目录，但显示为`all`和`ying`。\n{% codeblock line_number:false%}\n[all]\n    comment = fs root directory\n    path = /\n;   writeable = no\n;   browseable = yes\n    valid users = ying\n\n[ying]\n    comment = ying's home\n    path = /home/ying\n    writeable = yes\n    create mask = 0664\n    directory mask = 0775\n;   browseable = yes\n    valid users = ying\n{% endcodeblock %}\n\n将`ying`添加为smb的共享用户：`sudo smbpasswd -a ying`， 按提示设置`ying`的smb密码，**可以与系统密码不同**。\n重启smbd，使设置生效：`sudo systemctl restart smbd`。\n\n> Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。\n\n从Windows的文件管理器的地址栏访问 `\\\\10.1.1.5` ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 **“映射网络驱动器”** 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为`\\\\u` 。\n\n从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是`smb://10.1.1.5`或`smb://u`。macOS会自动把共享文件挂载到`/Volumes`下。\n\n> Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的`WINS`名字服务。\n> 另一种方法是在`hosts`文件中为IP地址指定名字。\n\n![](/img/smb.png)\n\n> Samba共享文件与`sftp`的区别在于，`sftp`不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。\n> PS, `testparm`命令可以用来检查`smb.conf`的配置是否正确。\n\n> 参考\n+ [Setting up Samba as a Standalone Server - samba wiki](https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server)\n+ [在CentOS 7中Samba服务安装和配置](http://lybing.blog.51cto.com/3286625/1676515)\n\n## 更改Samba的默认端口号\n2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。\n估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是`smb://10.1.1.5:4455/home/`，其中4455是修改后的端口号。\n\n修改Samba的端口号只需在`/etc/samba/smb.conf`中增加\n{% codeblock line_number:false%}\n[global]\n   smb ports = 4455 445  # 可以同时监听多个端口号\n...\n{% endcodeblock %}\n\n# 远程桌面\n## mstsc\nWindows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议[Remote Desktop Protocol，RDP](https://en.wikipedia.org/wiki/Remote_Desktop_Protocol)。\n\n+ 客户端在`所有程序→Windows附件→远程桌面连接`，或直接执行命令`mstsc`。\n+ 服务程序：依次打开`控制面板→所有控制面板项→系统`，或`Win+X，Y`，然后单击左侧的`高级系统设置`，打开`系统属性`对话框，在`远程`选项卡中的`远程桌面`部分选中`允许远程连接到此计算机`，并选择某个用户。\n![Windows上的远程桌面客户端](/img/win-mstsc.png)\n![Windows上启用远程桌面](/img/win-mstsc-svr.png)\n\nUbuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。\n如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。\n\nWindows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。\n\n## vnc\nVNC（[Virtual Network Computing](https://en.wikipedia.org/wiki/Virtual_Network_Computing)）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了`远程共享`程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。\nVNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。\n\n可以参考教程[https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。\n\nWindows上没有内置的VNC客户端，有一些免费的`VNC-Viewer`程序。\n\n> 注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，\n> 默认的 `Tab` 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-> Window Manager -> Keyboard”中清除 `Switch Window from same application` 关联的快捷键\n> 还可以在 “Settings-> Keyboard -> application shortcut” 中设置打开终端的快捷键 `exo-open --launch TerminalEmulator ~ Ctrl+Alt+T`\n\n## 其它\n在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 **[TeamViewer](https://www.teamviewer.com)**，[向日葵](http://sunlogin.oray.com/zh_CN/)等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。\n","slug":"remote","published":1,"updated":"2017-10-30T02:47:45.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8vjv0002344fsvl6ts8s","content":"<p>一些基础的远程操作，包括ssh，共享文件，远程桌面。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89\">Linux远程执行命令（ssh）</a><ul>\n<li><a href=\"#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh\">Linux下设置和使用ssh</a></li>\n<li><a href=\"#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95\">Windows安装和设置xshell，使用密码ssh登录</a></li>\n<li><a href=\"#scp\">scp</a></li>\n<li><a href=\"#sftp\">sftp</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95\">设置ssh使用密钥登录</a><ul>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9\">生成密钥对</a></li>\n<li><a href=\"#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9\">分发密钥对</a><ul>\n<li><a href=\"#ssh-copy-id\">ssh-copy-id</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC\">复制密钥文本</a></li>\n</ul>\n</li>\n<li><a href=\"#ssh-config%E8%AE%BE%E7%BD%AE\">ssh config设置</a></li>\n<li><a href=\"#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D\">踢出ssh会话</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89\">远程共享文件（SMB/CIFS）</a><ul>\n<li><a href=\"#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Samba访问Windows提供的共享文件</a></li>\n<li><a href=\"#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Windows访问Samba的共享文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7\">更改Samba的默认端口号</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2\">远程桌面</a><ul>\n<li><a href=\"#mstsc\">mstsc</a></li>\n<li><a href=\"#vnc\">vnc</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（<code>ssh</code>），共享文件（<code>Samba</code>）和远程桌面（<code>mstsc</code>和<code>vnc</code>）。<br>远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。</p>\n<p>为了方便配置，<strong>建议关闭系统的防火墙</strong>。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是<code>10.1.1.5</code>，用户名<code>ying</code>；Windows的IP是<code>10.1.1.1</code>，用户名也是<code>ying</code>。</p>\n<h1 id=\"Linux远程执行命令（ssh）\"><a href=\"#Linux远程执行命令（ssh）\" class=\"headerlink\" title=\"Linux远程执行命令（ssh）\"></a>Linux远程执行命令（ssh）</h1><p>ssh（<a href=\"https://en.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">Secure Shell</a>）通过加密的网络通道在客户端和服务器之间传递命令及其输出。<br>在ssh之前，远程执行命令是通过<code>telnet</code>或<code>rsh</code>等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。<br>可以在ssh提供的加密通道上完成其它网络通信：如<code>scp</code>是在ssh加密通道上实现的远程拷贝（<code>rcp</code>）；<code>sftp</code>是在ssh加密通道上实现的<code>ftp</code>；<code>git</code>也有使用ssh加密通道传输文件的模式。<br>对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。</p>\n<h2 id=\"Linux下设置和使用ssh\"><a href=\"#Linux下设置和使用ssh\" class=\"headerlink\" title=\"Linux下设置和使用ssh\"></a>Linux下设置和使用ssh</h2><p>Linux系统的ssh服务程序是<code>OpenSSH Server</code>，执行命令<code>sudo apt install openssh-server</code>。<br>安装过程中会将ssh服务程序（<code>sshd</code>）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。</p>\n<blockquote>\n<p>查看SSH Server状态，执行<code>systemctl status sshd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart sshd</code></p>\n</blockquote>\n<p>一般Linux系统都内置了ssh客户端，执行<br><code>ssh 用户名@主机名或IP</code><br>登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。<br>登录到本机的命令是<code>ssh localhost</code><br>第一次登录某个主机会提示是否 <strong>信任</strong> 该主机，需要输入<code>yes</code>，之后才会提示输入远程主机的登录密码。</p>\n<blockquote>\n<p>修改<code>/etc/ssh/ssh_config</code>，将其中<code>#   StrictHostKeyChecking ask</code> 改为 <code>StrictHostKeyChecking no</code>，这样在第一次登录时就不会询问是否要信任该主机了。</p>\n</blockquote>\n<p>如果登录到远程主机只是执行一两条命令，可执行<br><code>ssh 用户名@主机名或IP 命令</code><br>当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。</p>\n<h2 id=\"Windows安装和设置xshell，使用密码ssh登录\"><a href=\"#Windows安装和设置xshell，使用密码ssh登录\" class=\"headerlink\" title=\"Windows安装和设置xshell，使用密码ssh登录\"></a>Windows安装和设置xshell，使用密码ssh登录</h2><p>Windows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。</p>\n<blockquote>\n<p>Windows版的<code>git</code>包含一个简化版<code>MinGW</code>，将<code>&lt;git安装目录&gt;\\usr\\bin</code>这个路径添加到Windows的<code>Path</code>环境变量，就可以在Windows的命令窗口执行<code>ssh</code>，<code>scp</code>及其它很多Linux命令了。<br><code>MinGW</code> 中也包含SSH Server程序<code>sshd</code>，不过估计很少会登录到Windows执行命令行操作吧。</p>\n</blockquote>\n<p>从官网下载并安装 <a href=\"http://www.netsarang.com/download/down_xsh.html\" target=\"_blank\" rel=\"external\">xshell</a> （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 <strong>普通下载</strong>。</p>\n<p>启动xshell后，可以直接执行<code>ssh ying@10.1.1.5</code>，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。<br><img src=\"/img/xshell-ui.png\" alt=\"\"></p>\n<blockquote>\n<p>工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行<code>open &lt;会话名&gt;</code>。<br>工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。<br>每个会话即<code>&lt;用户文档&gt;\\NetSarang\\Xshell\\Sessions</code>下的一个配置文件，会话也可以复制后修改。</p>\n</blockquote>\n<p>为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 <strong>“会话属性”</strong> 对话框中</p>\n<ul>\n<li>在“连接” 输入主机 <code>10.1.1.5</code>，在用户身份验证中选择方法为Password，输入用户名 <code>ying</code> 和 密码；</li>\n<li>在“终端” 修改“编码”为UTF-8；</li>\n<li>在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。</li>\n</ul>\n<p><img src=\"/img/xshell-prop.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”<code>Ctrl+C</code>对应的是中断当前命令。<br>xshell中默认“复制”、“粘贴”的快捷键是<code>Ctrl+Ins</code>，<code>Shift+Ins</code>，而不是<code>Ctrl+C</code>，<code>Ctrl+V</code>。<br>可以打开 “工具”-&gt;“选项”，“键盘和鼠标”选项卡，“按键对应”-&gt;“编辑”，将其修改为<code>Ctrl+C</code>，<code>Ctrl+V</code>，而原来Linux终端的快捷键需要加<code>Shift</code>，如中断当前命令的<code>Ctrl+C</code>变成了<code>Ctrl+Shift+C</code>。</p>\n</blockquote>\n<h2 id=\"scp\"><a href=\"#scp\" class=\"headerlink\" title=\"scp\"></a>scp</h2><p>通过ssh加密的通道传输文件。文件路径格式为<code>用户名@主机名或IP:主机上的路径</code>。注意，Windows文件路径中的盘符<code>C:\\</code>变成了<code>/c/</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">scp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/</div></pre></td></tr></table></figure></p>\n<h2 id=\"sftp\"><a href=\"#sftp\" class=\"headerlink\" title=\"sftp\"></a>sftp</h2><p><code>OpenSSH Server</code>内置了一个<code>sftp</code>服务器，会随<code>sshd</code>服务自动启动。我们还需要一个<code>sftp</code>的客户端即可传送文件。<br>这里使用图形界面的，跨平台的，免费的，开源的<a href=\"https://filezilla-project.org/download.php?type=client\" target=\"_blank\" rel=\"external\">Filezilla</a>。下载并安装后，在“快速连接”工具栏输入主机<code>sftp://10.1.1.5</code>，及用户名 <code>ying</code> 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。<br><img src=\"/img/sftp.png\" alt=\"\"></p>\n<p>Android上的<code>ES文件浏览器</code>也支持<code>sftp</code>（还支持下面介绍的smb局域网文件共享）。</p>\n<h2 id=\"设置ssh使用密钥登录\"><a href=\"#设置ssh使用密钥登录\" class=\"headerlink\" title=\"设置ssh使用密钥登录\"></a>设置ssh使用密钥登录</h2><p>更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用<code>rsa</code>算法，公钥和私钥分别保存在两个 <strong>文本</strong> 文件<code>id_rsa.pub</code>和<code>id_rsa</code>中。</p>\n<ul>\n<li>公钥<code>id_rsa.pub</code>保存在要登录的目标机器上（服务器，Github等），</li>\n<li>私钥<code>id_rsa</code>保存在 <strong>发起</strong> 登录的机器上（客户端），私钥要妥善保管，防止泄露。</li>\n</ul>\n<p>Linux主机的密钥对默认保存在<code>~/.ssh/</code>目录。<br>Windows是<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh\\</code>目录。在图形界面的文件管理器中不能创建以<code>.</code>开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（<code>Win键+X，C</code>），执行命令<code>mkdir C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>。</p>\n<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3><p>因为加密算法是公开的，有多种工具可以生成密钥。<br>对Linux或MinGW，执行<code>ssh-keygen -t rsa -P &quot;&quot;</code> ，会在<code>~/.ssh/</code>生成密钥对<code>id_rsa.pub</code>和<code>id_rsa</code>。</p>\n<p>xshell也可以生成密钥对：</p>\n<ul>\n<li>打开 “工具”-&gt; “新建用户密钥生成向导” 或 “工具”-&gt; “用户密钥管理者” -&gt; “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；</li>\n<li>选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；</li>\n<li>选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。</li>\n</ul>\n<p><img src=\"/img/xshell-key.png\" alt=\"\"></p>\n<h3 id=\"分发密钥对\"><a href=\"#分发密钥对\" class=\"headerlink\" title=\"分发密钥对\"></a>分发密钥对</h3><p>要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的<code>.ssh/authorized_keys</code>文件中。<br>分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的<code>scp</code>和<code>sftp</code>，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行<code>wget</code>或<code>curl</code>命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。</p>\n<h4 id=\"ssh-copy-id\"><a href=\"#ssh-copy-id\" class=\"headerlink\" title=\"ssh-copy-id\"></a>ssh-copy-id</h4><p>执行命令<code>ssh-copy-id -i 公钥文件 用户名@主机名或IP</code>，将公钥拷贝到远程Linux主机的<code>/home/&lt;用户名&gt;/.ssh/authorized_keys</code>文件中。当然，这个命令需要用密码访问远程主机。</p>\n<h4 id=\"复制密钥文本\"><a href=\"#复制密钥文本\" class=\"headerlink\" title=\"复制密钥文本\"></a>复制密钥文本</h4><p>如将Linux主机上生成的私钥<code>id_rsa</code>拷贝到Windows上：</p>\n<ul>\n<li>使用xshell用密码登录到Linux，执行<code>cat ~/.ssh/id_rsa</code>，输出私钥的内容，复制输出的文字。</li>\n<li>在Windows文件管理器中打开路径<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>，在其中创建一个名为<code>id_rsa.txt</code>的文本文件，将上一步复制的文字粘贴进去，然后把文件名的<code>.txt</code>扩展名去掉，即改为<code>id_rsa</code>。</li>\n</ul>\n<p>可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行<code>git</code>、<code>ssh</code>等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。</p>\n<h3 id=\"ssh-config设置\"><a href=\"#ssh-config设置\" class=\"headerlink\" title=\"ssh config设置\"></a>ssh config设置</h3><p>在<code>~/.ssh/config</code>文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Host   别名</div><div class=\"line\">    HostName 主机名或IP</div><div class=\"line\">    Port     端口</div><div class=\"line\">    User     用户名</div><div class=\"line\">    IdentityFile   私钥文件</div><div class=\"line\"></div><div class=\"line\">Host u</div><div class=\"line\">    Hostname  10.1.1.5</div><div class=\"line\">    Port      22</div><div class=\"line\">    User      ying</div><div class=\"line\"></div><div class=\"line\">Host          10.1.1.6</div><div class=\"line\">Port          2222</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>这样就可以直接执行<code>ssh 别名</code>登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在<code>scp</code>的路径中。</p>\n<h3 id=\"踢出ssh会话\"><a href=\"#踢出ssh会话\" class=\"headerlink\" title=\"踢出ssh会话\"></a>踢出ssh会话</h3><p>查看在线用户：<code>w</code> 或 <code>who</code>，两者输出格式有所不同。<br>查看自己的连接信息：<code>who am i</code>。<br>踢出其它会话：<code>pkill -9 -t pts/1</code>，其中<code>pts/1</code>是被踢会话的终端。</p>\n<h1 id=\"远程共享文件（SMB-CIFS）\"><a href=\"#远程共享文件（SMB-CIFS）\" class=\"headerlink\" title=\"远程共享文件（SMB/CIFS）\"></a>远程共享文件（SMB/CIFS）</h1><p>“共享文件”（<a href=\"https://en.wikipedia.org/wiki/Server_Message_Block\" target=\"_blank\" rel=\"external\">Server Message Block，SMB</a> )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。<br>Samba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。<br>Linux上与SMB/CIFS功能是类似的是“网络文件系统”（<a href=\"https://en.wikipedia.org/wiki/Network_File_System\" target=\"_blank\" rel=\"external\">Network File System，NFS</a> ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过<code>控制面板→程序和功能→启用或关闭Windows功能</code>来添加NFS客户端和服务端软件。</p>\n<blockquote>\n<p>注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。<br>共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。</p>\n</blockquote>\n<p>Linux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行<code>sudo apt install cifs-utils</code>来安装。</p>\n<h2 id=\"Samba访问Windows提供的共享文件\"><a href=\"#Samba访问Windows提供的共享文件\" class=\"headerlink\" title=\"Samba访问Windows提供的共享文件\"></a>Samba访问Windows提供的共享文件</h2><p>Windows上启用共享文件夹只要在文件夹的<code>属性对话框→共享选项卡→高级共享</code>中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加<code>$</code>，就表示是隐藏的，必须通过输入完整路径才能打开。<br><img src=\"/img/win-share.png\" alt=\"Windows上启用共享文件夹\"></p>\n<p>创建挂载点<code>mkdir ~/z</code>，并在<code>/etc/fstab</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0</div></pre></td></tr></table></figure></p>\n<p>执行<code>sudo mount -a</code>，挂载<code>/etc/fstab</code>中新增的设置。<br>执行<code>ls ~/z</code>，应列出共享文件夹中的内容，确认挂载成功。</p>\n<blockquote>\n<p>上面的命令将共享文件夹<code>文档</code>挂载到Ubuntu的<code>/home/ying/z</code>，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。<br>其中uid是Ubuntu中用户<code>ying</code>的，具体的值可执行命令<code>id</code>，或在<code>/etc/passwd</code>中查看。</p>\n</blockquote>\n<h2 id=\"Windows访问Samba的共享文件\"><a href=\"#Windows访问Samba的共享文件\" class=\"headerlink\" title=\"Windows访问Samba的共享文件\"></a>Windows访问Samba的共享文件</h2><p>先要安装<code>Samba File Server</code>，执行<code>sudo apt install samba samba-common</code>。</p>\n<blockquote>\n<p>查看Samba Server的运行状态，执行<code>systemctl status smbd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart smbd</code></p>\n</blockquote>\n<p>添加共享文件夹：执行 <code>sudo nano /etc/samba/smb.conf</code>，在末尾添加如下内容，添加了只读的根目录<code>/</code>和可读写的<code>/home/ying</code>目录，但显示为<code>all</code>和<code>ying</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[all]</div><div class=\"line\">    comment = fs root directory</div><div class=\"line\">    path = /</div><div class=\"line\">;   writeable = no</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div><div class=\"line\"></div><div class=\"line\">[ying]</div><div class=\"line\">    comment = ying&apos;s home</div><div class=\"line\">    path = /home/ying</div><div class=\"line\">    writeable = yes</div><div class=\"line\">    create mask = 0664</div><div class=\"line\">    directory mask = 0775</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div></pre></td></tr></table></figure></p>\n<p>将<code>ying</code>添加为smb的共享用户：<code>sudo smbpasswd -a ying</code>， 按提示设置<code>ying</code>的smb密码，<strong>可以与系统密码不同</strong>。<br>重启smbd，使设置生效：<code>sudo systemctl restart smbd</code>。</p>\n<blockquote>\n<p>Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。</p>\n</blockquote>\n<p>从Windows的文件管理器的地址栏访问 <code>\\\\10.1.1.5</code> ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 <strong>“映射网络驱动器”</strong> 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为<code>\\\\u</code> 。</p>\n<p>从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是<code>smb://10.1.1.5</code>或<code>smb://u</code>。macOS会自动把共享文件挂载到<code>/Volumes</code>下。</p>\n<blockquote>\n<p>Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的<code>WINS</code>名字服务。<br>另一种方法是在<code>hosts</code>文件中为IP地址指定名字。</p>\n</blockquote>\n<p><img src=\"/img/smb.png\" alt=\"\"></p>\n<blockquote>\n<p>Samba共享文件与<code>sftp</code>的区别在于，<code>sftp</code>不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。<br>PS, <code>testparm</code>命令可以用来检查<code>smb.conf</code>的配置是否正确。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server\" target=\"_blank\" rel=\"external\">Setting up Samba as a Standalone Server - samba wiki</a></li>\n<li><a href=\"http://lybing.blog.51cto.com/3286625/1676515\" target=\"_blank\" rel=\"external\">在CentOS 7中Samba服务安装和配置</a></li>\n</ul>\n</blockquote>\n<h2 id=\"更改Samba的默认端口号\"><a href=\"#更改Samba的默认端口号\" class=\"headerlink\" title=\"更改Samba的默认端口号\"></a>更改Samba的默认端口号</h2><p>2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。<br>估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是<code>smb://10.1.1.5:4455/home/</code>，其中4455是修改后的端口号。</p>\n<p>修改Samba的端口号只需在<code>/etc/samba/smb.conf</code>中增加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">   smb ports = 4455 445  # 可以同时监听多个端口号</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h1><h2 id=\"mstsc\"><a href=\"#mstsc\" class=\"headerlink\" title=\"mstsc\"></a>mstsc</h2><p>Windows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议<a href=\"https://en.wikipedia.org/wiki/Remote_Desktop_Protocol\" target=\"_blank\" rel=\"external\">Remote Desktop Protocol，RDP</a>。</p>\n<ul>\n<li>客户端在<code>所有程序→Windows附件→远程桌面连接</code>，或直接执行命令<code>mstsc</code>。</li>\n<li>服务程序：依次打开<code>控制面板→所有控制面板项→系统</code>，或<code>Win+X，Y</code>，然后单击左侧的<code>高级系统设置</code>，打开<code>系统属性</code>对话框，在<code>远程</code>选项卡中的<code>远程桌面</code>部分选中<code>允许远程连接到此计算机</code>，并选择某个用户。<br><img src=\"/img/win-mstsc.png\" alt=\"Windows上的远程桌面客户端\"><br><img src=\"/img/win-mstsc-svr.png\" alt=\"Windows上启用远程桌面\"></li>\n</ul>\n<p>Ubuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。<br>如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。</p>\n<p>Windows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。</p>\n<h2 id=\"vnc\"><a href=\"#vnc\" class=\"headerlink\" title=\"vnc\"></a>vnc</h2><p>VNC（<a href=\"https://en.wikipedia.org/wiki/Virtual_Network_Computing\" target=\"_blank\" rel=\"external\">Virtual Network Computing</a>）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了<code>远程共享</code>程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。<br>VNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。</p>\n<p>可以参考教程[<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04\" target=\"_blank\" rel=\"external\">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04</a>] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。</p>\n<p>Windows上没有内置的VNC客户端，有一些免费的<code>VNC-Viewer</code>程序。</p>\n<blockquote>\n<p>注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，<br>默认的 <code>Tab</code> 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-&gt; Window Manager -&gt; Keyboard”中清除 <code>Switch Window from same application</code> 关联的快捷键<br>还可以在 “Settings-&gt; Keyboard -&gt; application shortcut” 中设置打开终端的快捷键 <code>exo-open --launch TerminalEmulator ~ Ctrl+Alt+T</code></p>\n</blockquote>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 <strong><a href=\"https://www.teamviewer.com\" target=\"_blank\" rel=\"external\">TeamViewer</a></strong>，<a href=\"http://sunlogin.oray.com/zh_CN/\" target=\"_blank\" rel=\"external\">向日葵</a>等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。</p>\n","site":{"data":{}},"excerpt":"<p>一些基础的远程操作，包括ssh，共享文件，远程桌面。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89\">Linux远程执行命令（ssh）</a><ul>\n<li><a href=\"#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh\">Linux下设置和使用ssh</a></li>\n<li><a href=\"#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95\">Windows安装和设置xshell，使用密码ssh登录</a></li>\n<li><a href=\"#scp\">scp</a></li>\n<li><a href=\"#sftp\">sftp</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95\">设置ssh使用密钥登录</a><ul>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9\">生成密钥对</a></li>\n<li><a href=\"#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9\">分发密钥对</a><ul>\n<li><a href=\"#ssh-copy-id\">ssh-copy-id</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC\">复制密钥文本</a></li>\n</ul>\n</li>\n<li><a href=\"#ssh-config%E8%AE%BE%E7%BD%AE\">ssh config设置</a></li>\n<li><a href=\"#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D\">踢出ssh会话</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89\">远程共享文件（SMB/CIFS）</a><ul>\n<li><a href=\"#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Samba访问Windows提供的共享文件</a></li>\n<li><a href=\"#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Windows访问Samba的共享文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7\">更改Samba的默认端口号</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2\">远程桌面</a><ul>\n<li><a href=\"#mstsc\">mstsc</a></li>\n<li><a href=\"#vnc\">vnc</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（<code>ssh</code>），共享文件（<code>Samba</code>）和远程桌面（<code>mstsc</code>和<code>vnc</code>）。<br>远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。</p>\n<p>为了方便配置，<strong>建议关闭系统的防火墙</strong>。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是<code>10.1.1.5</code>，用户名<code>ying</code>；Windows的IP是<code>10.1.1.1</code>，用户名也是<code>ying</code>。</p>\n<h1 id=\"Linux远程执行命令（ssh）\"><a href=\"#Linux远程执行命令（ssh）\" class=\"headerlink\" title=\"Linux远程执行命令（ssh）\"></a>Linux远程执行命令（ssh）</h1><p>ssh（<a href=\"https://en.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">Secure Shell</a>）通过加密的网络通道在客户端和服务器之间传递命令及其输出。<br>在ssh之前，远程执行命令是通过<code>telnet</code>或<code>rsh</code>等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。<br>可以在ssh提供的加密通道上完成其它网络通信：如<code>scp</code>是在ssh加密通道上实现的远程拷贝（<code>rcp</code>）；<code>sftp</code>是在ssh加密通道上实现的<code>ftp</code>；<code>git</code>也有使用ssh加密通道传输文件的模式。<br>对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。</p>\n<h2 id=\"Linux下设置和使用ssh\"><a href=\"#Linux下设置和使用ssh\" class=\"headerlink\" title=\"Linux下设置和使用ssh\"></a>Linux下设置和使用ssh</h2><p>Linux系统的ssh服务程序是<code>OpenSSH Server</code>，执行命令<code>sudo apt install openssh-server</code>。<br>安装过程中会将ssh服务程序（<code>sshd</code>）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。</p>\n<blockquote>\n<p>查看SSH Server状态，执行<code>systemctl status sshd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart sshd</code></p>\n</blockquote>\n<p>一般Linux系统都内置了ssh客户端，执行<br><code>ssh 用户名@主机名或IP</code><br>登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。<br>登录到本机的命令是<code>ssh localhost</code><br>第一次登录某个主机会提示是否 <strong>信任</strong> 该主机，需要输入<code>yes</code>，之后才会提示输入远程主机的登录密码。</p>\n<blockquote>\n<p>修改<code>/etc/ssh/ssh_config</code>，将其中<code>#   StrictHostKeyChecking ask</code> 改为 <code>StrictHostKeyChecking no</code>，这样在第一次登录时就不会询问是否要信任该主机了。</p>\n</blockquote>\n<p>如果登录到远程主机只是执行一两条命令，可执行<br><code>ssh 用户名@主机名或IP 命令</code><br>当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。</p>\n<h2 id=\"Windows安装和设置xshell，使用密码ssh登录\"><a href=\"#Windows安装和设置xshell，使用密码ssh登录\" class=\"headerlink\" title=\"Windows安装和设置xshell，使用密码ssh登录\"></a>Windows安装和设置xshell，使用密码ssh登录</h2><p>Windows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。</p>\n<blockquote>\n<p>Windows版的<code>git</code>包含一个简化版<code>MinGW</code>，将<code>&lt;git安装目录&gt;\\usr\\bin</code>这个路径添加到Windows的<code>Path</code>环境变量，就可以在Windows的命令窗口执行<code>ssh</code>，<code>scp</code>及其它很多Linux命令了。<br><code>MinGW</code> 中也包含SSH Server程序<code>sshd</code>，不过估计很少会登录到Windows执行命令行操作吧。</p>\n</blockquote>\n<p>从官网下载并安装 <a href=\"http://www.netsarang.com/download/down_xsh.html\" target=\"_blank\" rel=\"external\">xshell</a> （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 <strong>普通下载</strong>。</p>\n<p>启动xshell后，可以直接执行<code>ssh ying@10.1.1.5</code>，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。<br><img src=\"/img/xshell-ui.png\" alt=\"\"></p>\n<blockquote>\n<p>工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行<code>open &lt;会话名&gt;</code>。<br>工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。<br>每个会话即<code>&lt;用户文档&gt;\\NetSarang\\Xshell\\Sessions</code>下的一个配置文件，会话也可以复制后修改。</p>\n</blockquote>\n<p>为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 <strong>“会话属性”</strong> 对话框中</p>\n<ul>\n<li>在“连接” 输入主机 <code>10.1.1.5</code>，在用户身份验证中选择方法为Password，输入用户名 <code>ying</code> 和 密码；</li>\n<li>在“终端” 修改“编码”为UTF-8；</li>\n<li>在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。</li>\n</ul>\n<p><img src=\"/img/xshell-prop.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”<code>Ctrl+C</code>对应的是中断当前命令。<br>xshell中默认“复制”、“粘贴”的快捷键是<code>Ctrl+Ins</code>，<code>Shift+Ins</code>，而不是<code>Ctrl+C</code>，<code>Ctrl+V</code>。<br>可以打开 “工具”-&gt;“选项”，“键盘和鼠标”选项卡，“按键对应”-&gt;“编辑”，将其修改为<code>Ctrl+C</code>，<code>Ctrl+V</code>，而原来Linux终端的快捷键需要加<code>Shift</code>，如中断当前命令的<code>Ctrl+C</code>变成了<code>Ctrl+Shift+C</code>。</p>\n</blockquote>\n<h2 id=\"scp\"><a href=\"#scp\" class=\"headerlink\" title=\"scp\"></a>scp</h2><p>通过ssh加密的通道传输文件。文件路径格式为<code>用户名@主机名或IP:主机上的路径</code>。注意，Windows文件路径中的盘符<code>C:\\</code>变成了<code>/c/</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">scp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/</div></pre></td></tr></table></figure></p>\n<h2 id=\"sftp\"><a href=\"#sftp\" class=\"headerlink\" title=\"sftp\"></a>sftp</h2><p><code>OpenSSH Server</code>内置了一个<code>sftp</code>服务器，会随<code>sshd</code>服务自动启动。我们还需要一个<code>sftp</code>的客户端即可传送文件。<br>这里使用图形界面的，跨平台的，免费的，开源的<a href=\"https://filezilla-project.org/download.php?type=client\" target=\"_blank\" rel=\"external\">Filezilla</a>。下载并安装后，在“快速连接”工具栏输入主机<code>sftp://10.1.1.5</code>，及用户名 <code>ying</code> 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。<br><img src=\"/img/sftp.png\" alt=\"\"></p>\n<p>Android上的<code>ES文件浏览器</code>也支持<code>sftp</code>（还支持下面介绍的smb局域网文件共享）。</p>\n<h2 id=\"设置ssh使用密钥登录\"><a href=\"#设置ssh使用密钥登录\" class=\"headerlink\" title=\"设置ssh使用密钥登录\"></a>设置ssh使用密钥登录</h2><p>更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用<code>rsa</code>算法，公钥和私钥分别保存在两个 <strong>文本</strong> 文件<code>id_rsa.pub</code>和<code>id_rsa</code>中。</p>\n<ul>\n<li>公钥<code>id_rsa.pub</code>保存在要登录的目标机器上（服务器，Github等），</li>\n<li>私钥<code>id_rsa</code>保存在 <strong>发起</strong> 登录的机器上（客户端），私钥要妥善保管，防止泄露。</li>\n</ul>\n<p>Linux主机的密钥对默认保存在<code>~/.ssh/</code>目录。<br>Windows是<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh\\</code>目录。在图形界面的文件管理器中不能创建以<code>.</code>开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（<code>Win键+X，C</code>），执行命令<code>mkdir C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>。</p>\n<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3><p>因为加密算法是公开的，有多种工具可以生成密钥。<br>对Linux或MinGW，执行<code>ssh-keygen -t rsa -P &quot;&quot;</code> ，会在<code>~/.ssh/</code>生成密钥对<code>id_rsa.pub</code>和<code>id_rsa</code>。</p>\n<p>xshell也可以生成密钥对：</p>\n<ul>\n<li>打开 “工具”-&gt; “新建用户密钥生成向导” 或 “工具”-&gt; “用户密钥管理者” -&gt; “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；</li>\n<li>选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；</li>\n<li>选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。</li>\n</ul>\n<p><img src=\"/img/xshell-key.png\" alt=\"\"></p>\n<h3 id=\"分发密钥对\"><a href=\"#分发密钥对\" class=\"headerlink\" title=\"分发密钥对\"></a>分发密钥对</h3><p>要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的<code>.ssh/authorized_keys</code>文件中。<br>分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的<code>scp</code>和<code>sftp</code>，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行<code>wget</code>或<code>curl</code>命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。</p>\n<h4 id=\"ssh-copy-id\"><a href=\"#ssh-copy-id\" class=\"headerlink\" title=\"ssh-copy-id\"></a>ssh-copy-id</h4><p>执行命令<code>ssh-copy-id -i 公钥文件 用户名@主机名或IP</code>，将公钥拷贝到远程Linux主机的<code>/home/&lt;用户名&gt;/.ssh/authorized_keys</code>文件中。当然，这个命令需要用密码访问远程主机。</p>\n<h4 id=\"复制密钥文本\"><a href=\"#复制密钥文本\" class=\"headerlink\" title=\"复制密钥文本\"></a>复制密钥文本</h4><p>如将Linux主机上生成的私钥<code>id_rsa</code>拷贝到Windows上：</p>\n<ul>\n<li>使用xshell用密码登录到Linux，执行<code>cat ~/.ssh/id_rsa</code>，输出私钥的内容，复制输出的文字。</li>\n<li>在Windows文件管理器中打开路径<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>，在其中创建一个名为<code>id_rsa.txt</code>的文本文件，将上一步复制的文字粘贴进去，然后把文件名的<code>.txt</code>扩展名去掉，即改为<code>id_rsa</code>。</li>\n</ul>\n<p>可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行<code>git</code>、<code>ssh</code>等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。</p>\n<h3 id=\"ssh-config设置\"><a href=\"#ssh-config设置\" class=\"headerlink\" title=\"ssh config设置\"></a>ssh config设置</h3><p>在<code>~/.ssh/config</code>文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Host   别名</div><div class=\"line\">    HostName 主机名或IP</div><div class=\"line\">    Port     端口</div><div class=\"line\">    User     用户名</div><div class=\"line\">    IdentityFile   私钥文件</div><div class=\"line\"></div><div class=\"line\">Host u</div><div class=\"line\">    Hostname  10.1.1.5</div><div class=\"line\">    Port      22</div><div class=\"line\">    User      ying</div><div class=\"line\"></div><div class=\"line\">Host          10.1.1.6</div><div class=\"line\">Port          2222</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>这样就可以直接执行<code>ssh 别名</code>登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在<code>scp</code>的路径中。</p>\n<h3 id=\"踢出ssh会话\"><a href=\"#踢出ssh会话\" class=\"headerlink\" title=\"踢出ssh会话\"></a>踢出ssh会话</h3><p>查看在线用户：<code>w</code> 或 <code>who</code>，两者输出格式有所不同。<br>查看自己的连接信息：<code>who am i</code>。<br>踢出其它会话：<code>pkill -9 -t pts/1</code>，其中<code>pts/1</code>是被踢会话的终端。</p>\n<h1 id=\"远程共享文件（SMB-CIFS）\"><a href=\"#远程共享文件（SMB-CIFS）\" class=\"headerlink\" title=\"远程共享文件（SMB/CIFS）\"></a>远程共享文件（SMB/CIFS）</h1><p>“共享文件”（<a href=\"https://en.wikipedia.org/wiki/Server_Message_Block\" target=\"_blank\" rel=\"external\">Server Message Block，SMB</a> )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。<br>Samba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。<br>Linux上与SMB/CIFS功能是类似的是“网络文件系统”（<a href=\"https://en.wikipedia.org/wiki/Network_File_System\" target=\"_blank\" rel=\"external\">Network File System，NFS</a> ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过<code>控制面板→程序和功能→启用或关闭Windows功能</code>来添加NFS客户端和服务端软件。</p>\n<blockquote>\n<p>注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。<br>共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。</p>\n</blockquote>\n<p>Linux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行<code>sudo apt install cifs-utils</code>来安装。</p>\n<h2 id=\"Samba访问Windows提供的共享文件\"><a href=\"#Samba访问Windows提供的共享文件\" class=\"headerlink\" title=\"Samba访问Windows提供的共享文件\"></a>Samba访问Windows提供的共享文件</h2><p>Windows上启用共享文件夹只要在文件夹的<code>属性对话框→共享选项卡→高级共享</code>中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加<code>$</code>，就表示是隐藏的，必须通过输入完整路径才能打开。<br><img src=\"/img/win-share.png\" alt=\"Windows上启用共享文件夹\"></p>\n<p>创建挂载点<code>mkdir ~/z</code>，并在<code>/etc/fstab</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0</div></pre></td></tr></table></figure></p>\n<p>执行<code>sudo mount -a</code>，挂载<code>/etc/fstab</code>中新增的设置。<br>执行<code>ls ~/z</code>，应列出共享文件夹中的内容，确认挂载成功。</p>\n<blockquote>\n<p>上面的命令将共享文件夹<code>文档</code>挂载到Ubuntu的<code>/home/ying/z</code>，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。<br>其中uid是Ubuntu中用户<code>ying</code>的，具体的值可执行命令<code>id</code>，或在<code>/etc/passwd</code>中查看。</p>\n</blockquote>\n<h2 id=\"Windows访问Samba的共享文件\"><a href=\"#Windows访问Samba的共享文件\" class=\"headerlink\" title=\"Windows访问Samba的共享文件\"></a>Windows访问Samba的共享文件</h2><p>先要安装<code>Samba File Server</code>，执行<code>sudo apt install samba samba-common</code>。</p>\n<blockquote>\n<p>查看Samba Server的运行状态，执行<code>systemctl status smbd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart smbd</code></p>\n</blockquote>\n<p>添加共享文件夹：执行 <code>sudo nano /etc/samba/smb.conf</code>，在末尾添加如下内容，添加了只读的根目录<code>/</code>和可读写的<code>/home/ying</code>目录，但显示为<code>all</code>和<code>ying</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[all]</div><div class=\"line\">    comment = fs root directory</div><div class=\"line\">    path = /</div><div class=\"line\">;   writeable = no</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div><div class=\"line\"></div><div class=\"line\">[ying]</div><div class=\"line\">    comment = ying&apos;s home</div><div class=\"line\">    path = /home/ying</div><div class=\"line\">    writeable = yes</div><div class=\"line\">    create mask = 0664</div><div class=\"line\">    directory mask = 0775</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div></pre></td></tr></table></figure></p>\n<p>将<code>ying</code>添加为smb的共享用户：<code>sudo smbpasswd -a ying</code>， 按提示设置<code>ying</code>的smb密码，<strong>可以与系统密码不同</strong>。<br>重启smbd，使设置生效：<code>sudo systemctl restart smbd</code>。</p>\n<blockquote>\n<p>Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。</p>\n</blockquote>\n<p>从Windows的文件管理器的地址栏访问 <code>\\\\10.1.1.5</code> ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 <strong>“映射网络驱动器”</strong> 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为<code>\\\\u</code> 。</p>\n<p>从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是<code>smb://10.1.1.5</code>或<code>smb://u</code>。macOS会自动把共享文件挂载到<code>/Volumes</code>下。</p>\n<blockquote>\n<p>Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的<code>WINS</code>名字服务。<br>另一种方法是在<code>hosts</code>文件中为IP地址指定名字。</p>\n</blockquote>\n<p><img src=\"/img/smb.png\" alt=\"\"></p>\n<blockquote>\n<p>Samba共享文件与<code>sftp</code>的区别在于，<code>sftp</code>不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。<br>PS, <code>testparm</code>命令可以用来检查<code>smb.conf</code>的配置是否正确。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server\" target=\"_blank\" rel=\"external\">Setting up Samba as a Standalone Server - samba wiki</a></li>\n<li><a href=\"http://lybing.blog.51cto.com/3286625/1676515\" target=\"_blank\" rel=\"external\">在CentOS 7中Samba服务安装和配置</a></li>\n</ul>\n</blockquote>\n<h2 id=\"更改Samba的默认端口号\"><a href=\"#更改Samba的默认端口号\" class=\"headerlink\" title=\"更改Samba的默认端口号\"></a>更改Samba的默认端口号</h2><p>2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。<br>估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是<code>smb://10.1.1.5:4455/home/</code>，其中4455是修改后的端口号。</p>\n<p>修改Samba的端口号只需在<code>/etc/samba/smb.conf</code>中增加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">   smb ports = 4455 445  # 可以同时监听多个端口号</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h1><h2 id=\"mstsc\"><a href=\"#mstsc\" class=\"headerlink\" title=\"mstsc\"></a>mstsc</h2><p>Windows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议<a href=\"https://en.wikipedia.org/wiki/Remote_Desktop_Protocol\" target=\"_blank\" rel=\"external\">Remote Desktop Protocol，RDP</a>。</p>\n<ul>\n<li>客户端在<code>所有程序→Windows附件→远程桌面连接</code>，或直接执行命令<code>mstsc</code>。</li>\n<li>服务程序：依次打开<code>控制面板→所有控制面板项→系统</code>，或<code>Win+X，Y</code>，然后单击左侧的<code>高级系统设置</code>，打开<code>系统属性</code>对话框，在<code>远程</code>选项卡中的<code>远程桌面</code>部分选中<code>允许远程连接到此计算机</code>，并选择某个用户。<br><img src=\"/img/win-mstsc.png\" alt=\"Windows上的远程桌面客户端\"><br><img src=\"/img/win-mstsc-svr.png\" alt=\"Windows上启用远程桌面\"></li>\n</ul>\n<p>Ubuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。<br>如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。</p>\n<p>Windows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。</p>\n<h2 id=\"vnc\"><a href=\"#vnc\" class=\"headerlink\" title=\"vnc\"></a>vnc</h2><p>VNC（<a href=\"https://en.wikipedia.org/wiki/Virtual_Network_Computing\" target=\"_blank\" rel=\"external\">Virtual Network Computing</a>）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了<code>远程共享</code>程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。<br>VNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。</p>\n<p>可以参考教程[<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04\" target=\"_blank\" rel=\"external\">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04</a>] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。</p>\n<p>Windows上没有内置的VNC客户端，有一些免费的<code>VNC-Viewer</code>程序。</p>\n<blockquote>\n<p>注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，<br>默认的 <code>Tab</code> 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-&gt; Window Manager -&gt; Keyboard”中清除 <code>Switch Window from same application</code> 关联的快捷键<br>还可以在 “Settings-&gt; Keyboard -&gt; application shortcut” 中设置打开终端的快捷键 <code>exo-open --launch TerminalEmulator ~ Ctrl+Alt+T</code></p>\n</blockquote>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 <strong><a href=\"https://www.teamviewer.com\" target=\"_blank\" rel=\"external\">TeamViewer</a></strong>，<a href=\"http://sunlogin.oray.com/zh_CN/\" target=\"_blank\" rel=\"external\">向日葵</a>等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。</p>"},{"title":"罗网是坚韧的","date":"2016-05-31T16:00:00.000Z","_content":"\n这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。\n为了清净，把日期改了，手工置底。\n\n====================\n\n<!--more-->\n\n吉檀迦利\n> 第28\n> 罗网是坚韧的，但是要撕破它的时候我又心痛。\n> 我只要自由，为希望自由我却觉得羞愧。\n> 我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。\n> 我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。\n> 我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。\n\n\n\n飞鸟集\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n\n> 第278\n> 我们在热爱世界时便生活在这世界上。\n\n![](/img/4books_IMG_20150328_201923.jpg)\n\n-----\n\n每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。\n\n[《瓦尔登湖》PDF](/doc/walden.pdf)是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时[积累了一些Word排版知识](https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html)，再者是受[《从一到无穷大》PDF](http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf) 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。\n\n\n-----\n\n# 离开是怎样的一种体验？\n转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。\n年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。\n顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。\n预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。\n今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。\n\n离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。\n真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。\n三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。\n然而现在熟悉的人基本都走了。\n除了离开，留下来看别人离开，可能更难过。","source":"_posts/obstinate-are-the-trammels.md","raw":"title: 罗网是坚韧的\ncategory: [misc]\ntags: \ndate: 2016-06-01\n---\n\n这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。\n为了清净，把日期改了，手工置底。\n\n====================\n\n<!--more-->\n\n吉檀迦利\n> 第28\n> 罗网是坚韧的，但是要撕破它的时候我又心痛。\n> 我只要自由，为希望自由我却觉得羞愧。\n> 我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。\n> 我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。\n> 我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。\n\n\n\n飞鸟集\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n\n> 第278\n> 我们在热爱世界时便生活在这世界上。\n\n![](/img/4books_IMG_20150328_201923.jpg)\n\n-----\n\n每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。\n\n[《瓦尔登湖》PDF](/doc/walden.pdf)是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时[积累了一些Word排版知识](https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html)，再者是受[《从一到无穷大》PDF](http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf) 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。\n\n\n-----\n\n# 离开是怎样的一种体验？\n转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。\n年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。\n顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。\n预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。\n今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。\n\n离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。\n真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。\n三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。\n然而现在熟悉的人基本都走了。\n除了离开，留下来看别人离开，可能更难过。","slug":"obstinate-are-the-trammels","published":1,"updated":"2017-10-30T03:42:14.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn8y360004344fhs8g5pbz","content":"<p>这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。<br>为了清净，把日期改了，手工置底。</p>\n<p>====================</p>\n<a id=\"more\"></a>\n<p>吉檀迦利</p>\n<blockquote>\n<p>第28<br>罗网是坚韧的，但是要撕破它的时候我又心痛。<br>我只要自由，为希望自由我却觉得羞愧。<br>我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。<br>我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。<br>我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。</p>\n</blockquote>\n<p>飞鸟集</p>\n<blockquote>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n<p>第278<br>我们在热爱世界时便生活在这世界上。</p>\n</blockquote>\n<p><img src=\"/img/4books_IMG_20150328_201923.jpg\" alt=\"\"></p>\n<hr>\n<p>每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。</p>\n<p><a href=\"/doc/walden.pdf\">《瓦尔登湖》PDF</a>是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时<a href=\"https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html\" target=\"_blank\" rel=\"external\">积累了一些Word排版知识</a>，再者是受<a href=\"http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf\" target=\"_blank\" rel=\"external\">《从一到无穷大》PDF</a> 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。</p>\n<hr>\n<h1 id=\"离开是怎样的一种体验？\"><a href=\"#离开是怎样的一种体验？\" class=\"headerlink\" title=\"离开是怎样的一种体验？\"></a>离开是怎样的一种体验？</h1><p>转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。<br>年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。<br>顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。<br>预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。<br>今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。</p>\n<p>离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。<br>真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。<br>三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。<br>然而现在熟悉的人基本都走了。<br>除了离开，留下来看别人离开，可能更难过。</p>\n","site":{"data":{}},"excerpt":"<p>这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。<br>为了清净，把日期改了，手工置底。</p>\n<p>====================</p>","more":"<p>吉檀迦利</p>\n<blockquote>\n<p>第28<br>罗网是坚韧的，但是要撕破它的时候我又心痛。<br>我只要自由，为希望自由我却觉得羞愧。<br>我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。<br>我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。<br>我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。</p>\n</blockquote>\n<p>飞鸟集</p>\n<blockquote>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n<p>第278<br>我们在热爱世界时便生活在这世界上。</p>\n</blockquote>\n<p><img src=\"/img/4books_IMG_20150328_201923.jpg\" alt=\"\"></p>\n<hr>\n<p>每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。</p>\n<p><a href=\"/doc/walden.pdf\">《瓦尔登湖》PDF</a>是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时<a href=\"https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html\" target=\"_blank\" rel=\"external\">积累了一些Word排版知识</a>，再者是受<a href=\"http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf\" target=\"_blank\" rel=\"external\">《从一到无穷大》PDF</a> 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。</p>\n<hr>\n<h1 id=\"离开是怎样的一种体验？\"><a href=\"#离开是怎样的一种体验？\" class=\"headerlink\" title=\"离开是怎样的一种体验？\"></a>离开是怎样的一种体验？</h1><p>转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。<br>年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。<br>顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。<br>预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。<br>今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。</p>\n<p>离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。<br>真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。<br>三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。<br>然而现在熟悉的人基本都走了。<br>除了离开，留下来看别人离开，可能更难过。</p>"},{"title":"在MPI集群执行Linpack测试","date":"2017-04-11T16:00:00.000Z","_content":"使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。\n尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。\n后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(\n<!--more-->\n\n<!-- TOC -->\n\n- [安装和设置mpich，blas（atlas），hpl](#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl)\n    - [设置mpich](#%E8%AE%BE%E7%BD%AEmpich)\n    - [BLAS, LINPACK/LAPACK, HPL](#blas-linpacklapack-hpl)\n    - [单机上执行 HPL](#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl)\n- [使用Intel MKL Benchmarks](#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks)\n- [Todo: 集群中测试mpi xhpl](#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl)\n\n<!-- /TOC -->\n\n# 安装和设置mpich，blas（atlas），hpl\n编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。\n\n## 设置mpich\n参考 [MPI安装手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf) 和 [MPI用户手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf)\n```\n# 安装编译器\nyum install -y gcc gcc-gfortran gcc-c++ bzip2 wget\n\n# yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译\nwget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz\ntar axf mpich-3.2.tar.gz\ncd ~/mpich-3.2\n./configure prefix=/opt/mpich\nmake -j 8 && make install  # make只会编译lib，make install才会编译lib和bin\n\ncp -r examples/ /opt/mpich/\n\n# 把编译结果打包\ncd ~\ntar zcf mpich-3.2-build.tar.gz /opt/mpich/\n# 可以将其保存到主机上\n\necho 'export PATH=$PATH:/opt/mpich/bin'                         >> /etc/profile\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib'   >> /etc/profile\nsource /etc/profile\n\n# 在本机测试一下\nmpiexec -n 3 /opt/mpich/examples/cpi\n```\n\nmpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。\nmpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。\n如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。\n要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。\n\n## BLAS, LINPACK/LAPACK, HPL\n[BLAS（Basic Linear Algebra Subprograms）- wiki](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) 或 [BLAS基础线性代数程序集 - wiki](https://zh.wikipedia.org/wiki/BLAS) 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。\n```\nwget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2\ntar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2\ncd ATLAS\nmkdir build; cd build\n../configure\nmake -j 8 && make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include\n# 同样将编译的结果也打包保存\nmkdir atlas\nmv bin/ lib/ include/ atlas/\ntar zcf atlas-build.tar.gz atlas/\n```\n\n[LINPACK](https://en.wikipedia.org/wiki/LINPACK)是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继[LAPACK](https://en.wikipedia.org/wiki/LAPACK)。[HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）](http://www.netlib.org/benchmark/hpl/)是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。\n\n参考 http://blog.chinaunix.net/uid-20104120-id-4071017.html 。\n```\nwget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz\ntar axf hpl-2.2.tar.gz\ncd hpl-2.2\ncp setup/Make.Linux_PII_CBLAS_gm Make.x86_64\n\n# 编辑 Make.x86_64，修改的内容如下。\n# 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。\n# 注意各值结尾不要有 空格。\n# 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录\nARCH         = x86_64\n\nTOPdir       = $(HOME)/hpl-2.2\nINCdir       = $(TOPdir)/include\nBINdir       = $(TOPdir)/bin\nLIBdir       = $(TOPdir)/lib\n\nMPdir        =\nMPinc        =\nMPlib        =\n\nLAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录\nLAinc        = -I$(LAdir)/include\nLAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a\n\n# 开始编译\nmake arch=x86_64 -j 8\n\n# 也将编译的结果也打包保存\nmv hpl hpl.bk.d; mkdir hpl\nmv bin/ lib/ include/ hpl/\nrmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/\ntar zcf hpl-build.tar.gz hpl/\n```\n\n## 单机上执行 HPL\n```\ncd /root/hpl-2.2/hpl/bin/\nmpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS\n# 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响\n```\n\n# 使用Intel MKL Benchmarks\n参考 https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite 。\n\n```\nwget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz\ntar axf l_mklb_p_2017.2.015.tgz\ncd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack\n./runme_xeon64\n```\n测试的结果约 150GFLOPS。\n还有一个Windows版的，在主机上测试也是接近的结果。\n\n# Todo: 集群中测试mpi xhpl\n直接运行 `l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack` 中的 `runme_intel64_static` 会报不识别 perhost 参数的错误。\n执行 `mpiexec -f hosts -n 12 ./xhpl_intel64_static`（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过`top`监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？\n参考\n+ [Intel® MPI Library - Documentation](https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation)\n+ [Intel® Optimized MP LINPACK Benchmark for Clusters](https://software.intel.com/en-us/node/528457)\n+ [HPL application note](https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note)\n+ [HPC LINPACK benchmark](http://khmel.org/?p=527)\n+ [如何做LINPACK测试及性能优化](http://blog.sciencenet.cn/blog-935970-892936.html)\n","source":"_posts/install-linpack-xhpl.md","raw":"title: 在MPI集群执行Linpack测试\ndate: 2017-04-12\ncategory: [misc]\ntags:\n\n---\n使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。\n尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。\n后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(\n<!--more-->\n\n<!-- TOC -->\n\n- [安装和设置mpich，blas（atlas），hpl](#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl)\n    - [设置mpich](#%E8%AE%BE%E7%BD%AEmpich)\n    - [BLAS, LINPACK/LAPACK, HPL](#blas-linpacklapack-hpl)\n    - [单机上执行 HPL](#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl)\n- [使用Intel MKL Benchmarks](#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks)\n- [Todo: 集群中测试mpi xhpl](#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl)\n\n<!-- /TOC -->\n\n# 安装和设置mpich，blas（atlas），hpl\n编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。\n\n## 设置mpich\n参考 [MPI安装手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf) 和 [MPI用户手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf)\n```\n# 安装编译器\nyum install -y gcc gcc-gfortran gcc-c++ bzip2 wget\n\n# yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译\nwget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz\ntar axf mpich-3.2.tar.gz\ncd ~/mpich-3.2\n./configure prefix=/opt/mpich\nmake -j 8 && make install  # make只会编译lib，make install才会编译lib和bin\n\ncp -r examples/ /opt/mpich/\n\n# 把编译结果打包\ncd ~\ntar zcf mpich-3.2-build.tar.gz /opt/mpich/\n# 可以将其保存到主机上\n\necho 'export PATH=$PATH:/opt/mpich/bin'                         >> /etc/profile\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib'   >> /etc/profile\nsource /etc/profile\n\n# 在本机测试一下\nmpiexec -n 3 /opt/mpich/examples/cpi\n```\n\nmpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。\nmpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。\n如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。\n要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。\n\n## BLAS, LINPACK/LAPACK, HPL\n[BLAS（Basic Linear Algebra Subprograms）- wiki](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) 或 [BLAS基础线性代数程序集 - wiki](https://zh.wikipedia.org/wiki/BLAS) 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。\n```\nwget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2\ntar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2\ncd ATLAS\nmkdir build; cd build\n../configure\nmake -j 8 && make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include\n# 同样将编译的结果也打包保存\nmkdir atlas\nmv bin/ lib/ include/ atlas/\ntar zcf atlas-build.tar.gz atlas/\n```\n\n[LINPACK](https://en.wikipedia.org/wiki/LINPACK)是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继[LAPACK](https://en.wikipedia.org/wiki/LAPACK)。[HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）](http://www.netlib.org/benchmark/hpl/)是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。\n\n参考 http://blog.chinaunix.net/uid-20104120-id-4071017.html 。\n```\nwget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz\ntar axf hpl-2.2.tar.gz\ncd hpl-2.2\ncp setup/Make.Linux_PII_CBLAS_gm Make.x86_64\n\n# 编辑 Make.x86_64，修改的内容如下。\n# 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。\n# 注意各值结尾不要有 空格。\n# 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录\nARCH         = x86_64\n\nTOPdir       = $(HOME)/hpl-2.2\nINCdir       = $(TOPdir)/include\nBINdir       = $(TOPdir)/bin\nLIBdir       = $(TOPdir)/lib\n\nMPdir        =\nMPinc        =\nMPlib        =\n\nLAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录\nLAinc        = -I$(LAdir)/include\nLAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a\n\n# 开始编译\nmake arch=x86_64 -j 8\n\n# 也将编译的结果也打包保存\nmv hpl hpl.bk.d; mkdir hpl\nmv bin/ lib/ include/ hpl/\nrmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/\ntar zcf hpl-build.tar.gz hpl/\n```\n\n## 单机上执行 HPL\n```\ncd /root/hpl-2.2/hpl/bin/\nmpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS\n# 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响\n```\n\n# 使用Intel MKL Benchmarks\n参考 https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite 。\n\n```\nwget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz\ntar axf l_mklb_p_2017.2.015.tgz\ncd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack\n./runme_xeon64\n```\n测试的结果约 150GFLOPS。\n还有一个Windows版的，在主机上测试也是接近的结果。\n\n# Todo: 集群中测试mpi xhpl\n直接运行 `l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack` 中的 `runme_intel64_static` 会报不识别 perhost 参数的错误。\n执行 `mpiexec -f hosts -n 12 ./xhpl_intel64_static`（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过`top`监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？\n参考\n+ [Intel® MPI Library - Documentation](https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation)\n+ [Intel® Optimized MP LINPACK Benchmark for Clusters](https://software.intel.com/en-us/node/528457)\n+ [HPL application note](https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note)\n+ [HPC LINPACK benchmark](http://khmel.org/?p=527)\n+ [如何做LINPACK测试及性能优化](http://blog.sciencenet.cn/blog-935970-892936.html)\n","slug":"install-linpack-xhpl","published":1,"updated":"2017-10-30T03:41:18.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn9e100000ig4f7g7it0c3","content":"<p>使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。<br>尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。<br>后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl\">安装和设置mpich，blas（atlas），hpl</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEmpich\">设置mpich</a></li>\n<li><a href=\"#blas-linpacklapack-hpl\">BLAS, LINPACK/LAPACK, HPL</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl\">单机上执行 HPL</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks\">使用Intel MKL Benchmarks</a></li>\n<li><a href=\"#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl\">Todo: 集群中测试mpi xhpl</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"安装和设置mpich，blas（atlas），hpl\"><a href=\"#安装和设置mpich，blas（atlas），hpl\" class=\"headerlink\" title=\"安装和设置mpich，blas（atlas），hpl\"></a>安装和设置mpich，blas（atlas），hpl</h1><p>编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。</p>\n<h2 id=\"设置mpich\"><a href=\"#设置mpich\" class=\"headerlink\" title=\"设置mpich\"></a>设置mpich</h2><p>参考 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf\" target=\"_blank\" rel=\"external\">MPI安装手册</a> 和 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf\" target=\"_blank\" rel=\"external\">MPI用户手册</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 安装编译器</div><div class=\"line\">yum install -y gcc gcc-gfortran gcc-c++ bzip2 wget</div><div class=\"line\"></div><div class=\"line\"># yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译</div><div class=\"line\">wget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz</div><div class=\"line\">tar axf mpich-3.2.tar.gz</div><div class=\"line\">cd ~/mpich-3.2</div><div class=\"line\">./configure prefix=/opt/mpich</div><div class=\"line\">make -j 8 &amp;&amp; make install  # make只会编译lib，make install才会编译lib和bin</div><div class=\"line\"></div><div class=\"line\">cp -r examples/ /opt/mpich/</div><div class=\"line\"></div><div class=\"line\"># 把编译结果打包</div><div class=\"line\">cd ~</div><div class=\"line\">tar zcf mpich-3.2-build.tar.gz /opt/mpich/</div><div class=\"line\"># 可以将其保存到主机上</div><div class=\"line\"></div><div class=\"line\">echo &apos;export PATH=$PATH:/opt/mpich/bin&apos;                         &gt;&gt; /etc/profile</div><div class=\"line\">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib&apos;   &gt;&gt; /etc/profile</div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\"># 在本机测试一下</div><div class=\"line\">mpiexec -n 3 /opt/mpich/examples/cpi</div></pre></td></tr></table></figure></p>\n<p>mpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。<br>mpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。<br>如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。<br>要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。</p>\n<h2 id=\"BLAS-LINPACK-LAPACK-HPL\"><a href=\"#BLAS-LINPACK-LAPACK-HPL\" class=\"headerlink\" title=\"BLAS, LINPACK/LAPACK, HPL\"></a>BLAS, LINPACK/LAPACK, HPL</h2><p><a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\" target=\"_blank\" rel=\"external\">BLAS（Basic Linear Algebra Subprograms）- wiki</a> 或 <a href=\"https://zh.wikipedia.org/wiki/BLAS\" target=\"_blank\" rel=\"external\">BLAS基础线性代数程序集 - wiki</a> 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2</div><div class=\"line\">tar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2</div><div class=\"line\">cd ATLAS</div><div class=\"line\">mkdir build; cd build</div><div class=\"line\">../configure</div><div class=\"line\">make -j 8 &amp;&amp; make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include</div><div class=\"line\"># 同样将编译的结果也打包保存</div><div class=\"line\">mkdir atlas</div><div class=\"line\">mv bin/ lib/ include/ atlas/</div><div class=\"line\">tar zcf atlas-build.tar.gz atlas/</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://en.wikipedia.org/wiki/LINPACK\" target=\"_blank\" rel=\"external\">LINPACK</a>是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继<a href=\"https://en.wikipedia.org/wiki/LAPACK\" target=\"_blank\" rel=\"external\">LAPACK</a>。<a href=\"http://www.netlib.org/benchmark/hpl/\" target=\"_blank\" rel=\"external\">HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）</a>是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。</p>\n<p>参考 <a href=\"http://blog.chinaunix.net/uid-20104120-id-4071017.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-20104120-id-4071017.html</a> 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz</div><div class=\"line\">tar axf hpl-2.2.tar.gz</div><div class=\"line\">cd hpl-2.2</div><div class=\"line\">cp setup/Make.Linux_PII_CBLAS_gm Make.x86_64</div><div class=\"line\"></div><div class=\"line\"># 编辑 Make.x86_64，修改的内容如下。</div><div class=\"line\"># 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。</div><div class=\"line\"># 注意各值结尾不要有 空格。</div><div class=\"line\"># 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录</div><div class=\"line\">ARCH         = x86_64</div><div class=\"line\"></div><div class=\"line\">TOPdir       = $(HOME)/hpl-2.2</div><div class=\"line\">INCdir       = $(TOPdir)/include</div><div class=\"line\">BINdir       = $(TOPdir)/bin</div><div class=\"line\">LIBdir       = $(TOPdir)/lib</div><div class=\"line\"></div><div class=\"line\">MPdir        =</div><div class=\"line\">MPinc        =</div><div class=\"line\">MPlib        =</div><div class=\"line\"></div><div class=\"line\">LAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录</div><div class=\"line\">LAinc        = -I$(LAdir)/include</div><div class=\"line\">LAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a</div><div class=\"line\"></div><div class=\"line\"># 开始编译</div><div class=\"line\">make arch=x86_64 -j 8</div><div class=\"line\"></div><div class=\"line\"># 也将编译的结果也打包保存</div><div class=\"line\">mv hpl hpl.bk.d; mkdir hpl</div><div class=\"line\">mv bin/ lib/ include/ hpl/</div><div class=\"line\">rmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/</div><div class=\"line\">tar zcf hpl-build.tar.gz hpl/</div></pre></td></tr></table></figure></p>\n<h2 id=\"单机上执行-HPL\"><a href=\"#单机上执行-HPL\" class=\"headerlink\" title=\"单机上执行 HPL\"></a>单机上执行 HPL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/hpl-2.2/hpl/bin/</div><div class=\"line\">mpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS</div><div class=\"line\"># 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响</div></pre></td></tr></table></figure>\n<h1 id=\"使用Intel-MKL-Benchmarks\"><a href=\"#使用Intel-MKL-Benchmarks\" class=\"headerlink\" title=\"使用Intel MKL Benchmarks\"></a>使用Intel MKL Benchmarks</h1><p>参考 <a href=\"https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite\" target=\"_blank\" rel=\"external\">https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz</div><div class=\"line\">tar axf l_mklb_p_2017.2.015.tgz</div><div class=\"line\">cd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack</div><div class=\"line\">./runme_xeon64</div></pre></td></tr></table></figure>\n<p>测试的结果约 150GFLOPS。<br>还有一个Windows版的，在主机上测试也是接近的结果。</p>\n<h1 id=\"Todo-集群中测试mpi-xhpl\"><a href=\"#Todo-集群中测试mpi-xhpl\" class=\"headerlink\" title=\"Todo: 集群中测试mpi xhpl\"></a>Todo: 集群中测试mpi xhpl</h1><p>直接运行 <code>l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack</code> 中的 <code>runme_intel64_static</code> 会报不识别 perhost 参数的错误。<br>执行 <code>mpiexec -f hosts -n 12 ./xhpl_intel64_static</code>（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过<code>top</code>监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？<br>参考</p>\n<ul>\n<li><a href=\"https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation\" target=\"_blank\" rel=\"external\">Intel® MPI Library - Documentation</a></li>\n<li><a href=\"https://software.intel.com/en-us/node/528457\" target=\"_blank\" rel=\"external\">Intel® Optimized MP LINPACK Benchmark for Clusters</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note\" target=\"_blank\" rel=\"external\">HPL application note</a></li>\n<li><a href=\"http://khmel.org/?p=527\" target=\"_blank\" rel=\"external\">HPC LINPACK benchmark</a></li>\n<li><a href=\"http://blog.sciencenet.cn/blog-935970-892936.html\" target=\"_blank\" rel=\"external\">如何做LINPACK测试及性能优化</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。<br>尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。<br>后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl\">安装和设置mpich，blas（atlas），hpl</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEmpich\">设置mpich</a></li>\n<li><a href=\"#blas-linpacklapack-hpl\">BLAS, LINPACK/LAPACK, HPL</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl\">单机上执行 HPL</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks\">使用Intel MKL Benchmarks</a></li>\n<li><a href=\"#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl\">Todo: 集群中测试mpi xhpl</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"安装和设置mpich，blas（atlas），hpl\"><a href=\"#安装和设置mpich，blas（atlas），hpl\" class=\"headerlink\" title=\"安装和设置mpich，blas（atlas），hpl\"></a>安装和设置mpich，blas（atlas），hpl</h1><p>编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。</p>\n<h2 id=\"设置mpich\"><a href=\"#设置mpich\" class=\"headerlink\" title=\"设置mpich\"></a>设置mpich</h2><p>参考 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf\" target=\"_blank\" rel=\"external\">MPI安装手册</a> 和 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf\" target=\"_blank\" rel=\"external\">MPI用户手册</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 安装编译器</div><div class=\"line\">yum install -y gcc gcc-gfortran gcc-c++ bzip2 wget</div><div class=\"line\"></div><div class=\"line\"># yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译</div><div class=\"line\">wget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz</div><div class=\"line\">tar axf mpich-3.2.tar.gz</div><div class=\"line\">cd ~/mpich-3.2</div><div class=\"line\">./configure prefix=/opt/mpich</div><div class=\"line\">make -j 8 &amp;&amp; make install  # make只会编译lib，make install才会编译lib和bin</div><div class=\"line\"></div><div class=\"line\">cp -r examples/ /opt/mpich/</div><div class=\"line\"></div><div class=\"line\"># 把编译结果打包</div><div class=\"line\">cd ~</div><div class=\"line\">tar zcf mpich-3.2-build.tar.gz /opt/mpich/</div><div class=\"line\"># 可以将其保存到主机上</div><div class=\"line\"></div><div class=\"line\">echo &apos;export PATH=$PATH:/opt/mpich/bin&apos;                         &gt;&gt; /etc/profile</div><div class=\"line\">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib&apos;   &gt;&gt; /etc/profile</div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\"># 在本机测试一下</div><div class=\"line\">mpiexec -n 3 /opt/mpich/examples/cpi</div></pre></td></tr></table></figure></p>\n<p>mpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。<br>mpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。<br>如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。<br>要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。</p>\n<h2 id=\"BLAS-LINPACK-LAPACK-HPL\"><a href=\"#BLAS-LINPACK-LAPACK-HPL\" class=\"headerlink\" title=\"BLAS, LINPACK/LAPACK, HPL\"></a>BLAS, LINPACK/LAPACK, HPL</h2><p><a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\" target=\"_blank\" rel=\"external\">BLAS（Basic Linear Algebra Subprograms）- wiki</a> 或 <a href=\"https://zh.wikipedia.org/wiki/BLAS\" target=\"_blank\" rel=\"external\">BLAS基础线性代数程序集 - wiki</a> 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2</div><div class=\"line\">tar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2</div><div class=\"line\">cd ATLAS</div><div class=\"line\">mkdir build; cd build</div><div class=\"line\">../configure</div><div class=\"line\">make -j 8 &amp;&amp; make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include</div><div class=\"line\"># 同样将编译的结果也打包保存</div><div class=\"line\">mkdir atlas</div><div class=\"line\">mv bin/ lib/ include/ atlas/</div><div class=\"line\">tar zcf atlas-build.tar.gz atlas/</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://en.wikipedia.org/wiki/LINPACK\" target=\"_blank\" rel=\"external\">LINPACK</a>是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继<a href=\"https://en.wikipedia.org/wiki/LAPACK\" target=\"_blank\" rel=\"external\">LAPACK</a>。<a href=\"http://www.netlib.org/benchmark/hpl/\" target=\"_blank\" rel=\"external\">HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）</a>是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。</p>\n<p>参考 <a href=\"http://blog.chinaunix.net/uid-20104120-id-4071017.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-20104120-id-4071017.html</a> 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz</div><div class=\"line\">tar axf hpl-2.2.tar.gz</div><div class=\"line\">cd hpl-2.2</div><div class=\"line\">cp setup/Make.Linux_PII_CBLAS_gm Make.x86_64</div><div class=\"line\"></div><div class=\"line\"># 编辑 Make.x86_64，修改的内容如下。</div><div class=\"line\"># 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。</div><div class=\"line\"># 注意各值结尾不要有 空格。</div><div class=\"line\"># 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录</div><div class=\"line\">ARCH         = x86_64</div><div class=\"line\"></div><div class=\"line\">TOPdir       = $(HOME)/hpl-2.2</div><div class=\"line\">INCdir       = $(TOPdir)/include</div><div class=\"line\">BINdir       = $(TOPdir)/bin</div><div class=\"line\">LIBdir       = $(TOPdir)/lib</div><div class=\"line\"></div><div class=\"line\">MPdir        =</div><div class=\"line\">MPinc        =</div><div class=\"line\">MPlib        =</div><div class=\"line\"></div><div class=\"line\">LAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录</div><div class=\"line\">LAinc        = -I$(LAdir)/include</div><div class=\"line\">LAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a</div><div class=\"line\"></div><div class=\"line\"># 开始编译</div><div class=\"line\">make arch=x86_64 -j 8</div><div class=\"line\"></div><div class=\"line\"># 也将编译的结果也打包保存</div><div class=\"line\">mv hpl hpl.bk.d; mkdir hpl</div><div class=\"line\">mv bin/ lib/ include/ hpl/</div><div class=\"line\">rmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/</div><div class=\"line\">tar zcf hpl-build.tar.gz hpl/</div></pre></td></tr></table></figure></p>\n<h2 id=\"单机上执行-HPL\"><a href=\"#单机上执行-HPL\" class=\"headerlink\" title=\"单机上执行 HPL\"></a>单机上执行 HPL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/hpl-2.2/hpl/bin/</div><div class=\"line\">mpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS</div><div class=\"line\"># 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响</div></pre></td></tr></table></figure>\n<h1 id=\"使用Intel-MKL-Benchmarks\"><a href=\"#使用Intel-MKL-Benchmarks\" class=\"headerlink\" title=\"使用Intel MKL Benchmarks\"></a>使用Intel MKL Benchmarks</h1><p>参考 <a href=\"https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite\" target=\"_blank\" rel=\"external\">https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz</div><div class=\"line\">tar axf l_mklb_p_2017.2.015.tgz</div><div class=\"line\">cd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack</div><div class=\"line\">./runme_xeon64</div></pre></td></tr></table></figure>\n<p>测试的结果约 150GFLOPS。<br>还有一个Windows版的，在主机上测试也是接近的结果。</p>\n<h1 id=\"Todo-集群中测试mpi-xhpl\"><a href=\"#Todo-集群中测试mpi-xhpl\" class=\"headerlink\" title=\"Todo: 集群中测试mpi xhpl\"></a>Todo: 集群中测试mpi xhpl</h1><p>直接运行 <code>l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack</code> 中的 <code>runme_intel64_static</code> 会报不识别 perhost 参数的错误。<br>执行 <code>mpiexec -f hosts -n 12 ./xhpl_intel64_static</code>（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过<code>top</code>监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？<br>参考</p>\n<ul>\n<li><a href=\"https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation\" target=\"_blank\" rel=\"external\">Intel® MPI Library - Documentation</a></li>\n<li><a href=\"https://software.intel.com/en-us/node/528457\" target=\"_blank\" rel=\"external\">Intel® Optimized MP LINPACK Benchmark for Clusters</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note\" target=\"_blank\" rel=\"external\">HPL application note</a></li>\n<li><a href=\"http://khmel.org/?p=527\" target=\"_blank\" rel=\"external\">HPC LINPACK benchmark</a></li>\n<li><a href=\"http://blog.sciencenet.cn/blog-935970-892936.html\" target=\"_blank\" rel=\"external\">如何做LINPACK测试及性能优化</a></li>\n</ul>"},{"title":"安装Ubuntu Server 16.04 lts","date":"2016-09-15T16:00:00.000Z","_content":"记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n    - [为什么是16.04](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604)\n    - [为什么是Server版](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88)\n    - [为什么使用 VM](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm)\n- [在虚拟中安装Ubuntu](#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu)\n    - [Virtualbox的全局设定](#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A)\n    - [安装Ubuntu](#%E5%AE%89%E8%A3%85ubuntu)\n- [基本配置](#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)\n    - [设置网络](#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C)\n    - [系统更新和升级](#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7)\n    - [[可选] 切换为root用户](#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7)\n    - [[可选] 设置sudo免密码](#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81)\n    - [杂项设置](#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE)\n    - [Tips](#tips)\n        - [PATH环境变量](#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n        - [`which`命令](#which%E5%91%BD%E4%BB%A4)\n        - [查看系统版本](#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC)\n\n<!-- /TOC -->\n\n# 说明\n\n## 为什么是16.04\n\n+ 16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。\n+ 16.04的软件源更新比较快，而且可以用更简洁的`apt`命令代替`apt-get`来安装程序。\n+ 另一个原因是[systemd](https://zh.wikipedia.org/wiki/Systemd)。`systemd`参考了Mac OS X的`launchd`，是一个替代`init`程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了`systemd`。Ubuntu 14.04 lts采用的是`upstart`，直到15.04版才转用`systemd`。在运行一些 **dokcer**，**etcd** 等服务程序的示例时，经常会看到用`systemd`的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。\n\n## 为什么是Server版\n因为在Ubuntu下只是在 **敲命令**，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 **Ubuntu桌面版默认强制** 安装一堆充满bug的办公软件，多媒体软件等。\n\n## 为什么使用 VM\n如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。\n如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(`headless`)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。\n\n> 如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机\n\"C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" startvm <虚拟机名> --type headless\n其中`C:\\Program Files\\Oracle\\VirtualBox\\`是vbox的安装路径，可以把它添加到`PATH`环境变量中。\n![](/img/vbox-headless.png)\n\n使用VM比物理机器更好的地方，\n+ 一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；\n+ 另一点是可以利用VM的 **快照功能** 方便地进行全系统的备份和恢复。\n\nVM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。\n即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。\n不建议在物理机器上安装双系统。\n\n# 在虚拟中安装Ubuntu\n\n## Virtualbox的全局设定\n安装好Virtualbox后，可以在`管理->全局设定`中修改`默认虚拟电脑位置`；另外在`网络`中添加`Nat网络`，并修改IP网段；修改已经默认添加的`仅主机(Host-Only)网络`的IP网段。\n如下图，设置Nat网络的IP网段为`10.0.1.0/24`，设置Host-Only网络的`主机虚拟网络界面`(即vbox的虚拟网卡)的IP为`10.1.1.1`，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 `192.168.56.0`网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。\n![添加Nat网络，并修改IP网段](/img/vboxconf-NatNetwork.png)\n\n![修改默认Host-Only网络的IP网段](/img/vboxconf-hostonly.png)\n\n## 安装Ubuntu\n从Ubuntu官网下载[Server 16.04.2 的.iso镜像](http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso)。\n在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。\n![](/img/vboxsetting-store.png)\n\n+ **[可选]** 安装系统前先 **不接入网络**，即在VM设置中不勾选`启用网络连接`，以免安装过程中联网更新耗时较长。\n+ **[强烈建议]** 安装时语言选择为 **英文**：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但`Location`要选择实际的区域，以匹配正确的时区。\n\n在最后的步骤中选中`Samba File Server`，`Standard System Utility`和`OpenSSH Server`（`空格键`选择或取消选择，`回车键`确认并继续下一步）。\n\n>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。\n\n![](/img/vboxsetting-net.png)\n\nServer没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是`ying`），回车，输入密码（没有任何显示），回车，进入系统的`shell`。\n![](/img/vm-tty.png)\n\n# 基本配置\n\n## 设置网络\n如果安装时没有接入网络，添加网卡后需要在`/etc/network/interfaces`中设置一下。\nUbuntu 16.04的网卡命名不是以前的类似`eth0`，`eth1`，而是`enp0s?`这样。`?`代表一个数字，\n执行`ip a`，如上图，输出的`2: enp0s3...`和`3: enp0s8...`就是已经识别出的网卡名。\n\n设置网卡：执行`sudo nano /etc/network/interfaces`，使用`nano`编辑`/etc/network/interfaces`，**增加** 下面的内容\n{% codeblock line_number:false%}\nauto  enp0s3       # NAT网络，用于连接外网\niface enp0s3 inet dhcp\n\nauto  enp0s8       # Host-Only网卡，设置静态IP，内网\niface enp0s8 inet static\naddress 10.1.1.5\nnetmask 255.255.255.0\n{% endcodeblock %}\n\n按 `Ctrl+X` 快捷键，再按 `Y` 键，回车，保存并退出`nano`。\n\n>`nano` 是一个简单的命令行文本编辑器，功能比较弱，但比`vim`直观一些。\n\n启动网卡：执行`sudo ifup enp0s3 enp0s8`，再次执行`ip a`，可以看到这两个网卡已经获取了IP地址。\n\n确认网卡工作正常：\n+ Nat网络连接外网：执行`curl ip.cn`，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）\n+ Host-only连接内网（主机）：执行`ping 10.1.1.1 -c 5`，应该能ping通。\n\n> 网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。\n\n## 系统更新和升级\n{% codeblock line_number:false%}\nsudo apt update   # 更新apt\nsudo apt upgrade  # 升级系统，可能耗时较长。\n{% endcodeblock %}\n\n如果网络速度较慢，可将apt源更换为[国内163](http://mirrors.163.com/.help/ubuntu.html)的，或者[http://mirrors.nju.edu.cn]，其中Ubuntu 16.04的代号是`xenial`。\n\n\n## [可选] 切换为root用户\n安装系统时设置的的用户有`sudo`权限。直接使用`root` **不是** 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的`sudo` 。\n执行`sudo passwd`，先输入当前用户的密码以授权`sudo`，然后输入两次`root`的登录密码。执行`exit`注销当前用户，以`root`和刚才设置的密码登录。\n\nssh默认禁止`root`用密码登录。可以修改`/etc/ssh/sshd_config`允许`root`使用密码登录，或为`root`设置使用密钥登录。\n\n## [可选] 设置sudo免密码\n如果不想直接使用`root`用户，还可以设置执行`sudo`时 **免输密码**。执行`sudo visudo`(实际上是`nano`编辑器)，找到 `%sudo\tALL=(ALL:ALL) ALL`这一行，改为`%sudo\tALL=(ALL:ALL) NOPASSWD: ALL` 。\n\n## 杂项设置\n\n{% codeblock line_number:false%}\n; 安装常用软件\nsudo apt install git zsh tree\n\n; 设置Git的全局用户名和Email\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\n\n; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF\n; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n\n; 设置zsh和oh-my-zsh\nsudo chsh ying -s /usr/bin/zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n; 使用短网址  \nwget https://git.io/SM81Wg -O - | sh\n\n; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。\n\n; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改\n; 禁用oh-my-zsh的自动更新，取消下面一行的注释\nDISABLE_AUTO_UPDATE=\"true\"\n\n; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH\n\n; 增加alias\nalias cls=\"clear\"\nalias dir=\"ls -alF\"\nalias ipconfig=\"ifconfig\"\nalias ping=\"ping -c 3\"\n\nalias ll=\"ls -alF\"\nalias ps=\"ps -af\"\nalias netstat=\"netstat -nap\"\nalias json=\"python -m json.tool\"\n{% endcodeblock %}\n\n## Tips\n### PATH环境变量\nLinux下的绝大多数命令，其实是对应着一个可执行程序的 **文件名**。这些可执行文件分散在 `PATH` 环境变量设置的目录列表中，比如\n{% codeblock line_number:false%}\necho $PATH\n; 输出为\n; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\n{% endcodeblock %}\n\n可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在`/usr/bin`，可以通过`ls /usr/bin`来确认。\n如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 *无法找到命令* 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到`PATH`。\n当前目录（`.`）默认没有加入到`PATH`中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要`./foo.sh`这样。\n\n### `which`命令\n{% codeblock line_number:false%}\n$ which which\nwhich: shell built-in command\n\n$ which echo\necho: shell built-in command\n\n$ which python\n/usr/bin/python\n{% endcodeblock %}\n\n### 查看系统版本\n查看发行版本和代号，执行`cat /etc/os-release`\n查看内核版本，执行`uname -a`\n\n-----\n\n设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。\n![](/img/vbox-snapshot.png)\n","source":"_posts/install-ubuntu.md","raw":"title: 安装Ubuntu Server 16.04 lts\ndate: 2016-09-16\ncategory: [misc]\ntags:\n\n---\n记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n    - [为什么是16.04](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604)\n    - [为什么是Server版](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88)\n    - [为什么使用 VM](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm)\n- [在虚拟中安装Ubuntu](#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu)\n    - [Virtualbox的全局设定](#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A)\n    - [安装Ubuntu](#%E5%AE%89%E8%A3%85ubuntu)\n- [基本配置](#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)\n    - [设置网络](#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C)\n    - [系统更新和升级](#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7)\n    - [[可选] 切换为root用户](#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7)\n    - [[可选] 设置sudo免密码](#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81)\n    - [杂项设置](#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE)\n    - [Tips](#tips)\n        - [PATH环境变量](#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n        - [`which`命令](#which%E5%91%BD%E4%BB%A4)\n        - [查看系统版本](#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC)\n\n<!-- /TOC -->\n\n# 说明\n\n## 为什么是16.04\n\n+ 16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。\n+ 16.04的软件源更新比较快，而且可以用更简洁的`apt`命令代替`apt-get`来安装程序。\n+ 另一个原因是[systemd](https://zh.wikipedia.org/wiki/Systemd)。`systemd`参考了Mac OS X的`launchd`，是一个替代`init`程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了`systemd`。Ubuntu 14.04 lts采用的是`upstart`，直到15.04版才转用`systemd`。在运行一些 **dokcer**，**etcd** 等服务程序的示例时，经常会看到用`systemd`的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。\n\n## 为什么是Server版\n因为在Ubuntu下只是在 **敲命令**，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 **Ubuntu桌面版默认强制** 安装一堆充满bug的办公软件，多媒体软件等。\n\n## 为什么使用 VM\n如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。\n如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(`headless`)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。\n\n> 如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机\n\"C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" startvm <虚拟机名> --type headless\n其中`C:\\Program Files\\Oracle\\VirtualBox\\`是vbox的安装路径，可以把它添加到`PATH`环境变量中。\n![](/img/vbox-headless.png)\n\n使用VM比物理机器更好的地方，\n+ 一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；\n+ 另一点是可以利用VM的 **快照功能** 方便地进行全系统的备份和恢复。\n\nVM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。\n即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。\n不建议在物理机器上安装双系统。\n\n# 在虚拟中安装Ubuntu\n\n## Virtualbox的全局设定\n安装好Virtualbox后，可以在`管理->全局设定`中修改`默认虚拟电脑位置`；另外在`网络`中添加`Nat网络`，并修改IP网段；修改已经默认添加的`仅主机(Host-Only)网络`的IP网段。\n如下图，设置Nat网络的IP网段为`10.0.1.0/24`，设置Host-Only网络的`主机虚拟网络界面`(即vbox的虚拟网卡)的IP为`10.1.1.1`，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 `192.168.56.0`网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。\n![添加Nat网络，并修改IP网段](/img/vboxconf-NatNetwork.png)\n\n![修改默认Host-Only网络的IP网段](/img/vboxconf-hostonly.png)\n\n## 安装Ubuntu\n从Ubuntu官网下载[Server 16.04.2 的.iso镜像](http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso)。\n在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。\n![](/img/vboxsetting-store.png)\n\n+ **[可选]** 安装系统前先 **不接入网络**，即在VM设置中不勾选`启用网络连接`，以免安装过程中联网更新耗时较长。\n+ **[强烈建议]** 安装时语言选择为 **英文**：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但`Location`要选择实际的区域，以匹配正确的时区。\n\n在最后的步骤中选中`Samba File Server`，`Standard System Utility`和`OpenSSH Server`（`空格键`选择或取消选择，`回车键`确认并继续下一步）。\n\n>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。\n\n![](/img/vboxsetting-net.png)\n\nServer没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是`ying`），回车，输入密码（没有任何显示），回车，进入系统的`shell`。\n![](/img/vm-tty.png)\n\n# 基本配置\n\n## 设置网络\n如果安装时没有接入网络，添加网卡后需要在`/etc/network/interfaces`中设置一下。\nUbuntu 16.04的网卡命名不是以前的类似`eth0`，`eth1`，而是`enp0s?`这样。`?`代表一个数字，\n执行`ip a`，如上图，输出的`2: enp0s3...`和`3: enp0s8...`就是已经识别出的网卡名。\n\n设置网卡：执行`sudo nano /etc/network/interfaces`，使用`nano`编辑`/etc/network/interfaces`，**增加** 下面的内容\n{% codeblock line_number:false%}\nauto  enp0s3       # NAT网络，用于连接外网\niface enp0s3 inet dhcp\n\nauto  enp0s8       # Host-Only网卡，设置静态IP，内网\niface enp0s8 inet static\naddress 10.1.1.5\nnetmask 255.255.255.0\n{% endcodeblock %}\n\n按 `Ctrl+X` 快捷键，再按 `Y` 键，回车，保存并退出`nano`。\n\n>`nano` 是一个简单的命令行文本编辑器，功能比较弱，但比`vim`直观一些。\n\n启动网卡：执行`sudo ifup enp0s3 enp0s8`，再次执行`ip a`，可以看到这两个网卡已经获取了IP地址。\n\n确认网卡工作正常：\n+ Nat网络连接外网：执行`curl ip.cn`，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）\n+ Host-only连接内网（主机）：执行`ping 10.1.1.1 -c 5`，应该能ping通。\n\n> 网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。\n\n## 系统更新和升级\n{% codeblock line_number:false%}\nsudo apt update   # 更新apt\nsudo apt upgrade  # 升级系统，可能耗时较长。\n{% endcodeblock %}\n\n如果网络速度较慢，可将apt源更换为[国内163](http://mirrors.163.com/.help/ubuntu.html)的，或者[http://mirrors.nju.edu.cn]，其中Ubuntu 16.04的代号是`xenial`。\n\n\n## [可选] 切换为root用户\n安装系统时设置的的用户有`sudo`权限。直接使用`root` **不是** 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的`sudo` 。\n执行`sudo passwd`，先输入当前用户的密码以授权`sudo`，然后输入两次`root`的登录密码。执行`exit`注销当前用户，以`root`和刚才设置的密码登录。\n\nssh默认禁止`root`用密码登录。可以修改`/etc/ssh/sshd_config`允许`root`使用密码登录，或为`root`设置使用密钥登录。\n\n## [可选] 设置sudo免密码\n如果不想直接使用`root`用户，还可以设置执行`sudo`时 **免输密码**。执行`sudo visudo`(实际上是`nano`编辑器)，找到 `%sudo\tALL=(ALL:ALL) ALL`这一行，改为`%sudo\tALL=(ALL:ALL) NOPASSWD: ALL` 。\n\n## 杂项设置\n\n{% codeblock line_number:false%}\n; 安装常用软件\nsudo apt install git zsh tree\n\n; 设置Git的全局用户名和Email\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\n\n; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF\n; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n\n; 设置zsh和oh-my-zsh\nsudo chsh ying -s /usr/bin/zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n; 使用短网址  \nwget https://git.io/SM81Wg -O - | sh\n\n; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。\n\n; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改\n; 禁用oh-my-zsh的自动更新，取消下面一行的注释\nDISABLE_AUTO_UPDATE=\"true\"\n\n; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH\n\n; 增加alias\nalias cls=\"clear\"\nalias dir=\"ls -alF\"\nalias ipconfig=\"ifconfig\"\nalias ping=\"ping -c 3\"\n\nalias ll=\"ls -alF\"\nalias ps=\"ps -af\"\nalias netstat=\"netstat -nap\"\nalias json=\"python -m json.tool\"\n{% endcodeblock %}\n\n## Tips\n### PATH环境变量\nLinux下的绝大多数命令，其实是对应着一个可执行程序的 **文件名**。这些可执行文件分散在 `PATH` 环境变量设置的目录列表中，比如\n{% codeblock line_number:false%}\necho $PATH\n; 输出为\n; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\n{% endcodeblock %}\n\n可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在`/usr/bin`，可以通过`ls /usr/bin`来确认。\n如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 *无法找到命令* 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到`PATH`。\n当前目录（`.`）默认没有加入到`PATH`中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要`./foo.sh`这样。\n\n### `which`命令\n{% codeblock line_number:false%}\n$ which which\nwhich: shell built-in command\n\n$ which echo\necho: shell built-in command\n\n$ which python\n/usr/bin/python\n{% endcodeblock %}\n\n### 查看系统版本\n查看发行版本和代号，执行`cat /etc/os-release`\n查看内核版本，执行`uname -a`\n\n-----\n\n设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。\n![](/img/vbox-snapshot.png)\n","slug":"install-ubuntu","published":1,"updated":"2017-10-30T02:47:52.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn9e150002ig4fed2r9n6i","content":"<p>记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604\">为什么是16.04</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88\">为什么是Server版</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm\">为什么使用 VM</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu\">在虚拟中安装Ubuntu</a><ul>\n<li><a href=\"#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A\">Virtualbox的全局设定</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85ubuntu\">安装Ubuntu</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\">基本配置</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C\">设置网络</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7\">系统更新和升级</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7\">[可选] 切换为root用户</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81\">[可选] 设置sudo免密码</a></li>\n<li><a href=\"#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE\">杂项设置</a></li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">PATH环境变量</a></li>\n<li><a href=\"#which%E5%91%BD%E4%BB%A4\"><code>which</code>命令</a></li>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC\">查看系统版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><h2 id=\"为什么是16-04\"><a href=\"#为什么是16-04\" class=\"headerlink\" title=\"为什么是16.04\"></a>为什么是16.04</h2><ul>\n<li>16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。</li>\n<li>16.04的软件源更新比较快，而且可以用更简洁的<code>apt</code>命令代替<code>apt-get</code>来安装程序。</li>\n<li>另一个原因是<a href=\"https://zh.wikipedia.org/wiki/Systemd\" target=\"_blank\" rel=\"external\">systemd</a>。<code>systemd</code>参考了Mac OS X的<code>launchd</code>，是一个替代<code>init</code>程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了<code>systemd</code>。Ubuntu 14.04 lts采用的是<code>upstart</code>，直到15.04版才转用<code>systemd</code>。在运行一些 <strong>dokcer</strong>，<strong>etcd</strong> 等服务程序的示例时，经常会看到用<code>systemd</code>的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。</li>\n</ul>\n<h2 id=\"为什么是Server版\"><a href=\"#为什么是Server版\" class=\"headerlink\" title=\"为什么是Server版\"></a>为什么是Server版</h2><p>因为在Ubuntu下只是在 <strong>敲命令</strong>，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 <strong>Ubuntu桌面版默认强制</strong> 安装一堆充满bug的办公软件，多媒体软件等。</p>\n<h2 id=\"为什么使用-VM\"><a href=\"#为什么使用-VM\" class=\"headerlink\" title=\"为什么使用 VM\"></a>为什么使用 VM</h2><p>如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。<br>如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(<code>headless</code>)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。</p>\n<blockquote>\n<p>如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机<br>“C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe” startvm &lt;虚拟机名&gt; –type headless<br>其中<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>是vbox的安装路径，可以把它添加到<code>PATH</code>环境变量中。<br><img src=\"/img/vbox-headless.png\" alt=\"\"></p>\n</blockquote>\n<p>使用VM比物理机器更好的地方，</p>\n<ul>\n<li>一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；</li>\n<li>另一点是可以利用VM的 <strong>快照功能</strong> 方便地进行全系统的备份和恢复。</li>\n</ul>\n<p>VM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。<br>即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。<br>不建议在物理机器上安装双系统。</p>\n<h1 id=\"在虚拟中安装Ubuntu\"><a href=\"#在虚拟中安装Ubuntu\" class=\"headerlink\" title=\"在虚拟中安装Ubuntu\"></a>在虚拟中安装Ubuntu</h1><h2 id=\"Virtualbox的全局设定\"><a href=\"#Virtualbox的全局设定\" class=\"headerlink\" title=\"Virtualbox的全局设定\"></a>Virtualbox的全局设定</h2><p>安装好Virtualbox后，可以在<code>管理-&gt;全局设定</code>中修改<code>默认虚拟电脑位置</code>；另外在<code>网络</code>中添加<code>Nat网络</code>，并修改IP网段；修改已经默认添加的<code>仅主机(Host-Only)网络</code>的IP网段。<br>如下图，设置Nat网络的IP网段为<code>10.0.1.0/24</code>，设置Host-Only网络的<code>主机虚拟网络界面</code>(即vbox的虚拟网卡)的IP为<code>10.1.1.1</code>，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 <code>192.168.56.0</code>网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。<br><img src=\"/img/vboxconf-NatNetwork.png\" alt=\"添加Nat网络，并修改IP网段\"></p>\n<p><img src=\"/img/vboxconf-hostonly.png\" alt=\"修改默认Host-Only网络的IP网段\"></p>\n<h2 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h2><p>从Ubuntu官网下载<a href=\"http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso\" target=\"_blank\" rel=\"external\">Server 16.04.2 的.iso镜像</a>。<br>在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。<br><img src=\"/img/vboxsetting-store.png\" alt=\"\"></p>\n<ul>\n<li><strong>[可选]</strong> 安装系统前先 <strong>不接入网络</strong>，即在VM设置中不勾选<code>启用网络连接</code>，以免安装过程中联网更新耗时较长。</li>\n<li><strong>[强烈建议]</strong> 安装时语言选择为 <strong>英文</strong>：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但<code>Location</code>要选择实际的区域，以匹配正确的时区。</li>\n</ul>\n<p>在最后的步骤中选中<code>Samba File Server</code>，<code>Standard System Utility</code>和<code>OpenSSH Server</code>（<code>空格键</code>选择或取消选择，<code>回车键</code>确认并继续下一步）。</p>\n<blockquote>\n<p>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。</p>\n</blockquote>\n<p><img src=\"/img/vboxsetting-net.png\" alt=\"\"></p>\n<p>Server没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是<code>ying</code>），回车，输入密码（没有任何显示），回车，进入系统的<code>shell</code>。<br><img src=\"/img/vm-tty.png\" alt=\"\"></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><h2 id=\"设置网络\"><a href=\"#设置网络\" class=\"headerlink\" title=\"设置网络\"></a>设置网络</h2><p>如果安装时没有接入网络，添加网卡后需要在<code>/etc/network/interfaces</code>中设置一下。<br>Ubuntu 16.04的网卡命名不是以前的类似<code>eth0</code>，<code>eth1</code>，而是<code>enp0s?</code>这样。<code>?</code>代表一个数字，<br>执行<code>ip a</code>，如上图，输出的<code>2: enp0s3...</code>和<code>3: enp0s8...</code>就是已经识别出的网卡名。</p>\n<p>设置网卡：执行<code>sudo nano /etc/network/interfaces</code>，使用<code>nano</code>编辑<code>/etc/network/interfaces</code>，<strong>增加</strong> 下面的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">auto  enp0s3       # NAT网络，用于连接外网</div><div class=\"line\">iface enp0s3 inet dhcp</div><div class=\"line\"></div><div class=\"line\">auto  enp0s8       # Host-Only网卡，设置静态IP，内网</div><div class=\"line\">iface enp0s8 inet static</div><div class=\"line\">address 10.1.1.5</div><div class=\"line\">netmask 255.255.255.0</div></pre></td></tr></table></figure></p>\n<p>按 <code>Ctrl+X</code> 快捷键，再按 <code>Y</code> 键，回车，保存并退出<code>nano</code>。</p>\n<blockquote>\n<p><code>nano</code> 是一个简单的命令行文本编辑器，功能比较弱，但比<code>vim</code>直观一些。</p>\n</blockquote>\n<p>启动网卡：执行<code>sudo ifup enp0s3 enp0s8</code>，再次执行<code>ip a</code>，可以看到这两个网卡已经获取了IP地址。</p>\n<p>确认网卡工作正常：</p>\n<ul>\n<li>Nat网络连接外网：执行<code>curl ip.cn</code>，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）</li>\n<li>Host-only连接内网（主机）：执行<code>ping 10.1.1.1 -c 5</code>，应该能ping通。</li>\n</ul>\n<blockquote>\n<p>网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。</p>\n</blockquote>\n<h2 id=\"系统更新和升级\"><a href=\"#系统更新和升级\" class=\"headerlink\" title=\"系统更新和升级\"></a>系统更新和升级</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo apt update   # 更新apt</div><div class=\"line\">sudo apt upgrade  # 升级系统，可能耗时较长。</div></pre></td></tr></table></figure>\n<p>如果网络速度较慢，可将apt源更换为<a href=\"http://mirrors.163.com/.help/ubuntu.html\" target=\"_blank\" rel=\"external\">国内163</a>的，或者[<a href=\"http://mirrors.nju.edu.cn]，其中Ubuntu\" target=\"_blank\" rel=\"external\">http://mirrors.nju.edu.cn]，其中Ubuntu</a> 16.04的代号是<code>xenial</code>。</p>\n<h2 id=\"可选-切换为root用户\"><a href=\"#可选-切换为root用户\" class=\"headerlink\" title=\"[可选] 切换为root用户\"></a>[可选] 切换为root用户</h2><p>安装系统时设置的的用户有<code>sudo</code>权限。直接使用<code>root</code> <strong>不是</strong> 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的<code>sudo</code> 。<br>执行<code>sudo passwd</code>，先输入当前用户的密码以授权<code>sudo</code>，然后输入两次<code>root</code>的登录密码。执行<code>exit</code>注销当前用户，以<code>root</code>和刚才设置的密码登录。</p>\n<p>ssh默认禁止<code>root</code>用密码登录。可以修改<code>/etc/ssh/sshd_config</code>允许<code>root</code>使用密码登录，或为<code>root</code>设置使用密钥登录。</p>\n<h2 id=\"可选-设置sudo免密码\"><a href=\"#可选-设置sudo免密码\" class=\"headerlink\" title=\"[可选] 设置sudo免密码\"></a>[可选] 设置sudo免密码</h2><p>如果不想直接使用<code>root</code>用户，还可以设置执行<code>sudo</code>时 <strong>免输密码</strong>。执行<code>sudo visudo</code>(实际上是<code>nano</code>编辑器)，找到 <code>%sudo    ALL=(ALL:ALL) ALL</code>这一行，改为<code>%sudo    ALL=(ALL:ALL) NOPASSWD: ALL</code> 。</p>\n<h2 id=\"杂项设置\"><a href=\"#杂项设置\" class=\"headerlink\" title=\"杂项设置\"></a>杂项设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">; 安装常用软件</div><div class=\"line\">sudo apt install git zsh tree</div><div class=\"line\"></div><div class=\"line\">; 设置Git的全局用户名和Email</div><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\"></div><div class=\"line\">; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF</div><div class=\"line\">; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div><div class=\"line\"></div><div class=\"line\">; 设置zsh和oh-my-zsh</div><div class=\"line\">sudo chsh ying -s /usr/bin/zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</div><div class=\"line\">; 使用短网址  </div><div class=\"line\">wget https://git.io/SM81Wg -O - | sh</div><div class=\"line\"></div><div class=\"line\">; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。</div><div class=\"line\"></div><div class=\"line\">; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改</div><div class=\"line\">; 禁用oh-my-zsh的自动更新，取消下面一行的注释</div><div class=\"line\">DISABLE_AUTO_UPDATE=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH</div><div class=\"line\"></div><div class=\"line\">; 增加alias</div><div class=\"line\">alias cls=&quot;clear&quot;</div><div class=\"line\">alias dir=&quot;ls -alF&quot;</div><div class=\"line\">alias ipconfig=&quot;ifconfig&quot;</div><div class=\"line\">alias ping=&quot;ping -c 3&quot;</div><div class=\"line\"></div><div class=\"line\">alias ll=&quot;ls -alF&quot;</div><div class=\"line\">alias ps=&quot;ps -af&quot;</div><div class=\"line\">alias netstat=&quot;netstat -nap&quot;</div><div class=\"line\">alias json=&quot;python -m json.tool&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><h3 id=\"PATH环境变量\"><a href=\"#PATH环境变量\" class=\"headerlink\" title=\"PATH环境变量\"></a>PATH环境变量</h3><p>Linux下的绝大多数命令，其实是对应着一个可执行程序的 <strong>文件名</strong>。这些可执行文件分散在 <code>PATH</code> 环境变量设置的目录列表中，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">echo $PATH</div><div class=\"line\">; 输出为</div><div class=\"line\">; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</div></pre></td></tr></table></figure></p>\n<p>可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在<code>/usr/bin</code>，可以通过<code>ls /usr/bin</code>来确认。<br>如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 <em>无法找到命令</em> 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到<code>PATH</code>。<br>当前目录（<code>.</code>）默认没有加入到<code>PATH</code>中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要<code>./foo.sh</code>这样。</p>\n<h3 id=\"which命令\"><a href=\"#which命令\" class=\"headerlink\" title=\"which命令\"></a><code>which</code>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ which which</div><div class=\"line\">which: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which echo</div><div class=\"line\">echo: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which python</div><div class=\"line\">/usr/bin/python</div></pre></td></tr></table></figure>\n<h3 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h3><p>查看发行版本和代号，执行<code>cat /etc/os-release</code><br>查看内核版本，执行<code>uname -a</code></p>\n<hr>\n<p>设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。<br><img src=\"/img/vbox-snapshot.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604\">为什么是16.04</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88\">为什么是Server版</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm\">为什么使用 VM</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu\">在虚拟中安装Ubuntu</a><ul>\n<li><a href=\"#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A\">Virtualbox的全局设定</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85ubuntu\">安装Ubuntu</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\">基本配置</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C\">设置网络</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7\">系统更新和升级</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7\">[可选] 切换为root用户</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81\">[可选] 设置sudo免密码</a></li>\n<li><a href=\"#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE\">杂项设置</a></li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">PATH环境变量</a></li>\n<li><a href=\"#which%E5%91%BD%E4%BB%A4\"><code>which</code>命令</a></li>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC\">查看系统版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><h2 id=\"为什么是16-04\"><a href=\"#为什么是16-04\" class=\"headerlink\" title=\"为什么是16.04\"></a>为什么是16.04</h2><ul>\n<li>16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。</li>\n<li>16.04的软件源更新比较快，而且可以用更简洁的<code>apt</code>命令代替<code>apt-get</code>来安装程序。</li>\n<li>另一个原因是<a href=\"https://zh.wikipedia.org/wiki/Systemd\" target=\"_blank\" rel=\"external\">systemd</a>。<code>systemd</code>参考了Mac OS X的<code>launchd</code>，是一个替代<code>init</code>程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了<code>systemd</code>。Ubuntu 14.04 lts采用的是<code>upstart</code>，直到15.04版才转用<code>systemd</code>。在运行一些 <strong>dokcer</strong>，<strong>etcd</strong> 等服务程序的示例时，经常会看到用<code>systemd</code>的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。</li>\n</ul>\n<h2 id=\"为什么是Server版\"><a href=\"#为什么是Server版\" class=\"headerlink\" title=\"为什么是Server版\"></a>为什么是Server版</h2><p>因为在Ubuntu下只是在 <strong>敲命令</strong>，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 <strong>Ubuntu桌面版默认强制</strong> 安装一堆充满bug的办公软件，多媒体软件等。</p>\n<h2 id=\"为什么使用-VM\"><a href=\"#为什么使用-VM\" class=\"headerlink\" title=\"为什么使用 VM\"></a>为什么使用 VM</h2><p>如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。<br>如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(<code>headless</code>)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。</p>\n<blockquote>\n<p>如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机<br>“C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe” startvm &lt;虚拟机名&gt; –type headless<br>其中<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>是vbox的安装路径，可以把它添加到<code>PATH</code>环境变量中。<br><img src=\"/img/vbox-headless.png\" alt=\"\"></p>\n</blockquote>\n<p>使用VM比物理机器更好的地方，</p>\n<ul>\n<li>一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；</li>\n<li>另一点是可以利用VM的 <strong>快照功能</strong> 方便地进行全系统的备份和恢复。</li>\n</ul>\n<p>VM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。<br>即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。<br>不建议在物理机器上安装双系统。</p>\n<h1 id=\"在虚拟中安装Ubuntu\"><a href=\"#在虚拟中安装Ubuntu\" class=\"headerlink\" title=\"在虚拟中安装Ubuntu\"></a>在虚拟中安装Ubuntu</h1><h2 id=\"Virtualbox的全局设定\"><a href=\"#Virtualbox的全局设定\" class=\"headerlink\" title=\"Virtualbox的全局设定\"></a>Virtualbox的全局设定</h2><p>安装好Virtualbox后，可以在<code>管理-&gt;全局设定</code>中修改<code>默认虚拟电脑位置</code>；另外在<code>网络</code>中添加<code>Nat网络</code>，并修改IP网段；修改已经默认添加的<code>仅主机(Host-Only)网络</code>的IP网段。<br>如下图，设置Nat网络的IP网段为<code>10.0.1.0/24</code>，设置Host-Only网络的<code>主机虚拟网络界面</code>(即vbox的虚拟网卡)的IP为<code>10.1.1.1</code>，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 <code>192.168.56.0</code>网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。<br><img src=\"/img/vboxconf-NatNetwork.png\" alt=\"添加Nat网络，并修改IP网段\"></p>\n<p><img src=\"/img/vboxconf-hostonly.png\" alt=\"修改默认Host-Only网络的IP网段\"></p>\n<h2 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h2><p>从Ubuntu官网下载<a href=\"http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso\" target=\"_blank\" rel=\"external\">Server 16.04.2 的.iso镜像</a>。<br>在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。<br><img src=\"/img/vboxsetting-store.png\" alt=\"\"></p>\n<ul>\n<li><strong>[可选]</strong> 安装系统前先 <strong>不接入网络</strong>，即在VM设置中不勾选<code>启用网络连接</code>，以免安装过程中联网更新耗时较长。</li>\n<li><strong>[强烈建议]</strong> 安装时语言选择为 <strong>英文</strong>：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但<code>Location</code>要选择实际的区域，以匹配正确的时区。</li>\n</ul>\n<p>在最后的步骤中选中<code>Samba File Server</code>，<code>Standard System Utility</code>和<code>OpenSSH Server</code>（<code>空格键</code>选择或取消选择，<code>回车键</code>确认并继续下一步）。</p>\n<blockquote>\n<p>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。</p>\n</blockquote>\n<p><img src=\"/img/vboxsetting-net.png\" alt=\"\"></p>\n<p>Server没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是<code>ying</code>），回车，输入密码（没有任何显示），回车，进入系统的<code>shell</code>。<br><img src=\"/img/vm-tty.png\" alt=\"\"></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><h2 id=\"设置网络\"><a href=\"#设置网络\" class=\"headerlink\" title=\"设置网络\"></a>设置网络</h2><p>如果安装时没有接入网络，添加网卡后需要在<code>/etc/network/interfaces</code>中设置一下。<br>Ubuntu 16.04的网卡命名不是以前的类似<code>eth0</code>，<code>eth1</code>，而是<code>enp0s?</code>这样。<code>?</code>代表一个数字，<br>执行<code>ip a</code>，如上图，输出的<code>2: enp0s3...</code>和<code>3: enp0s8...</code>就是已经识别出的网卡名。</p>\n<p>设置网卡：执行<code>sudo nano /etc/network/interfaces</code>，使用<code>nano</code>编辑<code>/etc/network/interfaces</code>，<strong>增加</strong> 下面的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">auto  enp0s3       # NAT网络，用于连接外网</div><div class=\"line\">iface enp0s3 inet dhcp</div><div class=\"line\"></div><div class=\"line\">auto  enp0s8       # Host-Only网卡，设置静态IP，内网</div><div class=\"line\">iface enp0s8 inet static</div><div class=\"line\">address 10.1.1.5</div><div class=\"line\">netmask 255.255.255.0</div></pre></td></tr></table></figure></p>\n<p>按 <code>Ctrl+X</code> 快捷键，再按 <code>Y</code> 键，回车，保存并退出<code>nano</code>。</p>\n<blockquote>\n<p><code>nano</code> 是一个简单的命令行文本编辑器，功能比较弱，但比<code>vim</code>直观一些。</p>\n</blockquote>\n<p>启动网卡：执行<code>sudo ifup enp0s3 enp0s8</code>，再次执行<code>ip a</code>，可以看到这两个网卡已经获取了IP地址。</p>\n<p>确认网卡工作正常：</p>\n<ul>\n<li>Nat网络连接外网：执行<code>curl ip.cn</code>，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）</li>\n<li>Host-only连接内网（主机）：执行<code>ping 10.1.1.1 -c 5</code>，应该能ping通。</li>\n</ul>\n<blockquote>\n<p>网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。</p>\n</blockquote>\n<h2 id=\"系统更新和升级\"><a href=\"#系统更新和升级\" class=\"headerlink\" title=\"系统更新和升级\"></a>系统更新和升级</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo apt update   # 更新apt</div><div class=\"line\">sudo apt upgrade  # 升级系统，可能耗时较长。</div></pre></td></tr></table></figure>\n<p>如果网络速度较慢，可将apt源更换为<a href=\"http://mirrors.163.com/.help/ubuntu.html\" target=\"_blank\" rel=\"external\">国内163</a>的，或者[<a href=\"http://mirrors.nju.edu.cn]，其中Ubuntu\" target=\"_blank\" rel=\"external\">http://mirrors.nju.edu.cn]，其中Ubuntu</a> 16.04的代号是<code>xenial</code>。</p>\n<h2 id=\"可选-切换为root用户\"><a href=\"#可选-切换为root用户\" class=\"headerlink\" title=\"[可选] 切换为root用户\"></a>[可选] 切换为root用户</h2><p>安装系统时设置的的用户有<code>sudo</code>权限。直接使用<code>root</code> <strong>不是</strong> 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的<code>sudo</code> 。<br>执行<code>sudo passwd</code>，先输入当前用户的密码以授权<code>sudo</code>，然后输入两次<code>root</code>的登录密码。执行<code>exit</code>注销当前用户，以<code>root</code>和刚才设置的密码登录。</p>\n<p>ssh默认禁止<code>root</code>用密码登录。可以修改<code>/etc/ssh/sshd_config</code>允许<code>root</code>使用密码登录，或为<code>root</code>设置使用密钥登录。</p>\n<h2 id=\"可选-设置sudo免密码\"><a href=\"#可选-设置sudo免密码\" class=\"headerlink\" title=\"[可选] 设置sudo免密码\"></a>[可选] 设置sudo免密码</h2><p>如果不想直接使用<code>root</code>用户，还可以设置执行<code>sudo</code>时 <strong>免输密码</strong>。执行<code>sudo visudo</code>(实际上是<code>nano</code>编辑器)，找到 <code>%sudo    ALL=(ALL:ALL) ALL</code>这一行，改为<code>%sudo    ALL=(ALL:ALL) NOPASSWD: ALL</code> 。</p>\n<h2 id=\"杂项设置\"><a href=\"#杂项设置\" class=\"headerlink\" title=\"杂项设置\"></a>杂项设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">; 安装常用软件</div><div class=\"line\">sudo apt install git zsh tree</div><div class=\"line\"></div><div class=\"line\">; 设置Git的全局用户名和Email</div><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\"></div><div class=\"line\">; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF</div><div class=\"line\">; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div><div class=\"line\"></div><div class=\"line\">; 设置zsh和oh-my-zsh</div><div class=\"line\">sudo chsh ying -s /usr/bin/zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</div><div class=\"line\">; 使用短网址  </div><div class=\"line\">wget https://git.io/SM81Wg -O - | sh</div><div class=\"line\"></div><div class=\"line\">; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。</div><div class=\"line\"></div><div class=\"line\">; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改</div><div class=\"line\">; 禁用oh-my-zsh的自动更新，取消下面一行的注释</div><div class=\"line\">DISABLE_AUTO_UPDATE=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH</div><div class=\"line\"></div><div class=\"line\">; 增加alias</div><div class=\"line\">alias cls=&quot;clear&quot;</div><div class=\"line\">alias dir=&quot;ls -alF&quot;</div><div class=\"line\">alias ipconfig=&quot;ifconfig&quot;</div><div class=\"line\">alias ping=&quot;ping -c 3&quot;</div><div class=\"line\"></div><div class=\"line\">alias ll=&quot;ls -alF&quot;</div><div class=\"line\">alias ps=&quot;ps -af&quot;</div><div class=\"line\">alias netstat=&quot;netstat -nap&quot;</div><div class=\"line\">alias json=&quot;python -m json.tool&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><h3 id=\"PATH环境变量\"><a href=\"#PATH环境变量\" class=\"headerlink\" title=\"PATH环境变量\"></a>PATH环境变量</h3><p>Linux下的绝大多数命令，其实是对应着一个可执行程序的 <strong>文件名</strong>。这些可执行文件分散在 <code>PATH</code> 环境变量设置的目录列表中，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">echo $PATH</div><div class=\"line\">; 输出为</div><div class=\"line\">; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</div></pre></td></tr></table></figure></p>\n<p>可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在<code>/usr/bin</code>，可以通过<code>ls /usr/bin</code>来确认。<br>如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 <em>无法找到命令</em> 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到<code>PATH</code>。<br>当前目录（<code>.</code>）默认没有加入到<code>PATH</code>中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要<code>./foo.sh</code>这样。</p>\n<h3 id=\"which命令\"><a href=\"#which命令\" class=\"headerlink\" title=\"which命令\"></a><code>which</code>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ which which</div><div class=\"line\">which: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which echo</div><div class=\"line\">echo: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which python</div><div class=\"line\">/usr/bin/python</div></pre></td></tr></table></figure>\n<h3 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h3><p>查看发行版本和代号，执行<code>cat /etc/os-release</code><br>查看内核版本，执行<code>uname -a</code></p>\n<hr>\n<p>设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。<br><img src=\"/img/vbox-snapshot.png\" alt=\"\"></p>"},{"title":"安装和设置Windows 10","date":"2016-09-16T16:00:00.000Z","_content":"记录一下安装Windows 10 LTSB 及 基本设置作为备忘。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [为什么是 LTSB](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb)\n- [创建USB安装盘，安装系统](#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [硬盘分区规划](#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92)\n- [常用快捷键](#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE)\n- [系统设置](#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE)\n- [安装Linux常用工具](#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7)\n- [Windows Server 2016 的设置](#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE)\n- [Reg文件](#reg%E6%96%87%E4%BB%B6)\n- [其它](#%E5%85%B6%E5%AE%83)\n    - [开启虚拟wifi](#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi)\n\n<!-- /TOC -->\n\n# 为什么是 LTSB\n1、Win10 LTSB企业版没有Edge浏览器\n2、无应用商店\n3、无任何系统自带磁贴程序\n4、无Cortana\n5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。\n总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。\n此外，还可以使用有学校后缀的Email在微软的[https://imagine.microsoft.com/zh-cn] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。\n\n# 创建USB安装盘，安装系统\n搜索`cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso` 或在[http://msdn.itellyou.cn] 找到下载的ED2K链接，下载后用[Rufus](http://rufus.akeo.ie/) 制作USB启动安装盘，注意要 **取消** `高级选项` 中的 `使用Rufus MBR配合 BIOS ID...`。\n然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。\n\n# 硬盘分区规划\n买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。\n\n# 常用快捷键\n+ Win + D : 切换显示桌面\n+ Win + E : 打开`文件资源管理器`\n+ Win + R : 打开`运行`对话框\n+ Win + X : 打开`开始`按钮的右键快捷菜单，*基本* 对应于`C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX`目录的快捷方式\n  + F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 `F` 键，或写成`Win+X, F`，这些键都在每个菜单项后面标出来了）\n  + P : 控制面板\n  + Y : 系统属性\n  + C/A : 命令窗口\n  + G : 计算机管理\n  + U, I : 注销\n  + U, R : 重启\n  + U, U : 关机\n\n> [向Win+X添加快捷方式](http://blog.sina.com.cn/s/blog_a0c06a350102y239.html)。为了方便使用git附带的minGW，创建了一个指向`git-bash.exe`的快捷方式。可以在`C:\\Users\\Ying\\.bash_profile`增加一个`cd /E/Code`的命令来修改`git-bash`的默认启动目录。\n\n# 系统设置\n\n0. 安装系统更新（会自动安装大部分驱动）\n1. 在`系统属性`对话框中\n  + 更改计算机名\n  + 调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量\n  + 禁用系统保护\n  + 禁用远程协助，开启远程桌面\n2. 关闭休眠：Win+X, A，然后再命令行输入 `powercfg /h off`\n3. 在每个分区，打开`分区属性`对话框，取消`除了文件属性外，还允许索引此驱动器上的文件内容`；磁盘清理，删除`Windows.old`\n4. 安装字体，如`Microsoft Yahei Mono`，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体\n5. 更改IE主页为`about:tabs`，删除内置的加速器\n6. 在`文件夹选项`\n + 设置`打开文件资源管理器时打开`此电脑\n + 取消隐私相关选项\n + `查看`中将大图标文件夹视图`应用到文件夹`\n + 取消`使用共享向导`\n + 取消`始终显示图标，从不显示缩略图`\n + 取消`隐藏受保护的操作系统文件`，选择`显示隐藏的文件、文件夹或驱动器`\n + 取消`隐藏已知文件类型的扩展名`\n7. 在`个性化->主题->桌面图标设置`中选中显示`计算机`桌面图标\n8. 任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标\n9. 禁用防火墙，取消`安全性与维护`中的所有消息\n10. 禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender\n11. 禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索\n12. 安装`百度输入法`，设置使用双拼；安装`7zip`，`迅雷精简版`，`Everything`\n13. 移动系统默认文件夹\n  + 在D盘新建`D:\\桌面`，`D:\\下载`，`D:\\App`，`D:\\文档\\音乐`，`D:文档\\图片`，`D:\\文档\\视频`，`D:文档\\收藏夹`\n  + 在`C:\\Users\\Ying\\`各系统默认文件夹的属性对话框的`位置`选项卡中，将其移动到对应的D盘新位置\n  + `D:\\App`存放一些绿色免安装的程序\n  + **不要** 使用以前的更改注册表的方法来移动默认文件夹\n14. 删除/合并开始菜单项\n  + `C:\\ProgramData\\Microsoft\\Windows\\Start Menu`\n  + `C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu`\n15. 禁用某些服务\n16. 安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用`cleanmaster.exe`清理磁盘和隐私项，使用`winmaster.exe`清理右键菜单\n\nGhost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。\n\n# 安装Linux常用工具\n安装git（不是Github，当然也可以），其中自带`MinGW`，其中有`bash`、`curl`、`vim`、`ssh`等工具。\n在`PATH`环境变量中添上其路径（`D:\\App\\git\\mingw64\\bin`，`D:\\App\\Git\\usr\\bin`和`D:\\App\\Git\\bin`）即可。\n还可以安装 [Linux Subsystem on Windows（WSL）](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) 和 ‎Bash on Ubuntu on Windows。\n\n# Windows Server 2016 的设置\n\n+ 安装系统更新，鲁大师安装不能识别的设备驱动\n+ 设置Windows audio服务为自动启动\n+ 卸载Defender\n+ 组策略-> 计算机配置\n  + Windows设置-> 安全设置-> 帐户策略-> 密码策略-> 密码必须符合复杂性要求\n  + Windows设置-> 安全设置-> 本地策略-> 安全选项-> 交互式登录：无须按Ctrl+Alt+Del\n  + 管理模板-> 系统-> 显示“关闭事件跟踪程序”\n\n# Reg文件\n\n[直接下载Win10.reg](/doc/win10.reg)\n\n```\nWindows Registry Editor Version 5.00\n\n;更改命令行窗口字体\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]\n\"0\"=\"Lucida Console\"\n\"936\"=\"*Microsoft YaHei Mono\"\n\"00\"=\"Consolas\"\n\n;开启的分区共享(C$, D$...)\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]\n\"LocalAccountTokenFilterPolicy\"=dword:00000001\n\n;清除通知区域图标，需重启文件资源管理器\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]\n\n;删除“此电脑”下的6个文件夹\n;视频\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}]\n;文档\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{d3162b92-9365-467a-956b-92703aca08af}]\n;桌面\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}]\n;音乐\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}]\n;下载\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{088e3905-0323-4b02-9826-5d99428e115f}]\n;图片\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]\n\n;删除文件资源管理器左侧的OneDrive\n[HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}\\ShellFolder]\n\"FolderValueFlags\"=dword:00000028\n\"Attributes\"=dword:f090004d\n\n;使用“照片查看器”打开图片\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.gif]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.png]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n\n```\n\n# 其它\n## 开启虚拟wifi\n设置\n```\nnetsh wlan set hostednetwork mode=allow ssid=Ying key=12345678\n```\n\n开启\n```\nnetsh wlan start hostednetwork\n```\n\n连接外网\n有线网卡 的属性中选择`共享`\n","source":"_posts/install-win-10.md","raw":"title: 安装和设置Windows 10\ndate: 2016-09-17\ncategory: [misc]\ntags:\n\n---\n记录一下安装Windows 10 LTSB 及 基本设置作为备忘。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [为什么是 LTSB](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb)\n- [创建USB安装盘，安装系统](#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [硬盘分区规划](#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92)\n- [常用快捷键](#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE)\n- [系统设置](#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE)\n- [安装Linux常用工具](#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7)\n- [Windows Server 2016 的设置](#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE)\n- [Reg文件](#reg%E6%96%87%E4%BB%B6)\n- [其它](#%E5%85%B6%E5%AE%83)\n    - [开启虚拟wifi](#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi)\n\n<!-- /TOC -->\n\n# 为什么是 LTSB\n1、Win10 LTSB企业版没有Edge浏览器\n2、无应用商店\n3、无任何系统自带磁贴程序\n4、无Cortana\n5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。\n总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。\n此外，还可以使用有学校后缀的Email在微软的[https://imagine.microsoft.com/zh-cn] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。\n\n# 创建USB安装盘，安装系统\n搜索`cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso` 或在[http://msdn.itellyou.cn] 找到下载的ED2K链接，下载后用[Rufus](http://rufus.akeo.ie/) 制作USB启动安装盘，注意要 **取消** `高级选项` 中的 `使用Rufus MBR配合 BIOS ID...`。\n然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。\n\n# 硬盘分区规划\n买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。\n\n# 常用快捷键\n+ Win + D : 切换显示桌面\n+ Win + E : 打开`文件资源管理器`\n+ Win + R : 打开`运行`对话框\n+ Win + X : 打开`开始`按钮的右键快捷菜单，*基本* 对应于`C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX`目录的快捷方式\n  + F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 `F` 键，或写成`Win+X, F`，这些键都在每个菜单项后面标出来了）\n  + P : 控制面板\n  + Y : 系统属性\n  + C/A : 命令窗口\n  + G : 计算机管理\n  + U, I : 注销\n  + U, R : 重启\n  + U, U : 关机\n\n> [向Win+X添加快捷方式](http://blog.sina.com.cn/s/blog_a0c06a350102y239.html)。为了方便使用git附带的minGW，创建了一个指向`git-bash.exe`的快捷方式。可以在`C:\\Users\\Ying\\.bash_profile`增加一个`cd /E/Code`的命令来修改`git-bash`的默认启动目录。\n\n# 系统设置\n\n0. 安装系统更新（会自动安装大部分驱动）\n1. 在`系统属性`对话框中\n  + 更改计算机名\n  + 调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量\n  + 禁用系统保护\n  + 禁用远程协助，开启远程桌面\n2. 关闭休眠：Win+X, A，然后再命令行输入 `powercfg /h off`\n3. 在每个分区，打开`分区属性`对话框，取消`除了文件属性外，还允许索引此驱动器上的文件内容`；磁盘清理，删除`Windows.old`\n4. 安装字体，如`Microsoft Yahei Mono`，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体\n5. 更改IE主页为`about:tabs`，删除内置的加速器\n6. 在`文件夹选项`\n + 设置`打开文件资源管理器时打开`此电脑\n + 取消隐私相关选项\n + `查看`中将大图标文件夹视图`应用到文件夹`\n + 取消`使用共享向导`\n + 取消`始终显示图标，从不显示缩略图`\n + 取消`隐藏受保护的操作系统文件`，选择`显示隐藏的文件、文件夹或驱动器`\n + 取消`隐藏已知文件类型的扩展名`\n7. 在`个性化->主题->桌面图标设置`中选中显示`计算机`桌面图标\n8. 任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标\n9. 禁用防火墙，取消`安全性与维护`中的所有消息\n10. 禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender\n11. 禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索\n12. 安装`百度输入法`，设置使用双拼；安装`7zip`，`迅雷精简版`，`Everything`\n13. 移动系统默认文件夹\n  + 在D盘新建`D:\\桌面`，`D:\\下载`，`D:\\App`，`D:\\文档\\音乐`，`D:文档\\图片`，`D:\\文档\\视频`，`D:文档\\收藏夹`\n  + 在`C:\\Users\\Ying\\`各系统默认文件夹的属性对话框的`位置`选项卡中，将其移动到对应的D盘新位置\n  + `D:\\App`存放一些绿色免安装的程序\n  + **不要** 使用以前的更改注册表的方法来移动默认文件夹\n14. 删除/合并开始菜单项\n  + `C:\\ProgramData\\Microsoft\\Windows\\Start Menu`\n  + `C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu`\n15. 禁用某些服务\n16. 安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用`cleanmaster.exe`清理磁盘和隐私项，使用`winmaster.exe`清理右键菜单\n\nGhost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。\n\n# 安装Linux常用工具\n安装git（不是Github，当然也可以），其中自带`MinGW`，其中有`bash`、`curl`、`vim`、`ssh`等工具。\n在`PATH`环境变量中添上其路径（`D:\\App\\git\\mingw64\\bin`，`D:\\App\\Git\\usr\\bin`和`D:\\App\\Git\\bin`）即可。\n还可以安装 [Linux Subsystem on Windows（WSL）](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) 和 ‎Bash on Ubuntu on Windows。\n\n# Windows Server 2016 的设置\n\n+ 安装系统更新，鲁大师安装不能识别的设备驱动\n+ 设置Windows audio服务为自动启动\n+ 卸载Defender\n+ 组策略-> 计算机配置\n  + Windows设置-> 安全设置-> 帐户策略-> 密码策略-> 密码必须符合复杂性要求\n  + Windows设置-> 安全设置-> 本地策略-> 安全选项-> 交互式登录：无须按Ctrl+Alt+Del\n  + 管理模板-> 系统-> 显示“关闭事件跟踪程序”\n\n# Reg文件\n\n[直接下载Win10.reg](/doc/win10.reg)\n\n```\nWindows Registry Editor Version 5.00\n\n;更改命令行窗口字体\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]\n\"0\"=\"Lucida Console\"\n\"936\"=\"*Microsoft YaHei Mono\"\n\"00\"=\"Consolas\"\n\n;开启的分区共享(C$, D$...)\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]\n\"LocalAccountTokenFilterPolicy\"=dword:00000001\n\n;清除通知区域图标，需重启文件资源管理器\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]\n\n;删除“此电脑”下的6个文件夹\n;视频\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}]\n;文档\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{d3162b92-9365-467a-956b-92703aca08af}]\n;桌面\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}]\n;音乐\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}]\n;下载\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{088e3905-0323-4b02-9826-5d99428e115f}]\n;图片\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]\n\n;删除文件资源管理器左侧的OneDrive\n[HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}\\ShellFolder]\n\"FolderValueFlags\"=dword:00000028\n\"Attributes\"=dword:f090004d\n\n;使用“照片查看器”打开图片\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.gif]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.png]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n\n```\n\n# 其它\n## 开启虚拟wifi\n设置\n```\nnetsh wlan set hostednetwork mode=allow ssid=Ying key=12345678\n```\n\n开启\n```\nnetsh wlan start hostednetwork\n```\n\n连接外网\n有线网卡 的属性中选择`共享`\n","slug":"install-win-10","published":1,"updated":"2017-10-30T03:42:23.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn9e160003ig4f4y0ulzbz","content":"<p>记录一下安装Windows 10 LTSB 及 基本设置作为备忘。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb\">为什么是 LTSB</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">创建USB安装盘，安装系统</a></li>\n<li><a href=\"#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92\">硬盘分区规划</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE\">常用快捷键</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE\">系统设置</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7\">安装Linux常用工具</a></li>\n<li><a href=\"#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE\">Windows Server 2016 的设置</a></li>\n<li><a href=\"#reg%E6%96%87%E4%BB%B6\">Reg文件</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a><ul>\n<li><a href=\"#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi\">开启虚拟wifi</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"为什么是-LTSB\"><a href=\"#为什么是-LTSB\" class=\"headerlink\" title=\"为什么是 LTSB\"></a>为什么是 LTSB</h1><p>1、Win10 LTSB企业版没有Edge浏览器<br>2、无应用商店<br>3、无任何系统自带磁贴程序<br>4、无Cortana<br>5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。<br>总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。<br>此外，还可以使用有学校后缀的Email在微软的[<a href=\"https://imagine.microsoft.com/zh-cn\" target=\"_blank\" rel=\"external\">https://imagine.microsoft.com/zh-cn</a>] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。</p>\n<h1 id=\"创建USB安装盘，安装系统\"><a href=\"#创建USB安装盘，安装系统\" class=\"headerlink\" title=\"创建USB安装盘，安装系统\"></a>创建USB安装盘，安装系统</h1><p>搜索<code>cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso</code> 或在[<a href=\"http://msdn.itellyou.cn\" target=\"_blank\" rel=\"external\">http://msdn.itellyou.cn</a>] 找到下载的ED2K链接，下载后用<a href=\"http://rufus.akeo.ie/\" target=\"_blank\" rel=\"external\">Rufus</a> 制作USB启动安装盘，注意要 <strong>取消</strong> <code>高级选项</code> 中的 <code>使用Rufus MBR配合 BIOS ID...</code>。<br>然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。</p>\n<h1 id=\"硬盘分区规划\"><a href=\"#硬盘分区规划\" class=\"headerlink\" title=\"硬盘分区规划\"></a>硬盘分区规划</h1><p>买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。</p>\n<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ul>\n<li>Win + D : 切换显示桌面</li>\n<li>Win + E : 打开<code>文件资源管理器</code></li>\n<li>Win + R : 打开<code>运行</code>对话框</li>\n<li>Win + X : 打开<code>开始</code>按钮的右键快捷菜单，<em>基本</em> 对应于<code>C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX</code>目录的快捷方式<ul>\n<li>F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 <code>F</code> 键，或写成<code>Win+X, F</code>，这些键都在每个菜单项后面标出来了）</li>\n<li>P : 控制面板</li>\n<li>Y : 系统属性</li>\n<li>C/A : 命令窗口</li>\n<li>G : 计算机管理</li>\n<li>U, I : 注销</li>\n<li>U, R : 重启</li>\n<li>U, U : 关机</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"http://blog.sina.com.cn/s/blog_a0c06a350102y239.html\" target=\"_blank\" rel=\"external\">向Win+X添加快捷方式</a>。为了方便使用git附带的minGW，创建了一个指向<code>git-bash.exe</code>的快捷方式。可以在<code>C:\\Users\\Ying\\.bash_profile</code>增加一个<code>cd /E/Code</code>的命令来修改<code>git-bash</code>的默认启动目录。</p>\n</blockquote>\n<h1 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h1><ol>\n<li>安装系统更新（会自动安装大部分驱动）</li>\n<li>在<code>系统属性</code>对话框中<ul>\n<li>更改计算机名</li>\n<li>调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量</li>\n<li>禁用系统保护</li>\n<li>禁用远程协助，开启远程桌面</li>\n</ul>\n</li>\n<li>关闭休眠：Win+X, A，然后再命令行输入 <code>powercfg /h off</code></li>\n<li>在每个分区，打开<code>分区属性</code>对话框，取消<code>除了文件属性外，还允许索引此驱动器上的文件内容</code>；磁盘清理，删除<code>Windows.old</code></li>\n<li>安装字体，如<code>Microsoft Yahei Mono</code>，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体</li>\n<li>更改IE主页为<code>about:tabs</code>，删除内置的加速器</li>\n<li>在<code>文件夹选项</code><ul>\n<li>设置<code>打开文件资源管理器时打开</code>此电脑</li>\n<li>取消隐私相关选项</li>\n<li><code>查看</code>中将大图标文件夹视图<code>应用到文件夹</code></li>\n<li>取消<code>使用共享向导</code></li>\n<li>取消<code>始终显示图标，从不显示缩略图</code></li>\n<li>取消<code>隐藏受保护的操作系统文件</code>，选择<code>显示隐藏的文件、文件夹或驱动器</code></li>\n<li>取消<code>隐藏已知文件类型的扩展名</code></li>\n</ul>\n</li>\n<li>在<code>个性化-&gt;主题-&gt;桌面图标设置</code>中选中显示<code>计算机</code>桌面图标</li>\n<li>任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标</li>\n<li>禁用防火墙，取消<code>安全性与维护</code>中的所有消息</li>\n<li>禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender</li>\n<li>禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索</li>\n<li>安装<code>百度输入法</code>，设置使用双拼；安装<code>7zip</code>，<code>迅雷精简版</code>，<code>Everything</code></li>\n<li>移动系统默认文件夹<ul>\n<li>在D盘新建<code>D:\\桌面</code>，<code>D:\\下载</code>，<code>D:\\App</code>，<code>D:\\文档\\音乐</code>，<code>D:文档\\图片</code>，<code>D:\\文档\\视频</code>，<code>D:文档\\收藏夹</code></li>\n<li>在<code>C:\\Users\\Ying\\</code>各系统默认文件夹的属性对话框的<code>位置</code>选项卡中，将其移动到对应的D盘新位置</li>\n<li><code>D:\\App</code>存放一些绿色免安装的程序</li>\n<li><strong>不要</strong> 使用以前的更改注册表的方法来移动默认文件夹</li>\n</ul>\n</li>\n<li>删除/合并开始菜单项<ul>\n<li><code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu</code></li>\n<li><code>C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu</code></li>\n</ul>\n</li>\n<li>禁用某些服务</li>\n<li>安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用<code>cleanmaster.exe</code>清理磁盘和隐私项，使用<code>winmaster.exe</code>清理右键菜单</li>\n</ol>\n<p>Ghost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。</p>\n<h1 id=\"安装Linux常用工具\"><a href=\"#安装Linux常用工具\" class=\"headerlink\" title=\"安装Linux常用工具\"></a>安装Linux常用工具</h1><p>安装git（不是Github，当然也可以），其中自带<code>MinGW</code>，其中有<code>bash</code>、<code>curl</code>、<code>vim</code>、<code>ssh</code>等工具。<br>在<code>PATH</code>环境变量中添上其路径（<code>D:\\App\\git\\mingw64\\bin</code>，<code>D:\\App\\Git\\usr\\bin</code>和<code>D:\\App\\Git\\bin</code>）即可。<br>还可以安装 <a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/install_guide\" target=\"_blank\" rel=\"external\">Linux Subsystem on Windows（WSL）</a> 和 ‎Bash on Ubuntu on Windows。</p>\n<h1 id=\"Windows-Server-2016-的设置\"><a href=\"#Windows-Server-2016-的设置\" class=\"headerlink\" title=\"Windows Server 2016 的设置\"></a>Windows Server 2016 的设置</h1><ul>\n<li>安装系统更新，鲁大师安装不能识别的设备驱动</li>\n<li>设置Windows audio服务为自动启动</li>\n<li>卸载Defender</li>\n<li>组策略-&gt; 计算机配置<ul>\n<li>Windows设置-&gt; 安全设置-&gt; 帐户策略-&gt; 密码策略-&gt; 密码必须符合复杂性要求</li>\n<li>Windows设置-&gt; 安全设置-&gt; 本地策略-&gt; 安全选项-&gt; 交互式登录：无须按Ctrl+Alt+Del</li>\n<li>管理模板-&gt; 系统-&gt; 显示“关闭事件跟踪程序”</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Reg文件\"><a href=\"#Reg文件\" class=\"headerlink\" title=\"Reg文件\"></a>Reg文件</h1><p><a href=\"/doc/win10.reg\">直接下载Win10.reg</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">Windows Registry Editor Version 5.00</div><div class=\"line\"></div><div class=\"line\">;更改命令行窗口字体</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]</div><div class=\"line\">&quot;0&quot;=&quot;Lucida Console&quot;</div><div class=\"line\">&quot;936&quot;=&quot;*Microsoft YaHei Mono&quot;</div><div class=\"line\">&quot;00&quot;=&quot;Consolas&quot;</div><div class=\"line\"></div><div class=\"line\">;开启的分区共享(C$, D$...)</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]</div><div class=\"line\">&quot;LocalAccountTokenFilterPolicy&quot;=dword:00000001</div><div class=\"line\"></div><div class=\"line\">;清除通知区域图标，需重启文件资源管理器</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]</div><div class=\"line\"></div><div class=\"line\">;删除“此电脑”下的6个文件夹</div><div class=\"line\">;视频</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a&#125;]</div><div class=\"line\">;文档</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;d3162b92-9365-467a-956b-92703aca08af&#125;]</div><div class=\"line\">;桌面</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;B4BFCC3A-DB2C-424C-B029-7FE99A87C641&#125;]</div><div class=\"line\">;音乐</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;3dfdf296-dbec-4fb4-81d1-6a3438bcf4de&#125;]</div><div class=\"line\">;下载</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;088e3905-0323-4b02-9826-5d99428e115f&#125;]</div><div class=\"line\">;图片</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;24ad3ad4-a569-4530-98e1-ab02f9417aa8&#125;]</div><div class=\"line\"></div><div class=\"line\">;删除文件资源管理器左侧的OneDrive</div><div class=\"line\">[HKEY_CLASSES_ROOT\\CLSID\\&#123;018D5C66-4533-4307-9B53-224DE2ED1FE6&#125;\\ShellFolder]</div><div class=\"line\">&quot;FolderValueFlags&quot;=dword:00000028</div><div class=\"line\">&quot;Attributes&quot;=dword:f090004d</div><div class=\"line\"></div><div class=\"line\">;使用“照片查看器”打开图片</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.gif]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.png]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div></pre></td></tr></table></figure>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"开启虚拟wifi\"><a href=\"#开启虚拟wifi\" class=\"headerlink\" title=\"开启虚拟wifi\"></a>开启虚拟wifi</h2><p>设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan set hostednetwork mode=allow ssid=Ying key=12345678</div></pre></td></tr></table></figure></p>\n<p>开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan start hostednetwork</div></pre></td></tr></table></figure></p>\n<p>连接外网<br>有线网卡 的属性中选择<code>共享</code></p>\n","site":{"data":{}},"excerpt":"<p>记录一下安装Windows 10 LTSB 及 基本设置作为备忘。</p>","more":"<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb\">为什么是 LTSB</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">创建USB安装盘，安装系统</a></li>\n<li><a href=\"#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92\">硬盘分区规划</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE\">常用快捷键</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE\">系统设置</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7\">安装Linux常用工具</a></li>\n<li><a href=\"#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE\">Windows Server 2016 的设置</a></li>\n<li><a href=\"#reg%E6%96%87%E4%BB%B6\">Reg文件</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a><ul>\n<li><a href=\"#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi\">开启虚拟wifi</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"为什么是-LTSB\"><a href=\"#为什么是-LTSB\" class=\"headerlink\" title=\"为什么是 LTSB\"></a>为什么是 LTSB</h1><p>1、Win10 LTSB企业版没有Edge浏览器<br>2、无应用商店<br>3、无任何系统自带磁贴程序<br>4、无Cortana<br>5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。<br>总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。<br>此外，还可以使用有学校后缀的Email在微软的[<a href=\"https://imagine.microsoft.com/zh-cn\" target=\"_blank\" rel=\"external\">https://imagine.microsoft.com/zh-cn</a>] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。</p>\n<h1 id=\"创建USB安装盘，安装系统\"><a href=\"#创建USB安装盘，安装系统\" class=\"headerlink\" title=\"创建USB安装盘，安装系统\"></a>创建USB安装盘，安装系统</h1><p>搜索<code>cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso</code> 或在[<a href=\"http://msdn.itellyou.cn\" target=\"_blank\" rel=\"external\">http://msdn.itellyou.cn</a>] 找到下载的ED2K链接，下载后用<a href=\"http://rufus.akeo.ie/\" target=\"_blank\" rel=\"external\">Rufus</a> 制作USB启动安装盘，注意要 <strong>取消</strong> <code>高级选项</code> 中的 <code>使用Rufus MBR配合 BIOS ID...</code>。<br>然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。</p>\n<h1 id=\"硬盘分区规划\"><a href=\"#硬盘分区规划\" class=\"headerlink\" title=\"硬盘分区规划\"></a>硬盘分区规划</h1><p>买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。</p>\n<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ul>\n<li>Win + D : 切换显示桌面</li>\n<li>Win + E : 打开<code>文件资源管理器</code></li>\n<li>Win + R : 打开<code>运行</code>对话框</li>\n<li>Win + X : 打开<code>开始</code>按钮的右键快捷菜单，<em>基本</em> 对应于<code>C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX</code>目录的快捷方式<ul>\n<li>F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 <code>F</code> 键，或写成<code>Win+X, F</code>，这些键都在每个菜单项后面标出来了）</li>\n<li>P : 控制面板</li>\n<li>Y : 系统属性</li>\n<li>C/A : 命令窗口</li>\n<li>G : 计算机管理</li>\n<li>U, I : 注销</li>\n<li>U, R : 重启</li>\n<li>U, U : 关机</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"http://blog.sina.com.cn/s/blog_a0c06a350102y239.html\" target=\"_blank\" rel=\"external\">向Win+X添加快捷方式</a>。为了方便使用git附带的minGW，创建了一个指向<code>git-bash.exe</code>的快捷方式。可以在<code>C:\\Users\\Ying\\.bash_profile</code>增加一个<code>cd /E/Code</code>的命令来修改<code>git-bash</code>的默认启动目录。</p>\n</blockquote>\n<h1 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h1><ol>\n<li>安装系统更新（会自动安装大部分驱动）</li>\n<li>在<code>系统属性</code>对话框中<ul>\n<li>更改计算机名</li>\n<li>调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量</li>\n<li>禁用系统保护</li>\n<li>禁用远程协助，开启远程桌面</li>\n</ul>\n</li>\n<li>关闭休眠：Win+X, A，然后再命令行输入 <code>powercfg /h off</code></li>\n<li>在每个分区，打开<code>分区属性</code>对话框，取消<code>除了文件属性外，还允许索引此驱动器上的文件内容</code>；磁盘清理，删除<code>Windows.old</code></li>\n<li>安装字体，如<code>Microsoft Yahei Mono</code>，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体</li>\n<li>更改IE主页为<code>about:tabs</code>，删除内置的加速器</li>\n<li>在<code>文件夹选项</code><ul>\n<li>设置<code>打开文件资源管理器时打开</code>此电脑</li>\n<li>取消隐私相关选项</li>\n<li><code>查看</code>中将大图标文件夹视图<code>应用到文件夹</code></li>\n<li>取消<code>使用共享向导</code></li>\n<li>取消<code>始终显示图标，从不显示缩略图</code></li>\n<li>取消<code>隐藏受保护的操作系统文件</code>，选择<code>显示隐藏的文件、文件夹或驱动器</code></li>\n<li>取消<code>隐藏已知文件类型的扩展名</code></li>\n</ul>\n</li>\n<li>在<code>个性化-&gt;主题-&gt;桌面图标设置</code>中选中显示<code>计算机</code>桌面图标</li>\n<li>任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标</li>\n<li>禁用防火墙，取消<code>安全性与维护</code>中的所有消息</li>\n<li>禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender</li>\n<li>禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索</li>\n<li>安装<code>百度输入法</code>，设置使用双拼；安装<code>7zip</code>，<code>迅雷精简版</code>，<code>Everything</code></li>\n<li>移动系统默认文件夹<ul>\n<li>在D盘新建<code>D:\\桌面</code>，<code>D:\\下载</code>，<code>D:\\App</code>，<code>D:\\文档\\音乐</code>，<code>D:文档\\图片</code>，<code>D:\\文档\\视频</code>，<code>D:文档\\收藏夹</code></li>\n<li>在<code>C:\\Users\\Ying\\</code>各系统默认文件夹的属性对话框的<code>位置</code>选项卡中，将其移动到对应的D盘新位置</li>\n<li><code>D:\\App</code>存放一些绿色免安装的程序</li>\n<li><strong>不要</strong> 使用以前的更改注册表的方法来移动默认文件夹</li>\n</ul>\n</li>\n<li>删除/合并开始菜单项<ul>\n<li><code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu</code></li>\n<li><code>C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu</code></li>\n</ul>\n</li>\n<li>禁用某些服务</li>\n<li>安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用<code>cleanmaster.exe</code>清理磁盘和隐私项，使用<code>winmaster.exe</code>清理右键菜单</li>\n</ol>\n<p>Ghost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。</p>\n<h1 id=\"安装Linux常用工具\"><a href=\"#安装Linux常用工具\" class=\"headerlink\" title=\"安装Linux常用工具\"></a>安装Linux常用工具</h1><p>安装git（不是Github，当然也可以），其中自带<code>MinGW</code>，其中有<code>bash</code>、<code>curl</code>、<code>vim</code>、<code>ssh</code>等工具。<br>在<code>PATH</code>环境变量中添上其路径（<code>D:\\App\\git\\mingw64\\bin</code>，<code>D:\\App\\Git\\usr\\bin</code>和<code>D:\\App\\Git\\bin</code>）即可。<br>还可以安装 <a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/install_guide\" target=\"_blank\" rel=\"external\">Linux Subsystem on Windows（WSL）</a> 和 ‎Bash on Ubuntu on Windows。</p>\n<h1 id=\"Windows-Server-2016-的设置\"><a href=\"#Windows-Server-2016-的设置\" class=\"headerlink\" title=\"Windows Server 2016 的设置\"></a>Windows Server 2016 的设置</h1><ul>\n<li>安装系统更新，鲁大师安装不能识别的设备驱动</li>\n<li>设置Windows audio服务为自动启动</li>\n<li>卸载Defender</li>\n<li>组策略-&gt; 计算机配置<ul>\n<li>Windows设置-&gt; 安全设置-&gt; 帐户策略-&gt; 密码策略-&gt; 密码必须符合复杂性要求</li>\n<li>Windows设置-&gt; 安全设置-&gt; 本地策略-&gt; 安全选项-&gt; 交互式登录：无须按Ctrl+Alt+Del</li>\n<li>管理模板-&gt; 系统-&gt; 显示“关闭事件跟踪程序”</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Reg文件\"><a href=\"#Reg文件\" class=\"headerlink\" title=\"Reg文件\"></a>Reg文件</h1><p><a href=\"/doc/win10.reg\">直接下载Win10.reg</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">Windows Registry Editor Version 5.00</div><div class=\"line\"></div><div class=\"line\">;更改命令行窗口字体</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]</div><div class=\"line\">&quot;0&quot;=&quot;Lucida Console&quot;</div><div class=\"line\">&quot;936&quot;=&quot;*Microsoft YaHei Mono&quot;</div><div class=\"line\">&quot;00&quot;=&quot;Consolas&quot;</div><div class=\"line\"></div><div class=\"line\">;开启的分区共享(C$, D$...)</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]</div><div class=\"line\">&quot;LocalAccountTokenFilterPolicy&quot;=dword:00000001</div><div class=\"line\"></div><div class=\"line\">;清除通知区域图标，需重启文件资源管理器</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]</div><div class=\"line\"></div><div class=\"line\">;删除“此电脑”下的6个文件夹</div><div class=\"line\">;视频</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a&#125;]</div><div class=\"line\">;文档</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;d3162b92-9365-467a-956b-92703aca08af&#125;]</div><div class=\"line\">;桌面</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;B4BFCC3A-DB2C-424C-B029-7FE99A87C641&#125;]</div><div class=\"line\">;音乐</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;3dfdf296-dbec-4fb4-81d1-6a3438bcf4de&#125;]</div><div class=\"line\">;下载</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;088e3905-0323-4b02-9826-5d99428e115f&#125;]</div><div class=\"line\">;图片</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;24ad3ad4-a569-4530-98e1-ab02f9417aa8&#125;]</div><div class=\"line\"></div><div class=\"line\">;删除文件资源管理器左侧的OneDrive</div><div class=\"line\">[HKEY_CLASSES_ROOT\\CLSID\\&#123;018D5C66-4533-4307-9B53-224DE2ED1FE6&#125;\\ShellFolder]</div><div class=\"line\">&quot;FolderValueFlags&quot;=dword:00000028</div><div class=\"line\">&quot;Attributes&quot;=dword:f090004d</div><div class=\"line\"></div><div class=\"line\">;使用“照片查看器”打开图片</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.gif]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.png]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div></pre></td></tr></table></figure>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"开启虚拟wifi\"><a href=\"#开启虚拟wifi\" class=\"headerlink\" title=\"开启虚拟wifi\"></a>开启虚拟wifi</h2><p>设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan set hostednetwork mode=allow ssid=Ying key=12345678</div></pre></td></tr></table></figure></p>\n<p>开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan start hostednetwork</div></pre></td></tr></table></figure></p>\n<p>连接外网<br>有线网卡 的属性中选择<code>共享</code></p>"},{"title":"CCF目录单页版","date":"2017-02-24T16:00:00.000Z","_content":"CCF目录有[网页版](http://history.ccf.org.cn/sites/ccf/paiming.jsp)和[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)。\n前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。\nMarkdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 **[CCF目录完整列表2017-02-25](/doc/ccf-all-in-one-2017-02-25.html)** 。\n此外还有 **[Excel格式](/doc/ccf_all_in_one_2017-02-25.xlsx)**。\n\nCCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是[CCF目录](http://webtest.ccf.org.cn/xspj/gyml/) ，HTML版不太完整，而且没有提供PDF文件。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n- [CCF目录中存在的问题](#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [同一刊物同时被列入不同方向](#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91)\n    - [同一方向中的重复会议](#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE)\n\n<!-- /TOC -->\n\n# 说明\n表格中的类别简写分别是:\n+ AI：人工智能\n+ 系统：计算机体系结构/并行与分布计算/存储系统\n+ 软工：软件工程/系统软件/程序设计语言\n+ 数据库：数据库/数据检索/内容检索\n+ 安全：网络与信息安全\n+ 多媒体：计算机图形学与多媒体\n+ 网络：计算机网络\n+ 理论：计算机科学理论\n+ 其它：交叉/综合/新兴\n+ 交互：人机交互与普适计算\n\n表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。\n\n# CCF目录中存在的问题\n\n## 同一刊物同时被列入不同方向\n多个研究方向经常出现交叉，所以这种情况也是可以接受的。\n\n+ B类刊物 `DKE: Data and Knowledge Engineering` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IJIS: International Journal of Intelligent Systems` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IPL: Information Processing Letters` 分别被列入了 理论 和 数据库 方向\n+ B类刊物 `TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications` 分别被列入了 网络 和 多媒体 方向\n\n## 同一方向中的重复会议\n+ 安全方向的 C类会议 `ASIACCS`和 A类会议 `CCS`给出的链接都是 [http://dblp.org/db/conf/ccs/] ，这个不是错误，因为dblp上确实是在同一页面显示了 `ASIACCS` 和 `CCS`，不过列表中 `ASIACCS`的全称不太恰当\n+ 交互方向的 C类会议 `DIS: ACM Conference on Designing Interactive  Systems` 在第2条和第11条重复出现了两次\n\n<img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\">\n","source":"_posts/ccf-all-in-one.md","raw":"title: CCF目录单页版\ncategory: [misc]\ntags:\ndate: 2017-02-25\n\n---\nCCF目录有[网页版](http://history.ccf.org.cn/sites/ccf/paiming.jsp)和[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)。\n前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。\nMarkdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 **[CCF目录完整列表2017-02-25](/doc/ccf-all-in-one-2017-02-25.html)** 。\n此外还有 **[Excel格式](/doc/ccf_all_in_one_2017-02-25.xlsx)**。\n\nCCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是[CCF目录](http://webtest.ccf.org.cn/xspj/gyml/) ，HTML版不太完整，而且没有提供PDF文件。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n- [CCF目录中存在的问题](#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [同一刊物同时被列入不同方向](#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91)\n    - [同一方向中的重复会议](#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE)\n\n<!-- /TOC -->\n\n# 说明\n表格中的类别简写分别是:\n+ AI：人工智能\n+ 系统：计算机体系结构/并行与分布计算/存储系统\n+ 软工：软件工程/系统软件/程序设计语言\n+ 数据库：数据库/数据检索/内容检索\n+ 安全：网络与信息安全\n+ 多媒体：计算机图形学与多媒体\n+ 网络：计算机网络\n+ 理论：计算机科学理论\n+ 其它：交叉/综合/新兴\n+ 交互：人机交互与普适计算\n\n表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。\n\n# CCF目录中存在的问题\n\n## 同一刊物同时被列入不同方向\n多个研究方向经常出现交叉，所以这种情况也是可以接受的。\n\n+ B类刊物 `DKE: Data and Knowledge Engineering` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IJIS: International Journal of Intelligent Systems` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IPL: Information Processing Letters` 分别被列入了 理论 和 数据库 方向\n+ B类刊物 `TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications` 分别被列入了 网络 和 多媒体 方向\n\n## 同一方向中的重复会议\n+ 安全方向的 C类会议 `ASIACCS`和 A类会议 `CCS`给出的链接都是 [http://dblp.org/db/conf/ccs/] ，这个不是错误，因为dblp上确实是在同一页面显示了 `ASIACCS` 和 `CCS`，不过列表中 `ASIACCS`的全称不太恰当\n+ 交互方向的 C类会议 `DIS: ACM Conference on Designing Interactive  Systems` 在第2条和第11条重复出现了两次\n\n<img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\">\n","slug":"ccf-all-in-one","published":1,"updated":"2017-10-30T02:48:06.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn9nsj0000zk4ffsg8mc4f","content":"<p>CCF目录有<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">网页版</a>和<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>。<br>前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。<br>Markdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 <strong><a href=\"/doc/ccf-all-in-one-2017-02-25.html\">CCF目录完整列表2017-02-25</a></strong> 。<br>此外还有 <strong><a href=\"/doc/ccf_all_in_one_2017-02-25.xlsx\">Excel格式</a></strong>。</p>\n<p>CCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是<a href=\"http://webtest.ccf.org.cn/xspj/gyml/\" target=\"_blank\" rel=\"external\">CCF目录</a> ，HTML版不太完整，而且没有提供PDF文件。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a></li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\">CCF目录中存在的问题</a><ul>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91\">同一刊物同时被列入不同方向</a></li>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE\">同一方向中的重复会议</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>表格中的类别简写分别是:</p>\n<ul>\n<li>AI：人工智能</li>\n<li>系统：计算机体系结构/并行与分布计算/存储系统</li>\n<li>软工：软件工程/系统软件/程序设计语言</li>\n<li>数据库：数据库/数据检索/内容检索</li>\n<li>安全：网络与信息安全</li>\n<li>多媒体：计算机图形学与多媒体</li>\n<li>网络：计算机网络</li>\n<li>理论：计算机科学理论</li>\n<li>其它：交叉/综合/新兴</li>\n<li>交互：人机交互与普适计算</li>\n</ul>\n<p>表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。</p>\n<h1 id=\"CCF目录中存在的问题\"><a href=\"#CCF目录中存在的问题\" class=\"headerlink\" title=\"CCF目录中存在的问题\"></a>CCF目录中存在的问题</h1><h2 id=\"同一刊物同时被列入不同方向\"><a href=\"#同一刊物同时被列入不同方向\" class=\"headerlink\" title=\"同一刊物同时被列入不同方向\"></a>同一刊物同时被列入不同方向</h2><p>多个研究方向经常出现交叉，所以这种情况也是可以接受的。</p>\n<ul>\n<li>B类刊物 <code>DKE: Data and Knowledge Engineering</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IJIS: International Journal of Intelligent Systems</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IPL: Information Processing Letters</code> 分别被列入了 理论 和 数据库 方向</li>\n<li>B类刊物 <code>TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications</code> 分别被列入了 网络 和 多媒体 方向</li>\n</ul>\n<h2 id=\"同一方向中的重复会议\"><a href=\"#同一方向中的重复会议\" class=\"headerlink\" title=\"同一方向中的重复会议\"></a>同一方向中的重复会议</h2><ul>\n<li>安全方向的 C类会议 <code>ASIACCS</code>和 A类会议 <code>CCS</code>给出的链接都是 [<a href=\"http://dblp.org/db/conf/ccs/\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/ccs/</a>] ，这个不是错误，因为dblp上确实是在同一页面显示了 <code>ASIACCS</code> 和 <code>CCS</code>，不过列表中 <code>ASIACCS</code>的全称不太恰当</li>\n<li>交互方向的 C类会议 <code>DIS: ACM Conference on Designing Interactive  Systems</code> 在第2条和第11条重复出现了两次</li>\n</ul>\n<p><img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\"></p>\n","site":{"data":{}},"excerpt":"<p>CCF目录有<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">网页版</a>和<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>。<br>前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。<br>Markdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 <strong><a href=\"/doc/ccf-all-in-one-2017-02-25.html\">CCF目录完整列表2017-02-25</a></strong> 。<br>此外还有 <strong><a href=\"/doc/ccf_all_in_one_2017-02-25.xlsx\">Excel格式</a></strong>。</p>\n<p>CCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是<a href=\"http://webtest.ccf.org.cn/xspj/gyml/\" target=\"_blank\" rel=\"external\">CCF目录</a> ，HTML版不太完整，而且没有提供PDF文件。</p>","more":"<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a></li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\">CCF目录中存在的问题</a><ul>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91\">同一刊物同时被列入不同方向</a></li>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE\">同一方向中的重复会议</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>表格中的类别简写分别是:</p>\n<ul>\n<li>AI：人工智能</li>\n<li>系统：计算机体系结构/并行与分布计算/存储系统</li>\n<li>软工：软件工程/系统软件/程序设计语言</li>\n<li>数据库：数据库/数据检索/内容检索</li>\n<li>安全：网络与信息安全</li>\n<li>多媒体：计算机图形学与多媒体</li>\n<li>网络：计算机网络</li>\n<li>理论：计算机科学理论</li>\n<li>其它：交叉/综合/新兴</li>\n<li>交互：人机交互与普适计算</li>\n</ul>\n<p>表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。</p>\n<h1 id=\"CCF目录中存在的问题\"><a href=\"#CCF目录中存在的问题\" class=\"headerlink\" title=\"CCF目录中存在的问题\"></a>CCF目录中存在的问题</h1><h2 id=\"同一刊物同时被列入不同方向\"><a href=\"#同一刊物同时被列入不同方向\" class=\"headerlink\" title=\"同一刊物同时被列入不同方向\"></a>同一刊物同时被列入不同方向</h2><p>多个研究方向经常出现交叉，所以这种情况也是可以接受的。</p>\n<ul>\n<li>B类刊物 <code>DKE: Data and Knowledge Engineering</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IJIS: International Journal of Intelligent Systems</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IPL: Information Processing Letters</code> 分别被列入了 理论 和 数据库 方向</li>\n<li>B类刊物 <code>TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications</code> 分别被列入了 网络 和 多媒体 方向</li>\n</ul>\n<h2 id=\"同一方向中的重复会议\"><a href=\"#同一方向中的重复会议\" class=\"headerlink\" title=\"同一方向中的重复会议\"></a>同一方向中的重复会议</h2><ul>\n<li>安全方向的 C类会议 <code>ASIACCS</code>和 A类会议 <code>CCS</code>给出的链接都是 [<a href=\"http://dblp.org/db/conf/ccs/\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/ccs/</a>] ，这个不是错误，因为dblp上确实是在同一页面显示了 <code>ASIACCS</code> 和 <code>CCS</code>，不过列表中 <code>ASIACCS</code>的全称不太恰当</li>\n<li>交互方向的 C类会议 <code>DIS: ACM Conference on Designing Interactive  Systems</code> 在第2条和第11条重复出现了两次</li>\n</ul>\n<p><img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\"></p>"},{"title":"使用Cobbler搭建PXE服务器","date":"2017-03-21T16:00:00.000Z","_content":"[PXE](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83) （Preboot eXecution Environment，预执行环境）是通过 **局域网** 来启动计算机（和安装操作系统）的技术。\n一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 **DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）**，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。\nCobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [测试环境](#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83)\n- [Cobbler设置步骤](#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4)\n    - [禁用SELinux](#%E7%A6%81%E7%94%A8selinux)\n    - [禁用防火墙](#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99)\n    - [安装软件](#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6)\n    - [设置为开机启动的服务](#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1)\n    - [生成加密的root密码](#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81)\n- [修改cobbler的配置](#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改xinetd tftp的配置](#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改dhcp配置](#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE)\n    - [使用 dnsmasq 提供 dhcp 服务](#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1)\n    - [启动相关服务](#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1)\n    - [执行 `cobbler check`](#%E6%89%A7%E8%A1%8C-cobbler-check)\n    - [导入CentOS系统的iso安装镜像](#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F)\n    - [修改Kickstarts文件](#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6)\n    - [更新设置，最后的检查](#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5)\n- [在其它机器使用PXE安装系统](#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [在docker容器中运行cobbler](#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler)\n    - [docker容器使用systemd](#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd)\n    - [使用容器的几个坑](#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91)\n- [真机上部署遇到的问题](#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [选择合适的网卡](#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1)\n    - [Dell iDRAC](#dell-idrac)\n- [参考](#%E5%8F%82%E8%80%83)\n\n<!-- /TOC -->\n\n# 测试环境\n虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。\n\n新建一个虚拟机，安装CentOS 7，使用的镜像是 **[CentOS-7-x86_64-Minimal-1611.iso](http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso)** 。因为是Minimal的，不必选择附加的软件包。\n安装后登录系统，查看IP地址`ip a`，可以通过ssh登录到VM。\n关闭VM，拍摄一个快照。\n+ IP ： 10.1.1.10\n+ 子网掩码：255.255.255.0\n+ 用户：root\n\n# Cobbler设置步骤\n\n> 因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。\n\n## 禁用SELinux\n```\nsed -i 's/SELINUX\\=enforcing/SELINUX\\=disabled/g' /etc/selinux/config\nsetenforce 0\n```\n\n## 禁用防火墙\n```\nsystemctl disable firewalld\nsystemctl stop firewalld\n```\n\n## 安装软件\n```\nyum -y install epel-release\nyum -y install cobbler dhcp httpd xinetd pykickstart fence-agents\n```\n\n## 设置为开机启动的服务\n```\nsystemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n> PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。\ncobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。\n\n## 生成加密的root密码\n```\nopenssl passwd -1 -salt \"centos\" \"centos\"\n# 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了\n$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\n```\n\n# 修改cobbler的配置\n```\nvi /etc/cobbler/settings\n# 改动 的内容如下\ndefault_password_crypted: \"$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\"\nmanage_dhcp: 1\nnext_server: 10.1.1.10\nserver: 10.1.1.10\n```\n> [修改后的完整 settings 文件 (删除了注释)](/doc/cobbler-setting.txt)\n\n## 修改xinetd tftp的配置\n```\nvi /etc/xinetd.d/tftp\n# 将 disable = yes 改为  disable = no\n```\n\n## 修改dhcp配置\n```\nvi /etc/cobbler/dhcp.template\n# 改动的内容包括 子网段，分配的IP区间，\n# 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）\n# $next-server 是指向 /etc/cobbler/settings 中的对应值\n#\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n     option routers             10.1.1.2;\n     option domain-name-servers 10.1.1.2;\n     option subnet-mask         255.255.255.0;\n     range dynamic-bootp        10.1.1.100 10.1.1.110;\n     default-lease-time         21700;\n     max-lease-time             43100;\n     next-server                $next_server;\n\n     class \"pxeclients\" {\n          match if substring (option vendor-class-identifier, 0, 9) = \"PXEClient\";\n          if option pxe-system-type = 00:02 {\n              filename \"ia64/elilo.efi\";\n          } else if option pxe-system-type = 00:06 {\n              filename \"grub/grub-x86.efi\";\n          } else if option pxe-system-type = 00:07 {\n              filename \"grub/grub-x86_64.efi\";\n          } else {\n              filename \"pxelinux.0\";\n          }\n     }\n}\n```\n\n> 如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。\n遇到这种情况，可以将 `/etc/cobbler/settings` 中的 `manage_dhcp: 1` 改为 `0`， 然后手动管理 dhcp：修改 `/etc/dhcp/dhcpd.conf`，格式如下。\n\n```\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n        option routers 10.1.1.2;\n        option domain-name-servers 10.1.1.2;\n        option subnet-mask 255.255.255.0;\n        default-lease-time 21600;\n        max-lease-time 43200;\n        range 10.1.1.100 10.1.1.110;\n        next-server 10.1.1.10;\n        filename \"pxelinux.0\";\n}\n```\n注意要把 `$next_server` 设置为 **具体的 IP地址**，这个配置项是 PXE 的关键。\n<!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。-->\n如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。\n如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。\n`/etc/cobbler/settings` 中 `next_server` 和 `server` 指定的IP地址要和DHCP的网段在 **同一个局域网段** 才能正常工作。\n\n## 使用 dnsmasq 提供 dhcp 服务\n\n参考[Managing DHCP - cobbler manual](http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html)，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： `yum install -y dnsmasq`。\n如果让cobbler来配置dnsmasq，需要设置`/etc/cobbler/settings` 中为 `manage_dhcp: 1`，\n然后修改 `/etc/cobbler/modules.conf`，将\n```\n[dhcp]\nmodule = manage_isc   # isc 即 dhcpd\n# 改为\n[dhcp]\nmodule = manage_dnsmasq\n```\n\n然后修改 `/etc/cobbler/dnsmasq.template`，dnsmasq的配置比较简单，只要修改IP区间即可\n```\ndhcp-range=10.1.1.100,10.1.1.110\n```\n\n> 注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。\n如果只是临时提供 dhcp 服务，可设置比较小的区间，**特别要避免与已有的重要服务器发生 IP地址 冲突**！\n\n## 启动相关服务\n> 注意： 重启服务器后，需要确认下面的几项服务是否正常启动。\n\n```\nsystemctl start cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n## 执行 `cobbler check`\n```\n# 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。\nThe following are potential configuration items that you may want to fix:\n1 : debmirror package is not installed, it will be required to manage debian deployments and repositories\nRestart cobblerd and then run 'cobbler sync' to apply changes.\n```\n\n+ 如果提示需下载额外的boot loader，可执行 `cobbler get-loaders` ，这 **不是必须的**，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，`/etc/cobbler/settings` 中可以在 `proxy_url_ext` 设置代理地址。\n+ 如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行`systemctl status httpd` 查看，还可以通过访问 http://10.1.1.10 （next_server的IP地址）来确认.可能是 `/etc/cobbler/settings` 中 `next_server` 或 `server` 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。\n\n再次执行 `cobbler check`，并检查相关的服务是否正常启动，然后继续执行下面的步骤。\n\n## 导入CentOS系统的iso安装镜像\n\n虚拟机中已经为Guest OS加载了iso文件到`/dev/cdrom`，需要再挂载到`/mnt`：`mount -t auto -o loop,ro /dev/cdrom /mnt`；\n也可以直接挂载iso文件：`mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt`。\n\n导入安装镜像：`cobbler import --name=centos --arch=x86_64 --path=/mnt`。\n等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 `/var/www/cobbler/ks_mirror/`\n\n查看导入的项目：`cobbler profile list`\n输出为 centos-x86_64，进一步查看，`cobbler profile report --name=centos-x86_64`。\n\n## 修改Kickstarts文件\n从上面的命令输出可知使用的Kickstart文件在 `/var/lib/cobbler/kickstarts/sample_end.ks`\n修改下面2项\n+ `firewall --enable`            改为 `firewall --disable`\n+ `timezone  America/New_York`   改为 `timezone  Asia/Shanghai`\n\n## 更新设置，最后的检查\n```\ncobbler sync\nsystemctl restart cobblerd\ncobbler check\n```\n\n# 在其它机器使用PXE安装系统\n新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -> 电源 -> 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 `F10` 键保存并重启虚拟机。\n![](/img/pxe-boot-config.png)\n\n稍等一下，DHCP配置完成后会显示启动项如下：\n![](/img/pxe-boot-menu.png)\n选择第二项 centos-x86_64，回车，就会开始自动安装。\n\n稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。\n从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。\n\n> 从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；\n此外还可以在[settings](/doc/cobbler-setting.txt)中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，\n在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。\n水平有限，就不深入这些功能了;-(\n\n-----\n# 在docker容器中运行cobbler\n\n## docker容器使用systemd\n通过 `docker pull centos:7` 直接pull下来的镜像 **不能使用** `systemd`， 因为这与 docker 的 **单容器单进程** 哲学不相容~~\n我们需要自己build一个支持systemd的镜像，参考 [Docker Hub 的 CentOS镜像](https://hub.docker.com/_/centos/) 或[Docker Store 的  CentOS](https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f)的页面中 **Systemd integration** 一节提供的 Dockerfile 即可。\n\n再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（**增加 which 和 curl**），启用相关服务项，其它设置进入容器的shell手工修改。\n\n假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用\n+ host 网络，`--network host`\n+ 特权模式，`--privileged`\n+ 挂载cgroup的fs，以使用systemd，`-v /sys/fs/cgroup:/sys/fs/cgroup:ro`\n+ 挂载`/mnt`，这是已经挂载到主机的CentOS安装文件iso镜像，`-v /mnt:/mnt:ro`\n\n```\ndocker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ \n--name cobbler cobbler:latest /usr/sbin/init\n```\n\n因为容器的`Entrypoint`是`/usr/sbin/init`，而且是`-d`，即detached，启动后不会进入shell。\n可以通过`docker exec`执行容器的shell，需要增加 `-ti`选项为shell分配一个终端，\n```\ndocker exec -ti cobbler bash\n```\n\n退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行`exit`。\n\n按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。\n\n## 使用容器的几个坑\n> Docker官方的CentOS镜像太精简了，\n+ 没有 `curl` 及 `wget`，还少了 `which`， 也需要装上；\n+ `/etc/httpd/logs`是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个`/etc/httpd/logs/`目录即可；\n+ 没有 `/var/log/cobbler/tasks` 目录，导致cobbler sync 失败，手动创建该目录。 \n\n\n# 真机上部署遇到的问题\n## 选择合适的网卡\n服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是`em1`，但有的机器需要修改BIOS选择`em2`网卡才行。\n\n## Dell iDRAC\n服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。\n在使用PXE之前，先要装好一台机器。\n装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。\niDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行`javacpl.exe`）中添加 `安全例外项`。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。\n> iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。\n\n通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-( \n安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。\n\n旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。\n\n\n# 参考\n+ [Cobbler Quick Start](http://cobbler.github.io/manuals/quickstart/)\n+ [Centos7.2安装Cobbler 并安装系统](http://readshlinux.blog.51cto.com/9322509/1812402)\n+ [How to Install and Configure Cobbler on CentOS 7.x](http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/)\n","source":"_posts/cobbler-pxe.md","raw":"title: 使用Cobbler搭建PXE服务器\ncategory: misc\ndate: 2017-3-22\ntags:\n\n---\n[PXE](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83) （Preboot eXecution Environment，预执行环境）是通过 **局域网** 来启动计算机（和安装操作系统）的技术。\n一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 **DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）**，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。\nCobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [测试环境](#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83)\n- [Cobbler设置步骤](#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4)\n    - [禁用SELinux](#%E7%A6%81%E7%94%A8selinux)\n    - [禁用防火墙](#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99)\n    - [安装软件](#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6)\n    - [设置为开机启动的服务](#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1)\n    - [生成加密的root密码](#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81)\n- [修改cobbler的配置](#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改xinetd tftp的配置](#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改dhcp配置](#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE)\n    - [使用 dnsmasq 提供 dhcp 服务](#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1)\n    - [启动相关服务](#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1)\n    - [执行 `cobbler check`](#%E6%89%A7%E8%A1%8C-cobbler-check)\n    - [导入CentOS系统的iso安装镜像](#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F)\n    - [修改Kickstarts文件](#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6)\n    - [更新设置，最后的检查](#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5)\n- [在其它机器使用PXE安装系统](#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [在docker容器中运行cobbler](#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler)\n    - [docker容器使用systemd](#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd)\n    - [使用容器的几个坑](#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91)\n- [真机上部署遇到的问题](#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [选择合适的网卡](#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1)\n    - [Dell iDRAC](#dell-idrac)\n- [参考](#%E5%8F%82%E8%80%83)\n\n<!-- /TOC -->\n\n# 测试环境\n虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。\n\n新建一个虚拟机，安装CentOS 7，使用的镜像是 **[CentOS-7-x86_64-Minimal-1611.iso](http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso)** 。因为是Minimal的，不必选择附加的软件包。\n安装后登录系统，查看IP地址`ip a`，可以通过ssh登录到VM。\n关闭VM，拍摄一个快照。\n+ IP ： 10.1.1.10\n+ 子网掩码：255.255.255.0\n+ 用户：root\n\n# Cobbler设置步骤\n\n> 因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。\n\n## 禁用SELinux\n```\nsed -i 's/SELINUX\\=enforcing/SELINUX\\=disabled/g' /etc/selinux/config\nsetenforce 0\n```\n\n## 禁用防火墙\n```\nsystemctl disable firewalld\nsystemctl stop firewalld\n```\n\n## 安装软件\n```\nyum -y install epel-release\nyum -y install cobbler dhcp httpd xinetd pykickstart fence-agents\n```\n\n## 设置为开机启动的服务\n```\nsystemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n> PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。\ncobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。\n\n## 生成加密的root密码\n```\nopenssl passwd -1 -salt \"centos\" \"centos\"\n# 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了\n$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\n```\n\n# 修改cobbler的配置\n```\nvi /etc/cobbler/settings\n# 改动 的内容如下\ndefault_password_crypted: \"$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\"\nmanage_dhcp: 1\nnext_server: 10.1.1.10\nserver: 10.1.1.10\n```\n> [修改后的完整 settings 文件 (删除了注释)](/doc/cobbler-setting.txt)\n\n## 修改xinetd tftp的配置\n```\nvi /etc/xinetd.d/tftp\n# 将 disable = yes 改为  disable = no\n```\n\n## 修改dhcp配置\n```\nvi /etc/cobbler/dhcp.template\n# 改动的内容包括 子网段，分配的IP区间，\n# 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）\n# $next-server 是指向 /etc/cobbler/settings 中的对应值\n#\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n     option routers             10.1.1.2;\n     option domain-name-servers 10.1.1.2;\n     option subnet-mask         255.255.255.0;\n     range dynamic-bootp        10.1.1.100 10.1.1.110;\n     default-lease-time         21700;\n     max-lease-time             43100;\n     next-server                $next_server;\n\n     class \"pxeclients\" {\n          match if substring (option vendor-class-identifier, 0, 9) = \"PXEClient\";\n          if option pxe-system-type = 00:02 {\n              filename \"ia64/elilo.efi\";\n          } else if option pxe-system-type = 00:06 {\n              filename \"grub/grub-x86.efi\";\n          } else if option pxe-system-type = 00:07 {\n              filename \"grub/grub-x86_64.efi\";\n          } else {\n              filename \"pxelinux.0\";\n          }\n     }\n}\n```\n\n> 如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。\n遇到这种情况，可以将 `/etc/cobbler/settings` 中的 `manage_dhcp: 1` 改为 `0`， 然后手动管理 dhcp：修改 `/etc/dhcp/dhcpd.conf`，格式如下。\n\n```\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n        option routers 10.1.1.2;\n        option domain-name-servers 10.1.1.2;\n        option subnet-mask 255.255.255.0;\n        default-lease-time 21600;\n        max-lease-time 43200;\n        range 10.1.1.100 10.1.1.110;\n        next-server 10.1.1.10;\n        filename \"pxelinux.0\";\n}\n```\n注意要把 `$next_server` 设置为 **具体的 IP地址**，这个配置项是 PXE 的关键。\n<!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。-->\n如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。\n如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。\n`/etc/cobbler/settings` 中 `next_server` 和 `server` 指定的IP地址要和DHCP的网段在 **同一个局域网段** 才能正常工作。\n\n## 使用 dnsmasq 提供 dhcp 服务\n\n参考[Managing DHCP - cobbler manual](http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html)，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： `yum install -y dnsmasq`。\n如果让cobbler来配置dnsmasq，需要设置`/etc/cobbler/settings` 中为 `manage_dhcp: 1`，\n然后修改 `/etc/cobbler/modules.conf`，将\n```\n[dhcp]\nmodule = manage_isc   # isc 即 dhcpd\n# 改为\n[dhcp]\nmodule = manage_dnsmasq\n```\n\n然后修改 `/etc/cobbler/dnsmasq.template`，dnsmasq的配置比较简单，只要修改IP区间即可\n```\ndhcp-range=10.1.1.100,10.1.1.110\n```\n\n> 注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。\n如果只是临时提供 dhcp 服务，可设置比较小的区间，**特别要避免与已有的重要服务器发生 IP地址 冲突**！\n\n## 启动相关服务\n> 注意： 重启服务器后，需要确认下面的几项服务是否正常启动。\n\n```\nsystemctl start cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n## 执行 `cobbler check`\n```\n# 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。\nThe following are potential configuration items that you may want to fix:\n1 : debmirror package is not installed, it will be required to manage debian deployments and repositories\nRestart cobblerd and then run 'cobbler sync' to apply changes.\n```\n\n+ 如果提示需下载额外的boot loader，可执行 `cobbler get-loaders` ，这 **不是必须的**，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，`/etc/cobbler/settings` 中可以在 `proxy_url_ext` 设置代理地址。\n+ 如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行`systemctl status httpd` 查看，还可以通过访问 http://10.1.1.10 （next_server的IP地址）来确认.可能是 `/etc/cobbler/settings` 中 `next_server` 或 `server` 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。\n\n再次执行 `cobbler check`，并检查相关的服务是否正常启动，然后继续执行下面的步骤。\n\n## 导入CentOS系统的iso安装镜像\n\n虚拟机中已经为Guest OS加载了iso文件到`/dev/cdrom`，需要再挂载到`/mnt`：`mount -t auto -o loop,ro /dev/cdrom /mnt`；\n也可以直接挂载iso文件：`mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt`。\n\n导入安装镜像：`cobbler import --name=centos --arch=x86_64 --path=/mnt`。\n等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 `/var/www/cobbler/ks_mirror/`\n\n查看导入的项目：`cobbler profile list`\n输出为 centos-x86_64，进一步查看，`cobbler profile report --name=centos-x86_64`。\n\n## 修改Kickstarts文件\n从上面的命令输出可知使用的Kickstart文件在 `/var/lib/cobbler/kickstarts/sample_end.ks`\n修改下面2项\n+ `firewall --enable`            改为 `firewall --disable`\n+ `timezone  America/New_York`   改为 `timezone  Asia/Shanghai`\n\n## 更新设置，最后的检查\n```\ncobbler sync\nsystemctl restart cobblerd\ncobbler check\n```\n\n# 在其它机器使用PXE安装系统\n新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -> 电源 -> 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 `F10` 键保存并重启虚拟机。\n![](/img/pxe-boot-config.png)\n\n稍等一下，DHCP配置完成后会显示启动项如下：\n![](/img/pxe-boot-menu.png)\n选择第二项 centos-x86_64，回车，就会开始自动安装。\n\n稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。\n从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。\n\n> 从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；\n此外还可以在[settings](/doc/cobbler-setting.txt)中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，\n在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。\n水平有限，就不深入这些功能了;-(\n\n-----\n# 在docker容器中运行cobbler\n\n## docker容器使用systemd\n通过 `docker pull centos:7` 直接pull下来的镜像 **不能使用** `systemd`， 因为这与 docker 的 **单容器单进程** 哲学不相容~~\n我们需要自己build一个支持systemd的镜像，参考 [Docker Hub 的 CentOS镜像](https://hub.docker.com/_/centos/) 或[Docker Store 的  CentOS](https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f)的页面中 **Systemd integration** 一节提供的 Dockerfile 即可。\n\n再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（**增加 which 和 curl**），启用相关服务项，其它设置进入容器的shell手工修改。\n\n假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用\n+ host 网络，`--network host`\n+ 特权模式，`--privileged`\n+ 挂载cgroup的fs，以使用systemd，`-v /sys/fs/cgroup:/sys/fs/cgroup:ro`\n+ 挂载`/mnt`，这是已经挂载到主机的CentOS安装文件iso镜像，`-v /mnt:/mnt:ro`\n\n```\ndocker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ \n--name cobbler cobbler:latest /usr/sbin/init\n```\n\n因为容器的`Entrypoint`是`/usr/sbin/init`，而且是`-d`，即detached，启动后不会进入shell。\n可以通过`docker exec`执行容器的shell，需要增加 `-ti`选项为shell分配一个终端，\n```\ndocker exec -ti cobbler bash\n```\n\n退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行`exit`。\n\n按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。\n\n## 使用容器的几个坑\n> Docker官方的CentOS镜像太精简了，\n+ 没有 `curl` 及 `wget`，还少了 `which`， 也需要装上；\n+ `/etc/httpd/logs`是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个`/etc/httpd/logs/`目录即可；\n+ 没有 `/var/log/cobbler/tasks` 目录，导致cobbler sync 失败，手动创建该目录。 \n\n\n# 真机上部署遇到的问题\n## 选择合适的网卡\n服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是`em1`，但有的机器需要修改BIOS选择`em2`网卡才行。\n\n## Dell iDRAC\n服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。\n在使用PXE之前，先要装好一台机器。\n装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。\niDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行`javacpl.exe`）中添加 `安全例外项`。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。\n> iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。\n\n通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-( \n安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。\n\n旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。\n\n\n# 参考\n+ [Cobbler Quick Start](http://cobbler.github.io/manuals/quickstart/)\n+ [Centos7.2安装Cobbler 并安装系统](http://readshlinux.blog.51cto.com/9322509/1812402)\n+ [How to Install and Configure Cobbler on CentOS 7.x](http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/)\n","slug":"cobbler-pxe","published":1,"updated":"2017-10-30T02:48:03.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dn9w7d0000cc4ftqx4wpk7","content":"<p><a href=\"https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\" target=\"_blank\" rel=\"external\">PXE</a> （Preboot eXecution Environment，预执行环境）是通过 <strong>局域网</strong> 来启动计算机（和安装操作系统）的技术。<br>一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 <strong>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</strong>，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。<br>Cobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">测试环境</a></li>\n<li><a href=\"#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4\">Cobbler设置步骤</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8selinux\">禁用SELinux</a></li>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99\">禁用防火墙</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6\">安装软件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1\">设置为开机启动的服务</a></li>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81\">生成加密的root密码</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE\">修改cobbler的配置</a><ul>\n<li><a href=\"#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE\">修改xinetd tftp的配置</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE\">修改dhcp配置</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1\">使用 dnsmasq 提供 dhcp 服务</a></li>\n<li><a href=\"#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1\">启动相关服务</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C-cobbler-check\">执行 <code>cobbler check</code></a></li>\n<li><a href=\"#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F\">导入CentOS系统的iso安装镜像</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6\">修改Kickstarts文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5\">更新设置，最后的检查</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">在其它机器使用PXE安装系统</a></li>\n<li><a href=\"#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler\">在docker容器中运行cobbler</a><ul>\n<li><a href=\"#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd\">docker容器使用systemd</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91\">使用容器的几个坑</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">真机上部署遇到的问题</a><ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1\">选择合适的网卡</a></li>\n<li><a href=\"#dell-idrac\">Dell iDRAC</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。</p>\n<p>新建一个虚拟机，安装CentOS 7，使用的镜像是 <strong><a href=\"http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-Minimal-1611.iso</a></strong> 。因为是Minimal的，不必选择附加的软件包。<br>安装后登录系统，查看IP地址<code>ip a</code>，可以通过ssh登录到VM。<br>关闭VM，拍摄一个快照。</p>\n<ul>\n<li>IP ： 10.1.1.10</li>\n<li>子网掩码：255.255.255.0</li>\n<li>用户：root</li>\n</ul>\n<h1 id=\"Cobbler设置步骤\"><a href=\"#Cobbler设置步骤\" class=\"headerlink\" title=\"Cobbler设置步骤\"></a>Cobbler设置步骤</h1><blockquote>\n<p>因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。</p>\n</blockquote>\n<h2 id=\"禁用SELinux\"><a href=\"#禁用SELinux\" class=\"headerlink\" title=\"禁用SELinux\"></a>禁用SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &apos;s/SELINUX\\=enforcing/SELINUX\\=disabled/g&apos; /etc/selinux/config</div><div class=\"line\">setenforce 0</div></pre></td></tr></table></figure>\n<h2 id=\"禁用防火墙\"><a href=\"#禁用防火墙\" class=\"headerlink\" title=\"禁用防火墙\"></a>禁用防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div></pre></td></tr></table></figure>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install epel-release</div><div class=\"line\">yum -y install cobbler dhcp httpd xinetd pykickstart fence-agents</div></pre></td></tr></table></figure>\n<h2 id=\"设置为开机启动的服务\"><a href=\"#设置为开机启动的服务\" class=\"headerlink\" title=\"设置为开机启动的服务\"></a>设置为开机启动的服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<blockquote>\n<p>PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。<br>cobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。</p>\n</blockquote>\n<h2 id=\"生成加密的root密码\"><a href=\"#生成加密的root密码\" class=\"headerlink\" title=\"生成加密的root密码\"></a>生成加密的root密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">openssl passwd -1 -salt &quot;centos&quot; &quot;centos&quot;</div><div class=\"line\"># 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了</div><div class=\"line\">$1$centos$Uq6E6Wp5SDZYbs6MCmamP0</div></pre></td></tr></table></figure>\n<h1 id=\"修改cobbler的配置\"><a href=\"#修改cobbler的配置\" class=\"headerlink\" title=\"修改cobbler的配置\"></a>修改cobbler的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/settings</div><div class=\"line\"># 改动 的内容如下</div><div class=\"line\">default_password_crypted: &quot;$1$centos$Uq6E6Wp5SDZYbs6MCmamP0&quot;</div><div class=\"line\">manage_dhcp: 1</div><div class=\"line\">next_server: 10.1.1.10</div><div class=\"line\">server: 10.1.1.10</div></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"/doc/cobbler-setting.txt\">修改后的完整 settings 文件 (删除了注释)</a></p>\n</blockquote>\n<h2 id=\"修改xinetd-tftp的配置\"><a href=\"#修改xinetd-tftp的配置\" class=\"headerlink\" title=\"修改xinetd tftp的配置\"></a>修改xinetd tftp的配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/xinetd.d/tftp</div><div class=\"line\"># 将 disable = yes 改为  disable = no</div></pre></td></tr></table></figure>\n<h2 id=\"修改dhcp配置\"><a href=\"#修改dhcp配置\" class=\"headerlink\" title=\"修改dhcp配置\"></a>修改dhcp配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/dhcp.template</div><div class=\"line\"># 改动的内容包括 子网段，分配的IP区间，</div><div class=\"line\"># 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）</div><div class=\"line\"># $next-server 是指向 /etc/cobbler/settings 中的对应值</div><div class=\"line\">#</div><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">     option routers             10.1.1.2;</div><div class=\"line\">     option domain-name-servers 10.1.1.2;</div><div class=\"line\">     option subnet-mask         255.255.255.0;</div><div class=\"line\">     range dynamic-bootp        10.1.1.100 10.1.1.110;</div><div class=\"line\">     default-lease-time         21700;</div><div class=\"line\">     max-lease-time             43100;</div><div class=\"line\">     next-server                $next_server;</div><div class=\"line\"></div><div class=\"line\">     class &quot;pxeclients&quot; &#123;</div><div class=\"line\">          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;</div><div class=\"line\">          if option pxe-system-type = 00:02 &#123;</div><div class=\"line\">              filename &quot;ia64/elilo.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:06 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:07 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86_64.efi&quot;;</div><div class=\"line\">          &#125; else &#123;</div><div class=\"line\">              filename &quot;pxelinux.0&quot;;</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。<br>遇到这种情况，可以将 <code>/etc/cobbler/settings</code> 中的 <code>manage_dhcp: 1</code> 改为 <code>0</code>， 然后手动管理 dhcp：修改 <code>/etc/dhcp/dhcpd.conf</code>，格式如下。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">        option routers 10.1.1.2;</div><div class=\"line\">        option domain-name-servers 10.1.1.2;</div><div class=\"line\">        option subnet-mask 255.255.255.0;</div><div class=\"line\">        default-lease-time 21600;</div><div class=\"line\">        max-lease-time 43200;</div><div class=\"line\">        range 10.1.1.100 10.1.1.110;</div><div class=\"line\">        next-server 10.1.1.10;</div><div class=\"line\">        filename &quot;pxelinux.0&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意要把 <code>$next_server</code> 设置为 <strong>具体的 IP地址</strong>，这个配置项是 PXE 的关键。<br><!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。--><br>如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。<br>如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。<br><code>/etc/cobbler/settings</code> 中 <code>next_server</code> 和 <code>server</code> 指定的IP地址要和DHCP的网段在 <strong>同一个局域网段</strong> 才能正常工作。</p>\n<h2 id=\"使用-dnsmasq-提供-dhcp-服务\"><a href=\"#使用-dnsmasq-提供-dhcp-服务\" class=\"headerlink\" title=\"使用 dnsmasq 提供 dhcp 服务\"></a>使用 dnsmasq 提供 dhcp 服务</h2><p>参考<a href=\"http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html\" target=\"_blank\" rel=\"external\">Managing DHCP - cobbler manual</a>，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： <code>yum install -y dnsmasq</code>。<br>如果让cobbler来配置dnsmasq，需要设置<code>/etc/cobbler/settings</code> 中为 <code>manage_dhcp: 1</code>，<br>然后修改 <code>/etc/cobbler/modules.conf</code>，将<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_isc   # isc 即 dhcpd</div><div class=\"line\"># 改为</div><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_dnsmasq</div></pre></td></tr></table></figure></p>\n<p>然后修改 <code>/etc/cobbler/dnsmasq.template</code>，dnsmasq的配置比较简单，只要修改IP区间即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dhcp-range=10.1.1.100,10.1.1.110</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。<br>如果只是临时提供 dhcp 服务，可设置比较小的区间，<strong>特别要避免与已有的重要服务器发生 IP地址 冲突</strong>！</p>\n</blockquote>\n<h2 id=\"启动相关服务\"><a href=\"#启动相关服务\" class=\"headerlink\" title=\"启动相关服务\"></a>启动相关服务</h2><blockquote>\n<p>注意： 重启服务器后，需要确认下面的几项服务是否正常启动。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl start cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<h2 id=\"执行-cobbler-check\"><a href=\"#执行-cobbler-check\" class=\"headerlink\" title=\"执行 cobbler check\"></a>执行 <code>cobbler check</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。</div><div class=\"line\">The following are potential configuration items that you may want to fix:</div><div class=\"line\">1 : debmirror package is not installed, it will be required to manage debian deployments and repositories</div><div class=\"line\">Restart cobblerd and then run &apos;cobbler sync&apos; to apply changes.</div></pre></td></tr></table></figure>\n<ul>\n<li>如果提示需下载额外的boot loader，可执行 <code>cobbler get-loaders</code> ，这 <strong>不是必须的</strong>，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，<code>/etc/cobbler/settings</code> 中可以在 <code>proxy_url_ext</code> 设置代理地址。</li>\n<li>如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行<code>systemctl status httpd</code> 查看，还可以通过访问 <a href=\"http://10.1.1.10\" target=\"_blank\" rel=\"external\">http://10.1.1.10</a> （next_server的IP地址）来确认.可能是 <code>/etc/cobbler/settings</code> 中 <code>next_server</code> 或 <code>server</code> 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。</li>\n</ul>\n<p>再次执行 <code>cobbler check</code>，并检查相关的服务是否正常启动，然后继续执行下面的步骤。</p>\n<h2 id=\"导入CentOS系统的iso安装镜像\"><a href=\"#导入CentOS系统的iso安装镜像\" class=\"headerlink\" title=\"导入CentOS系统的iso安装镜像\"></a>导入CentOS系统的iso安装镜像</h2><p>虚拟机中已经为Guest OS加载了iso文件到<code>/dev/cdrom</code>，需要再挂载到<code>/mnt</code>：<code>mount -t auto -o loop,ro /dev/cdrom /mnt</code>；<br>也可以直接挂载iso文件：<code>mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt</code>。</p>\n<p>导入安装镜像：<code>cobbler import --name=centos --arch=x86_64 --path=/mnt</code>。<br>等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 <code>/var/www/cobbler/ks_mirror/</code></p>\n<p>查看导入的项目：<code>cobbler profile list</code><br>输出为 centos-x86_64，进一步查看，<code>cobbler profile report --name=centos-x86_64</code>。</p>\n<h2 id=\"修改Kickstarts文件\"><a href=\"#修改Kickstarts文件\" class=\"headerlink\" title=\"修改Kickstarts文件\"></a>修改Kickstarts文件</h2><p>从上面的命令输出可知使用的Kickstart文件在 <code>/var/lib/cobbler/kickstarts/sample_end.ks</code><br>修改下面2项</p>\n<ul>\n<li><code>firewall --enable</code>            改为 <code>firewall --disable</code></li>\n<li><code>timezone  America/New_York</code>   改为 <code>timezone  Asia/Shanghai</code></li>\n</ul>\n<h2 id=\"更新设置，最后的检查\"><a href=\"#更新设置，最后的检查\" class=\"headerlink\" title=\"更新设置，最后的检查\"></a>更新设置，最后的检查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cobbler sync</div><div class=\"line\">systemctl restart cobblerd</div><div class=\"line\">cobbler check</div></pre></td></tr></table></figure>\n<h1 id=\"在其它机器使用PXE安装系统\"><a href=\"#在其它机器使用PXE安装系统\" class=\"headerlink\" title=\"在其它机器使用PXE安装系统\"></a>在其它机器使用PXE安装系统</h1><p>新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -&gt; 电源 -&gt; 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 <code>F10</code> 键保存并重启虚拟机。<br><img src=\"/img/pxe-boot-config.png\" alt=\"\"></p>\n<p>稍等一下，DHCP配置完成后会显示启动项如下：<br><img src=\"/img/pxe-boot-menu.png\" alt=\"\"><br>选择第二项 centos-x86_64，回车，就会开始自动安装。</p>\n<p>稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。<br>从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。</p>\n<blockquote>\n<p>从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；<br>此外还可以在<a href=\"/doc/cobbler-setting.txt\">settings</a>中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，<br>在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。<br>水平有限，就不深入这些功能了;-(</p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中运行cobbler\"><a href=\"#在docker容器中运行cobbler\" class=\"headerlink\" title=\"在docker容器中运行cobbler\"></a>在docker容器中运行cobbler</h1><h2 id=\"docker容器使用systemd\"><a href=\"#docker容器使用systemd\" class=\"headerlink\" title=\"docker容器使用systemd\"></a>docker容器使用systemd</h2><p>通过 <code>docker pull centos:7</code> 直接pull下来的镜像 <strong>不能使用</strong> <code>systemd</code>， 因为这与 docker 的 <strong>单容器单进程</strong> 哲学不相容~~<br>我们需要自己build一个支持systemd的镜像，参考 <a href=\"https://hub.docker.com/_/centos/\" target=\"_blank\" rel=\"external\">Docker Hub 的 CentOS镜像</a> 或<a href=\"https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f\" target=\"_blank\" rel=\"external\">Docker Store 的  CentOS</a>的页面中 <strong>Systemd integration</strong> 一节提供的 Dockerfile 即可。</p>\n<p>再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（<strong>增加 which 和 curl</strong>），启用相关服务项，其它设置进入容器的shell手工修改。</p>\n<p>假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用</p>\n<ul>\n<li>host 网络，<code>--network host</code></li>\n<li>特权模式，<code>--privileged</code></li>\n<li>挂载cgroup的fs，以使用systemd，<code>-v /sys/fs/cgroup:/sys/fs/cgroup:ro</code></li>\n<li>挂载<code>/mnt</code>，这是已经挂载到主机的CentOS安装文件iso镜像，<code>-v /mnt:/mnt:ro</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ </div><div class=\"line\">--name cobbler cobbler:latest /usr/sbin/init</div></pre></td></tr></table></figure>\n<p>因为容器的<code>Entrypoint</code>是<code>/usr/sbin/init</code>，而且是<code>-d</code>，即detached，启动后不会进入shell。<br>可以通过<code>docker exec</code>执行容器的shell，需要增加 <code>-ti</code>选项为shell分配一个终端，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -ti cobbler bash</div></pre></td></tr></table></figure></p>\n<p>退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行<code>exit</code>。</p>\n<p>按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。</p>\n<h2 id=\"使用容器的几个坑\"><a href=\"#使用容器的几个坑\" class=\"headerlink\" title=\"使用容器的几个坑\"></a>使用容器的几个坑</h2><blockquote>\n<p>Docker官方的CentOS镜像太精简了，</p>\n<ul>\n<li>没有 <code>curl</code> 及 <code>wget</code>，还少了 <code>which</code>， 也需要装上；</li>\n<li><code>/etc/httpd/logs</code>是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个<code>/etc/httpd/logs/</code>目录即可；</li>\n<li>没有 <code>/var/log/cobbler/tasks</code> 目录，导致cobbler sync 失败，手动创建该目录。 </li>\n</ul>\n</blockquote>\n<h1 id=\"真机上部署遇到的问题\"><a href=\"#真机上部署遇到的问题\" class=\"headerlink\" title=\"真机上部署遇到的问题\"></a>真机上部署遇到的问题</h1><h2 id=\"选择合适的网卡\"><a href=\"#选择合适的网卡\" class=\"headerlink\" title=\"选择合适的网卡\"></a>选择合适的网卡</h2><p>服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是<code>em1</code>，但有的机器需要修改BIOS选择<code>em2</code>网卡才行。</p>\n<h2 id=\"Dell-iDRAC\"><a href=\"#Dell-iDRAC\" class=\"headerlink\" title=\"Dell iDRAC\"></a>Dell iDRAC</h2><p>服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。<br>在使用PXE之前，先要装好一台机器。<br>装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。<br>iDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行<code>javacpl.exe</code>）中添加 <code>安全例外项</code>。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。</p>\n<blockquote>\n<p>iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。</p>\n</blockquote>\n<p>通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-(<br>安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。</p>\n<p>旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://cobbler.github.io/manuals/quickstart/\" target=\"_blank\" rel=\"external\">Cobbler Quick Start</a></li>\n<li><a href=\"http://readshlinux.blog.51cto.com/9322509/1812402\" target=\"_blank\" rel=\"external\">Centos7.2安装Cobbler 并安装系统</a></li>\n<li><a href=\"http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/\" target=\"_blank\" rel=\"external\">How to Install and Configure Cobbler on CentOS 7.x</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\" target=\"_blank\" rel=\"external\">PXE</a> （Preboot eXecution Environment，预执行环境）是通过 <strong>局域网</strong> 来启动计算机（和安装操作系统）的技术。<br>一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 <strong>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</strong>，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。<br>Cobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">测试环境</a></li>\n<li><a href=\"#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4\">Cobbler设置步骤</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8selinux\">禁用SELinux</a></li>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99\">禁用防火墙</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6\">安装软件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1\">设置为开机启动的服务</a></li>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81\">生成加密的root密码</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE\">修改cobbler的配置</a><ul>\n<li><a href=\"#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE\">修改xinetd tftp的配置</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE\">修改dhcp配置</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1\">使用 dnsmasq 提供 dhcp 服务</a></li>\n<li><a href=\"#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1\">启动相关服务</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C-cobbler-check\">执行 <code>cobbler check</code></a></li>\n<li><a href=\"#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F\">导入CentOS系统的iso安装镜像</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6\">修改Kickstarts文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5\">更新设置，最后的检查</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">在其它机器使用PXE安装系统</a></li>\n<li><a href=\"#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler\">在docker容器中运行cobbler</a><ul>\n<li><a href=\"#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd\">docker容器使用systemd</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91\">使用容器的几个坑</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">真机上部署遇到的问题</a><ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1\">选择合适的网卡</a></li>\n<li><a href=\"#dell-idrac\">Dell iDRAC</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。</p>\n<p>新建一个虚拟机，安装CentOS 7，使用的镜像是 <strong><a href=\"http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-Minimal-1611.iso</a></strong> 。因为是Minimal的，不必选择附加的软件包。<br>安装后登录系统，查看IP地址<code>ip a</code>，可以通过ssh登录到VM。<br>关闭VM，拍摄一个快照。</p>\n<ul>\n<li>IP ： 10.1.1.10</li>\n<li>子网掩码：255.255.255.0</li>\n<li>用户：root</li>\n</ul>\n<h1 id=\"Cobbler设置步骤\"><a href=\"#Cobbler设置步骤\" class=\"headerlink\" title=\"Cobbler设置步骤\"></a>Cobbler设置步骤</h1><blockquote>\n<p>因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。</p>\n</blockquote>\n<h2 id=\"禁用SELinux\"><a href=\"#禁用SELinux\" class=\"headerlink\" title=\"禁用SELinux\"></a>禁用SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &apos;s/SELINUX\\=enforcing/SELINUX\\=disabled/g&apos; /etc/selinux/config</div><div class=\"line\">setenforce 0</div></pre></td></tr></table></figure>\n<h2 id=\"禁用防火墙\"><a href=\"#禁用防火墙\" class=\"headerlink\" title=\"禁用防火墙\"></a>禁用防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div></pre></td></tr></table></figure>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install epel-release</div><div class=\"line\">yum -y install cobbler dhcp httpd xinetd pykickstart fence-agents</div></pre></td></tr></table></figure>\n<h2 id=\"设置为开机启动的服务\"><a href=\"#设置为开机启动的服务\" class=\"headerlink\" title=\"设置为开机启动的服务\"></a>设置为开机启动的服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<blockquote>\n<p>PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。<br>cobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。</p>\n</blockquote>\n<h2 id=\"生成加密的root密码\"><a href=\"#生成加密的root密码\" class=\"headerlink\" title=\"生成加密的root密码\"></a>生成加密的root密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">openssl passwd -1 -salt &quot;centos&quot; &quot;centos&quot;</div><div class=\"line\"># 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了</div><div class=\"line\">$1$centos$Uq6E6Wp5SDZYbs6MCmamP0</div></pre></td></tr></table></figure>\n<h1 id=\"修改cobbler的配置\"><a href=\"#修改cobbler的配置\" class=\"headerlink\" title=\"修改cobbler的配置\"></a>修改cobbler的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/settings</div><div class=\"line\"># 改动 的内容如下</div><div class=\"line\">default_password_crypted: &quot;$1$centos$Uq6E6Wp5SDZYbs6MCmamP0&quot;</div><div class=\"line\">manage_dhcp: 1</div><div class=\"line\">next_server: 10.1.1.10</div><div class=\"line\">server: 10.1.1.10</div></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"/doc/cobbler-setting.txt\">修改后的完整 settings 文件 (删除了注释)</a></p>\n</blockquote>\n<h2 id=\"修改xinetd-tftp的配置\"><a href=\"#修改xinetd-tftp的配置\" class=\"headerlink\" title=\"修改xinetd tftp的配置\"></a>修改xinetd tftp的配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/xinetd.d/tftp</div><div class=\"line\"># 将 disable = yes 改为  disable = no</div></pre></td></tr></table></figure>\n<h2 id=\"修改dhcp配置\"><a href=\"#修改dhcp配置\" class=\"headerlink\" title=\"修改dhcp配置\"></a>修改dhcp配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/dhcp.template</div><div class=\"line\"># 改动的内容包括 子网段，分配的IP区间，</div><div class=\"line\"># 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）</div><div class=\"line\"># $next-server 是指向 /etc/cobbler/settings 中的对应值</div><div class=\"line\">#</div><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">     option routers             10.1.1.2;</div><div class=\"line\">     option domain-name-servers 10.1.1.2;</div><div class=\"line\">     option subnet-mask         255.255.255.0;</div><div class=\"line\">     range dynamic-bootp        10.1.1.100 10.1.1.110;</div><div class=\"line\">     default-lease-time         21700;</div><div class=\"line\">     max-lease-time             43100;</div><div class=\"line\">     next-server                $next_server;</div><div class=\"line\"></div><div class=\"line\">     class &quot;pxeclients&quot; &#123;</div><div class=\"line\">          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;</div><div class=\"line\">          if option pxe-system-type = 00:02 &#123;</div><div class=\"line\">              filename &quot;ia64/elilo.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:06 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:07 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86_64.efi&quot;;</div><div class=\"line\">          &#125; else &#123;</div><div class=\"line\">              filename &quot;pxelinux.0&quot;;</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。<br>遇到这种情况，可以将 <code>/etc/cobbler/settings</code> 中的 <code>manage_dhcp: 1</code> 改为 <code>0</code>， 然后手动管理 dhcp：修改 <code>/etc/dhcp/dhcpd.conf</code>，格式如下。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">        option routers 10.1.1.2;</div><div class=\"line\">        option domain-name-servers 10.1.1.2;</div><div class=\"line\">        option subnet-mask 255.255.255.0;</div><div class=\"line\">        default-lease-time 21600;</div><div class=\"line\">        max-lease-time 43200;</div><div class=\"line\">        range 10.1.1.100 10.1.1.110;</div><div class=\"line\">        next-server 10.1.1.10;</div><div class=\"line\">        filename &quot;pxelinux.0&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意要把 <code>$next_server</code> 设置为 <strong>具体的 IP地址</strong>，这个配置项是 PXE 的关键。<br><!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。--><br>如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。<br>如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。<br><code>/etc/cobbler/settings</code> 中 <code>next_server</code> 和 <code>server</code> 指定的IP地址要和DHCP的网段在 <strong>同一个局域网段</strong> 才能正常工作。</p>\n<h2 id=\"使用-dnsmasq-提供-dhcp-服务\"><a href=\"#使用-dnsmasq-提供-dhcp-服务\" class=\"headerlink\" title=\"使用 dnsmasq 提供 dhcp 服务\"></a>使用 dnsmasq 提供 dhcp 服务</h2><p>参考<a href=\"http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html\" target=\"_blank\" rel=\"external\">Managing DHCP - cobbler manual</a>，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： <code>yum install -y dnsmasq</code>。<br>如果让cobbler来配置dnsmasq，需要设置<code>/etc/cobbler/settings</code> 中为 <code>manage_dhcp: 1</code>，<br>然后修改 <code>/etc/cobbler/modules.conf</code>，将<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_isc   # isc 即 dhcpd</div><div class=\"line\"># 改为</div><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_dnsmasq</div></pre></td></tr></table></figure></p>\n<p>然后修改 <code>/etc/cobbler/dnsmasq.template</code>，dnsmasq的配置比较简单，只要修改IP区间即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dhcp-range=10.1.1.100,10.1.1.110</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。<br>如果只是临时提供 dhcp 服务，可设置比较小的区间，<strong>特别要避免与已有的重要服务器发生 IP地址 冲突</strong>！</p>\n</blockquote>\n<h2 id=\"启动相关服务\"><a href=\"#启动相关服务\" class=\"headerlink\" title=\"启动相关服务\"></a>启动相关服务</h2><blockquote>\n<p>注意： 重启服务器后，需要确认下面的几项服务是否正常启动。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl start cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<h2 id=\"执行-cobbler-check\"><a href=\"#执行-cobbler-check\" class=\"headerlink\" title=\"执行 cobbler check\"></a>执行 <code>cobbler check</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。</div><div class=\"line\">The following are potential configuration items that you may want to fix:</div><div class=\"line\">1 : debmirror package is not installed, it will be required to manage debian deployments and repositories</div><div class=\"line\">Restart cobblerd and then run &apos;cobbler sync&apos; to apply changes.</div></pre></td></tr></table></figure>\n<ul>\n<li>如果提示需下载额外的boot loader，可执行 <code>cobbler get-loaders</code> ，这 <strong>不是必须的</strong>，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，<code>/etc/cobbler/settings</code> 中可以在 <code>proxy_url_ext</code> 设置代理地址。</li>\n<li>如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行<code>systemctl status httpd</code> 查看，还可以通过访问 <a href=\"http://10.1.1.10\" target=\"_blank\" rel=\"external\">http://10.1.1.10</a> （next_server的IP地址）来确认.可能是 <code>/etc/cobbler/settings</code> 中 <code>next_server</code> 或 <code>server</code> 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。</li>\n</ul>\n<p>再次执行 <code>cobbler check</code>，并检查相关的服务是否正常启动，然后继续执行下面的步骤。</p>\n<h2 id=\"导入CentOS系统的iso安装镜像\"><a href=\"#导入CentOS系统的iso安装镜像\" class=\"headerlink\" title=\"导入CentOS系统的iso安装镜像\"></a>导入CentOS系统的iso安装镜像</h2><p>虚拟机中已经为Guest OS加载了iso文件到<code>/dev/cdrom</code>，需要再挂载到<code>/mnt</code>：<code>mount -t auto -o loop,ro /dev/cdrom /mnt</code>；<br>也可以直接挂载iso文件：<code>mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt</code>。</p>\n<p>导入安装镜像：<code>cobbler import --name=centos --arch=x86_64 --path=/mnt</code>。<br>等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 <code>/var/www/cobbler/ks_mirror/</code></p>\n<p>查看导入的项目：<code>cobbler profile list</code><br>输出为 centos-x86_64，进一步查看，<code>cobbler profile report --name=centos-x86_64</code>。</p>\n<h2 id=\"修改Kickstarts文件\"><a href=\"#修改Kickstarts文件\" class=\"headerlink\" title=\"修改Kickstarts文件\"></a>修改Kickstarts文件</h2><p>从上面的命令输出可知使用的Kickstart文件在 <code>/var/lib/cobbler/kickstarts/sample_end.ks</code><br>修改下面2项</p>\n<ul>\n<li><code>firewall --enable</code>            改为 <code>firewall --disable</code></li>\n<li><code>timezone  America/New_York</code>   改为 <code>timezone  Asia/Shanghai</code></li>\n</ul>\n<h2 id=\"更新设置，最后的检查\"><a href=\"#更新设置，最后的检查\" class=\"headerlink\" title=\"更新设置，最后的检查\"></a>更新设置，最后的检查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cobbler sync</div><div class=\"line\">systemctl restart cobblerd</div><div class=\"line\">cobbler check</div></pre></td></tr></table></figure>\n<h1 id=\"在其它机器使用PXE安装系统\"><a href=\"#在其它机器使用PXE安装系统\" class=\"headerlink\" title=\"在其它机器使用PXE安装系统\"></a>在其它机器使用PXE安装系统</h1><p>新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -&gt; 电源 -&gt; 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 <code>F10</code> 键保存并重启虚拟机。<br><img src=\"/img/pxe-boot-config.png\" alt=\"\"></p>\n<p>稍等一下，DHCP配置完成后会显示启动项如下：<br><img src=\"/img/pxe-boot-menu.png\" alt=\"\"><br>选择第二项 centos-x86_64，回车，就会开始自动安装。</p>\n<p>稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。<br>从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。</p>\n<blockquote>\n<p>从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；<br>此外还可以在<a href=\"/doc/cobbler-setting.txt\">settings</a>中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，<br>在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。<br>水平有限，就不深入这些功能了;-(</p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中运行cobbler\"><a href=\"#在docker容器中运行cobbler\" class=\"headerlink\" title=\"在docker容器中运行cobbler\"></a>在docker容器中运行cobbler</h1><h2 id=\"docker容器使用systemd\"><a href=\"#docker容器使用systemd\" class=\"headerlink\" title=\"docker容器使用systemd\"></a>docker容器使用systemd</h2><p>通过 <code>docker pull centos:7</code> 直接pull下来的镜像 <strong>不能使用</strong> <code>systemd</code>， 因为这与 docker 的 <strong>单容器单进程</strong> 哲学不相容~~<br>我们需要自己build一个支持systemd的镜像，参考 <a href=\"https://hub.docker.com/_/centos/\" target=\"_blank\" rel=\"external\">Docker Hub 的 CentOS镜像</a> 或<a href=\"https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f\" target=\"_blank\" rel=\"external\">Docker Store 的  CentOS</a>的页面中 <strong>Systemd integration</strong> 一节提供的 Dockerfile 即可。</p>\n<p>再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（<strong>增加 which 和 curl</strong>），启用相关服务项，其它设置进入容器的shell手工修改。</p>\n<p>假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用</p>\n<ul>\n<li>host 网络，<code>--network host</code></li>\n<li>特权模式，<code>--privileged</code></li>\n<li>挂载cgroup的fs，以使用systemd，<code>-v /sys/fs/cgroup:/sys/fs/cgroup:ro</code></li>\n<li>挂载<code>/mnt</code>，这是已经挂载到主机的CentOS安装文件iso镜像，<code>-v /mnt:/mnt:ro</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ </div><div class=\"line\">--name cobbler cobbler:latest /usr/sbin/init</div></pre></td></tr></table></figure>\n<p>因为容器的<code>Entrypoint</code>是<code>/usr/sbin/init</code>，而且是<code>-d</code>，即detached，启动后不会进入shell。<br>可以通过<code>docker exec</code>执行容器的shell，需要增加 <code>-ti</code>选项为shell分配一个终端，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -ti cobbler bash</div></pre></td></tr></table></figure></p>\n<p>退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行<code>exit</code>。</p>\n<p>按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。</p>\n<h2 id=\"使用容器的几个坑\"><a href=\"#使用容器的几个坑\" class=\"headerlink\" title=\"使用容器的几个坑\"></a>使用容器的几个坑</h2><blockquote>\n<p>Docker官方的CentOS镜像太精简了，</p>\n<ul>\n<li>没有 <code>curl</code> 及 <code>wget</code>，还少了 <code>which</code>， 也需要装上；</li>\n<li><code>/etc/httpd/logs</code>是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个<code>/etc/httpd/logs/</code>目录即可；</li>\n<li>没有 <code>/var/log/cobbler/tasks</code> 目录，导致cobbler sync 失败，手动创建该目录。 </li>\n</ul>\n</blockquote>\n<h1 id=\"真机上部署遇到的问题\"><a href=\"#真机上部署遇到的问题\" class=\"headerlink\" title=\"真机上部署遇到的问题\"></a>真机上部署遇到的问题</h1><h2 id=\"选择合适的网卡\"><a href=\"#选择合适的网卡\" class=\"headerlink\" title=\"选择合适的网卡\"></a>选择合适的网卡</h2><p>服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是<code>em1</code>，但有的机器需要修改BIOS选择<code>em2</code>网卡才行。</p>\n<h2 id=\"Dell-iDRAC\"><a href=\"#Dell-iDRAC\" class=\"headerlink\" title=\"Dell iDRAC\"></a>Dell iDRAC</h2><p>服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。<br>在使用PXE之前，先要装好一台机器。<br>装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。<br>iDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行<code>javacpl.exe</code>）中添加 <code>安全例外项</code>。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。</p>\n<blockquote>\n<p>iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。</p>\n</blockquote>\n<p>通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-(<br>安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。</p>\n<p>旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://cobbler.github.io/manuals/quickstart/\" target=\"_blank\" rel=\"external\">Cobbler Quick Start</a></li>\n<li><a href=\"http://readshlinux.blog.51cto.com/9322509/1812402\" target=\"_blank\" rel=\"external\">Centos7.2安装Cobbler 并安装系统</a></li>\n<li><a href=\"http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/\" target=\"_blank\" rel=\"external\">How to Install and Configure Cobbler on CentOS 7.x</a></li>\n</ul>"},{"title":"Hello Hexo！","date":"2016-09-14T16:00:00.000Z","_content":"欢迎访问。\n本博客使用[Hexo](http://hexo.io/)生成。本文记录了设置过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [简介](#%E7%AE%80%E4%BB%8B)\n- [在Ubuntu 16.04上安装所需程序](#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [在Windows 10上安装所需程序](#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [初次设置](#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE)\n    - [初始化博客文件夹](#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9)\n    - [安装rss插件，git插件，math插件](#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6)\n    - [设置 `_config.yml`](#%E8%AE%BE%E7%BD%AE-configyml)\n    - [使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)](#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane)\n    - [文件结构](#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84)\n    - [修改`scaffold/post.md`模板](#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF)\n    - [修改 hexo-server默认的4000端口号为80](#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80)\n- [hexo 基本操作](#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)\n    - [常用命令](#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)\n    - [撰写文章](#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0)\n    - [发布静态html的博客网站到 Github](#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github)\n    - [为整个blog建立repo](#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo)\n    - [克隆已有的blog项目](#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE)\n- [Tips](#tips)\n    - [编辑数学公式](#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F)\n    - [设置代码块不显示行号](#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7)\n\n<!-- /TOC -->\n\n# 简介\n\n[Hexo](https://hexo.io/)是一个基于[Node.js](https://nodejs.org/)的博客生成工具。它把 [Markdown 格式](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.\nhexo有多种博客主题可选，这里使用了 [jane 主题](https://github.com/hejianxian/hexo-theme-jane)。\n[Github](https://github.com)提供了`https://[github-userId].github.io` 这样的二级域名的静态html站点的托管服务，还可以通过`CNAME`设置自己的域名（需向域名服务商购买）。\n\n下面的设置过程参考了[hexo简易教程](http://mclspace.com/2014/10/19/about-hexo/) 和 [hexo_install_config](http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/)。\n\n\n# 在Ubuntu 16.04上安装所需程序\n\n如果是桌面版的Ubuntu，打开终端（快捷键为`Ctrl+Alt+T`），执行下面的命令。\n\n## 安装git\n\n```\nsudo apt install git\n```\n\n设置 git\n\n```\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n```\n\ngit默认使用`~/.ssh`下的 key，需要在Github上注册对应的public key才能提交代码。\n\n## 安装node.js\n\na. 从Node.js官网 https://nodejs.org/en/download/ 下载Linux-x64系统的二进制安装包，解压到`/usr/local/`。\n\n```\ncd ~\nver=v6.9.2\nwget https://nodejs.org/dist/${ver}/node-${ver}-linux-x64.tar.xz\n\ntar axf node-${ver}-linux-x64.tar.xz\ncd node-${ver}-linux-x64/\nsudo cp -r ./ /usr/local/\ncd ..\nrm -rf node-${ver}-linux-x64.tar.xz\n```\n\nb. 通过添加软件源的方式\n参考[Installing Node.js via package manager](https://nodejs.org/en/download/package-manager/)，\n\n```\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt install -y nodejs\n\nsudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等\n```\n\n## 安装hexo\n\n```\nsudo npm install hexo-cli -g\n```\n\n# 在Windows 10上安装所需程序\n\n## 安装git\n\n从git官网 https://git-scm.com/downloads 下载Windows 系统的[git客户端安装程序](https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe) 。\n执行安装程序，建议\n+ 将其安装到`C:\\git`这样比较短的路径下，方便以后敲命令，\n+ 并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，\n+ 还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。\n\n>安装git的同时会安装[MinGW(Minimalist GNU for Windows)](http://www.mingw.org/)，上面的选项会把git和MinGW的可执行程序添加到`PATH`环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。\n>安装git后，`C:\\git\\usr\\bin`下面的`.exe`程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。\n\n打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。\nWindows系统上git默认使用`C:\\Users\\[UserName]\\.ssh`下的 key。\n> 以`.`开头的文件夹需要在命令窗口执行`mkdir`来创建。\n\n## 安装node.js\n从Node.js https://nodejs.org/en/download/ 下载[Windows x64系统的二进制安装包](https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi) 。\n执行安装程序，建议将其安装到`C:\\nodejs`，并选择将其添加到`PATH`路径中。\n\n## 安装hexo\n打开命令窗口，执行下面的命令\n```\nnpm install hexo-cli -g\n```\n\n# 初次设置\n\n## 初始化博客文件夹\n```\nhexo init blog\n```\n\n在Github创建一个名为`[github-userId].github.io`的项目。\n\n## 安装rss插件，git插件，math插件\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-deployer-git   --save\nnpm install hexo-math           --save\n```\n\n## 设置 `_config.yml`\n\n在 `_config.yml` 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：\n\n```\n## Themes: https://hexo.io/themes/\ntheme: jane\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:ying-zhang/ying-zhang.github.io.git\n  branch: master\n```\n\n## 使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)\n这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到`themes/`文件夹。\n直接在主题文件中修改了等宽字体，及正文的宽度。\n顺便删除默认主题landscape。\n\n## 文件结构\n\n| 文件/文件夹     |       说明     |\n| --------------- | -------------- |\n| `_config.yml`   | 博客的主配置文件 |\n| `.deploy_git/`  | 用于push到Github、heroku等的git仓库，里面有与`public/`相同的内容及`.git`的记录 |\n| `public/`       | 生成的完整的静态html网站，执行 `hexo clean` 会清除此文件夹 |\n| `scaffolds/`    | 里面有三个`.md`文件，其中`post.md`是博客文章的默认模板 |\n| `node_modules/` | 每个blog的文件夹中安装的hexo插件 |\n| `source/`       | 撰写的博客文章要放在`source/_post`下，`source/`文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 `public/`。可以在这里新建一个 `img/` 文件夹用于保存图片，文章中可以用`![图片说明](/img/image.png)`这样的代码来插入图片。 |\n| `themes/`       | 存放主题相关文件，各主题也有自己的`_config.yml。` |\n\n\n## 修改`scaffold/post.md`模板\n增加catagory，tags，及摘要和正文的分割线`<!--more-->`。\n> 注意，Markdown对空格和空行敏感。\n\n```\n---\ntitle: {{ title }}\ndate: {{ date }}\ncategory: misc\ntags: [tag1, tag2]\n---\n摘要部分\n<!--more-->\n---\n正文部分\n```\n\n## 修改 hexo-server默认的4000端口号为80\n如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。\n需修改`node_modules/hexo-server/index.js` 第8行 `port`。\n比如我的机器名是z，在chrome地址栏直接输入 `z/` 即可，ie则需要输入 http://z/\n\n# hexo 基本操作\n\n## 常用命令\n\n{% codeblock line_number:false%}\nhexo s     # server   本地预览，http://localhost:4000 。\nhexo d     # deploy   部署整个网站到heroku\nhexo g     # generate 生成静态html\n\nhexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。\nhexo d -g  # 依次执行生成和部署\n\nhexo clean # 删除 public/ 文件夹下所有内容\n{% endcodeblock %}\n\n## 撰写文章\n执行下面的命令，在`source/_posts/`下生成名为 `New-Post.md` 的文件。\n也可以通过常规的文件操作在`source/_posts/`下新建一个 `New-Post.md` 文件。\n\n{% codeblock line_number:false%}\nhexo n \"New Post\"\n{% endcodeblock %}\n\n更多详情可参考[使用hexo写作](http://hexo.io/docs/writing.html)的文档。\n\n## 发布静态html的博客网站到 Github\n{% codeblock line_number:false%}\nhexo d -g\n{% endcodeblock %}\n\n## 为整个blog建立repo\n\nHexo可以将生成的静态html博客网站发布到git仓库，但不会同步`source/`下源文件，`_config.yml`设置等。\n如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。\n为此，为已经设置好的博客建立一个新的git repo。\n\n{% codeblock line_number:false%}\ncd blog/\ngit init\n{% endcodeblock %}\n\n编辑`.gitignore`如下。\n{% codeblock line_number:false%}\n.DS_Store\nThumbs.db\nnode_modules/\nthemes/\npublic/\n.deploy_git/\n.npmignore\n{% endcodeblock %}\n> 注意：把`node_modules/`和`themes/`排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成`node_modules.7z` 和 `themes.7z` 会包括在git repo中。\n\n\n在Github创建一个名为`blog`的项目，\n{% codeblock line_number:false%}\ngit add .\ngit commit -m \"Init\"\ngit remote add github git@github.com:ying-zhang/blog.git\ngit push -u github master\n{% endcodeblock %}\n\n## 克隆已有的blog项目\n当然需要已经安装好git，nodejs和hexo。\n{% codeblock line_number:false%}\ngit clone git@github.com:ying-zhang/blog.git\ncd blog\n\ngit remote rename origin github\n\n7z x node_modules.7z    # 不要忘了这一步\n7z x themes.7z\n{% endcodeblock %}\n\n# Tips\n\nWindows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用[Atom编辑器](https://atom.io/) (并安装Markdown插件)\n\n## 编辑数学公式\n```\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n```\n\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n\n## 设置代码块不显示行号\n```\n{% codeblock line_number:false%}\necho \"Hello Hexo!\"\n{% endcodeblock %}\n```\n\n---\n\n飞鸟集 第128\n\n>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。\n\n所以，就随便写吧。\n","source":"_posts/hello-hexo.md","raw":"title: Hello Hexo！\ncategory: misc\ndate: 2016-09-15\ntags:\n\n---\n欢迎访问。\n本博客使用[Hexo](http://hexo.io/)生成。本文记录了设置过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [简介](#%E7%AE%80%E4%BB%8B)\n- [在Ubuntu 16.04上安装所需程序](#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [在Windows 10上安装所需程序](#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [初次设置](#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE)\n    - [初始化博客文件夹](#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9)\n    - [安装rss插件，git插件，math插件](#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6)\n    - [设置 `_config.yml`](#%E8%AE%BE%E7%BD%AE-configyml)\n    - [使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)](#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane)\n    - [文件结构](#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84)\n    - [修改`scaffold/post.md`模板](#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF)\n    - [修改 hexo-server默认的4000端口号为80](#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80)\n- [hexo 基本操作](#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)\n    - [常用命令](#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)\n    - [撰写文章](#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0)\n    - [发布静态html的博客网站到 Github](#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github)\n    - [为整个blog建立repo](#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo)\n    - [克隆已有的blog项目](#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE)\n- [Tips](#tips)\n    - [编辑数学公式](#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F)\n    - [设置代码块不显示行号](#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7)\n\n<!-- /TOC -->\n\n# 简介\n\n[Hexo](https://hexo.io/)是一个基于[Node.js](https://nodejs.org/)的博客生成工具。它把 [Markdown 格式](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.\nhexo有多种博客主题可选，这里使用了 [jane 主题](https://github.com/hejianxian/hexo-theme-jane)。\n[Github](https://github.com)提供了`https://[github-userId].github.io` 这样的二级域名的静态html站点的托管服务，还可以通过`CNAME`设置自己的域名（需向域名服务商购买）。\n\n下面的设置过程参考了[hexo简易教程](http://mclspace.com/2014/10/19/about-hexo/) 和 [hexo_install_config](http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/)。\n\n\n# 在Ubuntu 16.04上安装所需程序\n\n如果是桌面版的Ubuntu，打开终端（快捷键为`Ctrl+Alt+T`），执行下面的命令。\n\n## 安装git\n\n```\nsudo apt install git\n```\n\n设置 git\n\n```\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n```\n\ngit默认使用`~/.ssh`下的 key，需要在Github上注册对应的public key才能提交代码。\n\n## 安装node.js\n\na. 从Node.js官网 https://nodejs.org/en/download/ 下载Linux-x64系统的二进制安装包，解压到`/usr/local/`。\n\n```\ncd ~\nver=v6.9.2\nwget https://nodejs.org/dist/${ver}/node-${ver}-linux-x64.tar.xz\n\ntar axf node-${ver}-linux-x64.tar.xz\ncd node-${ver}-linux-x64/\nsudo cp -r ./ /usr/local/\ncd ..\nrm -rf node-${ver}-linux-x64.tar.xz\n```\n\nb. 通过添加软件源的方式\n参考[Installing Node.js via package manager](https://nodejs.org/en/download/package-manager/)，\n\n```\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt install -y nodejs\n\nsudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等\n```\n\n## 安装hexo\n\n```\nsudo npm install hexo-cli -g\n```\n\n# 在Windows 10上安装所需程序\n\n## 安装git\n\n从git官网 https://git-scm.com/downloads 下载Windows 系统的[git客户端安装程序](https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe) 。\n执行安装程序，建议\n+ 将其安装到`C:\\git`这样比较短的路径下，方便以后敲命令，\n+ 并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，\n+ 还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。\n\n>安装git的同时会安装[MinGW(Minimalist GNU for Windows)](http://www.mingw.org/)，上面的选项会把git和MinGW的可执行程序添加到`PATH`环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。\n>安装git后，`C:\\git\\usr\\bin`下面的`.exe`程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。\n\n打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。\nWindows系统上git默认使用`C:\\Users\\[UserName]\\.ssh`下的 key。\n> 以`.`开头的文件夹需要在命令窗口执行`mkdir`来创建。\n\n## 安装node.js\n从Node.js https://nodejs.org/en/download/ 下载[Windows x64系统的二进制安装包](https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi) 。\n执行安装程序，建议将其安装到`C:\\nodejs`，并选择将其添加到`PATH`路径中。\n\n## 安装hexo\n打开命令窗口，执行下面的命令\n```\nnpm install hexo-cli -g\n```\n\n# 初次设置\n\n## 初始化博客文件夹\n```\nhexo init blog\n```\n\n在Github创建一个名为`[github-userId].github.io`的项目。\n\n## 安装rss插件，git插件，math插件\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-deployer-git   --save\nnpm install hexo-math           --save\n```\n\n## 设置 `_config.yml`\n\n在 `_config.yml` 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：\n\n```\n## Themes: https://hexo.io/themes/\ntheme: jane\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:ying-zhang/ying-zhang.github.io.git\n  branch: master\n```\n\n## 使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)\n这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到`themes/`文件夹。\n直接在主题文件中修改了等宽字体，及正文的宽度。\n顺便删除默认主题landscape。\n\n## 文件结构\n\n| 文件/文件夹     |       说明     |\n| --------------- | -------------- |\n| `_config.yml`   | 博客的主配置文件 |\n| `.deploy_git/`  | 用于push到Github、heroku等的git仓库，里面有与`public/`相同的内容及`.git`的记录 |\n| `public/`       | 生成的完整的静态html网站，执行 `hexo clean` 会清除此文件夹 |\n| `scaffolds/`    | 里面有三个`.md`文件，其中`post.md`是博客文章的默认模板 |\n| `node_modules/` | 每个blog的文件夹中安装的hexo插件 |\n| `source/`       | 撰写的博客文章要放在`source/_post`下，`source/`文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 `public/`。可以在这里新建一个 `img/` 文件夹用于保存图片，文章中可以用`![图片说明](/img/image.png)`这样的代码来插入图片。 |\n| `themes/`       | 存放主题相关文件，各主题也有自己的`_config.yml。` |\n\n\n## 修改`scaffold/post.md`模板\n增加catagory，tags，及摘要和正文的分割线`<!--more-->`。\n> 注意，Markdown对空格和空行敏感。\n\n```\n---\ntitle: {{ title }}\ndate: {{ date }}\ncategory: misc\ntags: [tag1, tag2]\n---\n摘要部分\n<!--more-->\n---\n正文部分\n```\n\n## 修改 hexo-server默认的4000端口号为80\n如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。\n需修改`node_modules/hexo-server/index.js` 第8行 `port`。\n比如我的机器名是z，在chrome地址栏直接输入 `z/` 即可，ie则需要输入 http://z/\n\n# hexo 基本操作\n\n## 常用命令\n\n{% codeblock line_number:false%}\nhexo s     # server   本地预览，http://localhost:4000 。\nhexo d     # deploy   部署整个网站到heroku\nhexo g     # generate 生成静态html\n\nhexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。\nhexo d -g  # 依次执行生成和部署\n\nhexo clean # 删除 public/ 文件夹下所有内容\n{% endcodeblock %}\n\n## 撰写文章\n执行下面的命令，在`source/_posts/`下生成名为 `New-Post.md` 的文件。\n也可以通过常规的文件操作在`source/_posts/`下新建一个 `New-Post.md` 文件。\n\n{% codeblock line_number:false%}\nhexo n \"New Post\"\n{% endcodeblock %}\n\n更多详情可参考[使用hexo写作](http://hexo.io/docs/writing.html)的文档。\n\n## 发布静态html的博客网站到 Github\n{% codeblock line_number:false%}\nhexo d -g\n{% endcodeblock %}\n\n## 为整个blog建立repo\n\nHexo可以将生成的静态html博客网站发布到git仓库，但不会同步`source/`下源文件，`_config.yml`设置等。\n如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。\n为此，为已经设置好的博客建立一个新的git repo。\n\n{% codeblock line_number:false%}\ncd blog/\ngit init\n{% endcodeblock %}\n\n编辑`.gitignore`如下。\n{% codeblock line_number:false%}\n.DS_Store\nThumbs.db\nnode_modules/\nthemes/\npublic/\n.deploy_git/\n.npmignore\n{% endcodeblock %}\n> 注意：把`node_modules/`和`themes/`排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成`node_modules.7z` 和 `themes.7z` 会包括在git repo中。\n\n\n在Github创建一个名为`blog`的项目，\n{% codeblock line_number:false%}\ngit add .\ngit commit -m \"Init\"\ngit remote add github git@github.com:ying-zhang/blog.git\ngit push -u github master\n{% endcodeblock %}\n\n## 克隆已有的blog项目\n当然需要已经安装好git，nodejs和hexo。\n{% codeblock line_number:false%}\ngit clone git@github.com:ying-zhang/blog.git\ncd blog\n\ngit remote rename origin github\n\n7z x node_modules.7z    # 不要忘了这一步\n7z x themes.7z\n{% endcodeblock %}\n\n# Tips\n\nWindows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用[Atom编辑器](https://atom.io/) (并安装Markdown插件)\n\n## 编辑数学公式\n```\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n```\n\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n\n## 设置代码块不显示行号\n```\n{% codeblock line_number:false%}\necho \"Hello Hexo!\"\n{% endcodeblock %}\n```\n\n---\n\n飞鸟集 第128\n\n>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。\n\n所以，就随便写吧。\n","slug":"hello-hexo","published":1,"updated":"2017-10-30T03:51:50.679Z","_id":"cj9dnebp40000d84flsyplach","comments":1,"layout":"post","photos":[],"link":"","content":"<p>欢迎访问。<br>本博客使用<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>生成。本文记录了设置过程。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E7%AE%80%E4%BB%8B\">简介</a></li>\n<li><a href=\"#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Ubuntu 16.04上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Windows 10上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE\">初次设置</a><ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9\">初始化博客文件夹</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6\">安装rss插件，git插件，math插件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE-configyml\">设置 <code>_config.yml</code></a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane\">使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\">文件结构</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF\">修改<code>scaffold/post.md</code>模板</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80\">修改 hexo-server默认的4000端口号为80</a></li>\n</ul>\n</li>\n<li><a href=\"#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">hexo 基本操作</a><ul>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">常用命令</a></li>\n<li><a href=\"#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0\">撰写文章</a></li>\n<li><a href=\"#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github\">发布静态html的博客网站到 Github</a></li>\n<li><a href=\"#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo\">为整个blog建立repo</a></li>\n<li><a href=\"#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE\">克隆已有的blog项目</a></li>\n</ul>\n</li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F\">编辑数学公式</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7\">设置代码块不显示行号</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>是一个基于<a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>的博客生成工具。它把 <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\" rel=\"external\">Markdown 格式</a>的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.<br>hexo有多种博客主题可选，这里使用了 <a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane 主题</a>。<br><a href=\"https://github.com\" target=\"_blank\" rel=\"external\">Github</a>提供了<code>https://[github-userId].github.io</code> 这样的二级域名的静态html站点的托管服务，还可以通过<code>CNAME</code>设置自己的域名（需向域名服务商购买）。</p>\n<p>下面的设置过程参考了<a href=\"http://mclspace.com/2014/10/19/about-hexo/\" target=\"_blank\" rel=\"external\">hexo简易教程</a> 和 <a href=\"http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/\" target=\"_blank\" rel=\"external\">hexo_install_config</a>。</p>\n<h1 id=\"在Ubuntu-16-04上安装所需程序\"><a href=\"#在Ubuntu-16-04上安装所需程序\" class=\"headerlink\" title=\"在Ubuntu 16.04上安装所需程序\"></a>在Ubuntu 16.04上安装所需程序</h1><p>如果是桌面版的Ubuntu，打开终端（快捷键为<code>Ctrl+Alt+T</code>），执行下面的命令。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install git</div></pre></td></tr></table></figure>\n<p>设置 git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div></pre></td></tr></table></figure>\n<p>git默认使用<code>~/.ssh</code>下的 key，需要在Github上注册对应的public key才能提交代码。</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>a. 从Node.js官网 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载Linux-x64系统的二进制安装包，解压到<code>/usr/local/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">ver=v6.9.2</div><div class=\"line\">wget https://nodejs.org/dist/$&#123;ver&#125;/node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\"></div><div class=\"line\">tar axf node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\">cd node-$&#123;ver&#125;-linux-x64/</div><div class=\"line\">sudo cp -r ./ /usr/local/</div><div class=\"line\">cd ..</div><div class=\"line\">rm -rf node-$&#123;ver&#125;-linux-x64.tar.xz</div></pre></td></tr></table></figure>\n<p>b. 通过添加软件源的方式<br>参考<a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"external\">Installing Node.js via package manager</a>，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</div><div class=\"line\">sudo apt install -y nodejs</div><div class=\"line\"></div><div class=\"line\">sudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等</div></pre></td></tr></table></figure>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<h1 id=\"在Windows-10上安装所需程序\"><a href=\"#在Windows-10上安装所需程序\" class=\"headerlink\" title=\"在Windows 10上安装所需程序\"></a>在Windows 10上安装所需程序</h1><h2 id=\"安装git-1\"><a href=\"#安装git-1\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>从git官网 <a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">https://git-scm.com/downloads</a> 下载Windows 系统的<a href=\"https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe\" target=\"_blank\" rel=\"external\">git客户端安装程序</a> 。<br>执行安装程序，建议</p>\n<ul>\n<li>将其安装到<code>C:\\git</code>这样比较短的路径下，方便以后敲命令，</li>\n<li>并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，</li>\n<li>还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。</li>\n</ul>\n<blockquote>\n<p>安装git的同时会安装<a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"external\">MinGW(Minimalist GNU for Windows)</a>，上面的选项会把git和MinGW的可执行程序添加到<code>PATH</code>环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。<br>安装git后，<code>C:\\git\\usr\\bin</code>下面的<code>.exe</code>程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。</p>\n</blockquote>\n<p>打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。<br>Windows系统上git默认使用<code>C:\\Users\\[UserName]\\.ssh</code>下的 key。</p>\n<blockquote>\n<p>以<code>.</code>开头的文件夹需要在命令窗口执行<code>mkdir</code>来创建。</p>\n</blockquote>\n<h2 id=\"安装node-js-1\"><a href=\"#安装node-js-1\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>从Node.js <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载<a href=\"https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi\" target=\"_blank\" rel=\"external\">Windows x64系统的二进制安装包</a> 。<br>执行安装程序，建议将其安装到<code>C:\\nodejs</code>，并选择将其添加到<code>PATH</code>路径中。</p>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>打开命令窗口，执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>\n<h1 id=\"初次设置\"><a href=\"#初次设置\" class=\"headerlink\" title=\"初次设置\"></a>初次设置</h1><h2 id=\"初始化博客文件夹\"><a href=\"#初始化博客文件夹\" class=\"headerlink\" title=\"初始化博客文件夹\"></a>初始化博客文件夹</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure>\n<p>在Github创建一个名为<code>[github-userId].github.io</code>的项目。</p>\n<h2 id=\"安装rss插件，git插件，math插件\"><a href=\"#安装rss插件，git插件，math插件\" class=\"headerlink\" title=\"安装rss插件，git插件，math插件\"></a>安装rss插件，git插件，math插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-generator-feed --save</div><div class=\"line\">npm install hexo-deployer-git   --save</div><div class=\"line\">npm install hexo-math           --save</div></pre></td></tr></table></figure>\n<h2 id=\"设置-config-yml\"><a href=\"#设置-config-yml\" class=\"headerlink\" title=\"设置 _config.yml\"></a>设置 <code>_config.yml</code></h2><p>在 <code>_config.yml</code> 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: jane</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:ying-zhang/ying-zhang.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h2 id=\"使用jane主题\"><a href=\"#使用jane主题\" class=\"headerlink\" title=\"使用jane主题\"></a>使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></h2><p>这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到<code>themes/</code>文件夹。<br>直接在主题文件中修改了等宽字体，及正文的宽度。<br>顺便删除默认主题landscape。</p>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_config.yml</code></td>\n<td>博客的主配置文件</td>\n</tr>\n<tr>\n<td><code>.deploy_git/</code></td>\n<td>用于push到Github、heroku等的git仓库，里面有与<code>public/</code>相同的内容及<code>.git</code>的记录</td>\n</tr>\n<tr>\n<td><code>public/</code></td>\n<td>生成的完整的静态html网站，执行 <code>hexo clean</code> 会清除此文件夹</td>\n</tr>\n<tr>\n<td><code>scaffolds/</code></td>\n<td>里面有三个<code>.md</code>文件，其中<code>post.md</code>是博客文章的默认模板</td>\n</tr>\n<tr>\n<td><code>node_modules/</code></td>\n<td>每个blog的文件夹中安装的hexo插件</td>\n</tr>\n<tr>\n<td><code>source/</code></td>\n<td>撰写的博客文章要放在<code>source/_post</code>下，<code>source/</code>文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 <code>public/</code>。可以在这里新建一个 <code>img/</code> 文件夹用于保存图片，文章中可以用<code>![图片说明](/img/image.png)</code>这样的代码来插入图片。</td>\n</tr>\n<tr>\n<td><code>themes/</code></td>\n<td>存放主题相关文件，各主题也有自己的<code>_config.yml。</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修改scaffold-post-md模板\"><a href=\"#修改scaffold-post-md模板\" class=\"headerlink\" title=\"修改scaffold/post.md模板\"></a>修改<code>scaffold/post.md</code>模板</h2><p>增加catagory，tags，及摘要和正文的分割线<code>&lt;!--more--&gt;</code>。</p>\n<blockquote>\n<p>注意，Markdown对空格和空行敏感。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: &#123;&#123; title &#125;&#125;</div><div class=\"line\">date: &#123;&#123; date &#125;&#125;</div><div class=\"line\">category: misc</div><div class=\"line\">tags: [tag1, tag2]</div><div class=\"line\">---</div><div class=\"line\">摘要部分</div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\">---</div><div class=\"line\">正文部分</div></pre></td></tr></table></figure>\n<h2 id=\"修改-hexo-server默认的4000端口号为80\"><a href=\"#修改-hexo-server默认的4000端口号为80\" class=\"headerlink\" title=\"修改 hexo-server默认的4000端口号为80\"></a>修改 hexo-server默认的4000端口号为80</h2><p>如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。<br>需修改<code>node_modules/hexo-server/index.js</code> 第8行 <code>port</code>。<br>比如我的机器名是z，在chrome地址栏直接输入 <code>z/</code> 即可，ie则需要输入 <a href=\"http://z/\" target=\"_blank\" rel=\"external\">http://z/</a></p>\n<h1 id=\"hexo-基本操作\"><a href=\"#hexo-基本操作\" class=\"headerlink\" title=\"hexo 基本操作\"></a>hexo 基本操作</h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo s     # server   本地预览，http://localhost:4000 。</div><div class=\"line\">hexo d     # deploy   部署整个网站到heroku</div><div class=\"line\">hexo g     # generate 生成静态html</div><div class=\"line\"></div><div class=\"line\">hexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。</div><div class=\"line\">hexo d -g  # 依次执行生成和部署</div><div class=\"line\"></div><div class=\"line\">hexo clean # 删除 public/ 文件夹下所有内容</div></pre></td></tr></table></figure>\n<h2 id=\"撰写文章\"><a href=\"#撰写文章\" class=\"headerlink\" title=\"撰写文章\"></a>撰写文章</h2><p>执行下面的命令，在<code>source/_posts/</code>下生成名为 <code>New-Post.md</code> 的文件。<br>也可以通过常规的文件操作在<code>source/_posts/</code>下新建一个 <code>New-Post.md</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo n &quot;New Post&quot;</div></pre></td></tr></table></figure>\n<p>更多详情可参考<a href=\"http://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">使用hexo写作</a>的文档。</p>\n<h2 id=\"发布静态html的博客网站到-Github\"><a href=\"#发布静态html的博客网站到-Github\" class=\"headerlink\" title=\"发布静态html的博客网站到 Github\"></a>发布静态html的博客网站到 Github</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure>\n<h2 id=\"为整个blog建立repo\"><a href=\"#为整个blog建立repo\" class=\"headerlink\" title=\"为整个blog建立repo\"></a>为整个blog建立repo</h2><p>Hexo可以将生成的静态html博客网站发布到git仓库，但不会同步<code>source/</code>下源文件，<code>_config.yml</code>设置等。<br>如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。<br>为此，为已经设置好的博客建立一个新的git repo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd blog/</div><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>编辑<code>.gitignore</code>如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">node_modules/</div><div class=\"line\">themes/</div><div class=\"line\">public/</div><div class=\"line\">.deploy_git/</div><div class=\"line\">.npmignore</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：把<code>node_modules/</code>和<code>themes/</code>排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成<code>node_modules.7z</code> 和 <code>themes.7z</code> 会包括在git repo中。</p>\n</blockquote>\n<p>在Github创建一个名为<code>blog</code>的项目，<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;Init&quot;</div><div class=\"line\">git remote add github git@github.com:ying-zhang/blog.git</div><div class=\"line\">git push -u github master</div></pre></td></tr></table></figure></p>\n<h2 id=\"克隆已有的blog项目\"><a href=\"#克隆已有的blog项目\" class=\"headerlink\" title=\"克隆已有的blog项目\"></a>克隆已有的blog项目</h2><p>当然需要已经安装好git，nodejs和hexo。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ying-zhang/blog.git</div><div class=\"line\">cd blog</div><div class=\"line\"></div><div class=\"line\">git remote rename origin github</div><div class=\"line\"></div><div class=\"line\">7z x node_modules.7z    # 不要忘了这一步</div><div class=\"line\">7z x themes.7z</div></pre></td></tr></table></figure></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p>Windows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">Atom编辑器</a> (并安装Markdown插件)</p>\n<h2 id=\"编辑数学公式\"><a href=\"#编辑数学公式\" class=\"headerlink\" title=\"编辑数学公式\"></a>编辑数学公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% math %&#125;</div><div class=\"line\">\\begin&#123;align*&#125;</div><div class=\"line\">-\\sum_i&#123;P_i\\log_2\\frac&#123;P_i&#125;&#123;Q_i&#125;&#125; =&amp; \\sum_i&#123;P_i\\log_2\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\\\</div><div class=\"line\">\\le&amp; \\log_2\\sum_i&#123;P_i\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\tag&#123;Jensen 不等式&#125; \\\\</div><div class=\"line\">=&amp; \\log_2\\sum_i&#123;Q_i&#125; \\\\</div><div class=\"line\">=&amp; 0</div><div class=\"line\">\\end&#123;align*&#125;</div><div class=\"line\">&#123;% endmath %&#125;</div></pre></td></tr></table></figure>\n<span>$$\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =&amp; \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le&amp; \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=&amp; \\log_2\\sum_i{Q_i} \\\\\n=&amp; 0\n\\end{align*}$$</span><!-- Has MathJax -->\n<h2 id=\"设置代码块不显示行号\"><a href=\"#设置代码块不显示行号\" class=\"headerlink\" title=\"设置代码块不显示行号\"></a>设置代码块不显示行号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% codeblock line_number:false%&#125;</div><div class=\"line\">echo &quot;Hello Hexo!&quot;</div><div class=\"line\">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>飞鸟集 第128</p>\n<blockquote>\n<p>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。</p>\n</blockquote>\n<p>所以，就随便写吧。</p>\n","site":{"data":{}},"excerpt":"<p>欢迎访问。<br>本博客使用<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>生成。本文记录了设置过程。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E7%AE%80%E4%BB%8B\">简介</a></li>\n<li><a href=\"#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Ubuntu 16.04上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Windows 10上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE\">初次设置</a><ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9\">初始化博客文件夹</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6\">安装rss插件，git插件，math插件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE-configyml\">设置 <code>_config.yml</code></a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane\">使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\">文件结构</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF\">修改<code>scaffold/post.md</code>模板</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80\">修改 hexo-server默认的4000端口号为80</a></li>\n</ul>\n</li>\n<li><a href=\"#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">hexo 基本操作</a><ul>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">常用命令</a></li>\n<li><a href=\"#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0\">撰写文章</a></li>\n<li><a href=\"#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github\">发布静态html的博客网站到 Github</a></li>\n<li><a href=\"#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo\">为整个blog建立repo</a></li>\n<li><a href=\"#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE\">克隆已有的blog项目</a></li>\n</ul>\n</li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F\">编辑数学公式</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7\">设置代码块不显示行号</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>是一个基于<a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>的博客生成工具。它把 <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\" rel=\"external\">Markdown 格式</a>的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.<br>hexo有多种博客主题可选，这里使用了 <a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane 主题</a>。<br><a href=\"https://github.com\" target=\"_blank\" rel=\"external\">Github</a>提供了<code>https://[github-userId].github.io</code> 这样的二级域名的静态html站点的托管服务，还可以通过<code>CNAME</code>设置自己的域名（需向域名服务商购买）。</p>\n<p>下面的设置过程参考了<a href=\"http://mclspace.com/2014/10/19/about-hexo/\" target=\"_blank\" rel=\"external\">hexo简易教程</a> 和 <a href=\"http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/\" target=\"_blank\" rel=\"external\">hexo_install_config</a>。</p>\n<h1 id=\"在Ubuntu-16-04上安装所需程序\"><a href=\"#在Ubuntu-16-04上安装所需程序\" class=\"headerlink\" title=\"在Ubuntu 16.04上安装所需程序\"></a>在Ubuntu 16.04上安装所需程序</h1><p>如果是桌面版的Ubuntu，打开终端（快捷键为<code>Ctrl+Alt+T</code>），执行下面的命令。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install git</div></pre></td></tr></table></figure>\n<p>设置 git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div></pre></td></tr></table></figure>\n<p>git默认使用<code>~/.ssh</code>下的 key，需要在Github上注册对应的public key才能提交代码。</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>a. 从Node.js官网 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载Linux-x64系统的二进制安装包，解压到<code>/usr/local/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">ver=v6.9.2</div><div class=\"line\">wget https://nodejs.org/dist/$&#123;ver&#125;/node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\"></div><div class=\"line\">tar axf node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\">cd node-$&#123;ver&#125;-linux-x64/</div><div class=\"line\">sudo cp -r ./ /usr/local/</div><div class=\"line\">cd ..</div><div class=\"line\">rm -rf node-$&#123;ver&#125;-linux-x64.tar.xz</div></pre></td></tr></table></figure>\n<p>b. 通过添加软件源的方式<br>参考<a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"external\">Installing Node.js via package manager</a>，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</div><div class=\"line\">sudo apt install -y nodejs</div><div class=\"line\"></div><div class=\"line\">sudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等</div></pre></td></tr></table></figure>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<h1 id=\"在Windows-10上安装所需程序\"><a href=\"#在Windows-10上安装所需程序\" class=\"headerlink\" title=\"在Windows 10上安装所需程序\"></a>在Windows 10上安装所需程序</h1><h2 id=\"安装git-1\"><a href=\"#安装git-1\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>从git官网 <a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">https://git-scm.com/downloads</a> 下载Windows 系统的<a href=\"https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe\" target=\"_blank\" rel=\"external\">git客户端安装程序</a> 。<br>执行安装程序，建议</p>\n<ul>\n<li>将其安装到<code>C:\\git</code>这样比较短的路径下，方便以后敲命令，</li>\n<li>并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，</li>\n<li>还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。</li>\n</ul>\n<blockquote>\n<p>安装git的同时会安装<a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"external\">MinGW(Minimalist GNU for Windows)</a>，上面的选项会把git和MinGW的可执行程序添加到<code>PATH</code>环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。<br>安装git后，<code>C:\\git\\usr\\bin</code>下面的<code>.exe</code>程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。</p>\n</blockquote>\n<p>打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。<br>Windows系统上git默认使用<code>C:\\Users\\[UserName]\\.ssh</code>下的 key。</p>\n<blockquote>\n<p>以<code>.</code>开头的文件夹需要在命令窗口执行<code>mkdir</code>来创建。</p>\n</blockquote>\n<h2 id=\"安装node-js-1\"><a href=\"#安装node-js-1\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>从Node.js <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载<a href=\"https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi\" target=\"_blank\" rel=\"external\">Windows x64系统的二进制安装包</a> 。<br>执行安装程序，建议将其安装到<code>C:\\nodejs</code>，并选择将其添加到<code>PATH</code>路径中。</p>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>打开命令窗口，执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>\n<h1 id=\"初次设置\"><a href=\"#初次设置\" class=\"headerlink\" title=\"初次设置\"></a>初次设置</h1><h2 id=\"初始化博客文件夹\"><a href=\"#初始化博客文件夹\" class=\"headerlink\" title=\"初始化博客文件夹\"></a>初始化博客文件夹</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure>\n<p>在Github创建一个名为<code>[github-userId].github.io</code>的项目。</p>\n<h2 id=\"安装rss插件，git插件，math插件\"><a href=\"#安装rss插件，git插件，math插件\" class=\"headerlink\" title=\"安装rss插件，git插件，math插件\"></a>安装rss插件，git插件，math插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-generator-feed --save</div><div class=\"line\">npm install hexo-deployer-git   --save</div><div class=\"line\">npm install hexo-math           --save</div></pre></td></tr></table></figure>\n<h2 id=\"设置-config-yml\"><a href=\"#设置-config-yml\" class=\"headerlink\" title=\"设置 _config.yml\"></a>设置 <code>_config.yml</code></h2><p>在 <code>_config.yml</code> 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: jane</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:ying-zhang/ying-zhang.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h2 id=\"使用jane主题\"><a href=\"#使用jane主题\" class=\"headerlink\" title=\"使用jane主题\"></a>使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></h2><p>这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到<code>themes/</code>文件夹。<br>直接在主题文件中修改了等宽字体，及正文的宽度。<br>顺便删除默认主题landscape。</p>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_config.yml</code></td>\n<td>博客的主配置文件</td>\n</tr>\n<tr>\n<td><code>.deploy_git/</code></td>\n<td>用于push到Github、heroku等的git仓库，里面有与<code>public/</code>相同的内容及<code>.git</code>的记录</td>\n</tr>\n<tr>\n<td><code>public/</code></td>\n<td>生成的完整的静态html网站，执行 <code>hexo clean</code> 会清除此文件夹</td>\n</tr>\n<tr>\n<td><code>scaffolds/</code></td>\n<td>里面有三个<code>.md</code>文件，其中<code>post.md</code>是博客文章的默认模板</td>\n</tr>\n<tr>\n<td><code>node_modules/</code></td>\n<td>每个blog的文件夹中安装的hexo插件</td>\n</tr>\n<tr>\n<td><code>source/</code></td>\n<td>撰写的博客文章要放在<code>source/_post</code>下，<code>source/</code>文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 <code>public/</code>。可以在这里新建一个 <code>img/</code> 文件夹用于保存图片，文章中可以用<code>![图片说明](/img/image.png)</code>这样的代码来插入图片。</td>\n</tr>\n<tr>\n<td><code>themes/</code></td>\n<td>存放主题相关文件，各主题也有自己的<code>_config.yml。</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修改scaffold-post-md模板\"><a href=\"#修改scaffold-post-md模板\" class=\"headerlink\" title=\"修改scaffold/post.md模板\"></a>修改<code>scaffold/post.md</code>模板</h2><p>增加catagory，tags，及摘要和正文的分割线<code>&lt;!--more--&gt;</code>。</p>\n<blockquote>\n<p>注意，Markdown对空格和空行敏感。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: &#123;&#123; title &#125;&#125;</div><div class=\"line\">date: &#123;&#123; date &#125;&#125;</div><div class=\"line\">category: misc</div><div class=\"line\">tags: [tag1, tag2]</div><div class=\"line\">---</div><div class=\"line\">摘要部分</div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\">---</div><div class=\"line\">正文部分</div></pre></td></tr></table></figure>\n<h2 id=\"修改-hexo-server默认的4000端口号为80\"><a href=\"#修改-hexo-server默认的4000端口号为80\" class=\"headerlink\" title=\"修改 hexo-server默认的4000端口号为80\"></a>修改 hexo-server默认的4000端口号为80</h2><p>如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。<br>需修改<code>node_modules/hexo-server/index.js</code> 第8行 <code>port</code>。<br>比如我的机器名是z，在chrome地址栏直接输入 <code>z/</code> 即可，ie则需要输入 <a href=\"http://z/\" target=\"_blank\" rel=\"external\">http://z/</a></p>\n<h1 id=\"hexo-基本操作\"><a href=\"#hexo-基本操作\" class=\"headerlink\" title=\"hexo 基本操作\"></a>hexo 基本操作</h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo s     # server   本地预览，http://localhost:4000 。</div><div class=\"line\">hexo d     # deploy   部署整个网站到heroku</div><div class=\"line\">hexo g     # generate 生成静态html</div><div class=\"line\"></div><div class=\"line\">hexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。</div><div class=\"line\">hexo d -g  # 依次执行生成和部署</div><div class=\"line\"></div><div class=\"line\">hexo clean # 删除 public/ 文件夹下所有内容</div></pre></td></tr></table></figure>\n<h2 id=\"撰写文章\"><a href=\"#撰写文章\" class=\"headerlink\" title=\"撰写文章\"></a>撰写文章</h2><p>执行下面的命令，在<code>source/_posts/</code>下生成名为 <code>New-Post.md</code> 的文件。<br>也可以通过常规的文件操作在<code>source/_posts/</code>下新建一个 <code>New-Post.md</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo n &quot;New Post&quot;</div></pre></td></tr></table></figure>\n<p>更多详情可参考<a href=\"http://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">使用hexo写作</a>的文档。</p>\n<h2 id=\"发布静态html的博客网站到-Github\"><a href=\"#发布静态html的博客网站到-Github\" class=\"headerlink\" title=\"发布静态html的博客网站到 Github\"></a>发布静态html的博客网站到 Github</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure>\n<h2 id=\"为整个blog建立repo\"><a href=\"#为整个blog建立repo\" class=\"headerlink\" title=\"为整个blog建立repo\"></a>为整个blog建立repo</h2><p>Hexo可以将生成的静态html博客网站发布到git仓库，但不会同步<code>source/</code>下源文件，<code>_config.yml</code>设置等。<br>如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。<br>为此，为已经设置好的博客建立一个新的git repo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd blog/</div><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>编辑<code>.gitignore</code>如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">node_modules/</div><div class=\"line\">themes/</div><div class=\"line\">public/</div><div class=\"line\">.deploy_git/</div><div class=\"line\">.npmignore</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：把<code>node_modules/</code>和<code>themes/</code>排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成<code>node_modules.7z</code> 和 <code>themes.7z</code> 会包括在git repo中。</p>\n</blockquote>\n<p>在Github创建一个名为<code>blog</code>的项目，<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;Init&quot;</div><div class=\"line\">git remote add github git@github.com:ying-zhang/blog.git</div><div class=\"line\">git push -u github master</div></pre></td></tr></table></figure></p>\n<h2 id=\"克隆已有的blog项目\"><a href=\"#克隆已有的blog项目\" class=\"headerlink\" title=\"克隆已有的blog项目\"></a>克隆已有的blog项目</h2><p>当然需要已经安装好git，nodejs和hexo。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ying-zhang/blog.git</div><div class=\"line\">cd blog</div><div class=\"line\"></div><div class=\"line\">git remote rename origin github</div><div class=\"line\"></div><div class=\"line\">7z x node_modules.7z    # 不要忘了这一步</div><div class=\"line\">7z x themes.7z</div></pre></td></tr></table></figure></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p>Windows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用<a href=\"https://atom.io/\" target=\"_blank\" rel=\"external\">Atom编辑器</a> (并安装Markdown插件)</p>\n<h2 id=\"编辑数学公式\"><a href=\"#编辑数学公式\" class=\"headerlink\" title=\"编辑数学公式\"></a>编辑数学公式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% math %&#125;</div><div class=\"line\">\\begin&#123;align*&#125;</div><div class=\"line\">-\\sum_i&#123;P_i\\log_2\\frac&#123;P_i&#125;&#123;Q_i&#125;&#125; =&amp; \\sum_i&#123;P_i\\log_2\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\\\</div><div class=\"line\">\\le&amp; \\log_2\\sum_i&#123;P_i\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\tag&#123;Jensen 不等式&#125; \\\\</div><div class=\"line\">=&amp; \\log_2\\sum_i&#123;Q_i&#125; \\\\</div><div class=\"line\">=&amp; 0</div><div class=\"line\">\\end&#123;align*&#125;</div><div class=\"line\">&#123;% endmath %&#125;</div></pre></td></tr></table></figure>\n<span>$$\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =&amp; \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le&amp; \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=&amp; \\log_2\\sum_i{Q_i} \\\\\n=&amp; 0\n\\end{align*}$$</span><!-- Has MathJax -->\n<h2 id=\"设置代码块不显示行号\"><a href=\"#设置代码块不显示行号\" class=\"headerlink\" title=\"设置代码块不显示行号\"></a>设置代码块不显示行号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% codeblock line_number:false%&#125;</div><div class=\"line\">echo &quot;Hello Hexo!&quot;</div><div class=\"line\">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>飞鸟集 第128</p>\n<blockquote>\n<p>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。</p>\n</blockquote>\n<p>所以，就随便写吧。</p>"},{"title":"【译文】Docker镜像格式规范，v1.2","date":"2017-05-15T16:00:00.000Z","_content":"原文见 https://github.com/moby/moby/blob/master/image/spec/v1.2.md\nDocker已经迁移到Moby项目了。\n\n<!--more-->\n<!-- TOC -->\n\n    - [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n- [Docker镜像规范v1.2.0](#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120)\n    - [术语](#%E6%9C%AF%E8%AF%AD)\n        - [层（Layer）](#%E5%B1%82%EF%BC%88layer%EF%BC%89)\n        - [镜像的JSON描述文件](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6)\n        - [镜像文件变更集（changeset）](#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89)\n        - [层的DiffID](#%E5%B1%82%E7%9A%84diffid)\n        - [层的ChainID](#%E5%B1%82%E7%9A%84chainid)\n        - [镜像的ImageID](#%E9%95%9C%E5%83%8F%E7%9A%84imageid)\n        - [标签（Tag）](#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89)\n        - [镜像名（Repository）](#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89)\n    - [镜像的JSON描述文件示例](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B)\n    - [镜像的JSON描述文件说明](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E)\n        - [created](#created)\n        - [author](#author)\n        - [architecture](#architecture)\n        - [os](#os)\n        - [config](#config)\n            - [User](#user)\n            - [Memory](#memory)\n            - [MemorySwap](#memoryswap)\n            - [CpuShares](#cpushares)\n            - [ExposedPorts](#exposedports)\n            - [Env](#env)\n            - [Entrypoint](#entrypoint)\n            - [Cmd](#cmd)\n            - [Healthcheck](#healthcheck)\n                - [Test](#test)\n                - [Volumes](#volumes)\n                - [WorkingDir](#workingdir)\n                - [rootfs](#rootfs)\n        - [history](#history)\n    - [创建镜像文件变更集](#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86)\n    - [镜像的组合格式](#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F)\n- [TODO](#todo)\n- [补充](#%E8%A1%A5%E5%85%85)\n    - [alpine镜像的主机存储布局](#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80)\n\n<!-- /TOC -->\n\n# Docker镜像规范v1.2.0\n\n**镜像（Image）**是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。\n此版本的镜像规范自Docker 1.12开始采用。\n\n> 译注：本规范中的 **filesystem** 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 **文件集**。\n\n## 术语\n本规范使用以下术语:\n### 层（Layer）\n镜像由 **层** 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。\n\n### 镜像的JSON描述文件\n整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。\n该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。\n \n### 镜像文件变更集（changeset）\n每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。\n\n### 层的DiffID\n将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个`tar`包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用`tar-split`来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。\n\n>译注：关于层的打包和解包的可重复性，`tar`程序将一组文件打包的 **顺序** 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。\n参考：[tar打包的顺序](https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined)。\n\n### 层的ChainID\n为方便起见，可以给一串有序的层计算出一个ID，称为 **ChainID**。\n仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：\n\n$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ \" \\quad\" +DiffID(layerN))$$ \n\n### 镜像的ImageID\n每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。\n\n### 标签（Tag）\nTag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即`[a-zA-Z0-9_.-]`，首个字符不能是`.`或`-`。Tag不能超过127个字符。\n\n### 镜像名（Repository）\n这里的`Repository`是指镜像全名在冒号`:`之前的部分，冒号`:`之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为`my-app:3.1.4`的镜像，`my-app`就是镜像的 Repository 部分。\nRepository又可以用斜杠`/`分隔开，`/`之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 **不得** 包含下划线`_`字符，主机名可以有如`：8080`格式的端口号。\n镜像名可以包含小写字符，数字和分隔符。 分隔符是句点`.`，一个或两个下划线`_`，或一个或多个短横线`-`，镜像名 **不允许** 以分隔符开头或结尾。\n\n> 译注：\n+ 这里的 Repository 容易与git的 **代码仓库** 概念混淆。\n+ DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线`_`，参考[RFC 1123](https://tools.ietf.org/html/rfc1123)\n\n\n## 镜像的JSON描述文件示例\n下面是一个镜像的JSON描述文件示例：\n\n```\n{\n  \"architecture\": \"amd64\",\n  \"author\": \"Alyssa P. Hacker &ltalyspdev@example.com&gt\",\n  \"config\": {\n    \"Cmd\": [\n      \"--foreground\",\n      \"--config\",\n      \"/etc/my-app.d/default.cfg\"\n    ],\n    \"CpuShares\": 8,\n    \"Entrypoint\": [\n      \"/bin/my-app-binary\"\n    ],\n    \"Env\": [\n      \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n      \"FOO=docker_is_a_really\",\n      \"BAR=great_tool_you_know\"\n    ],\n    \"ExposedPorts\": {\n      \"8080/tcp\": {}\n    },\n    \"Memory\": 2048,\n    \"MemorySwap\": 4096,\n    \"User\": \"alice\",\n    \"Volumes\": {\n      \"/var/job-result-data\": {},\n      \"/var/log/my-app-logs\": {}\n    },\n    \"WorkingDir\": \"/home/alice\"\n  },\n  \"created\": \"2015-10-31T22:22:56.015925234Z\",\n  \"history\": [\n    {\n      \"created\": \"2015-10-31T22:22:54.690851953Z\",\n      \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n    },\n    {\n      \"created\": \"2015-10-31T22:22:55.613815829Z\",\n      \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n      \"empty_layer\": true\n    }\n  ],\n  \"os\": \"linux\",\n  \"rootfs\": {\n    \"diff_ids\": [\n      \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n      \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\"\n    ],\n    \"type\": \"layers\"\n  }\n}\n\n```\n\n注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。\n\n## 镜像的JSON描述文件说明\n\n### created\n`string`\n镜像创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)。\n\n### author\n`string`\n创建和负责维护改镜像的人员或组织名，或Email。\n### architecture\n`string`\n镜像中可执行文件的CPU架构，可以是 \n+ `386`\n+ `amd64`\n+ `arm`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。\n\n### os\n`string`\n镜像运行的操作系统名，可以是 \n+ `darwin`\n+ `freebsd`\n+ `linux`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。\n\n### config\n`struct`\n`config`结构是从镜像创建容器时，使用的基本执行参数。`config`可以是空值`null`，则创建容器时必须提供所有必要的执行参数。\n\n`config`结构的各字段说明\n#### User \n`string`\n容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：\n+ `user`\n+ `uid`\n+ `user:group`\n+ `uid:gid`\n+ `uid:group`\n+ `user:gid`\n\n如果没有给出组名 `group`/`gid`，默认的组使用容器中`/etc/passwd`文件对应的`user`/`uid`项。\n\n#### Memory \n`integer`\n内存限值（以 **字节** 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### MemorySwap \n`integer`\n总的内存使用量（内存 + swap），设置为`-1`则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### CpuShares \n`integer`\nCPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### ExposedPorts \n`struct`\n基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"8080\": {},\n    \"53/udp\": {},\n    \"2356/tcp\": {}\n}\n```\n其中的键可以是下面的格式：\n+ `\"port/tcp\"`\n+ `\"port/udp\"`\n+ `\"port\"`\n如果没有给出协议，默认使用`tcp`协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。\n\n#### Env \n`array of strings`\nEnv的每项都是 `VARNAME=\"var value\"` 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。\n\n#### Entrypoint \n`array of strings`\n容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。\n\n#### Cmd \n`array of strings`\n容器启动时执行的命令参数列表（附加在`Entrypoint`之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出`Entrypoint`，那么`Cmd`列表的第一项将被认为是可执行的程序名。\n\n#### Healthcheck \n`struct`\n用以检查容器是否正常的测试命令，如下面的例子所示：\n```\n{\n  \"Test\": [\n      \"CMD-SHELL\",\n      \"/usr/bin/check-health localhost\"\n  ],\n  \"Interval\": 30000000000,\n  \"Timeout\":  10000000000,\n  \"Retries\":  3\n}\n```\n\n此结构有如下字段，\n\n##### Test \n`array of strings`\n用以检查容器是否正常的测试命令，可以是\n+ `[]` : 继承父镜像的健康检查命令；\n+ `[\"NONE\"]` : 禁用健康检查；\n+ `[\"CMD\", arg1, arg2, ...]` : 直接执行命令和参数；\n+ `[\"CMD-SHELL\", command]` : 使用系统默认shell执行命令；\n\n如果容器状态正常，测试命令退出后应返回 `0`，否则返回 `1`。\n+ Interval `integer`：相邻两次尝试的间隔，单位为纳秒；\n+ Timeout `integer`：认为异常的超时间隔，单位为纳秒；\n+ Retries `integer`：认为异常的重试次数。\n\n任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。\n\n##### Volumes \n`struct`\n创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"/var/my-app-data/\": {},\n    \"/etc/some-config.d/\": {},\n}\n```\n\n##### WorkingDir \n`string`\n容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。\n\n##### rootfs \n`struct`\nrootfs结构是镜像各层的`DiffID`列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:\n+ `type`，其值一般为 `layers`.\n+ `diff_ids` 各层散列（`DiffID`）的数组，顺序为从最底层到最顶层。\n\n下面是 rootfs 的一个例子：\n\n```\n\"rootfs\": {\n  \"diff_ids\": [\n    \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n    \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\",\n    \"sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49\"\n  ],\n  \"type\": \"layers\"\n}\n```\n\n### history \n`struct`\n`history`结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。\n+ `created`: 创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)；\n+ `author`: 创建的作者；\n+ `created_by`: 创建该层的命令；\n+ `comment`: 创建该层的注释；\n+ `empty_layer`: 标识此项历史记录是否会创建一个文件变更集。如果值为`true`，则此项历史不会对应一个实际的文件集（如`ENV`命令就对层的文件没有影响）。\n下面是 history 结构的一个例子：\n```\n\"history\": [\n  {\n    \"created\": \"2015-10-31T22:22:54.690851953Z\",\n    \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n  },\n  {\n    \"created\": \"2015-10-31T22:22:55.613815829Z\",\n    \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n    \"empty_layer\": true\n  }\n]\n```\n\n镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。\n\n## 创建镜像文件变更集\n创建镜像文件变更集的例子如下：\n首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名`c3167915dc9d`（层的DiffID是基于目录内的文件内容生成的）。\n\n然后在其中创建文件和目录:\n```\nc3167915dc9d/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n将目录`c3167915dc9d`提交为一个 `tar` 包（无压缩），其中包含如下的文件：\n\n```\netc/my-app-config\nbin/my-app-binary\nbin/my-app-tools\n```\n\n如果要在此基础上更改文件，则创建一个新的目录，假如为`f60c56784b83`，将其初始化为父镜像的快照，即与目录`c3167915dc9d`的内容相同。\n>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。\n\n```\nf60c56784b83/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n然后添加一个配置目录`/etc/my-app.d`，其中包含默认的配置文件。可执行程序`my-app-tools`也更新了，以便处理新的配置文件路径。\n修改后的目录`f60c56784b83`如下所示：\n```\nf60c56784b83/\n    etc/\n        my-app.d/\n            default.cfg\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n其中移除了`/etc/my-app-config`，然后创建了新的目录和文件`/etc/my-app.d/default.cfg`。`/bin/my-app-tools`也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照`f60c56784b83`比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：\n```\n增加：  /etc/my-app.d/default.cfg\n修改：  /bin/my-app-tools\n删除：  /etc/my-app-config\n```\n\n创建一个 **仅包含** 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加`.wh.`前缀（表示已删除）。\n> 注意：无法直接创建以名称`.wh.`开头的文件或目录。\n\n目录`f60c56784b83`生成的`tar` 包中有如下的文件：\n\n```\n/etc/my-app.d/default.cfg\n/bin/my-app-tools\n/etc/.wh.my-app-config\n```\n\n任何镜像都是由若干类似的文件变更集的tar包组成的。\n\n## 镜像的组合格式\n包含镜像完整内容的单一tar包格式如下：\n- 镜像名：tag\n- 镜像的 JSON 配置文件\n- 各层的tar包\n\n如镜像`library/busybox`的组合tar包内容如下（使用`tree`命令输出）：\n\n```\n.\n├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\n├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── manifest.json\n└── repositories\n```\n\n镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。\n> 注意：该目录名 **不必** 是层的`DiffID`或`ChainID`。\n\n每个目录包含3个文件：\n+ `VERSION` - `json`文件模式的版本号；\n+ `json` - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。\n+ `layer.tar` - 该层的tar包。\n\n注意：这个目录结构仅用于向后兼容。当前的实现使用`manifest.json`文件中列出的目录。\n\n`VERSION`文件只是JSON元数据模式的版本号：`1.0`。\n\n`repositories`也是一个JSON文件，包含镜像名和tag列表：\n```\n{  \n    \"busybox\":{  \n        \"latest\":\"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\"\n    }\n}\n```\n\n其中有镜像的`repository`和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用`manifest.json`文件。\n\n`manifest.json`文件是顶层镜像的JSON配置。\n该文件包含以下元数据：\n```\n[\n  {\n    \"Config\": \"47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\",\n    \"RepoTags\": [\"busybox:latest\"],\n    \"Layers\": [\n      \"a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar\",\n      \"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar\"\n    ]\n  }\n]\n```\n\n上面这个JSON数组中，每项都对应着一个镜像。\n+ `Config` 指向该镜像的JSON文件；\n+ `RepoTags` 是该镜像的名称；\n+ `Layers` 指向镜像各层的 tar 包；\n+ `Parent` 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 `manifest.json` 文件中存在。\n\n\n不要把 `manifest.json` 与用来push和pull镜像的分发清单（distribution manifest）相混淆。\n一般来说，支持v1.2版本镜像规范的实现将使用`manifest.json`文件，早期的实现仍使用 `*/json`和`repositories`文件。\n\n# TODO\n其它相关文档：\n+ [Open Containers Initiative Image Spec](https://github.com/opencontainers/image-spec)\n+ [Image Manifest Version 2, Schema 2](https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md)\n+ [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/master/docs/spec/api.md)\n+ [Supporting Container Images in Mesos Containerizer](https://github.com/apache/mesos/blob/master/docs/container-image.md)\n\n# 补充\n>注意：不要把上面的 **镜像格式** 与镜像的 **主机存储布局** 搞混了。\n+ 镜像格式是执行`docker save <镜像名或ID>`之后得到的对应镜像`tar`包的格式。\n+ 镜像在主机的存储布局，以及镜像push和pull都 **不会** 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。\n\n>镜像的各层存在顺序依赖，而镜像也有父子继承关系。\n最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。\n\n## alpine镜像的主机存储布局\nalpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。\n+ ./aufs是解开layer.tar后的文件内容；\n+ ./aufs/mnt是容器文件系统的挂载点；\n+ ./containers是创建的容器的读写层；\n+ ./image/aufs/distribution中两个文件夹相当于正反查找的指针；\n+ ./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；\n\n```\n# tree /var/lib/docker\n/var/lib/docker\n├── aufs\n│   ├── diff\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   │       ├── bin\n│   │       │   ├── ash -> /bin/busybox\n│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）\n│   ├── layers\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   └── mnt\n│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n├── containers\n├── image\n│   └── aufs\n│       ├── distribution\n│       │   ├── diffid-by-digest\n│       │   │   └── sha256\n│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299\n│       │   └── v2metadata-by-diffid\n│       │       └── sha256\n│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       ├── imagedb\n│       │   ├── content\n│       │   │   └── sha256\n│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9\n│       │   └── metadata\n│       │       └── sha256\n│       ├── layerdb\n│       │   ├── sha256\n│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       │   │       ├── cache-id \n│       │   │       ├── diff\n│       │   │       ├── size\n│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件\n│       │   └── tmp\n│       └── repositories.json\n├── network\n│   └── files\n│       └── local-kv.db\n├── plugins\n│   ├── storage\n│   │   └── blobs\n│   │       └── tmp\n│   └── tmp\n├── swarm\n├── tmp\n├── trust\n└── volumes\n    └── metadata.db\n\n```","source":"_posts/docker-image-spec-v1.2.md","raw":"title: 【译文】Docker镜像格式规范，v1.2\ncategory: [cloud]\ntags:\ndate: 2017-05-16\n---\n原文见 https://github.com/moby/moby/blob/master/image/spec/v1.2.md\nDocker已经迁移到Moby项目了。\n\n<!--more-->\n<!-- TOC -->\n\n    - [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n- [Docker镜像规范v1.2.0](#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120)\n    - [术语](#%E6%9C%AF%E8%AF%AD)\n        - [层（Layer）](#%E5%B1%82%EF%BC%88layer%EF%BC%89)\n        - [镜像的JSON描述文件](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6)\n        - [镜像文件变更集（changeset）](#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89)\n        - [层的DiffID](#%E5%B1%82%E7%9A%84diffid)\n        - [层的ChainID](#%E5%B1%82%E7%9A%84chainid)\n        - [镜像的ImageID](#%E9%95%9C%E5%83%8F%E7%9A%84imageid)\n        - [标签（Tag）](#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89)\n        - [镜像名（Repository）](#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89)\n    - [镜像的JSON描述文件示例](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B)\n    - [镜像的JSON描述文件说明](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E)\n        - [created](#created)\n        - [author](#author)\n        - [architecture](#architecture)\n        - [os](#os)\n        - [config](#config)\n            - [User](#user)\n            - [Memory](#memory)\n            - [MemorySwap](#memoryswap)\n            - [CpuShares](#cpushares)\n            - [ExposedPorts](#exposedports)\n            - [Env](#env)\n            - [Entrypoint](#entrypoint)\n            - [Cmd](#cmd)\n            - [Healthcheck](#healthcheck)\n                - [Test](#test)\n                - [Volumes](#volumes)\n                - [WorkingDir](#workingdir)\n                - [rootfs](#rootfs)\n        - [history](#history)\n    - [创建镜像文件变更集](#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86)\n    - [镜像的组合格式](#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F)\n- [TODO](#todo)\n- [补充](#%E8%A1%A5%E5%85%85)\n    - [alpine镜像的主机存储布局](#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80)\n\n<!-- /TOC -->\n\n# Docker镜像规范v1.2.0\n\n**镜像（Image）**是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。\n此版本的镜像规范自Docker 1.12开始采用。\n\n> 译注：本规范中的 **filesystem** 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 **文件集**。\n\n## 术语\n本规范使用以下术语:\n### 层（Layer）\n镜像由 **层** 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。\n\n### 镜像的JSON描述文件\n整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。\n该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。\n \n### 镜像文件变更集（changeset）\n每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。\n\n### 层的DiffID\n将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个`tar`包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用`tar-split`来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。\n\n>译注：关于层的打包和解包的可重复性，`tar`程序将一组文件打包的 **顺序** 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。\n参考：[tar打包的顺序](https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined)。\n\n### 层的ChainID\n为方便起见，可以给一串有序的层计算出一个ID，称为 **ChainID**。\n仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：\n\n$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ \" \\quad\" +DiffID(layerN))$$ \n\n### 镜像的ImageID\n每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。\n\n### 标签（Tag）\nTag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即`[a-zA-Z0-9_.-]`，首个字符不能是`.`或`-`。Tag不能超过127个字符。\n\n### 镜像名（Repository）\n这里的`Repository`是指镜像全名在冒号`:`之前的部分，冒号`:`之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为`my-app:3.1.4`的镜像，`my-app`就是镜像的 Repository 部分。\nRepository又可以用斜杠`/`分隔开，`/`之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 **不得** 包含下划线`_`字符，主机名可以有如`：8080`格式的端口号。\n镜像名可以包含小写字符，数字和分隔符。 分隔符是句点`.`，一个或两个下划线`_`，或一个或多个短横线`-`，镜像名 **不允许** 以分隔符开头或结尾。\n\n> 译注：\n+ 这里的 Repository 容易与git的 **代码仓库** 概念混淆。\n+ DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线`_`，参考[RFC 1123](https://tools.ietf.org/html/rfc1123)\n\n\n## 镜像的JSON描述文件示例\n下面是一个镜像的JSON描述文件示例：\n\n```\n{\n  \"architecture\": \"amd64\",\n  \"author\": \"Alyssa P. Hacker &ltalyspdev@example.com&gt\",\n  \"config\": {\n    \"Cmd\": [\n      \"--foreground\",\n      \"--config\",\n      \"/etc/my-app.d/default.cfg\"\n    ],\n    \"CpuShares\": 8,\n    \"Entrypoint\": [\n      \"/bin/my-app-binary\"\n    ],\n    \"Env\": [\n      \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n      \"FOO=docker_is_a_really\",\n      \"BAR=great_tool_you_know\"\n    ],\n    \"ExposedPorts\": {\n      \"8080/tcp\": {}\n    },\n    \"Memory\": 2048,\n    \"MemorySwap\": 4096,\n    \"User\": \"alice\",\n    \"Volumes\": {\n      \"/var/job-result-data\": {},\n      \"/var/log/my-app-logs\": {}\n    },\n    \"WorkingDir\": \"/home/alice\"\n  },\n  \"created\": \"2015-10-31T22:22:56.015925234Z\",\n  \"history\": [\n    {\n      \"created\": \"2015-10-31T22:22:54.690851953Z\",\n      \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n    },\n    {\n      \"created\": \"2015-10-31T22:22:55.613815829Z\",\n      \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n      \"empty_layer\": true\n    }\n  ],\n  \"os\": \"linux\",\n  \"rootfs\": {\n    \"diff_ids\": [\n      \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n      \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\"\n    ],\n    \"type\": \"layers\"\n  }\n}\n\n```\n\n注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。\n\n## 镜像的JSON描述文件说明\n\n### created\n`string`\n镜像创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)。\n\n### author\n`string`\n创建和负责维护改镜像的人员或组织名，或Email。\n### architecture\n`string`\n镜像中可执行文件的CPU架构，可以是 \n+ `386`\n+ `amd64`\n+ `arm`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。\n\n### os\n`string`\n镜像运行的操作系统名，可以是 \n+ `darwin`\n+ `freebsd`\n+ `linux`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。\n\n### config\n`struct`\n`config`结构是从镜像创建容器时，使用的基本执行参数。`config`可以是空值`null`，则创建容器时必须提供所有必要的执行参数。\n\n`config`结构的各字段说明\n#### User \n`string`\n容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：\n+ `user`\n+ `uid`\n+ `user:group`\n+ `uid:gid`\n+ `uid:group`\n+ `user:gid`\n\n如果没有给出组名 `group`/`gid`，默认的组使用容器中`/etc/passwd`文件对应的`user`/`uid`项。\n\n#### Memory \n`integer`\n内存限值（以 **字节** 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### MemorySwap \n`integer`\n总的内存使用量（内存 + swap），设置为`-1`则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### CpuShares \n`integer`\nCPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### ExposedPorts \n`struct`\n基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"8080\": {},\n    \"53/udp\": {},\n    \"2356/tcp\": {}\n}\n```\n其中的键可以是下面的格式：\n+ `\"port/tcp\"`\n+ `\"port/udp\"`\n+ `\"port\"`\n如果没有给出协议，默认使用`tcp`协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。\n\n#### Env \n`array of strings`\nEnv的每项都是 `VARNAME=\"var value\"` 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。\n\n#### Entrypoint \n`array of strings`\n容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。\n\n#### Cmd \n`array of strings`\n容器启动时执行的命令参数列表（附加在`Entrypoint`之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出`Entrypoint`，那么`Cmd`列表的第一项将被认为是可执行的程序名。\n\n#### Healthcheck \n`struct`\n用以检查容器是否正常的测试命令，如下面的例子所示：\n```\n{\n  \"Test\": [\n      \"CMD-SHELL\",\n      \"/usr/bin/check-health localhost\"\n  ],\n  \"Interval\": 30000000000,\n  \"Timeout\":  10000000000,\n  \"Retries\":  3\n}\n```\n\n此结构有如下字段，\n\n##### Test \n`array of strings`\n用以检查容器是否正常的测试命令，可以是\n+ `[]` : 继承父镜像的健康检查命令；\n+ `[\"NONE\"]` : 禁用健康检查；\n+ `[\"CMD\", arg1, arg2, ...]` : 直接执行命令和参数；\n+ `[\"CMD-SHELL\", command]` : 使用系统默认shell执行命令；\n\n如果容器状态正常，测试命令退出后应返回 `0`，否则返回 `1`。\n+ Interval `integer`：相邻两次尝试的间隔，单位为纳秒；\n+ Timeout `integer`：认为异常的超时间隔，单位为纳秒；\n+ Retries `integer`：认为异常的重试次数。\n\n任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。\n\n##### Volumes \n`struct`\n创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"/var/my-app-data/\": {},\n    \"/etc/some-config.d/\": {},\n}\n```\n\n##### WorkingDir \n`string`\n容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。\n\n##### rootfs \n`struct`\nrootfs结构是镜像各层的`DiffID`列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:\n+ `type`，其值一般为 `layers`.\n+ `diff_ids` 各层散列（`DiffID`）的数组，顺序为从最底层到最顶层。\n\n下面是 rootfs 的一个例子：\n\n```\n\"rootfs\": {\n  \"diff_ids\": [\n    \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n    \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\",\n    \"sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49\"\n  ],\n  \"type\": \"layers\"\n}\n```\n\n### history \n`struct`\n`history`结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。\n+ `created`: 创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)；\n+ `author`: 创建的作者；\n+ `created_by`: 创建该层的命令；\n+ `comment`: 创建该层的注释；\n+ `empty_layer`: 标识此项历史记录是否会创建一个文件变更集。如果值为`true`，则此项历史不会对应一个实际的文件集（如`ENV`命令就对层的文件没有影响）。\n下面是 history 结构的一个例子：\n```\n\"history\": [\n  {\n    \"created\": \"2015-10-31T22:22:54.690851953Z\",\n    \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n  },\n  {\n    \"created\": \"2015-10-31T22:22:55.613815829Z\",\n    \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n    \"empty_layer\": true\n  }\n]\n```\n\n镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。\n\n## 创建镜像文件变更集\n创建镜像文件变更集的例子如下：\n首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名`c3167915dc9d`（层的DiffID是基于目录内的文件内容生成的）。\n\n然后在其中创建文件和目录:\n```\nc3167915dc9d/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n将目录`c3167915dc9d`提交为一个 `tar` 包（无压缩），其中包含如下的文件：\n\n```\netc/my-app-config\nbin/my-app-binary\nbin/my-app-tools\n```\n\n如果要在此基础上更改文件，则创建一个新的目录，假如为`f60c56784b83`，将其初始化为父镜像的快照，即与目录`c3167915dc9d`的内容相同。\n>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。\n\n```\nf60c56784b83/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n然后添加一个配置目录`/etc/my-app.d`，其中包含默认的配置文件。可执行程序`my-app-tools`也更新了，以便处理新的配置文件路径。\n修改后的目录`f60c56784b83`如下所示：\n```\nf60c56784b83/\n    etc/\n        my-app.d/\n            default.cfg\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n其中移除了`/etc/my-app-config`，然后创建了新的目录和文件`/etc/my-app.d/default.cfg`。`/bin/my-app-tools`也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照`f60c56784b83`比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：\n```\n增加：  /etc/my-app.d/default.cfg\n修改：  /bin/my-app-tools\n删除：  /etc/my-app-config\n```\n\n创建一个 **仅包含** 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加`.wh.`前缀（表示已删除）。\n> 注意：无法直接创建以名称`.wh.`开头的文件或目录。\n\n目录`f60c56784b83`生成的`tar` 包中有如下的文件：\n\n```\n/etc/my-app.d/default.cfg\n/bin/my-app-tools\n/etc/.wh.my-app-config\n```\n\n任何镜像都是由若干类似的文件变更集的tar包组成的。\n\n## 镜像的组合格式\n包含镜像完整内容的单一tar包格式如下：\n- 镜像名：tag\n- 镜像的 JSON 配置文件\n- 各层的tar包\n\n如镜像`library/busybox`的组合tar包内容如下（使用`tree`命令输出）：\n\n```\n.\n├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\n├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── manifest.json\n└── repositories\n```\n\n镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。\n> 注意：该目录名 **不必** 是层的`DiffID`或`ChainID`。\n\n每个目录包含3个文件：\n+ `VERSION` - `json`文件模式的版本号；\n+ `json` - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。\n+ `layer.tar` - 该层的tar包。\n\n注意：这个目录结构仅用于向后兼容。当前的实现使用`manifest.json`文件中列出的目录。\n\n`VERSION`文件只是JSON元数据模式的版本号：`1.0`。\n\n`repositories`也是一个JSON文件，包含镜像名和tag列表：\n```\n{  \n    \"busybox\":{  \n        \"latest\":\"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\"\n    }\n}\n```\n\n其中有镜像的`repository`和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用`manifest.json`文件。\n\n`manifest.json`文件是顶层镜像的JSON配置。\n该文件包含以下元数据：\n```\n[\n  {\n    \"Config\": \"47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\",\n    \"RepoTags\": [\"busybox:latest\"],\n    \"Layers\": [\n      \"a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar\",\n      \"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar\"\n    ]\n  }\n]\n```\n\n上面这个JSON数组中，每项都对应着一个镜像。\n+ `Config` 指向该镜像的JSON文件；\n+ `RepoTags` 是该镜像的名称；\n+ `Layers` 指向镜像各层的 tar 包；\n+ `Parent` 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 `manifest.json` 文件中存在。\n\n\n不要把 `manifest.json` 与用来push和pull镜像的分发清单（distribution manifest）相混淆。\n一般来说，支持v1.2版本镜像规范的实现将使用`manifest.json`文件，早期的实现仍使用 `*/json`和`repositories`文件。\n\n# TODO\n其它相关文档：\n+ [Open Containers Initiative Image Spec](https://github.com/opencontainers/image-spec)\n+ [Image Manifest Version 2, Schema 2](https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md)\n+ [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/master/docs/spec/api.md)\n+ [Supporting Container Images in Mesos Containerizer](https://github.com/apache/mesos/blob/master/docs/container-image.md)\n\n# 补充\n>注意：不要把上面的 **镜像格式** 与镜像的 **主机存储布局** 搞混了。\n+ 镜像格式是执行`docker save <镜像名或ID>`之后得到的对应镜像`tar`包的格式。\n+ 镜像在主机的存储布局，以及镜像push和pull都 **不会** 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。\n\n>镜像的各层存在顺序依赖，而镜像也有父子继承关系。\n最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。\n\n## alpine镜像的主机存储布局\nalpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。\n+ ./aufs是解开layer.tar后的文件内容；\n+ ./aufs/mnt是容器文件系统的挂载点；\n+ ./containers是创建的容器的读写层；\n+ ./image/aufs/distribution中两个文件夹相当于正反查找的指针；\n+ ./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；\n\n```\n# tree /var/lib/docker\n/var/lib/docker\n├── aufs\n│   ├── diff\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   │       ├── bin\n│   │       │   ├── ash -> /bin/busybox\n│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）\n│   ├── layers\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   └── mnt\n│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n├── containers\n├── image\n│   └── aufs\n│       ├── distribution\n│       │   ├── diffid-by-digest\n│       │   │   └── sha256\n│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299\n│       │   └── v2metadata-by-diffid\n│       │       └── sha256\n│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       ├── imagedb\n│       │   ├── content\n│       │   │   └── sha256\n│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9\n│       │   └── metadata\n│       │       └── sha256\n│       ├── layerdb\n│       │   ├── sha256\n│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       │   │       ├── cache-id \n│       │   │       ├── diff\n│       │   │       ├── size\n│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件\n│       │   └── tmp\n│       └── repositories.json\n├── network\n│   └── files\n│       └── local-kv.db\n├── plugins\n│   ├── storage\n│   │   └── blobs\n│   │       └── tmp\n│   └── tmp\n├── swarm\n├── tmp\n├── trust\n└── volumes\n    └── metadata.db\n\n```","slug":"docker-image-spec-v1.2","published":1,"updated":"2017-10-30T03:41:07.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9dnel0c0000s04fyl499ly8","content":"<p>原文见 <a href=\"https://github.com/moby/moby/blob/master/image/spec/v1.2.md\" target=\"_blank\" rel=\"external\">https://github.com/moby/moby/blob/master/image/spec/v1.2.md</a><br>Docker已经迁移到Moby项目了。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<pre><code>- [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n</code></pre><ul>\n<li><a href=\"#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120\">Docker镜像规范v1.2.0</a><ul>\n<li><a href=\"#%E6%9C%AF%E8%AF%AD\">术语</a><ul>\n<li><a href=\"#%E5%B1%82%EF%BC%88layer%EF%BC%89\">层（Layer）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6\">镜像的JSON描述文件</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89\">镜像文件变更集（changeset）</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84diffid\">层的DiffID</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84chainid\">层的ChainID</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84imageid\">镜像的ImageID</a></li>\n<li><a href=\"#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89\">标签（Tag）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89\">镜像名（Repository）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B\">镜像的JSON描述文件示例</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E\">镜像的JSON描述文件说明</a><ul>\n<li><a href=\"#created\">created</a></li>\n<li><a href=\"#author\">author</a></li>\n<li><a href=\"#architecture\">architecture</a></li>\n<li><a href=\"#os\">os</a></li>\n<li><a href=\"#config\">config</a><ul>\n<li><a href=\"#user\">User</a></li>\n<li><a href=\"#memory\">Memory</a></li>\n<li><a href=\"#memoryswap\">MemorySwap</a></li>\n<li><a href=\"#cpushares\">CpuShares</a></li>\n<li><a href=\"#exposedports\">ExposedPorts</a></li>\n<li><a href=\"#env\">Env</a></li>\n<li><a href=\"#entrypoint\">Entrypoint</a></li>\n<li><a href=\"#cmd\">Cmd</a></li>\n<li><a href=\"#healthcheck\">Healthcheck</a><ul>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#volumes\">Volumes</a></li>\n<li><a href=\"#workingdir\">WorkingDir</a></li>\n<li><a href=\"#rootfs\">rootfs</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#history\">history</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86\">创建镜像文件变更集</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F\">镜像的组合格式</a></li>\n</ul>\n</li>\n<li><a href=\"#todo\">TODO</a></li>\n<li><a href=\"#%E8%A1%A5%E5%85%85\">补充</a><ul>\n<li><a href=\"#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80\">alpine镜像的主机存储布局</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"Docker镜像规范v1-2-0\"><a href=\"#Docker镜像规范v1-2-0\" class=\"headerlink\" title=\"Docker镜像规范v1.2.0\"></a>Docker镜像规范v1.2.0</h1><p><strong>镜像（Image）</strong>是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。<br>此版本的镜像规范自Docker 1.12开始采用。</p>\n<blockquote>\n<p>译注：本规范中的 <strong>filesystem</strong> 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 <strong>文件集</strong>。</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>本规范使用以下术语:</p>\n<h3 id=\"层（Layer）\"><a href=\"#层（Layer）\" class=\"headerlink\" title=\"层（Layer）\"></a>层（Layer）</h3><p>镜像由 <strong>层</strong> 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。</p>\n<h3 id=\"镜像的JSON描述文件\"><a href=\"#镜像的JSON描述文件\" class=\"headerlink\" title=\"镜像的JSON描述文件\"></a>镜像的JSON描述文件</h3><p>整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。<br>该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。</p>\n<h3 id=\"镜像文件变更集（changeset）\"><a href=\"#镜像文件变更集（changeset）\" class=\"headerlink\" title=\"镜像文件变更集（changeset）\"></a>镜像文件变更集（changeset）</h3><p>每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。</p>\n<h3 id=\"层的DiffID\"><a href=\"#层的DiffID\" class=\"headerlink\" title=\"层的DiffID\"></a>层的DiffID</h3><p>将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个<code>tar</code>包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用<code>tar-split</code>来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。</p>\n<blockquote>\n<p>译注：关于层的打包和解包的可重复性，<code>tar</code>程序将一组文件打包的 <strong>顺序</strong> 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。<br>参考：<a href=\"https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined\" target=\"_blank\" rel=\"external\">tar打包的顺序</a>。</p>\n</blockquote>\n<h3 id=\"层的ChainID\"><a href=\"#层的ChainID\" class=\"headerlink\" title=\"层的ChainID\"></a>层的ChainID</h3><p>为方便起见，可以给一串有序的层计算出一个ID，称为 <strong>ChainID</strong>。<br>仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：</p>\n<p>$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ “ \\quad” +DiffID(layerN))$$ </p>\n<h3 id=\"镜像的ImageID\"><a href=\"#镜像的ImageID\" class=\"headerlink\" title=\"镜像的ImageID\"></a>镜像的ImageID</h3><p>每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。</p>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>Tag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即<code>[a-zA-Z0-9_.-]</code>，首个字符不能是<code>.</code>或<code>-</code>。Tag不能超过127个字符。</p>\n<h3 id=\"镜像名（Repository）\"><a href=\"#镜像名（Repository）\" class=\"headerlink\" title=\"镜像名（Repository）\"></a>镜像名（Repository）</h3><p>这里的<code>Repository</code>是指镜像全名在冒号<code>:</code>之前的部分，冒号<code>:</code>之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为<code>my-app:3.1.4</code>的镜像，<code>my-app</code>就是镜像的 Repository 部分。<br>Repository又可以用斜杠<code>/</code>分隔开，<code>/</code>之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 <strong>不得</strong> 包含下划线<code>_</code>字符，主机名可以有如<code>：8080</code>格式的端口号。<br>镜像名可以包含小写字符，数字和分隔符。 分隔符是句点<code>.</code>，一个或两个下划线<code>_</code>，或一个或多个短横线<code>-</code>，镜像名 <strong>不允许</strong> 以分隔符开头或结尾。</p>\n<blockquote>\n<p>译注：</p>\n<ul>\n<li>这里的 Repository 容易与git的 <strong>代码仓库</strong> 概念混淆。</li>\n<li>DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线<code>_</code>，参考<a href=\"https://tools.ietf.org/html/rfc1123\" target=\"_blank\" rel=\"external\">RFC 1123</a></li>\n</ul>\n</blockquote>\n<h2 id=\"镜像的JSON描述文件示例\"><a href=\"#镜像的JSON描述文件示例\" class=\"headerlink\" title=\"镜像的JSON描述文件示例\"></a>镜像的JSON描述文件示例</h2><p>下面是一个镜像的JSON描述文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;architecture&quot;: &quot;amd64&quot;,</div><div class=\"line\">  &quot;author&quot;: &quot;Alyssa P. Hacker &amp;ltalyspdev@example.com&amp;gt&quot;,</div><div class=\"line\">  &quot;config&quot;: &#123;</div><div class=\"line\">    &quot;Cmd&quot;: [</div><div class=\"line\">      &quot;--foreground&quot;,</div><div class=\"line\">      &quot;--config&quot;,</div><div class=\"line\">      &quot;/etc/my-app.d/default.cfg&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;CpuShares&quot;: 8,</div><div class=\"line\">    &quot;Entrypoint&quot;: [</div><div class=\"line\">      &quot;/bin/my-app-binary&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;Env&quot;: [</div><div class=\"line\">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</div><div class=\"line\">      &quot;FOO=docker_is_a_really&quot;,</div><div class=\"line\">      &quot;BAR=great_tool_you_know&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;ExposedPorts&quot;: &#123;</div><div class=\"line\">      &quot;8080/tcp&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;Memory&quot;: 2048,</div><div class=\"line\">    &quot;MemorySwap&quot;: 4096,</div><div class=\"line\">    &quot;User&quot;: &quot;alice&quot;,</div><div class=\"line\">    &quot;Volumes&quot;: &#123;</div><div class=\"line\">      &quot;/var/job-result-data&quot;: &#123;&#125;,</div><div class=\"line\">      &quot;/var/log/my-app-logs&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;WorkingDir&quot;: &quot;/home/alice&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;created&quot;: &quot;2015-10-31T22:22:56.015925234Z&quot;,</div><div class=\"line\">  &quot;history&quot;: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">      &quot;empty_layer&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;os&quot;: &quot;linux&quot;,</div><div class=\"line\">  &quot;rootfs&quot;: &#123;</div><div class=\"line\">    &quot;diff_ids&quot;: [</div><div class=\"line\">      &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">      &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。</p>\n<h2 id=\"镜像的JSON描述文件说明\"><a href=\"#镜像的JSON描述文件说明\" class=\"headerlink\" title=\"镜像的JSON描述文件说明\"></a>镜像的JSON描述文件说明</h2><h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p><code>string</code><br>镜像创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>。</p>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><p><code>string</code><br>创建和负责维护改镜像的人员或组织名，或Email。</p>\n<h3 id=\"architecture\"><a href=\"#architecture\" class=\"headerlink\" title=\"architecture\"></a>architecture</h3><p><code>string</code><br>镜像中可执行文件的CPU架构，可以是 </p>\n<ul>\n<li><code>386</code></li>\n<li><code>amd64</code></li>\n<li><code>arm</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。</li>\n</ul>\n<h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><p><code>string</code><br>镜像运行的操作系统名，可以是 </p>\n<ul>\n<li><code>darwin</code></li>\n<li><code>freebsd</code></li>\n<li><code>linux</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。</li>\n</ul>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p><code>struct</code><br><code>config</code>结构是从镜像创建容器时，使用的基本执行参数。<code>config</code>可以是空值<code>null</code>，则创建容器时必须提供所有必要的执行参数。</p>\n<p><code>config</code>结构的各字段说明</p>\n<h4 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h4><p><code>string</code><br>容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：</p>\n<ul>\n<li><code>user</code></li>\n<li><code>uid</code></li>\n<li><code>user:group</code></li>\n<li><code>uid:gid</code></li>\n<li><code>uid:group</code></li>\n<li><code>user:gid</code></li>\n</ul>\n<p>如果没有给出组名 <code>group</code>/<code>gid</code>，默认的组使用容器中<code>/etc/passwd</code>文件对应的<code>user</code>/<code>uid</code>项。</p>\n<h4 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h4><p><code>integer</code><br>内存限值（以 <strong>字节</strong> 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"MemorySwap\"><a href=\"#MemorySwap\" class=\"headerlink\" title=\"MemorySwap\"></a>MemorySwap</h4><p><code>integer</code><br>总的内存使用量（内存 + swap），设置为<code>-1</code>则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"CpuShares\"><a href=\"#CpuShares\" class=\"headerlink\" title=\"CpuShares\"></a>CpuShares</h4><p><code>integer</code><br>CPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"ExposedPorts\"><a href=\"#ExposedPorts\" class=\"headerlink\" title=\"ExposedPorts\"></a>ExposedPorts</h4><p><code>struct</code><br>基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;8080&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;53/udp&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;2356/tcp&quot;: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的键可以是下面的格式：</p>\n<ul>\n<li><code>&quot;port/tcp&quot;</code></li>\n<li><code>&quot;port/udp&quot;</code></li>\n<li><code>&quot;port&quot;</code><br>如果没有给出协议，默认使用<code>tcp</code>协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。</li>\n</ul>\n<h4 id=\"Env\"><a href=\"#Env\" class=\"headerlink\" title=\"Env\"></a>Env</h4><p><code>array of strings</code><br>Env的每项都是 <code>VARNAME=&quot;var value&quot;</code> 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。</p>\n<h4 id=\"Entrypoint\"><a href=\"#Entrypoint\" class=\"headerlink\" title=\"Entrypoint\"></a>Entrypoint</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。</p>\n<h4 id=\"Cmd\"><a href=\"#Cmd\" class=\"headerlink\" title=\"Cmd\"></a>Cmd</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表（附加在<code>Entrypoint</code>之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出<code>Entrypoint</code>，那么<code>Cmd</code>列表的第一项将被认为是可执行的程序名。</p>\n<h4 id=\"Healthcheck\"><a href=\"#Healthcheck\" class=\"headerlink\" title=\"Healthcheck\"></a>Healthcheck</h4><p><code>struct</code><br>用以检查容器是否正常的测试命令，如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;Test&quot;: [</div><div class=\"line\">      &quot;CMD-SHELL&quot;,</div><div class=\"line\">      &quot;/usr/bin/check-health localhost&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;Interval&quot;: 30000000000,</div><div class=\"line\">  &quot;Timeout&quot;:  10000000000,</div><div class=\"line\">  &quot;Retries&quot;:  3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此结构有如下字段，</p>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h5><p><code>array of strings</code><br>用以检查容器是否正常的测试命令，可以是</p>\n<ul>\n<li><code>[]</code> : 继承父镜像的健康检查命令；</li>\n<li><code>[&quot;NONE&quot;]</code> : 禁用健康检查；</li>\n<li><code>[&quot;CMD&quot;, arg1, arg2, ...]</code> : 直接执行命令和参数；</li>\n<li><code>[&quot;CMD-SHELL&quot;, command]</code> : 使用系统默认shell执行命令；</li>\n</ul>\n<p>如果容器状态正常，测试命令退出后应返回 <code>0</code>，否则返回 <code>1</code>。</p>\n<ul>\n<li>Interval <code>integer</code>：相邻两次尝试的间隔，单位为纳秒；</li>\n<li>Timeout <code>integer</code>：认为异常的超时间隔，单位为纳秒；</li>\n<li>Retries <code>integer</code>：认为异常的重试次数。</li>\n</ul>\n<p>任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。</p>\n<h5 id=\"Volumes\"><a href=\"#Volumes\" class=\"headerlink\" title=\"Volumes\"></a>Volumes</h5><p><code>struct</code><br>创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;/var/my-app-data/&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;/etc/some-config.d/&quot;: &#123;&#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"WorkingDir\"><a href=\"#WorkingDir\" class=\"headerlink\" title=\"WorkingDir\"></a>WorkingDir</h5><p><code>string</code><br>容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。</p>\n<h5 id=\"rootfs\"><a href=\"#rootfs\" class=\"headerlink\" title=\"rootfs\"></a>rootfs</h5><p><code>struct</code><br>rootfs结构是镜像各层的<code>DiffID</code>列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:</p>\n<ul>\n<li><code>type</code>，其值一般为 <code>layers</code>.</li>\n<li><code>diff_ids</code> 各层散列（<code>DiffID</code>）的数组，顺序为从最底层到最顶层。</li>\n</ul>\n<p>下面是 rootfs 的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;rootfs&quot;: &#123;</div><div class=\"line\">  &quot;diff_ids&quot;: [</div><div class=\"line\">    &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">    &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</div><div class=\"line\">    &quot;sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>struct</code><br><code>history</code>结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。</p>\n<ul>\n<li><code>created</code>: 创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>；</li>\n<li><code>author</code>: 创建的作者；</li>\n<li><code>created_by</code>: 创建该层的命令；</li>\n<li><code>comment</code>: 创建该层的注释；</li>\n<li><code>empty_layer</code>: 标识此项历史记录是否会创建一个文件变更集。如果值为<code>true</code>，则此项历史不会对应一个实际的文件集（如<code>ENV</code>命令就对层的文件没有影响）。<br>下面是 history 结构的一个例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;history&quot;: [</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">    &quot;empty_layer&quot;: true</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。</p>\n<h2 id=\"创建镜像文件变更集\"><a href=\"#创建镜像文件变更集\" class=\"headerlink\" title=\"创建镜像文件变更集\"></a>创建镜像文件变更集</h2><p>创建镜像文件变更集的例子如下：<br>首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名<code>c3167915dc9d</code>（层的DiffID是基于目录内的文件内容生成的）。</p>\n<p>然后在其中创建文件和目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">c3167915dc9d/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>将目录<code>c3167915dc9d</code>提交为一个 <code>tar</code> 包（无压缩），其中包含如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">etc/my-app-config</div><div class=\"line\">bin/my-app-binary</div><div class=\"line\">bin/my-app-tools</div></pre></td></tr></table></figure>\n<p>如果要在此基础上更改文件，则创建一个新的目录，假如为<code>f60c56784b83</code>，将其初始化为父镜像的快照，即与目录<code>c3167915dc9d</code>的内容相同。</p>\n<blockquote>\n<p>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure>\n<p>然后添加一个配置目录<code>/etc/my-app.d</code>，其中包含默认的配置文件。可执行程序<code>my-app-tools</code>也更新了，以便处理新的配置文件路径。<br>修改后的目录<code>f60c56784b83</code>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app.d/</div><div class=\"line\">            default.cfg</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>其中移除了<code>/etc/my-app-config</code>，然后创建了新的目录和文件<code>/etc/my-app.d/default.cfg</code>。<code>/bin/my-app-tools</code>也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照<code>f60c56784b83</code>比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加：  /etc/my-app.d/default.cfg</div><div class=\"line\">修改：  /bin/my-app-tools</div><div class=\"line\">删除：  /etc/my-app-config</div></pre></td></tr></table></figure></p>\n<p>创建一个 <strong>仅包含</strong> 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加<code>.wh.</code>前缀（表示已删除）。</p>\n<blockquote>\n<p>注意：无法直接创建以名称<code>.wh.</code>开头的文件或目录。</p>\n</blockquote>\n<p>目录<code>f60c56784b83</code>生成的<code>tar</code> 包中有如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my-app.d/default.cfg</div><div class=\"line\">/bin/my-app-tools</div><div class=\"line\">/etc/.wh.my-app-config</div></pre></td></tr></table></figure>\n<p>任何镜像都是由若干类似的文件变更集的tar包组成的。</p>\n<h2 id=\"镜像的组合格式\"><a href=\"#镜像的组合格式\" class=\"headerlink\" title=\"镜像的组合格式\"></a>镜像的组合格式</h2><p>包含镜像完整内容的单一tar包格式如下：</p>\n<ul>\n<li>镜像名：tag</li>\n<li>镜像的 JSON 配置文件</li>\n<li>各层的tar包</li>\n</ul>\n<p>如镜像<code>library/busybox</code>的组合tar包内容如下（使用<code>tree</code>命令输出）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json</div><div class=\"line\">├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── manifest.json</div><div class=\"line\">└── repositories</div></pre></td></tr></table></figure>\n<p>镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。</p>\n<blockquote>\n<p>注意：该目录名 <strong>不必</strong> 是层的<code>DiffID</code>或<code>ChainID</code>。</p>\n</blockquote>\n<p>每个目录包含3个文件：</p>\n<ul>\n<li><code>VERSION</code> - <code>json</code>文件模式的版本号；</li>\n<li><code>json</code> - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。</li>\n<li><code>layer.tar</code> - 该层的tar包。</li>\n</ul>\n<p>注意：这个目录结构仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件中列出的目录。</p>\n<p><code>VERSION</code>文件只是JSON元数据模式的版本号：<code>1.0</code>。</p>\n<p><code>repositories</code>也是一个JSON文件，包含镜像名和tag列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  </div><div class=\"line\">    &quot;busybox&quot;:&#123;  </div><div class=\"line\">        &quot;latest&quot;:&quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有镜像的<code>repository</code>和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件。</p>\n<p><code>manifest.json</code>文件是顶层镜像的JSON配置。<br>该文件包含以下元数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;Config&quot;: &quot;47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json&quot;,</div><div class=\"line\">    &quot;RepoTags&quot;: [&quot;busybox:latest&quot;],</div><div class=\"line\">    &quot;Layers&quot;: [</div><div class=\"line\">      &quot;a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar&quot;,</div><div class=\"line\">      &quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar&quot;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>上面这个JSON数组中，每项都对应着一个镜像。</p>\n<ul>\n<li><code>Config</code> 指向该镜像的JSON文件；</li>\n<li><code>RepoTags</code> 是该镜像的名称；</li>\n<li><code>Layers</code> 指向镜像各层的 tar 包；</li>\n<li><code>Parent</code> 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 <code>manifest.json</code> 文件中存在。</li>\n</ul>\n<p>不要把 <code>manifest.json</code> 与用来push和pull镜像的分发清单（distribution manifest）相混淆。<br>一般来说，支持v1.2版本镜像规范的实现将使用<code>manifest.json</code>文件，早期的实现仍使用 <code>*/json</code>和<code>repositories</code>文件。</p>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><p>其它相关文档：</p>\n<ul>\n<li><a href=\"https://github.com/opencontainers/image-spec\" target=\"_blank\" rel=\"external\">Open Containers Initiative Image Spec</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md\" target=\"_blank\" rel=\"external\">Image Manifest Version 2, Schema 2</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/api.md\" target=\"_blank\" rel=\"external\">Docker Registry HTTP API V2</a></li>\n<li><a href=\"https://github.com/apache/mesos/blob/master/docs/container-image.md\" target=\"_blank\" rel=\"external\">Supporting Container Images in Mesos Containerizer</a></li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<p>注意：不要把上面的 <strong>镜像格式</strong> 与镜像的 <strong>主机存储布局</strong> 搞混了。</p>\n<ul>\n<li>镜像格式是执行<code>docker save &lt;镜像名或ID&gt;</code>之后得到的对应镜像<code>tar</code>包的格式。</li>\n<li>镜像在主机的存储布局，以及镜像push和pull都 <strong>不会</strong> 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。</li>\n</ul>\n<p>镜像的各层存在顺序依赖，而镜像也有父子继承关系。<br>最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。</p>\n</blockquote>\n<h2 id=\"alpine镜像的主机存储布局\"><a href=\"#alpine镜像的主机存储布局\" class=\"headerlink\" title=\"alpine镜像的主机存储布局\"></a>alpine镜像的主机存储布局</h2><p>alpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。</p>\n<ul>\n<li>./aufs是解开layer.tar后的文件内容；</li>\n<li>./aufs/mnt是容器文件系统的挂载点；</li>\n<li>./containers是创建的容器的读写层；</li>\n<li>./image/aufs/distribution中两个文件夹相当于正反查找的指针；</li>\n<li>./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"># tree /var/lib/docker</div><div class=\"line\">/var/lib/docker</div><div class=\"line\">├── aufs</div><div class=\"line\">│   ├── diff</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   │       ├── bin</div><div class=\"line\">│   │       │   ├── ash -&gt; /bin/busybox</div><div class=\"line\">│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）</div><div class=\"line\">│   ├── layers</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   └── mnt</div><div class=\"line\">│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">├── containers</div><div class=\"line\">├── image</div><div class=\"line\">│   └── aufs</div><div class=\"line\">│       ├── distribution</div><div class=\"line\">│       │   ├── diffid-by-digest</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299</div><div class=\"line\">│       │   └── v2metadata-by-diffid</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       ├── imagedb</div><div class=\"line\">│       │   ├── content</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9</div><div class=\"line\">│       │   └── metadata</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       ├── layerdb</div><div class=\"line\">│       │   ├── sha256</div><div class=\"line\">│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       │   │       ├── cache-id </div><div class=\"line\">│       │   │       ├── diff</div><div class=\"line\">│       │   │       ├── size</div><div class=\"line\">│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件</div><div class=\"line\">│       │   └── tmp</div><div class=\"line\">│       └── repositories.json</div><div class=\"line\">├── network</div><div class=\"line\">│   └── files</div><div class=\"line\">│       └── local-kv.db</div><div class=\"line\">├── plugins</div><div class=\"line\">│   ├── storage</div><div class=\"line\">│   │   └── blobs</div><div class=\"line\">│   │       └── tmp</div><div class=\"line\">│   └── tmp</div><div class=\"line\">├── swarm</div><div class=\"line\">├── tmp</div><div class=\"line\">├── trust</div><div class=\"line\">└── volumes</div><div class=\"line\">    └── metadata.db</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>原文见 <a href=\"https://github.com/moby/moby/blob/master/image/spec/v1.2.md\" target=\"_blank\" rel=\"external\">https://github.com/moby/moby/blob/master/image/spec/v1.2.md</a><br>Docker已经迁移到Moby项目了。</p>","more":"<!-- TOC -->\n<pre><code>- [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n</code></pre><ul>\n<li><a href=\"#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120\">Docker镜像规范v1.2.0</a><ul>\n<li><a href=\"#%E6%9C%AF%E8%AF%AD\">术语</a><ul>\n<li><a href=\"#%E5%B1%82%EF%BC%88layer%EF%BC%89\">层（Layer）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6\">镜像的JSON描述文件</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89\">镜像文件变更集（changeset）</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84diffid\">层的DiffID</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84chainid\">层的ChainID</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84imageid\">镜像的ImageID</a></li>\n<li><a href=\"#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89\">标签（Tag）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89\">镜像名（Repository）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B\">镜像的JSON描述文件示例</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E\">镜像的JSON描述文件说明</a><ul>\n<li><a href=\"#created\">created</a></li>\n<li><a href=\"#author\">author</a></li>\n<li><a href=\"#architecture\">architecture</a></li>\n<li><a href=\"#os\">os</a></li>\n<li><a href=\"#config\">config</a><ul>\n<li><a href=\"#user\">User</a></li>\n<li><a href=\"#memory\">Memory</a></li>\n<li><a href=\"#memoryswap\">MemorySwap</a></li>\n<li><a href=\"#cpushares\">CpuShares</a></li>\n<li><a href=\"#exposedports\">ExposedPorts</a></li>\n<li><a href=\"#env\">Env</a></li>\n<li><a href=\"#entrypoint\">Entrypoint</a></li>\n<li><a href=\"#cmd\">Cmd</a></li>\n<li><a href=\"#healthcheck\">Healthcheck</a><ul>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#volumes\">Volumes</a></li>\n<li><a href=\"#workingdir\">WorkingDir</a></li>\n<li><a href=\"#rootfs\">rootfs</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#history\">history</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86\">创建镜像文件变更集</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F\">镜像的组合格式</a></li>\n</ul>\n</li>\n<li><a href=\"#todo\">TODO</a></li>\n<li><a href=\"#%E8%A1%A5%E5%85%85\">补充</a><ul>\n<li><a href=\"#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80\">alpine镜像的主机存储布局</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"Docker镜像规范v1-2-0\"><a href=\"#Docker镜像规范v1-2-0\" class=\"headerlink\" title=\"Docker镜像规范v1.2.0\"></a>Docker镜像规范v1.2.0</h1><p><strong>镜像（Image）</strong>是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。<br>此版本的镜像规范自Docker 1.12开始采用。</p>\n<blockquote>\n<p>译注：本规范中的 <strong>filesystem</strong> 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 <strong>文件集</strong>。</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>本规范使用以下术语:</p>\n<h3 id=\"层（Layer）\"><a href=\"#层（Layer）\" class=\"headerlink\" title=\"层（Layer）\"></a>层（Layer）</h3><p>镜像由 <strong>层</strong> 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。</p>\n<h3 id=\"镜像的JSON描述文件\"><a href=\"#镜像的JSON描述文件\" class=\"headerlink\" title=\"镜像的JSON描述文件\"></a>镜像的JSON描述文件</h3><p>整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。<br>该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。</p>\n<h3 id=\"镜像文件变更集（changeset）\"><a href=\"#镜像文件变更集（changeset）\" class=\"headerlink\" title=\"镜像文件变更集（changeset）\"></a>镜像文件变更集（changeset）</h3><p>每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。</p>\n<h3 id=\"层的DiffID\"><a href=\"#层的DiffID\" class=\"headerlink\" title=\"层的DiffID\"></a>层的DiffID</h3><p>将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个<code>tar</code>包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用<code>tar-split</code>来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。</p>\n<blockquote>\n<p>译注：关于层的打包和解包的可重复性，<code>tar</code>程序将一组文件打包的 <strong>顺序</strong> 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。<br>参考：<a href=\"https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined\" target=\"_blank\" rel=\"external\">tar打包的顺序</a>。</p>\n</blockquote>\n<h3 id=\"层的ChainID\"><a href=\"#层的ChainID\" class=\"headerlink\" title=\"层的ChainID\"></a>层的ChainID</h3><p>为方便起见，可以给一串有序的层计算出一个ID，称为 <strong>ChainID</strong>。<br>仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：</p>\n<p>$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ “ \\quad” +DiffID(layerN))$$ </p>\n<h3 id=\"镜像的ImageID\"><a href=\"#镜像的ImageID\" class=\"headerlink\" title=\"镜像的ImageID\"></a>镜像的ImageID</h3><p>每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。</p>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>Tag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即<code>[a-zA-Z0-9_.-]</code>，首个字符不能是<code>.</code>或<code>-</code>。Tag不能超过127个字符。</p>\n<h3 id=\"镜像名（Repository）\"><a href=\"#镜像名（Repository）\" class=\"headerlink\" title=\"镜像名（Repository）\"></a>镜像名（Repository）</h3><p>这里的<code>Repository</code>是指镜像全名在冒号<code>:</code>之前的部分，冒号<code>:</code>之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为<code>my-app:3.1.4</code>的镜像，<code>my-app</code>就是镜像的 Repository 部分。<br>Repository又可以用斜杠<code>/</code>分隔开，<code>/</code>之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 <strong>不得</strong> 包含下划线<code>_</code>字符，主机名可以有如<code>：8080</code>格式的端口号。<br>镜像名可以包含小写字符，数字和分隔符。 分隔符是句点<code>.</code>，一个或两个下划线<code>_</code>，或一个或多个短横线<code>-</code>，镜像名 <strong>不允许</strong> 以分隔符开头或结尾。</p>\n<blockquote>\n<p>译注：</p>\n<ul>\n<li>这里的 Repository 容易与git的 <strong>代码仓库</strong> 概念混淆。</li>\n<li>DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线<code>_</code>，参考<a href=\"https://tools.ietf.org/html/rfc1123\" target=\"_blank\" rel=\"external\">RFC 1123</a></li>\n</ul>\n</blockquote>\n<h2 id=\"镜像的JSON描述文件示例\"><a href=\"#镜像的JSON描述文件示例\" class=\"headerlink\" title=\"镜像的JSON描述文件示例\"></a>镜像的JSON描述文件示例</h2><p>下面是一个镜像的JSON描述文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;architecture&quot;: &quot;amd64&quot;,</div><div class=\"line\">  &quot;author&quot;: &quot;Alyssa P. Hacker &amp;ltalyspdev@example.com&amp;gt&quot;,</div><div class=\"line\">  &quot;config&quot;: &#123;</div><div class=\"line\">    &quot;Cmd&quot;: [</div><div class=\"line\">      &quot;--foreground&quot;,</div><div class=\"line\">      &quot;--config&quot;,</div><div class=\"line\">      &quot;/etc/my-app.d/default.cfg&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;CpuShares&quot;: 8,</div><div class=\"line\">    &quot;Entrypoint&quot;: [</div><div class=\"line\">      &quot;/bin/my-app-binary&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;Env&quot;: [</div><div class=\"line\">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</div><div class=\"line\">      &quot;FOO=docker_is_a_really&quot;,</div><div class=\"line\">      &quot;BAR=great_tool_you_know&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;ExposedPorts&quot;: &#123;</div><div class=\"line\">      &quot;8080/tcp&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;Memory&quot;: 2048,</div><div class=\"line\">    &quot;MemorySwap&quot;: 4096,</div><div class=\"line\">    &quot;User&quot;: &quot;alice&quot;,</div><div class=\"line\">    &quot;Volumes&quot;: &#123;</div><div class=\"line\">      &quot;/var/job-result-data&quot;: &#123;&#125;,</div><div class=\"line\">      &quot;/var/log/my-app-logs&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;WorkingDir&quot;: &quot;/home/alice&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;created&quot;: &quot;2015-10-31T22:22:56.015925234Z&quot;,</div><div class=\"line\">  &quot;history&quot;: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">      &quot;empty_layer&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;os&quot;: &quot;linux&quot;,</div><div class=\"line\">  &quot;rootfs&quot;: &#123;</div><div class=\"line\">    &quot;diff_ids&quot;: [</div><div class=\"line\">      &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">      &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。</p>\n<h2 id=\"镜像的JSON描述文件说明\"><a href=\"#镜像的JSON描述文件说明\" class=\"headerlink\" title=\"镜像的JSON描述文件说明\"></a>镜像的JSON描述文件说明</h2><h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p><code>string</code><br>镜像创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>。</p>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><p><code>string</code><br>创建和负责维护改镜像的人员或组织名，或Email。</p>\n<h3 id=\"architecture\"><a href=\"#architecture\" class=\"headerlink\" title=\"architecture\"></a>architecture</h3><p><code>string</code><br>镜像中可执行文件的CPU架构，可以是 </p>\n<ul>\n<li><code>386</code></li>\n<li><code>amd64</code></li>\n<li><code>arm</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。</li>\n</ul>\n<h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><p><code>string</code><br>镜像运行的操作系统名，可以是 </p>\n<ul>\n<li><code>darwin</code></li>\n<li><code>freebsd</code></li>\n<li><code>linux</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。</li>\n</ul>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p><code>struct</code><br><code>config</code>结构是从镜像创建容器时，使用的基本执行参数。<code>config</code>可以是空值<code>null</code>，则创建容器时必须提供所有必要的执行参数。</p>\n<p><code>config</code>结构的各字段说明</p>\n<h4 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h4><p><code>string</code><br>容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：</p>\n<ul>\n<li><code>user</code></li>\n<li><code>uid</code></li>\n<li><code>user:group</code></li>\n<li><code>uid:gid</code></li>\n<li><code>uid:group</code></li>\n<li><code>user:gid</code></li>\n</ul>\n<p>如果没有给出组名 <code>group</code>/<code>gid</code>，默认的组使用容器中<code>/etc/passwd</code>文件对应的<code>user</code>/<code>uid</code>项。</p>\n<h4 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h4><p><code>integer</code><br>内存限值（以 <strong>字节</strong> 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"MemorySwap\"><a href=\"#MemorySwap\" class=\"headerlink\" title=\"MemorySwap\"></a>MemorySwap</h4><p><code>integer</code><br>总的内存使用量（内存 + swap），设置为<code>-1</code>则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"CpuShares\"><a href=\"#CpuShares\" class=\"headerlink\" title=\"CpuShares\"></a>CpuShares</h4><p><code>integer</code><br>CPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"ExposedPorts\"><a href=\"#ExposedPorts\" class=\"headerlink\" title=\"ExposedPorts\"></a>ExposedPorts</h4><p><code>struct</code><br>基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;8080&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;53/udp&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;2356/tcp&quot;: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的键可以是下面的格式：</p>\n<ul>\n<li><code>&quot;port/tcp&quot;</code></li>\n<li><code>&quot;port/udp&quot;</code></li>\n<li><code>&quot;port&quot;</code><br>如果没有给出协议，默认使用<code>tcp</code>协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。</li>\n</ul>\n<h4 id=\"Env\"><a href=\"#Env\" class=\"headerlink\" title=\"Env\"></a>Env</h4><p><code>array of strings</code><br>Env的每项都是 <code>VARNAME=&quot;var value&quot;</code> 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。</p>\n<h4 id=\"Entrypoint\"><a href=\"#Entrypoint\" class=\"headerlink\" title=\"Entrypoint\"></a>Entrypoint</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。</p>\n<h4 id=\"Cmd\"><a href=\"#Cmd\" class=\"headerlink\" title=\"Cmd\"></a>Cmd</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表（附加在<code>Entrypoint</code>之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出<code>Entrypoint</code>，那么<code>Cmd</code>列表的第一项将被认为是可执行的程序名。</p>\n<h4 id=\"Healthcheck\"><a href=\"#Healthcheck\" class=\"headerlink\" title=\"Healthcheck\"></a>Healthcheck</h4><p><code>struct</code><br>用以检查容器是否正常的测试命令，如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;Test&quot;: [</div><div class=\"line\">      &quot;CMD-SHELL&quot;,</div><div class=\"line\">      &quot;/usr/bin/check-health localhost&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;Interval&quot;: 30000000000,</div><div class=\"line\">  &quot;Timeout&quot;:  10000000000,</div><div class=\"line\">  &quot;Retries&quot;:  3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此结构有如下字段，</p>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h5><p><code>array of strings</code><br>用以检查容器是否正常的测试命令，可以是</p>\n<ul>\n<li><code>[]</code> : 继承父镜像的健康检查命令；</li>\n<li><code>[&quot;NONE&quot;]</code> : 禁用健康检查；</li>\n<li><code>[&quot;CMD&quot;, arg1, arg2, ...]</code> : 直接执行命令和参数；</li>\n<li><code>[&quot;CMD-SHELL&quot;, command]</code> : 使用系统默认shell执行命令；</li>\n</ul>\n<p>如果容器状态正常，测试命令退出后应返回 <code>0</code>，否则返回 <code>1</code>。</p>\n<ul>\n<li>Interval <code>integer</code>：相邻两次尝试的间隔，单位为纳秒；</li>\n<li>Timeout <code>integer</code>：认为异常的超时间隔，单位为纳秒；</li>\n<li>Retries <code>integer</code>：认为异常的重试次数。</li>\n</ul>\n<p>任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。</p>\n<h5 id=\"Volumes\"><a href=\"#Volumes\" class=\"headerlink\" title=\"Volumes\"></a>Volumes</h5><p><code>struct</code><br>创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;/var/my-app-data/&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;/etc/some-config.d/&quot;: &#123;&#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"WorkingDir\"><a href=\"#WorkingDir\" class=\"headerlink\" title=\"WorkingDir\"></a>WorkingDir</h5><p><code>string</code><br>容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。</p>\n<h5 id=\"rootfs\"><a href=\"#rootfs\" class=\"headerlink\" title=\"rootfs\"></a>rootfs</h5><p><code>struct</code><br>rootfs结构是镜像各层的<code>DiffID</code>列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:</p>\n<ul>\n<li><code>type</code>，其值一般为 <code>layers</code>.</li>\n<li><code>diff_ids</code> 各层散列（<code>DiffID</code>）的数组，顺序为从最底层到最顶层。</li>\n</ul>\n<p>下面是 rootfs 的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;rootfs&quot;: &#123;</div><div class=\"line\">  &quot;diff_ids&quot;: [</div><div class=\"line\">    &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">    &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</div><div class=\"line\">    &quot;sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>struct</code><br><code>history</code>结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。</p>\n<ul>\n<li><code>created</code>: 创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>；</li>\n<li><code>author</code>: 创建的作者；</li>\n<li><code>created_by</code>: 创建该层的命令；</li>\n<li><code>comment</code>: 创建该层的注释；</li>\n<li><code>empty_layer</code>: 标识此项历史记录是否会创建一个文件变更集。如果值为<code>true</code>，则此项历史不会对应一个实际的文件集（如<code>ENV</code>命令就对层的文件没有影响）。<br>下面是 history 结构的一个例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;history&quot;: [</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">    &quot;empty_layer&quot;: true</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。</p>\n<h2 id=\"创建镜像文件变更集\"><a href=\"#创建镜像文件变更集\" class=\"headerlink\" title=\"创建镜像文件变更集\"></a>创建镜像文件变更集</h2><p>创建镜像文件变更集的例子如下：<br>首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名<code>c3167915dc9d</code>（层的DiffID是基于目录内的文件内容生成的）。</p>\n<p>然后在其中创建文件和目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">c3167915dc9d/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>将目录<code>c3167915dc9d</code>提交为一个 <code>tar</code> 包（无压缩），其中包含如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">etc/my-app-config</div><div class=\"line\">bin/my-app-binary</div><div class=\"line\">bin/my-app-tools</div></pre></td></tr></table></figure>\n<p>如果要在此基础上更改文件，则创建一个新的目录，假如为<code>f60c56784b83</code>，将其初始化为父镜像的快照，即与目录<code>c3167915dc9d</code>的内容相同。</p>\n<blockquote>\n<p>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure>\n<p>然后添加一个配置目录<code>/etc/my-app.d</code>，其中包含默认的配置文件。可执行程序<code>my-app-tools</code>也更新了，以便处理新的配置文件路径。<br>修改后的目录<code>f60c56784b83</code>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app.d/</div><div class=\"line\">            default.cfg</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>其中移除了<code>/etc/my-app-config</code>，然后创建了新的目录和文件<code>/etc/my-app.d/default.cfg</code>。<code>/bin/my-app-tools</code>也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照<code>f60c56784b83</code>比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加：  /etc/my-app.d/default.cfg</div><div class=\"line\">修改：  /bin/my-app-tools</div><div class=\"line\">删除：  /etc/my-app-config</div></pre></td></tr></table></figure></p>\n<p>创建一个 <strong>仅包含</strong> 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加<code>.wh.</code>前缀（表示已删除）。</p>\n<blockquote>\n<p>注意：无法直接创建以名称<code>.wh.</code>开头的文件或目录。</p>\n</blockquote>\n<p>目录<code>f60c56784b83</code>生成的<code>tar</code> 包中有如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my-app.d/default.cfg</div><div class=\"line\">/bin/my-app-tools</div><div class=\"line\">/etc/.wh.my-app-config</div></pre></td></tr></table></figure>\n<p>任何镜像都是由若干类似的文件变更集的tar包组成的。</p>\n<h2 id=\"镜像的组合格式\"><a href=\"#镜像的组合格式\" class=\"headerlink\" title=\"镜像的组合格式\"></a>镜像的组合格式</h2><p>包含镜像完整内容的单一tar包格式如下：</p>\n<ul>\n<li>镜像名：tag</li>\n<li>镜像的 JSON 配置文件</li>\n<li>各层的tar包</li>\n</ul>\n<p>如镜像<code>library/busybox</code>的组合tar包内容如下（使用<code>tree</code>命令输出）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json</div><div class=\"line\">├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── manifest.json</div><div class=\"line\">└── repositories</div></pre></td></tr></table></figure>\n<p>镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。</p>\n<blockquote>\n<p>注意：该目录名 <strong>不必</strong> 是层的<code>DiffID</code>或<code>ChainID</code>。</p>\n</blockquote>\n<p>每个目录包含3个文件：</p>\n<ul>\n<li><code>VERSION</code> - <code>json</code>文件模式的版本号；</li>\n<li><code>json</code> - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。</li>\n<li><code>layer.tar</code> - 该层的tar包。</li>\n</ul>\n<p>注意：这个目录结构仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件中列出的目录。</p>\n<p><code>VERSION</code>文件只是JSON元数据模式的版本号：<code>1.0</code>。</p>\n<p><code>repositories</code>也是一个JSON文件，包含镜像名和tag列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  </div><div class=\"line\">    &quot;busybox&quot;:&#123;  </div><div class=\"line\">        &quot;latest&quot;:&quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有镜像的<code>repository</code>和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件。</p>\n<p><code>manifest.json</code>文件是顶层镜像的JSON配置。<br>该文件包含以下元数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;Config&quot;: &quot;47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json&quot;,</div><div class=\"line\">    &quot;RepoTags&quot;: [&quot;busybox:latest&quot;],</div><div class=\"line\">    &quot;Layers&quot;: [</div><div class=\"line\">      &quot;a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar&quot;,</div><div class=\"line\">      &quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar&quot;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>上面这个JSON数组中，每项都对应着一个镜像。</p>\n<ul>\n<li><code>Config</code> 指向该镜像的JSON文件；</li>\n<li><code>RepoTags</code> 是该镜像的名称；</li>\n<li><code>Layers</code> 指向镜像各层的 tar 包；</li>\n<li><code>Parent</code> 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 <code>manifest.json</code> 文件中存在。</li>\n</ul>\n<p>不要把 <code>manifest.json</code> 与用来push和pull镜像的分发清单（distribution manifest）相混淆。<br>一般来说，支持v1.2版本镜像规范的实现将使用<code>manifest.json</code>文件，早期的实现仍使用 <code>*/json</code>和<code>repositories</code>文件。</p>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><p>其它相关文档：</p>\n<ul>\n<li><a href=\"https://github.com/opencontainers/image-spec\" target=\"_blank\" rel=\"external\">Open Containers Initiative Image Spec</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md\" target=\"_blank\" rel=\"external\">Image Manifest Version 2, Schema 2</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/api.md\" target=\"_blank\" rel=\"external\">Docker Registry HTTP API V2</a></li>\n<li><a href=\"https://github.com/apache/mesos/blob/master/docs/container-image.md\" target=\"_blank\" rel=\"external\">Supporting Container Images in Mesos Containerizer</a></li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<p>注意：不要把上面的 <strong>镜像格式</strong> 与镜像的 <strong>主机存储布局</strong> 搞混了。</p>\n<ul>\n<li>镜像格式是执行<code>docker save &lt;镜像名或ID&gt;</code>之后得到的对应镜像<code>tar</code>包的格式。</li>\n<li>镜像在主机的存储布局，以及镜像push和pull都 <strong>不会</strong> 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。</li>\n</ul>\n<p>镜像的各层存在顺序依赖，而镜像也有父子继承关系。<br>最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。</p>\n</blockquote>\n<h2 id=\"alpine镜像的主机存储布局\"><a href=\"#alpine镜像的主机存储布局\" class=\"headerlink\" title=\"alpine镜像的主机存储布局\"></a>alpine镜像的主机存储布局</h2><p>alpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。</p>\n<ul>\n<li>./aufs是解开layer.tar后的文件内容；</li>\n<li>./aufs/mnt是容器文件系统的挂载点；</li>\n<li>./containers是创建的容器的读写层；</li>\n<li>./image/aufs/distribution中两个文件夹相当于正反查找的指针；</li>\n<li>./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"># tree /var/lib/docker</div><div class=\"line\">/var/lib/docker</div><div class=\"line\">├── aufs</div><div class=\"line\">│   ├── diff</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   │       ├── bin</div><div class=\"line\">│   │       │   ├── ash -&gt; /bin/busybox</div><div class=\"line\">│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）</div><div class=\"line\">│   ├── layers</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   └── mnt</div><div class=\"line\">│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">├── containers</div><div class=\"line\">├── image</div><div class=\"line\">│   └── aufs</div><div class=\"line\">│       ├── distribution</div><div class=\"line\">│       │   ├── diffid-by-digest</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299</div><div class=\"line\">│       │   └── v2metadata-by-diffid</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       ├── imagedb</div><div class=\"line\">│       │   ├── content</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9</div><div class=\"line\">│       │   └── metadata</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       ├── layerdb</div><div class=\"line\">│       │   ├── sha256</div><div class=\"line\">│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       │   │       ├── cache-id </div><div class=\"line\">│       │   │       ├── diff</div><div class=\"line\">│       │   │       ├── size</div><div class=\"line\">│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件</div><div class=\"line\">│       │   └── tmp</div><div class=\"line\">│       └── repositories.json</div><div class=\"line\">├── network</div><div class=\"line\">│   └── files</div><div class=\"line\">│       └── local-kv.db</div><div class=\"line\">├── plugins</div><div class=\"line\">│   ├── storage</div><div class=\"line\">│   │   └── blobs</div><div class=\"line\">│   │       └── tmp</div><div class=\"line\">│   └── tmp</div><div class=\"line\">├── swarm</div><div class=\"line\">├── tmp</div><div class=\"line\">├── trust</div><div class=\"line\">└── volumes</div><div class=\"line\">    └── metadata.db</div></pre></td></tr></table></figure>"},{"title":"【译文修订】使用Borg在Google管理大规模集群","date":"2017-10-30T16:00:00.000Z","_content":"\n发表于EuroSys 2015的 ***Large-scale cluster management at Google with Borg*** 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。\n\n\n<!--more-->\n\n---\n\n**Large-scale cl uster management at Google with Borg**\n\n作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes\n\nhttp://research.google.com/pubs/pub43438.html 或 直接 [下载PDF全文](/doc/EuroSys15_Borg.pdf)\n\n译者：难易 http://my.oschina.net/HardySimpson\n\nEuroSys’15, http://dx.doi.org/10.1145/2741948.2741964\n\n# 摘要\n\n谷歌的Borg系统群集管理器运行几十万个以上的jobs，来自几千个不同的应用，跨多个集群，每个集群有上万个机器。\n\n它通过管理控制、高效的任务包装、超售、和进程级别性能隔离实现了高利用率。它支持高可用性应用程序与运行时功能，最大限度地减少故障恢复时间，减少相关故障概率的调度策略。Borg简化了用户生活，通过提供一个声明性的工作规范语言，名称服务集成，实时作业监控，和分析和模拟系统行为的工具。\n\n我们将会展现Borg系统架构和特点，重要的设计决策，定量分析它的一些策略，和十年以来的运维经验和学到的东西。\n\n# 1. 简介\n\n集群管理系统我们内部叫Borg，它管理、调度、开始、重启和监控谷歌运行的应用程序的生命周期。本文介绍它是怎么做到这些的。\n\nBorg提供了三个主要的好处：它（1）隐藏资源管理和故障处理细节，使其用户可以专注于应用开发；（2）高可靠性和高可用性的操作，并支持应用程序做到高可靠高可用；（3）让我们在跨数以万计的机器上有效运行。Borg不是第一个来解决这些问题的系统，但它是在这个规模，这种程度的弹性和完整性下运行的为数不多的几个系统之一。\n\n本文围绕这些主题来编写，包括了我们在生产环境运行十年的一些功力。\n\n![Fig. 1](/img/borg-fig-01.png)\n\n# 2.用户视角\n\nBorg的用户是谷歌开发人员和系统管理员(网站可靠性工程师 SRE)，他们运行谷歌应用与服务。用户以job的方式提交他们的工作给Borg，job由一个或多个task组成，每个task含有同样的二进制程序。一个job在一个Borg的Cell里面跑，一个Cell是包括了多台机器的单元。这一节主要讲用户视角下的Borg系统。\n\n## 2.1 工作负载\n\nBorg Cell主要运行两种异构的工作负载。第一种是长期的服务，应该“永远”运行下去，并处理短时间的敏感请求（几微秒到几百毫秒）。这种服务是面向终端用户的产品如Gmail、Google Docs、网页搜索，内部基础设施服务（例如，Bigtable）。第二种是批处理任务，需要几秒到几天来完成，对短期性能波动不敏感。在一个Cell上混合运行了这两种负载，取决于他们的主要租户（比如说，有些Cell就是专门用来跑密集的批处理任务的）。工作负载也随着时间会产生变化：批处理任务做完就好，终端用户服务的负载是以每天为周期的。Borg需要把这两种情况都处理好。\n\nBorg有一个2011年5月的负载数据[80]，已经被广泛的分析了[68,26，27，57，1]。\n\n最近几年，很多应用框架是搭建在Borg上的，包括我们内部的MapReduce[23]、flumejava[18]、Millwheel[3]、Pregel[59]。这中间的大部分都是有一个控制器，可以提交job。前2个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和他的后继者CFS、Bigtable[19]、Megastore[8]都是跑在Borg上的。\n\n在这篇文章里面，我们把高优先级的Borg的jobs定义为生产(prod)，剩下的是非生产的(non-prod)。大多长期服务是prod的，大部分批处理任务是non-prod的。在一个典型的Cell里面，prod job分配了70%的CPU资源然后实际用了60%；分配了55%的内存资源然后实际用了85%。在$5.5会展示分配和实际值的差是很重要的。\n\n## 2.2 集群和Cell\n\n一个Cell里面的所有机器都属于单个集群，集群是由高性能的数据中心级别的光纤网络连接起来的。一个集群安装在数据中心的一座楼里面，n座楼合在一起成为一个site。一个集群通常包括一个大的Cell还有一些小的或测试性质的Cell。我们尽量避免任何单点故障。\n\n在测试的Cell之外，我们中等大小的Cell大概包括10000台机器；一些Cell还要大很多。一个Cell中的机器在很多方面都是异构的：大小(CPU,RAM,disk,network)、处理器类型、性能以及外部IP地址或flash存储。Borg隔离了这些差异，让用户单纯的选择用哪个Cell来跑任务，分配资源、安装程序和其它依赖、监控系统的健康并在故障时重启。\n\n(译者：Cell其实就是逻辑上的集群)\n\n## 2.3 job和task\n\n一个Borg的job的属性有：名字、拥有者和有多少个task。job可以有一些约束，来指定这个job跑在什么架构的处理器、操作系统版本、是否有外部IP。约束可以是硬的或者软的。一个job可以指定在另一个job跑完后再开始。一个job只在一个Cell里面跑。\n\n每个task包括了一组linux进程，跑在一台机器的一个容器内[62]。大部分Borg的工作负载没有跑在虚拟机(VM)里面，因为我们不想付出虚拟化的代价。而且，Borg在设计的时候还没硬件虚拟化什么事儿哪。\n\ntask也有一些属性，包括资源用量，在job中的排序。大多task的属性和job的通用task属性是一样的，也可以被覆盖 —— 例如，提供task专用的命令行参数，包括CPU核、内存、磁盘空间、磁盘访问速度、TCP端口等等，这些都是可以分别设置并按照一个好的粒度提供。我们不提供固定的资源的单元。Borg程序都是静态编译的，这样在跑的环境下就没有依赖，这些程序都被打成一个包，包括二进制和数据文件，能被Borg安装起来。\n\n用户通过RPC来操作Borg的job，大多是从命令行工具，或者从我们的监控系统($2.6)。大多job描述文件是用一种申明式配置文件BCL -- GCL[12]的一个变种，会产生一个protobuf文件[67]。BCL有一些自己的关键字。GCL提供了lambda表达式来允许计算，这样就能让应用在环境里面调整自己的配置。上万个BCL配置文件超过一千行长，系统中累计跑了了千万行BCL。Borg的job配置很类似于Aurora配置文件[6]。\n\n![Fig. 2](/img/borg-fig-02.png)\n\n图2展现了job的和task的状态机和生命周期。\n\n用户可以在运行时改变一个job中的task的属性，通过推送一个新的job配置给Borg。这个新的配置命令Borg更新task的规格。这就像是跑一个轻量级的，非原子性的事务，而且可以在提交后轻易再改回来。更新是滚动式的，在更新中可以限制task重启的数量，如果有太多task停掉，操作可以终止。\n\n一些task更新，例如更新二进制程序，需要task重启；另外一些例如修改资源需求和限制会导致这个机器不适合跑现有的task，需要停止task再重新调度到别的机器上；还有一些例如修改优先级是可以不用重启或者移动task的。\n\ntask需要能够接受Unix的SIGTERM信号，在他们被强制发送SIGKILL之前，这样就有时间去做清理、保存状态、结束现有请求执行、拒绝新请求。实际的notice的delay bound。实践中，80%的task能正常处理终止信号。\n\n## 2.4 Allocs\n\nBorg的alloc(allocation的缩写)是在单台机器上的一组保留的资源配额，用来让一个或更多的task跑；这些资源一直分配在那边，无论有没有被用。allocs可以被分配出来给未来的task，用来保持资源在停止一个task和重启这个task之间，用来聚集不同jobs的tasks到同一台机器上——例如一个web server实例和附加的，用于把serverURL日志发送到一个分布式文件系统的日志搜集实例。一个alloc的资源管理方式和一台机器上的资源管理方式是类似的；多个tasks在一个alloc上跑并共享资源。如果一个alloc必须被重新定位到其他的机器上，那么它的task也要跟着重新调度。\n\n一个alloc set就像一个job：它是一组allocs保留了多台机器上的资源。一旦alloc set被创建，一个或多个jobs就可以被提交进去跑。简而言之，我们会用task来表示一个alloc或者一个top-level task(一个alloc之外的)，用job来表示一个job或者alloc set。\n\n## 2.5 优先级、配额和管理控制\n\n当有超量的工作负载在运行的时候会发生什么事情？我们的解决方案是优先级和配额。\n\n所有job都有优先级，一个小的正整数。高优先级的task可以优先获取资源，即使后面被杀掉。Borg定义了不重叠的优先级段给不同任务用，包括(优先级降序)：监控、生产、批任务、高性能(测试或免费)。在这篇文章里面，prod的jobs是在监控和生产段。\n\n虽然一个降级的task总会在cell的其他地方找到一席之地。降级瀑布也有可能会发生，就是一个task降下来之后，把下面运行的task再挤到别的机器上，如此往复。为了避免这种情况，我们禁止了prod级task互相排挤。合理粒度的优先级在其他场景下也很有用——MapReduce的master跑的优先级比worker高一点，来保证他们的可用性。\n\n优先级是jobs的相对重要性，决定了jobs在一个cell里面是跑还是等(pending)。配额则是用来决定jobs是否运行被调度。配额就是一组资源(CPU, RAM, disk)的数量在一个指定的优先级、一个指定的时间段(月这个量级)。数量决定了这个用户的job可以用的最多资源(例子：20TB内存和prod优先级从现在到7月在xx cell内)。配额检查是管理控制的一部分，不是调度层的：配额不足的任务在提交的时候就会被拒绝。\n\n高优先级的配额总是花费的比低优先级要多。prod级的配额是被限制为一个cell里面实际的资源量，所以用户提交了prod级的job的配额时，可以期待这个job一定会跑，去掉一些碎片外。即使这样，我们鼓励用户多买一点比自己需要多一点的配额，很多用户超买是因为他们的应用程序的用户数量增长后需要的配额就大了。对于超买，我们的应对方案是低优先级资源的超售：所有用户在0优先级都可以用无限的配额，虽然在实际运行中这种情况很难跑起来。一个低优先级的job在资源不足时会保持等(pending)状态。\n\n配额分配在Borg系统之外，和我们的物理资源计划有关。这些资源计划在不同的数据中心产生不同的价格和配额。用户jobs只在有足够配额和足够优先级之后才能启动。配额的使用让Dominant Resource Fairness(DRF)[29, 35, 36, 66]不是那么必要了。\n\nBorg有一个容量系统给一些特殊权限给某些用户，例如，允许管理员删除或修改cell里面的job，或者允许用户区访问特定的内核特性或者让Borg对自己的job不做资源估算($5.5)。\n\n## 2.6 命名和监控\n\n光是创建和部署task是不够的：一个服务的客户端和其他系统需要能找到它们，即使它换了个地方。为了搞定这一点，Borg创造了一个稳定的“Borg name Service”(BNS)名字给每个task，这个名字包括了cell名字，job名字，和task编号。Borg把task的主机名和端口写入到一个持久化高可用文件里，以BNS名为文件名，放在Chubby[14]上。这个文件被我们的RPC系统使用，用来发现task的终端地址。BNS名称也是task的DNS名的基础构成部分，所以，cc cell的ubar用户的jfoo job的第50个task的DNS名称会是50.jfoo.ubar.cc.borg.google.com。Borg同时还会把job的大小和task的健康信息写入到Chubby在任何情况改变时，这样负载均衡就能知道怎么去路由请求了。\n\n几乎所有的Borg的task都会包含一个内置的HTTP服务，用来发布健康信息和几千个性能指标(例如RPC延时)。Borg监控这些健康检查URL，把其中响应超时的和error的task重启。其他数据也被监控工具追踪并在Dashboards上展示，当服务级别对象(SLO)出问题时就会报警。\n\n用户可以使用一个名叫Sigma的web UI，用来检查他们所有的job状态，一个特殊的cell，或者深入到某个job的某个task的资源用率，详细日志，操作历史，和最终命运。我们的应用产生大量的日志，都会被自动的滚动来避免塞满硬盘，会在一个task结束后保留一小段时间用来debug。如果一个job没有被跑起来，Borg会提供一个为什么挂起的解释，指导用户怎么修改这个job的资源需求来符合目前这个cell的情况。我们发布资源的使用方针，按照这个方针来做就容易被调度起来。\n\nBorg记录所有的job提交和task时间，以及每task的资源使用细节在基础存储服务里面。这个存储服务有一个分布式的只读的SQL-like的交互式接口，通过Dremel[61]提供出来。这些数据在实时使用、debug、系统查错和长期容量规划上都很有用。这些数据也是Google集群负载追踪的数据来源之一[80].\n\n所有这些特性帮助用户理解和debug Borg的行为和管理他们的job，并且帮助我们的SRE每个人管理超过上万台机器。\n\n# 3. Borg架构\n\n一个Borg的Cell包括一堆机器，一个逻辑的中心控制服务叫做Borgmaster，和在每台机器上跑的Borglet的agent进程(见图1)。所有Borg的组件都是用C++写的。\n\n![Fig. 1](/img/borg-fig-01.png)\n\n## 3.1 Borgmaster\n\nCell的Borgmaster由2个进程组成，主的Borgmaster进程和一个单独的scheduler($3.2)。主的Borgmaster处理所有客户端的RPC请求，例如修改状态(创建job)，提供数据读取服务(查找job)。它同时管理系统中所有组件(机器、task、allocs等等)的状态机，和Borglet通信，并且提供一个Sigma的备份Web UI。\n\nBorgmaster在逻辑上是一个单进程，但实际上开了5个副本。每个副本维护了一个内存级别的cell状态拷贝，这些状态同时被记录在一个高可用、分布式、Paxos-based存储[55]放在这些副本的本地硬盘上。在一个cell里面，一个单独的被选举出来的master同时用于Paxos leader和状态修改器，用来处理所有改变cell状态的请求，例如提交一个job或者在一个机器上终止一个task。当cell启动或前一个master挂了时，Paxos算法会选举出一个master；这需要一个Chubby锁然后其他系统可以找到master。选举一个master或者换一个新的需要的典型事件是10s，但需要大概1分钟才能让一个大的cell内生效，因为一些内存状态要重构。当一个副本从网络隔离中恢复时，需要动态的从其他Paxos副本中重新同步自己的状态。\n\n某个时刻的Borgmaster的状态被称为checkpoint，会被以快照形式+change log形式保存在Paxos存储里面。checkpoints有很多用途，包括把Borgmaster的状态恢复到以前的任意时刻(例如在处理一个请求之前，用来解决软件缺陷)；极端情况下手动修改checkpoints，形成一个持续的事件日志供今后用；或用于线下的在线仿真。\n\n一个高仿真的Borgmaster叫Fauxmaster，可以用来读取checkpoint文件，包括一份完整的Borgmaster的代码，和Borglet的存根接口。它接受RPC来改变状态机和执行操作，例如调度所有阻塞的tasks，我们用它来debug错误，和它交互就和Borgmaster交互是一样的，同样我们也有一个仿真的Borglet可以用checkpoint重放真实的交互。用户可以单步调试看到系统中的所有过去的改变。Fauxmaster在这种情况下也很有用：多个这个类型的job比较合适？以及在改变cell配置前做一个安全检查(这个操作会把任何关键jobs给踢掉吗？)\n\n## 3.2 调度 schedule\n\n当一个job被提交的时候，Borgmaster会把它持久化的存储在Paxos存储上，然后把这个job的task放到等待(pending)的队列里面去。这个队列会被scheduler异步的扫描，然后分发task到有充足资源的机器上。scheduler主要是处理task的，不是job。扫描从高优先级到低优先级，在同个优先级上用round-robin的方式处理，以保证用户之间的公平性和避免头上的大job阻塞住。调度算法有2个部分：可行性检查(feasibility checking)，找到一台能跑task的机器，和打分(scoring)，找个一个最合适的机器。\n\n在可行性检查这个阶段，scheduler会找到一组机器，都满足task的约束而且有足够可用的资源 —— 包括了一些已经分配给低优先级任务的可以被腾出来的资源。在打分阶段，scheduler会找到其中“最好”的机器。这个分数包括了用户的偏好，但主要是被内置的标准：例如最小化的倒腾其他task，找到已经有这个task安装包的，在电力和出错的可用域之间尽可能分散的，在单台机器上混合高低优先级的task以保证高峰期扩容的。\n\nBorg原来用E-PVM[4]的变种算法来打分，在异构的资源上生成一个单一的分数，在调度一个task时最小化系统的改变。但在实践中，E-PVM最后把负载平均分配到所有机器，把扩展空间留给高峰期 —— 但这么做的代价是增加了碎片，尤其是对于大的task需要大部分机器的时候；我们有时候给这种分配取绰号叫“最差匹配”。\n\n分配策略光谱的另一端是“最佳匹配”，把机器塞任务塞的越紧越好。这样就能留下一些空的机器给用户jobs(他们也跑存储服务)，所以处理大task就比较直接了，不过，紧分配会惩罚那些对自己所需资源预估不足的用户。这种策略会伤害爆发负载的应用，而且对需要低CPU的批处理任务特别不友好，这些任务可以被轻易调度到不用的资源上：20%的non-prod task需要小于0.1核的CPU。\n\n我们目前的打分模型是一个混合的，试图减少搁浅的资源 —— 一些因为这台机器上资源没被全部用掉而剩下的。比起“最佳匹配”，这个模型提供了3%-5%的打包效率提升(在[78]里面定义的)\n\n如果一台机器在打分后没有足够的资源运行新的task，Borg会驱逐(preempts)低优先级的任务，从最低优先级往上踢，直到资源够用。我们把被踢掉的task放到scheduler的等待(pending)队列里面去，而不是迁移或冬眠这些task。\n\ntask启动延迟(从job提交到task运行之间的时间段)是被我们持续关注的。这个时间差别很大，一般来说是25s。包安装耗费了这里面80%的时间：一个已知的瓶颈就是对本地硬盘的争抢。为了减少task启动时间，scheduler希望机器上已经有足够的包(程序和数据)：大部分包是只读的所以可以被分享和缓存。这是唯一一种Borg scheduler支持的数据本地化方式。顺便说一下，Borg分发包到机器的办法是树形的和BT类型的协议。\n\n另外，scheduler用了某些技术来扩散到几万台机器的cell里面。($3.4)\n\n## 3.3 Borglet\n\nBorglet是部署在cell的每台机器上的本地Borg代理程序。它启动停止task；如果task失败就重启；通过修改OS内核设置来管理本地资源；滚动debug日志；把本机的状态上报给Borgmaster和其他监控系统。\n\nBorgmaster每过几秒就会轮询所有的Borglet来获取机器当前的状态还有发送任何请求。这让Borgmaster能控制交流频率，避免一个显式的流控机制，而且防止了恢复风暴[9].\n\n选举出来的master负责发送消息给Borglet并且根据响应更新cell的状态。为了性能可扩展，每个Borgmaster副本会运行一个无状态的连接分配(link shard)来处理和特定几个Borglet的交流；这个分配会在Borgmaster选举的时候重新计算。为了保证弹性，Borglet把所有状态都报上来，但是link shard会聚合和压缩这些信息到状态机，来减少选举出来的master的负载。\n\n如果Borglet几次没有响应轮询请求，将会被标记为挂了(down)，然后上面跑的task会被重新分配到其他机器。如果通讯恢复，Borgmaster会让这个Borglet杀掉已经被分配出去的task，来避免重复。Borglet会继续常规的操作即使和Borgmaster恢复联系，所以目前跑的task和service保持运行以防所有的Borgmaster挂了。\n\n## 3.4 可扩展性\n\n我们还不知道Borg的可扩展性极限在哪里，每次我们碰到一个极限，我们就越过去。一个单独的Borgmaster可以管理一个cell里面几千台机器，若干个cell可以处理10000个任务每分钟。一个繁忙的Borgmaster使用10-14个CPU核以及50GB内存。我们用了几项技术来获得这种扩展性。\n\n早期的Borgmaster有一个简单的，同步的循环来处理请求、调度tasks，和Borglet通信。为了处理大的cell，我们把scheduler分出来作为一个单独的进程，然后就可以和别的Borgmaster功能并行的跑，别的Borgmaster可以开副本来容错。一个scheduler副本操作一份cell的状态拷贝。它重复地：从选举出来的master获取状态改变(包括所有的分配的和pending的工作)；更新自己的本地拷贝，做调度工作来分配task；告诉选举出来的master这些分配。master会接受这些信息然后应用之，除非这些信息不适合(例如，过时了)，这些会在scheduler的下一个循环里面处理。这一切都符合Omega[69]的乐观并行策略精神，而且我们最近真的给Borg添加这种功能，对不同的工作负载用不同的scheduler来调度。\n\n为了改进响应时间，我们增加了一些独立线程和Borglet通信、响应只读RPC。为了更高的性能，我们分享(分区)这些请求给5个Borgmaster副本$3.3。最后，这让99%的UI响应在1s以内，而95%的Borglet轮询在10s以内。\n\n一些让Borg scheduler更加可扩展的东西：\n\n分数缓存：评估一台机器的可用性和分数是比较昂贵的，所以Borg会一直缓存分数直到这个机器或者task变化了——例如，这台机器上的task结束了，一些属性修改了，或者task的需求改变了。忽略小的资源变化让缓存保质期变长。\n\n同级别均化处理：同一个Borg job的task一般来说有相同的需求和资源，所以不用一个个等待的task每次都去找可用机器，这会把所有可用的机器打n次分。Borg会对相同级别的task找一遍可用机器打一次分。\n\n适度随机：把一个大的Cell里面的所有机器都去衡量一遍可用性和打分是比较浪费的。所以scheduler会随机的检查机器，找到足够多的可用机器去打分，然后挑出最好的一个。这会减少task进入和离开系统时的打分次数和缓存失效。适度随机有点像Sparrow [65]的批处理采样技术，同样要面对优先级、驱逐、非同构系统和包安装的耗费。\n\n在我们的实验中($5)，调度整个cell的工作负载要花几百秒，但不用上面几项技术的话会花3天以上的时间。一般来说，一个在线的调度从等待队列里面花半秒就能搞定。\n\n# 4. 可用性\n\n![Fig. 3](/img/borg-fig-03.png)\n\n在大型分布式系统里面故障是很常见的[10,11,12]。图3展示了在15个cell里面task驱逐的原因。在Borg上跑的应用需要能处理这种事件，应用要支持开副本、存储数据到分布式存储这些技术，并能定期的做快照。即使这样，我们也尽可能的缓和这些事件造成的影响。例如，Borg：\n\n自动的重新调度被驱逐的task，如果需要放到新机器上运行\n通过把一个job分散到不同的可用域里面去，例如机器、机架、供电域\n在机器、OS升级这些维护性工作时，降低在同一时刻的一个job中的task的关闭率\n使用声明式的目标状态表示和幂等的状态改变做操作，这样故障的客户端可以无损的重新启动或安全的遗忘请求\n对于失联的机器上的task，限制一定的比率去重新调度，因为很难去区分大规模的机器故障和网络分区\n避免特定的会造成崩溃的task:机器的匹配\ncritical级别的中间数据写到本地硬盘的日志保存task很重要，就算这个task所属的alloc被终止或调度到其他机器上，也要恢复出来做。用户可以设置系统保持重复尝试多久：若干天是比较合理的做法。\n一个关键的Borg设计特性是：就算Borgmaster或者Borglet挂了，task也会继续运行下去。不过，保持master运行也很重要，因为在它挂的时候新的jobs不能提交，或者结束的无法更新状态，故障的机器上的task也不能重新调度。\n\nBorgmaster使用组合的技术在实践中保证99.99%的可用性：副本技术应对机器故障；管理控制应对超载；部署实例时用简单、底层的工具去减少外部依赖(译者：我猜测是rsync或者scp这种工具)。每个cell和其他cell都是独立的，这样减少了误操作关联和故障传染。为了达到这个目的，所以我们不搞大cell。\n\n# 5. 使用效率\n\nBorg的一个主要目的就是有效的利用Google的机器舰队，这可是一大笔财务投资：让效率提升几个百分点就能省下几百万美元。这一节讨论了和计算了一些Borg使用的技术和策略。\n\n## 5.1 测度方法论\n\n我们的job部署是有资源约束的，而且很少碰到负载高峰，我们的机器是异构的，我们从service job回收利用的资源跑batch job。所以，为了测量我们需要一个比“平均利用率”更抽象的标准。在做了一些实验后我们选择了cell密度(cell compaction)：给定一个负载，我们不断的从零开始(这样可以避免被一个倒霉的配置卡住)，部署到尽可能小的Cell里面去，直到再也不能从这个cell里面抽机器出来。这提供了一个清晰的终止条件，并促进了无陷阱的自动化比较，这里的陷阱指的是综合化的工作负载和建模[31]。一个定量的比较和估算技术可以看[78]，有不少微妙的细节。\n\n我们不可能在线上的cell做性能实验，所以我们用了Fauxmaster来达到高保真的模拟效果，使用了真的在线cell的负载数据包括所有的约束、实际限制、保留和常用数据($5.5)。这些数据从2014-10-1 14:00 PDT的Borg快照(checkpoints)里面提取出来。(其他快照也产生类似的结论)。我们选取了15个Borg cell来出报告，先排除了特殊目的的、测试的、小的(<5000机器)的cell，然后从剩下的各种量级大小的cell中平均取样。\n\n在压缩cell实验中为了保持机器异构性，我们随机选择去掉的机器。为了保持工作负载的异构性，我们保留了所有负载，除了那些对服务和存储需要有特定需求的。我们把那些需要超过一半cell的job的硬限制改成软的，允许不超过0.2%的task持续的pending如果它们过于挑剔机器；广泛的测试表明这些结果是可重复的。如果我们需要一个大的cell，就把原cell复制扩大；如果我们需要更多的cell，就复制几份cell。\n\n所有的实验都每个cell重复11次，用不同的随机数发生器。在图上，我们用一个横线来表示最少和最多需要的机器，然后选择90%这个位置作为结果，平均或者居中的结论不会代表一个系统管理员会做的最优选择。我们相信cell压缩提供了一个公平一致的方式去比较调度策略：好的策略只需要更少的机器来跑相同的负载。\n\n我们的实验聚焦在调度(打包)某个时间点的一个负载，而不是重放一段长期的工作踪迹。这部分是因为复制一个开放和关闭的队列模型比较困难，部分是因为传统的一段时间内跑完的指标和我们环境的长期跑服务不一样，部分是因为这样比较起来比较明确，部分是因为我们相信怎么整都差不多，部分是因为我们在消费20万个Borg CPU来做测试——即使在Google的量级，这也不是一个小数目(译者：就你丫理由多！)\n\n![Fig. 4](/img/borg-fig-04.png)\n\n在生产环境下，我们谨慎的留下了一些顶部空间给负载的增加，比如一些“黑天鹅”时间，负载高峰，机器故障，硬件升级，以及大范围故障(供电进灰)。图4显示了我们在现实世界中可以把cell压缩到多小。上面的基线是用来表示压缩大小的。\n\n## 5.2 Cell的共享使用\n\n几乎我们所有的机器都同时跑prod和non-prod的task：在共享Borg cell里有98%的机器同时跑这2种task，在所有Borg管理的机器里面有83%同时跑这2种task(我们有一些专用的Cell跑特定任务)。\n\n![Fig. 5](/img/borg-fig-05.png)\n\n鉴于很多其他的组织把面向用户应用和批处理应用在不同的集群上运行，我们设想一下如果我们也这么干会发生什么情况。图5展现了在一个中等大小的Cell上分开跑我们prod和non-prod的工作负载将需要20-30%多的机器。这是因为prod的job通常会保留一些资源来应对极少发生的负载高峰，但实际上在大多情况下不会用这些资源。Borg把这批资源回收利用了($5.5)来跑很多non-prod的工作，所以最终我们只需要更少的机器。\n\n![Fig. 6](/img/borg-fig-06.png)\n\n大部分Borg cell被几千个用户共享使用。图6展现了为什么。对这个测试，如果一个用户消费超过了10TiB内存(或100TiB)，我们就把这个用户的工作负载分离到一个单独的Cell里面去。我们目前的策略展现了它的威力：即使我们设置了这么高的阈值(来分离)，也需要2-16倍多的Cell，和20-150%多的机器。资源池的方案再次有效地节省了开销。\n\n但是，或许把很多不相关的用户和job类型打包放到一台机器上，会造成CPU冲突，然后就需要更多的机器进行补偿？为了验证这一点，我们看一下在同一台机器，锁定时钟周期，每指令循环数CPI(cycles per instruction)在不同环境的task下是怎么变化的。在这种情况下，CPI是一个可比较的指标而且可以代表冲突度量，因为2倍的CPI意味着CPU密集型程序要跑2倍的时间。这些数据是从一周内12000个随机的prod的task中获取的，用硬件测量工具[83]取的，并且对采样做了权重，这样每秒CPU都是平等的。测试结果不是非常明显。\n\n我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及(强相关)这个机器上同时跑的task数量；每往一台机器上增加1个task，就会增加0.3%的CPI(线性模型过滤数据)；增加一台10%的CPU使用率，就会增加小于2%的CPI。即使这已经是一个统计意义显著的正相关性，也只是解释了我们在CPI度量上看到的5%的变化，还有其他的因素支配着这个变化，例如应用程序固有的差别和特殊的干涉图案[24,83]。\n\n比较我们从共享Cell和少数只跑几种应用的专用Cell获取的CPI采样，我们看到共享Cell里面的CPI平均值为1.58(σ=0.35,方差)，专用Cell的CPI平均值是1.53(σ=0.32,方差).也就是说，共享Cell的性能差3%。\n\n为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差(或许对冲突更敏感的程序会被挪到专用Cell里面去)，我们观察了Borglet的CPI，在所有Cell的所有机器上都会被运行。我们发现专用Cell的CPI平均值是1.20(σ=0.29,方差)，而共享Cell里面的CPI平均值为1.43(σ=0.45,方差)，暗示了在专用Cell上运行程序会比在共享Cell上快1.19倍，这就超过了CPU使用量轻负载的这个因素，轻微的有利于专用Cell。\n\n这些实验确定了仓库级别的性能测试是比较微妙的，加强了[51]中的观察，并且得出了共享并没有显著的增加程序运行的开销。\n\n不过，就算我们假设用了我们结果中最不好的数据，共享还是有益的：比起CPU的降速，在各个方案里面减少机器更重要，这会带来减少所有资源的开销，包括内存和硬盘，不仅仅是CPU。\n\n## 5.3 大Cell\n\n![Fig. 7](/img/borg-fig-07.png)\n\nGoogle建立了大Cell，为了允许大的任务运行，也是为了降低资源碎片。我们通过把负载从一个cell分到多个小cell上来测试后面那个效应(降低碎片效应)，随机的把job用round-robin方式分配出去。图7展示了用很多小cell会明显的需要更多机器。\n\n## 5.4 资源请求粒度\n\n![Fig. 8](/img/borg-fig-08.png)\n\nBorg用户请求的CPU单位是千分之一核，内存和硬盘单位是byte。(1核是一个CPU的超线程，在不同机器类型中的一个通用单位)。图8展现了这个粒度的好处：CPU核和内存只有少数的“最佳击球点”，以及这些资源很少的相关性。这个分布和[68]里面的基本差不多，除了我们看到大内存的请求在90%这个线上。\n\n![Fig. 9](/img/borg-fig-09.png)\n\n提供一个固定尺寸的容器和虚拟机，在IaaS(infrastructure-as-a-service)提供商里面或许是比较流行的，但不符合我们的需求。为了展现这一点，我们把CPU核和内存限制做成一个个尺寸，然后把prod的job按照大一点最近的尺寸去跑(取这2个维度的平方值之和最近，也就是2维图上的直线)，0.5核的CPU,1G的内存为差值。图9显示了一般情况下我们需要30-50%多的资源来运行。上限来自于把大的task跑在一整台机器上，这些task即使扩大四倍也没办法在原有Cell上压缩跑。下限是允许这些task等待(pending)。(这比[37]里面的数据要大100%，因为我们支持超过4中尺寸而且允许CPU和内存无限扩张)。\n\n## 5.5 资源再利用\n\n一个job可以声明一个限制资源，是每个task能强制保证的资源上限。Borg会先检查这个限制是不是在用户的配额内，然后检查具体的机器是否有那么多资源来调度这个task。有的用户会买超过他们需要的配额，也有用户会的task实际需要更多的资源去跑，因为Borg会杀掉那些需要更多的内存和硬盘空间的task，或者卡住CPU使用率不上去。另外，一些task偶尔需要使用他们的所有资源(例如，在一天的高峰期或者受到了一个拒绝服务攻击)，大多时候用不上那么多资源。\n\n比起把那些分出来但不用的资源浪费掉，我们估计了一个task会用多少资源然后把其他的资源回收再利用给那些可以忍受低质量资源的工作，例如批处理job。这整个过程被叫做资源再利用(resource reclamation)。这个估值叫做task自留地资源(reservation)，被Borgmaster每过几秒就计算一次，是Borglet抓取的细粒度资源消费用率。最初的自留地资源被设置的和资源限制一样大；在300s之后，也就是启动那个阶段，自留地资源会缓慢的下降到实际用量加上一个安全值。自留地资源在实际用量超过它的时候会迅速上升。\n\nBorg调度器(scheduler)使用限制资源来计算prod task的可用性($3.2)，所以这些task从来不依赖于回收的资源，也不提供超售的资源；对于non-prod的task，使用了目前运行task的自留地资源，这么新的task可以被调度到回收资源。\n\n一台机器有可能因为自留地预估错度而导致运行时资源不足 —— 即使所有的task都在限制资源之内跑。如果这种情况发生了，我们杀掉或者限制non-prod task，从来不对prod task下手。\n\n![Fig. 10](/img/borg-fig-10.png)\n\n图10展示了如果没有资源再利用会需要更多的机器。在一个中等大小的Cell上大概有20%的工作负载跑在回收资源上。\n\n![Fig. 11](/img/borg-fig-11.png)\n\n图11可以看到更多的细节，包括回收资源、实际使用资源和限制资源的比例。一个超内存限制的task首先会被重新调度，不管优先级有多高，所以这样就很少有task会超过内存限制。另一方面，CPU使用率是可以轻易被卡住的，所以短期的超过自留地资源的高峰时没什么损害的。\n\n图11暗示了资源再利用可能是没必要的保守：在自留地和实际使用中间有一大片差距。为了测试这一点，我们选择了一个生产cell然后调试它的预估参数到一个激进策略上，把安全区划小点，然后做了一个介于激进和基本之间的中庸策略跑，然后恢复到基本策略。\n\n![Fig. 12](/img/borg-fig-12.png)\n\n图12展现了结果。第二周自留地资源和实际资源的差值是最小的，比第三周要小，最大的是第一和第四周。和预期的一样，周2和周3的OOM率有一个轻微的提升。在复查了这个结果后，我们觉得利大于弊，于是把中庸策略的参数放到其他cell上部署运行。\n\n# 6. 隔离性\n\n50%的机器跑9个以上的task；最忙的10%的机器大概跑25个task，4500个线程[83]。虽然在应用间共享机器会增加使用率，也需要一个比较好的机制来保证task之间不互相冲突。包括安全和性能都不能互相冲突。\n\n## 6.1 安全隔离\n\n我们使用Linux chroot监狱作为同一台机器不同task之间主要的安全隔离机制。为了允许远程debug，我们以前会分发ssh key来自动给用户权限去访问跑他们task的机器，现在不这么干了。对大多数用户来说，现在提供的是borgssh命令，这个程序和Borglet协同，来构建一个ssh shell，这个shell和task运行在同样的chroot和cgroup下，这样限制就更加严格了。\n\nVM和安全沙箱技术被使用在外部的软件上，在Google’s AppEngine (GAE) [38]和Google Compute Engine (GCE)环境下。我们把KVM进程中的每个hosted VM按照一个Borg task运行。\n\n## 6.2 性能隔离\n\n早期的Borglet使用了一种相对原始粗暴的资源隔离措施：事后内存、硬盘、CPU使用率检查，然后终止使用过多内存和硬盘的task，或者把用太多CPU的激进task通过Linux CPU优先级降下来。不过，很多粗暴的task还是很轻易的能影响同台机器上其他task的性能，然后很多用户就会多申请资源来让Borg减少调度的task数量，然后会导致系统资源利用率降低。资源回收可以弥补一些损失，但不是全部，因为要保证资源安全红线。在极端情况下，用户请求使用专用的机器或者cell。\n\n目前，所有Borg task都跑在Linux cgroup-based资源容器[17,58,62]里面，Borglet操作这些容器的设置，这样就增强了控制因为操作系统内核在起作用。即使这样，偶尔还是有低级别的资源冲突(例如内存带宽和L3缓存污染)还是会发生，见[60,83]\n\n为了搞定超负荷和超请求，Borg task有一个应用阶级(appclass)。最主要的区分在于延迟敏感latency-sensitive (LS)的应用和其他应用的区别，其他应用我们在文章里面叫batch。LS task是包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS task得到最高有待，可以为了这个把batch task一次饿个几秒种。\n\n第二个区分在于可压缩资源(例如CPU循环，disk I/O带宽)都是速率性的可以被回收的，对于一个task可以降低这些资源的量而不去杀掉task；和不可压缩资源(例如内存、硬盘空间)这些一般来说不杀掉task就没法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会杀掉task，从低优先级开始杀，直到剩下的自留地资源够用。如果机器用完了可压缩资源，Borglet会卡住使用率这样当短期高峰来到时不用杀掉任何task。如果情况没有改善，Borgmaster会从这个机器上去除一个或多个task。\n\nBorglet的用户空间控制循环在未来预期的基础上给prod task分配内存，在内存压力基础上给non-prod task分配内存；从内核事件来处理Out-of-Memory (OOM)；杀掉那些想获取超过自身限制内存的task，或者在一个超负载的机器上实际超过负载时。Linux的积极文件缓存策略让我们的实现更负载一点，因为精确计算内存用量会麻烦很多。\n\n为了增强性能隔离，LS task可以独占整个物理CPU核，不让别的LS task来用他们。batch task可以在任何核上面跑，不过他们只被分配了很少的和LS task共享的资源。Borglet动态的调整贪婪LS task的资源限制来保证他们不会把batch task饿上几分钟，有选择的在需要时使用CFS带宽控制[75]；光有共享是不行的，我们有多个优先级。\n\n![Fig. 13](/img/borg-fig-13.png)\n\n就像Leverich [56]，我们发现标准的Linux CPU调度(CFS)需要大幅调整来支持低延迟和高使用率。为了减少调度延迟，我们版本的CFS使用了额外的每cgroup历史[16]，允许LS task驱逐batch task，并且避免多个LS task跑在一个CPU上的调度量子效应(scheduling quantum，译者：或许指的是互相冲突？)。幸运的是，大多我们的应用使用的每个线程处理一个请求模型，这样就缓和了持久负载不均衡。我们节俭地使用cpusets来分配CPU核给有特殊延迟需求的应用。这些措施的一部分结果展现在图13里面。我们持续在这方面投入，增加了线程部署和CPU管理包括NUMA超线程、能源觉察(例如[81])，增加Borglet的控制精确度。\n\nTask被允许在他们的限制范围内消费资源。其中大部分task甚至被允许去使用更多的可压缩资源例如CPU，充分利用没有被使用的资源。大概5%的LS task禁止这么做，主要是为了增加可预测性；小于1%的batch task也禁止。使用超量内存默认是被禁止的，因为这会增加task被杀的概率，不过即使这样，10%的LS task打开了这个限制，79%的batch task也开了因为这事MapReduce框架默认的。这事对资源再回收($5.5)的一个补偿。Batch task很乐意使用没有被用起来的内存，也乐意不时的释放一些可回收的内存：大多情况下这跑的很好，即使有时候batch task会被急需资源的LS task杀掉。\n\n【编者的话】最后两章探讨的是相关工作和改进。从中可以看到从Borg到Kubernetes，他们也做了不少思考，而这方面的工作远远没有完善，一直在进行中。期待大家都能从Google的实践中学到一些东西，并分享出来。\n\n# 7. 相关工作\n\n资源调度在各个领域已经被研究了数十年了，包括在广域HPC超算集群中，在工作站网络中，在大规模服务器集群中。我们主要聚焦在最相关的大规模服务器集群这个领域。\n\n最近的一些研究分析了集群趋势，来自于Yahoo、Google、和Facebook[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载在规模和异构化方面碰到的挑战。[69]包含了这些集群管理架构的分类。\n\nApache Mesos [45]把资源管理和应用部署做了分离，资源管理由中心管理器(类似于Bormaster+scheduler)和多种类的“框架”比如Hadoop [41]和Spark [73]，使用offer-based的机制。Borg则主要把这些几种在一起，使用request-based的机制，可以大规模扩展。DRF [29, 35, 36, 66]策略是内赋在Mesos里的；Borg则使用优先级和配额认证来替代。Mesos开发者已经宣布了他们的雄心壮志：推测性资源分配和回收，然后把[69]里面的问题都解决。\n\nYARN [76]是一个Hadoop中心集群管理。每个应用都有一个管理器和中央资源管理器谈判；这和2008年开始Google MapReduce从Borg获取资源如出一辙。YARN的资源管理器最近才能容错。一个相关的开源项目是Hadoop Capacity Scheduler [42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近被扩展成支持多种资源类型、优先级、驱逐、和高级权限控制[21]。俄罗斯方块原型[40]支持了最大完工时间觉察的job打包。\n\nFacebook的Tupperware [64]，是一个类Borg系统来调度cgroup容器；虽然只有少量资料泄露，看起来他也提供资源回收利用功能。Twitter有一个开源的Aurora[5]，一个类Borg的长进程调度器，跑在Mesos智商，有一个类似于Borg的配置语言和状态机。\n\n来自于微软的Autopilot[48]提供了“自动化的软件部署和开通；系统监控，以及在软硬件故障时的修复操作”给微软集群。Borg生态系统提供了相同的特性，不过还有没说完的；Isaard [48]概括和很多我们想拥护的最佳实践。\n\nQuincy[49]使用了一个网络流模型来提供公平性和数据局部性在几百个节点的DAG数据处理上。Borg用的是配额和优先级在上万台机器上把资源分配给用户。Quincy处理直接执行图在Borg之上。\n\nCosmos [44]聚焦在批处理上，重点在于用户获得对集群捐献的资源进行公平获取。它使用一个每job的管理器来获取资源；没有更多公开的细节。\n\n微软的Apollo系统[13]使用了一个每job的调度器给短期存活的batch job使用，在和Borg差不多量级的集群下获取高流量输出。Apollo使用了一个低优先级后台任务随机执行策略来增加资源利用率，代价是有多天的延迟。Apollo几点提供一个预测矩阵，关于启动时间为两个资源维度的函数。然后调度器会综合计算启动开销、远程数据获取开销来决定部署到哪里，然后用一个随机延时来避免冲突。Borg用的是中央调度器来决定部署位置，给予优先级分配处理更多的资源维度，而且更关注高可用、长期跑的应用；Apollo也许可以处理更多的task请求并发。\n\n阿里巴巴的Fuxi(译者：也就是伏羲啦) [84]支撑数据分析的负载，从2009年开始运行。就像Borgmaster，一个中央的FuxiMaster(也是做了高可用多副本)从节点上获取可用的资源信息、接受应用的资源请求，然后做匹配。伏羲增加了和Borg完全相反的调度策略：伏羲把最新的可用资源分配给队列里面请求的任务。就像Mesos，伏羲允许定义“虚拟资源”类型。只有系统的工作负载输出是公开的。\n\nOmega [69]支持多并行，特别是“铅垂线”策略，粗略相当于Borgmaster加上它的持久存储和link shards(连接分配)。Omega调度器用的是乐观并行的方式去控制一个共享的cell观察和预期状态，把这些状态放在一个中央的存储里面，和Borglet用独立的连接器进行同步。Omega架构。Omage架构是被设计出来给多种不同的工作负载，这些工作负载都有自己的应用定义的RPC接口、状态机和调度策略(例如长期跑的服务端程序、多个框架下的batch job、存储基础设施、GCE上的虚拟机)。形成对比的是，Borg提供了一种“万灵药”，同样的RPC接口、状态机语义、调度策略，随着时间流逝规模和复杂度增加，需要支持更多的不同方式的负载，而可可扩展性目前来说还不算一个问题($3.4)\n\nGoogle的开源Kubernetes系统[53]把应用放在Docker容器内[28]，分发到多机器上。它可以跑在物理机(和Borg一样)或跑在其他云比如GCE提供的主机上。Kubernetes的开发者和Borg是同一拨人而且正在狂开发中。Google提供了一个云主机版本叫Google Container Engine [39]。我们会在下一节里面讨论从Borg中学到了哪些东西用在了Kubernetes上。\n\n在高性能计算社区有一些这个领域的长期传统工作(e.g., Maui, Moab, Platform LSF [2, 47, 50])；但是这和Google Cell所需要的规模、工作负载、容错性是完全不一样的。大概来说，这些系统通过让很多任务等待在一个长队列里面来获取极高的资源利用率。\n\n虚拟化提供商例如VMware [77]和数据中心方案提供商例如HP and IBM [46]给了一个大概在1000台机器量级的集群解决方案。另外，一些研究小组用几种方式提升了资源调度质量(e.g., [25, 40, 72, 74])。\n\n最后，就像我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]写了如何做故障计划、多租户、健康检查、权限控制、和重启动性来获得更大的机器数/操作员比。Borg的设计哲学也是这样的，让我们的一个SRE能支撑超过万台机器。\n\n# 8. 经验教训和未来工作\n\n在这一节中我们会聊一些十年以来我们在生产环境操作Borg得到的定性经验，然后描述下这些观察结果是怎么改善Kubernete[53]的设计。\n\n## 8.1 教训\n\n我们会从一些受到吐槽的Borg特性开始，然后说说Kubernetes是怎么干的。\n\n**Jobs是唯一的task分组的机制。**Borg没有天然的方法去管理多个job组成单个实体，或者去指向相关的服务实例(例如，金丝雀和生产跟踪)。作为hack，用户把他们的服务拓扑编码写在job名字里面，然后用更高层的工具区解析这些名字。这个问题的另外一面是，没办法去指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级和改变job的实例数。\n\n为了避免这些困难，Kubernetes不用job这个概念，而是用标签(label)来管理它的调度单位(pods)，标签是任意的键值对，用户可以把标签打在系统的所有对象上。这样，对于一个Borg job，就可以在pod上打上job:jobname这样的标签，其他的有用的分组也可以用标签来表示，例如服务、层级、发布类型(生产、测试、阶段)。Kubernetes用标签选择这种方式来选取对象，完成操作。这样就比固定的job分组更加灵活好用。\n\n**一台机器一个IP把事情弄复杂了。**在Borg里面，所有一台机器上的task都使用同一个IP地址，然后共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；task必须先声明他们需要多少端口，然后了解启动的时候哪些可以用；Borglet必须完成端口隔离；命名和RPC系统必须和IP一样处理端口。\n\n非常感谢Linux namespace，虚拟机，IPv6和软件定义网络SDN。Kubernetes可以用一种更用户友好的方式来消解这些复杂性：所有pod和service都可以有一个自己的IP地址，允许开发者选择端口而不是委托基础设施来帮他们选择，这些就消除了基础设置管理端口的复杂性。\n\n**给资深用户优化而忽略了初级用户。**Borg提供了一大堆针对“资深用户”的特性这样他们可以仔细的调试怎么跑他们的程序(BCL有230个参数的选项)：开始的目的是为了支持Google的大资源用户，提升他们的效率会带来更大的效益。但是很不幸的是这么复杂的API让初级用户用起来很复杂，约束了他们的进步。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中来决定合理的配置。这就让皮实的应用从实验中获得了自由：即使自动化出了麻烦的问题也不会导致灾难。\n\n## 8.2 经验\n\n另一方面，有不少Borg的设计是非常有益的，而且经历了时间考验。\n\n**Allocs是有用的。**Borg alloc抽象导出了广泛使用的logsaver样式($2.4)和另一个流行样式：定期数据载入更新的web server。Allocs和packages允许这些辅助服务能被一个独立的小组开发。Kubernetes相对于alloc的设计是pod，是一个多个容器共享的资源封装，总是被调度到同一台机器上。Kubernetes用pod里面的辅助容器来替代alloc里面的task，不过思想是一样的。\n\n**集群管理比task管理要做更多的事。**虽然Borg的主要角色是管理tasks和机器的生命周期，但Borg上的应用还是从其他的集群服务中收益良多，例如命名和负载均衡。Kubernetes用service抽象来支持命名和负载均衡：service有一个名字，用标签选择器来选择多个pod。在底下，Kubernetes自动的在这个service所拥有的pod之间自动负载均衡，然后在pod挂掉后被重新调度到其他机器上的时候也保持跟踪来做负载均衡。\n\n**反观自省是至关重要的。**虽然Borg基本上是“just works”的，但当有出了问题后，找到这个问题的根源是非常有挑战性的。一个关键设计抉择是Borg把所有的debug信息暴露给用户而不是隐藏：Borg有几千个用户，所以“自助”是debug的第一步。虽然这会让我们很难抛弃一些用户依赖的内部策略，但这还是成功的，而且我们没有找到其他现实的替代方式。为了管理这么巨量的资源，我们提供了几层UI和debug工具，这样就可以升入研究基础设施本身和应用的错误日志和事件细节。\n\nKubernetes也希望重现很多Borg的自探查技术。例如它和cAdvisor [15] 一切发型用于资源监控，用Elasticsearch/Kibana [30] 和 Fluentd [32]来做日志聚合。从master可以获取一个对象的状态快照。Kubernetes有一个一致的所有组件都能用的事件记录机制(例如pod被调度、容器挂了)，这样客户端就能访问。\n\n**master是分布式系统的核心.**Borgmaster原来被设计成一个单一的系统，但是后来，它变成了服务生态和用户job的核心。比方说，我们把调度器和主UI(Sigma)分离出来成为单独的进程，然后增加了权限控制、纵向横向扩展、重打包task、周期性job提交(cron)、工作流管理，系统操作存档用于离线查询。最后，这些让我们能够提升工作负载和特性集，而无需牺牲性能和可维护性。\n\nKubernetes的架构走的更远一些：它有一个API服务在核心，仅仅负责处理请求和维护底下的对象的状态。集群管理逻辑做成了一个小的、微服务类型的客户端程序和API服务通信，其中的副本管理器(replication controller)，维护在故障情况下pod的服务数量，还有节点管理器(node controller)，管理机器生命周期。\n\n## 8.3 总结\n\n在过去十年间所有几乎所有的Google集群负载都移到了Borg上。我们将会持续改进，并把学到的东西应用到Kubernetes上。\n\n#鸣谢\n\n这篇文章的作者同时也评审了这篇文章。但是几十个设计、实现、维护Borg组件和生态系统工程师才是这个系统成功的关键。我们在这里列表设计、实现、操作Borgmaster和Borglet的主要人员。如有遗漏抱歉。\n\nBorgmaster主设计师和实现者有Jeremy Dion和Mark Vandevoorde，还有Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu, Monika Henzinger。Borglet的主要设计实现者是Paul Menage。\n\n其他贡献者包括Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, OnufryWojtaszczyk, Patrick Johnson, Pedro Valenzuela, PiotrWitusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, TomaszWozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.\n\nBorg SRE团队也是非常重要的，包括Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, and Viraj Alankar。Borg配置语言(BCL)和borgcfg工具是Marcel van Lohuizen, Robert Griesemer制作的。\n\n谢谢我们的审稿人(尤其是especially Eric Brewer, Malte Schwarzkopf and Tom Rodeheffer)，以及我们的牧师Christos Kozyrakis，对这篇论文的反馈。\n\n#参考文献\n\n[1] O. A. Abdul-Rahman and K. Aida. Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon. In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.\n\n[2] Adaptive Computing Enterprises Inc., Provo, UT. MauiScheduler Administrator’s Guide, 3.2 edition, 2011.\n\n[3] T. Akidau, A. Balikov, K. Bekiro˘glu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. MillWheel: fault-tolerant stream processing at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.\n\n[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. An opportunity cost approach for job assignment in a scalable computing cluster. IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.\n\n[5] Apache Aurora.http://aurora.incubator.apache.org/, 2014.\n\n[6] Aurora Configuration Tutorial. https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014.\n\n[7] AWS. Amazon Web Services VM Instances. http://aws.amazon.com/ec2/instance-types/, 2014.\n\n[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. Megastore: Providing scalable, highly available storage for interactive services. In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.\n\n[9] M. Baker and J. Ousterhout. Availability in the Sprite distributed file system. Operating Systems Review,25(2):95–98, Apr. 1991.\n\n[10] L. A. Barroso, J. Clidaras, and U. H¨olzle. The datacenter as a computer: an introduction to the design of warehouse-scale machines. Morgan Claypool Publishers, 2nd edition, 2013.\n\n[11] L. A. Barroso, J. Dean, and U. Holzle. Web search for a planet: the Google cluster architecture. In IEEE Micro, pages 22–28, 2003.\n\n[12] I. Bokharouss. GCL Viewer: a study in improving the understanding of GCL programs. Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.\n\n[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. Apollo: scalable and coordinated scheduling for cloud-scale computing. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.\n\n[14] M. Burrows. The Chubby lock service for loosely-coupled distributed systems. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.\n\n[15] cAdvisor. https://github.com/google/cadvisor, 2014\n\n[16] CFS per-entity load patches. http://lwn.net/Articles/531853, 2013.\n\n[17] cgroups. http://en.wikipedia.org/wiki/Cgroups, 2014.\n\n[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. FlumeJava: easy, efficient data-parallel pipelines. In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.\n\n[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. Bigtable: a distributed storage system for structured data. ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.\n\n[20] Y. Chen, S. Alspaugh, and R. H. Katz. Design insights for MapReduce from diverse production workloads. Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.\n\n[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. Reservation-based scheduling: if you’re late don’t blame us! In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.\n\n[22] J. Dean and L. A. Barroso. The tail at scale. Communications of the ACM, 56(2):74–80, Feb. 2012.\n\n[23] J. Dean and S. Ghemawat. MapReduce: simplified data processing on large clusters. Communications of the ACM, 51(1):107–113, 2008.\n\n[24] C. Delimitrou and C. Kozyrakis. Paragon: QoS-aware scheduling for heterogeneous datacenters. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.\n\n[25] C. Delimitrou and C. Kozyrakis. Quasar: resource-efficient and QoS-aware cluster management. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.\n\n[26] S. Di, D. Kondo, and W. Cirne. Characterization and comparison of cloud versus Grid workloads. In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.\n\n[27] S. Di, D. Kondo, and C. Franck. Characterizing cloud applications on a Google data center. In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.\n\n[28] Docker Project. https://www.docker.io/, 2014.\n\n[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. No justified complaints: on fair sharing of multiple resources. In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.\n\n[30] ElasticSearch. http://www.elasticsearch.org, 2014.\n\n[31] D. G. Feitelson. Workload Modeling for Computer Systems Performance Evaluation. Cambridge University Press, 2014.\n\n[32] Fluentd. http://www.fluentd.org/, 2014.\n\n[33] GCE. Google Compute Engine. http: //cloud.google.com/products/compute-engine/, 2014.\n\n[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. The Google File System. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.\n\n[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. Dominant Resource Fairness: fair allocation of multiple resource types. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.\n\n[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. Choosy: max-min fair sharing for datacenter jobs with constraints. In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.\n\n[37] D. Gmach, J. Rolia, and L. Cherkasova. Selling T-shirts and time shares in the cloud. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.\n\n[38] Google App Engine. http://cloud.google.com/AppEngine, 2014.\n\n[39] Google Container Engine (GKE). https://cloud.google.com/container-engine/, 2015.\n\n[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. Multi-resource packing for cluster schedulers. In Proc. ACM SIGCOMM, Aug. 2014.\n\n[41] Apache Hadoop Project. http://hadoop.apache.org/, 2009.\n\n[42] Hadoop MapReduce Next Generation – Capacity Scheduler. http: //hadoop.apache.org/docs/r2.2.0/hadoop-yarn/ hadoop-yarn-site/CapacityScheduler.html, 2013.\n\n[43] J. Hamilton. On designing and deploying internet-scale services. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.\n\n[44] P. Helland. Cosmos: big data and big challenges. http://research.microsoft.com/en-us/events/ fs2011/helland_cosmos_big_data_and_big\\ _challenges.pdf, 2011.\n\n[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. Mesos: a platform for fine-grained resource sharing in the data center. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.\n\n[46] IBM Platform Computing. http://www-03.ibm.com/ systems/technicalcomputing/platformcomputing/ products/clustermanager/index.html.\n\n[47] S. Iqbal, R. Gupta, and Y.-C. Fang. Planning considerations for job scheduling in HPC clusters. Dell Power Solutions, Feb. 2005.\n\n[48] M. Isaard. Autopilot: Automatic data center management. ACM SIGOPS Operating Systems Review, 41(2), 2007.\n\n[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. Quincy: fair scheduling for distributed computing clusters. In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.\n\n[50] D. B. Jackson, Q. Snell, and M. J. Clement. Core algorithms of the Maui scheduler. In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.\n\n[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. Measuring interference between live datacenter applications. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.\n\n[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. An analysis of traces from a production MapReduce cluster. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.\n\n[53] Kubernetes. http://kubernetes.io, Aug. 2014.\n\n[54] Kernel Based Virtual Machine. http://www.linux-kvm.org.\n\n[55] L. Lamport. The part-time parliament. ACM Trans. on Computer Systems, 16(2):133–169, May 1998.\n\n[56] J. Leverich and C. Kozyrakis. Reconciling high server utilization and sub-millisecond quality-of-service. In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.\n\n[57] Z. Liu and S. Cho. Characterizing machines and workloads on a Google cluster. In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.\n\n[58] Google LMCTFY project (let me contain that for you). http://github.com/google/lmctfy, 2014.\n\n[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. Pregel: a system for large-scale graph processing. In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.\n\n[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations. In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.\n\n[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. Dremel: interactive analysis of web-scale datasets. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.\n\n[62] P. Menage. Linux control groups. http://www.kernel. org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.\n\n[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. Towards characterizing cloud backend workloads: insights from Google compute clusters. ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.\n\n[64] A. Narayanan. Tupperware: containerized deployment at Facebook. http://www.slideshare.net/dotCloud/ tupperware-containerized-deployment-at-facebook, June 2014.\n\n[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. Sparrow: distributed, low latency scheduling. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.\n\n[66] D. C. Parkes, A. D. Procaccia, and N. Shah. Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities. In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.\n\n[67] Protocol buffers. https: //developers.google.com/protocol-buffers/, and https://github.com/google/protobuf/., 2014.\n\n[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. Heterogeneity and dynamicity of clouds at scale: Google trace analysis. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n\n[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. Omega: flexible, scalable schedulers for large compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n\n[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. Modeling and synthesizing task placement constraints in Google compute clusters. In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.\n\n[71] E. Shmueli and D. G. Feitelson. On simulation and design of parallel-systems schedulers: are we doing the right thing? IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.\n\n[72] A. Singh, M. Korupolu, and D. Mohapatra. Server-storage virtualization: integration and load balancing in data centers. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.\n\n[73] Apache Spark Project. http://spark.apache.org/, 2014.\n\n[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n\n[75] P. Turner, B. Rao, and N. Rao. CPU bandwidth control for CFS. In Proc. Linux Symposium, pages 245–254, July 2010.\n\n[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. Apache Hadoop YARN: Yet Another Resource Negotiator. In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.\n\n[77] VMware VCloud Suite. http://www.vmware.com/products/vcloud-suite/.\n\n[78] A. Verma, M. Korupolu, and J. Wilkes. Evaluating job packing in warehouse-scale computing. In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.\n\n[79] W. Whitt. Open and closed models for networks of queues. AT&T Bell Labs Technical Journal, 63(9), Nov. 1984.\n\n[80] J. Wilkes. More Google cluster data. http://googleresearch.blogspot.com/2011/11/ more-google-cluster-data.html, Nov. 2011.\n\n[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. HaPPy: Hyperthread-aware power profiling dynamically. In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.\n\n[82] Q. Zhang, J. Hellerstein, and R. Boutaba. Characterizing task usage shapes in Google’s compute clusters. In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.\n\n[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. CPI2: CPU performance isolation for shared compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n\n[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. Fuxi: a fault-tolerant resource management and job scheduling system at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.\n\n# 勘误 2015-04-23\n\n自从胶片版定稿后，我们发现了若干疏忽和歧义。\n\n## 用户视角\n\nSRE干的比SA(system administration)要多得多：他们是Google生产服务的负责工程师。他们设计和实现软件，包括自动化系统、管理应用、底层基础设施服务来保证Google这个量级的高可靠和高性能。\n\n## 鸣谢\n\n我们不小心忽略了Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, and Pavanish Nirula。\n\n## 参考文献\n\n[1] Michael Litzkow, Miron Livny, and Matt Mutka. \"Condor - A Hunter of Idle Workstations\". In Proc. Int'l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.\n\n[2] Rajesh Raman, Miron Livny, and Marvin Solomon. \"Matchmaking: Distributed Resource Management for High Throughput Computing\". In Proc. Int'l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.\n\n","source":"_posts/eurosys15-borg-cn.md","raw":"title: 【译文修订】使用Borg在Google管理大规模集群\ncategory: cloud\ndate: 2017-10-31\ntags:\n\n---\n\n发表于EuroSys 2015的 ***Large-scale cluster management at Google with Borg*** 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。\n\n\n<!--more-->\n\n---\n\n**Large-scale cl uster management at Google with Borg**\n\n作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes\n\nhttp://research.google.com/pubs/pub43438.html 或 直接 [下载PDF全文](/doc/EuroSys15_Borg.pdf)\n\n译者：难易 http://my.oschina.net/HardySimpson\n\nEuroSys’15, http://dx.doi.org/10.1145/2741948.2741964\n\n# 摘要\n\n谷歌的Borg系统群集管理器运行几十万个以上的jobs，来自几千个不同的应用，跨多个集群，每个集群有上万个机器。\n\n它通过管理控制、高效的任务包装、超售、和进程级别性能隔离实现了高利用率。它支持高可用性应用程序与运行时功能，最大限度地减少故障恢复时间，减少相关故障概率的调度策略。Borg简化了用户生活，通过提供一个声明性的工作规范语言，名称服务集成，实时作业监控，和分析和模拟系统行为的工具。\n\n我们将会展现Borg系统架构和特点，重要的设计决策，定量分析它的一些策略，和十年以来的运维经验和学到的东西。\n\n# 1. 简介\n\n集群管理系统我们内部叫Borg，它管理、调度、开始、重启和监控谷歌运行的应用程序的生命周期。本文介绍它是怎么做到这些的。\n\nBorg提供了三个主要的好处：它（1）隐藏资源管理和故障处理细节，使其用户可以专注于应用开发；（2）高可靠性和高可用性的操作，并支持应用程序做到高可靠高可用；（3）让我们在跨数以万计的机器上有效运行。Borg不是第一个来解决这些问题的系统，但它是在这个规模，这种程度的弹性和完整性下运行的为数不多的几个系统之一。\n\n本文围绕这些主题来编写，包括了我们在生产环境运行十年的一些功力。\n\n![Fig. 1](/img/borg-fig-01.png)\n\n# 2.用户视角\n\nBorg的用户是谷歌开发人员和系统管理员(网站可靠性工程师 SRE)，他们运行谷歌应用与服务。用户以job的方式提交他们的工作给Borg，job由一个或多个task组成，每个task含有同样的二进制程序。一个job在一个Borg的Cell里面跑，一个Cell是包括了多台机器的单元。这一节主要讲用户视角下的Borg系统。\n\n## 2.1 工作负载\n\nBorg Cell主要运行两种异构的工作负载。第一种是长期的服务，应该“永远”运行下去，并处理短时间的敏感请求（几微秒到几百毫秒）。这种服务是面向终端用户的产品如Gmail、Google Docs、网页搜索，内部基础设施服务（例如，Bigtable）。第二种是批处理任务，需要几秒到几天来完成，对短期性能波动不敏感。在一个Cell上混合运行了这两种负载，取决于他们的主要租户（比如说，有些Cell就是专门用来跑密集的批处理任务的）。工作负载也随着时间会产生变化：批处理任务做完就好，终端用户服务的负载是以每天为周期的。Borg需要把这两种情况都处理好。\n\nBorg有一个2011年5月的负载数据[80]，已经被广泛的分析了[68,26，27，57，1]。\n\n最近几年，很多应用框架是搭建在Borg上的，包括我们内部的MapReduce[23]、flumejava[18]、Millwheel[3]、Pregel[59]。这中间的大部分都是有一个控制器，可以提交job。前2个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和他的后继者CFS、Bigtable[19]、Megastore[8]都是跑在Borg上的。\n\n在这篇文章里面，我们把高优先级的Borg的jobs定义为生产(prod)，剩下的是非生产的(non-prod)。大多长期服务是prod的，大部分批处理任务是non-prod的。在一个典型的Cell里面，prod job分配了70%的CPU资源然后实际用了60%；分配了55%的内存资源然后实际用了85%。在$5.5会展示分配和实际值的差是很重要的。\n\n## 2.2 集群和Cell\n\n一个Cell里面的所有机器都属于单个集群，集群是由高性能的数据中心级别的光纤网络连接起来的。一个集群安装在数据中心的一座楼里面，n座楼合在一起成为一个site。一个集群通常包括一个大的Cell还有一些小的或测试性质的Cell。我们尽量避免任何单点故障。\n\n在测试的Cell之外，我们中等大小的Cell大概包括10000台机器；一些Cell还要大很多。一个Cell中的机器在很多方面都是异构的：大小(CPU,RAM,disk,network)、处理器类型、性能以及外部IP地址或flash存储。Borg隔离了这些差异，让用户单纯的选择用哪个Cell来跑任务，分配资源、安装程序和其它依赖、监控系统的健康并在故障时重启。\n\n(译者：Cell其实就是逻辑上的集群)\n\n## 2.3 job和task\n\n一个Borg的job的属性有：名字、拥有者和有多少个task。job可以有一些约束，来指定这个job跑在什么架构的处理器、操作系统版本、是否有外部IP。约束可以是硬的或者软的。一个job可以指定在另一个job跑完后再开始。一个job只在一个Cell里面跑。\n\n每个task包括了一组linux进程，跑在一台机器的一个容器内[62]。大部分Borg的工作负载没有跑在虚拟机(VM)里面，因为我们不想付出虚拟化的代价。而且，Borg在设计的时候还没硬件虚拟化什么事儿哪。\n\ntask也有一些属性，包括资源用量，在job中的排序。大多task的属性和job的通用task属性是一样的，也可以被覆盖 —— 例如，提供task专用的命令行参数，包括CPU核、内存、磁盘空间、磁盘访问速度、TCP端口等等，这些都是可以分别设置并按照一个好的粒度提供。我们不提供固定的资源的单元。Borg程序都是静态编译的，这样在跑的环境下就没有依赖，这些程序都被打成一个包，包括二进制和数据文件，能被Borg安装起来。\n\n用户通过RPC来操作Borg的job，大多是从命令行工具，或者从我们的监控系统($2.6)。大多job描述文件是用一种申明式配置文件BCL -- GCL[12]的一个变种，会产生一个protobuf文件[67]。BCL有一些自己的关键字。GCL提供了lambda表达式来允许计算，这样就能让应用在环境里面调整自己的配置。上万个BCL配置文件超过一千行长，系统中累计跑了了千万行BCL。Borg的job配置很类似于Aurora配置文件[6]。\n\n![Fig. 2](/img/borg-fig-02.png)\n\n图2展现了job的和task的状态机和生命周期。\n\n用户可以在运行时改变一个job中的task的属性，通过推送一个新的job配置给Borg。这个新的配置命令Borg更新task的规格。这就像是跑一个轻量级的，非原子性的事务，而且可以在提交后轻易再改回来。更新是滚动式的，在更新中可以限制task重启的数量，如果有太多task停掉，操作可以终止。\n\n一些task更新，例如更新二进制程序，需要task重启；另外一些例如修改资源需求和限制会导致这个机器不适合跑现有的task，需要停止task再重新调度到别的机器上；还有一些例如修改优先级是可以不用重启或者移动task的。\n\ntask需要能够接受Unix的SIGTERM信号，在他们被强制发送SIGKILL之前，这样就有时间去做清理、保存状态、结束现有请求执行、拒绝新请求。实际的notice的delay bound。实践中，80%的task能正常处理终止信号。\n\n## 2.4 Allocs\n\nBorg的alloc(allocation的缩写)是在单台机器上的一组保留的资源配额，用来让一个或更多的task跑；这些资源一直分配在那边，无论有没有被用。allocs可以被分配出来给未来的task，用来保持资源在停止一个task和重启这个task之间，用来聚集不同jobs的tasks到同一台机器上——例如一个web server实例和附加的，用于把serverURL日志发送到一个分布式文件系统的日志搜集实例。一个alloc的资源管理方式和一台机器上的资源管理方式是类似的；多个tasks在一个alloc上跑并共享资源。如果一个alloc必须被重新定位到其他的机器上，那么它的task也要跟着重新调度。\n\n一个alloc set就像一个job：它是一组allocs保留了多台机器上的资源。一旦alloc set被创建，一个或多个jobs就可以被提交进去跑。简而言之，我们会用task来表示一个alloc或者一个top-level task(一个alloc之外的)，用job来表示一个job或者alloc set。\n\n## 2.5 优先级、配额和管理控制\n\n当有超量的工作负载在运行的时候会发生什么事情？我们的解决方案是优先级和配额。\n\n所有job都有优先级，一个小的正整数。高优先级的task可以优先获取资源，即使后面被杀掉。Borg定义了不重叠的优先级段给不同任务用，包括(优先级降序)：监控、生产、批任务、高性能(测试或免费)。在这篇文章里面，prod的jobs是在监控和生产段。\n\n虽然一个降级的task总会在cell的其他地方找到一席之地。降级瀑布也有可能会发生，就是一个task降下来之后，把下面运行的task再挤到别的机器上，如此往复。为了避免这种情况，我们禁止了prod级task互相排挤。合理粒度的优先级在其他场景下也很有用——MapReduce的master跑的优先级比worker高一点，来保证他们的可用性。\n\n优先级是jobs的相对重要性，决定了jobs在一个cell里面是跑还是等(pending)。配额则是用来决定jobs是否运行被调度。配额就是一组资源(CPU, RAM, disk)的数量在一个指定的优先级、一个指定的时间段(月这个量级)。数量决定了这个用户的job可以用的最多资源(例子：20TB内存和prod优先级从现在到7月在xx cell内)。配额检查是管理控制的一部分，不是调度层的：配额不足的任务在提交的时候就会被拒绝。\n\n高优先级的配额总是花费的比低优先级要多。prod级的配额是被限制为一个cell里面实际的资源量，所以用户提交了prod级的job的配额时，可以期待这个job一定会跑，去掉一些碎片外。即使这样，我们鼓励用户多买一点比自己需要多一点的配额，很多用户超买是因为他们的应用程序的用户数量增长后需要的配额就大了。对于超买，我们的应对方案是低优先级资源的超售：所有用户在0优先级都可以用无限的配额，虽然在实际运行中这种情况很难跑起来。一个低优先级的job在资源不足时会保持等(pending)状态。\n\n配额分配在Borg系统之外，和我们的物理资源计划有关。这些资源计划在不同的数据中心产生不同的价格和配额。用户jobs只在有足够配额和足够优先级之后才能启动。配额的使用让Dominant Resource Fairness(DRF)[29, 35, 36, 66]不是那么必要了。\n\nBorg有一个容量系统给一些特殊权限给某些用户，例如，允许管理员删除或修改cell里面的job，或者允许用户区访问特定的内核特性或者让Borg对自己的job不做资源估算($5.5)。\n\n## 2.6 命名和监控\n\n光是创建和部署task是不够的：一个服务的客户端和其他系统需要能找到它们，即使它换了个地方。为了搞定这一点，Borg创造了一个稳定的“Borg name Service”(BNS)名字给每个task，这个名字包括了cell名字，job名字，和task编号。Borg把task的主机名和端口写入到一个持久化高可用文件里，以BNS名为文件名，放在Chubby[14]上。这个文件被我们的RPC系统使用，用来发现task的终端地址。BNS名称也是task的DNS名的基础构成部分，所以，cc cell的ubar用户的jfoo job的第50个task的DNS名称会是50.jfoo.ubar.cc.borg.google.com。Borg同时还会把job的大小和task的健康信息写入到Chubby在任何情况改变时，这样负载均衡就能知道怎么去路由请求了。\n\n几乎所有的Borg的task都会包含一个内置的HTTP服务，用来发布健康信息和几千个性能指标(例如RPC延时)。Borg监控这些健康检查URL，把其中响应超时的和error的task重启。其他数据也被监控工具追踪并在Dashboards上展示，当服务级别对象(SLO)出问题时就会报警。\n\n用户可以使用一个名叫Sigma的web UI，用来检查他们所有的job状态，一个特殊的cell，或者深入到某个job的某个task的资源用率，详细日志，操作历史，和最终命运。我们的应用产生大量的日志，都会被自动的滚动来避免塞满硬盘，会在一个task结束后保留一小段时间用来debug。如果一个job没有被跑起来，Borg会提供一个为什么挂起的解释，指导用户怎么修改这个job的资源需求来符合目前这个cell的情况。我们发布资源的使用方针，按照这个方针来做就容易被调度起来。\n\nBorg记录所有的job提交和task时间，以及每task的资源使用细节在基础存储服务里面。这个存储服务有一个分布式的只读的SQL-like的交互式接口，通过Dremel[61]提供出来。这些数据在实时使用、debug、系统查错和长期容量规划上都很有用。这些数据也是Google集群负载追踪的数据来源之一[80].\n\n所有这些特性帮助用户理解和debug Borg的行为和管理他们的job，并且帮助我们的SRE每个人管理超过上万台机器。\n\n# 3. Borg架构\n\n一个Borg的Cell包括一堆机器，一个逻辑的中心控制服务叫做Borgmaster，和在每台机器上跑的Borglet的agent进程(见图1)。所有Borg的组件都是用C++写的。\n\n![Fig. 1](/img/borg-fig-01.png)\n\n## 3.1 Borgmaster\n\nCell的Borgmaster由2个进程组成，主的Borgmaster进程和一个单独的scheduler($3.2)。主的Borgmaster处理所有客户端的RPC请求，例如修改状态(创建job)，提供数据读取服务(查找job)。它同时管理系统中所有组件(机器、task、allocs等等)的状态机，和Borglet通信，并且提供一个Sigma的备份Web UI。\n\nBorgmaster在逻辑上是一个单进程，但实际上开了5个副本。每个副本维护了一个内存级别的cell状态拷贝，这些状态同时被记录在一个高可用、分布式、Paxos-based存储[55]放在这些副本的本地硬盘上。在一个cell里面，一个单独的被选举出来的master同时用于Paxos leader和状态修改器，用来处理所有改变cell状态的请求，例如提交一个job或者在一个机器上终止一个task。当cell启动或前一个master挂了时，Paxos算法会选举出一个master；这需要一个Chubby锁然后其他系统可以找到master。选举一个master或者换一个新的需要的典型事件是10s，但需要大概1分钟才能让一个大的cell内生效，因为一些内存状态要重构。当一个副本从网络隔离中恢复时，需要动态的从其他Paxos副本中重新同步自己的状态。\n\n某个时刻的Borgmaster的状态被称为checkpoint，会被以快照形式+change log形式保存在Paxos存储里面。checkpoints有很多用途，包括把Borgmaster的状态恢复到以前的任意时刻(例如在处理一个请求之前，用来解决软件缺陷)；极端情况下手动修改checkpoints，形成一个持续的事件日志供今后用；或用于线下的在线仿真。\n\n一个高仿真的Borgmaster叫Fauxmaster，可以用来读取checkpoint文件，包括一份完整的Borgmaster的代码，和Borglet的存根接口。它接受RPC来改变状态机和执行操作，例如调度所有阻塞的tasks，我们用它来debug错误，和它交互就和Borgmaster交互是一样的，同样我们也有一个仿真的Borglet可以用checkpoint重放真实的交互。用户可以单步调试看到系统中的所有过去的改变。Fauxmaster在这种情况下也很有用：多个这个类型的job比较合适？以及在改变cell配置前做一个安全检查(这个操作会把任何关键jobs给踢掉吗？)\n\n## 3.2 调度 schedule\n\n当一个job被提交的时候，Borgmaster会把它持久化的存储在Paxos存储上，然后把这个job的task放到等待(pending)的队列里面去。这个队列会被scheduler异步的扫描，然后分发task到有充足资源的机器上。scheduler主要是处理task的，不是job。扫描从高优先级到低优先级，在同个优先级上用round-robin的方式处理，以保证用户之间的公平性和避免头上的大job阻塞住。调度算法有2个部分：可行性检查(feasibility checking)，找到一台能跑task的机器，和打分(scoring)，找个一个最合适的机器。\n\n在可行性检查这个阶段，scheduler会找到一组机器，都满足task的约束而且有足够可用的资源 —— 包括了一些已经分配给低优先级任务的可以被腾出来的资源。在打分阶段，scheduler会找到其中“最好”的机器。这个分数包括了用户的偏好，但主要是被内置的标准：例如最小化的倒腾其他task，找到已经有这个task安装包的，在电力和出错的可用域之间尽可能分散的，在单台机器上混合高低优先级的task以保证高峰期扩容的。\n\nBorg原来用E-PVM[4]的变种算法来打分，在异构的资源上生成一个单一的分数，在调度一个task时最小化系统的改变。但在实践中，E-PVM最后把负载平均分配到所有机器，把扩展空间留给高峰期 —— 但这么做的代价是增加了碎片，尤其是对于大的task需要大部分机器的时候；我们有时候给这种分配取绰号叫“最差匹配”。\n\n分配策略光谱的另一端是“最佳匹配”，把机器塞任务塞的越紧越好。这样就能留下一些空的机器给用户jobs(他们也跑存储服务)，所以处理大task就比较直接了，不过，紧分配会惩罚那些对自己所需资源预估不足的用户。这种策略会伤害爆发负载的应用，而且对需要低CPU的批处理任务特别不友好，这些任务可以被轻易调度到不用的资源上：20%的non-prod task需要小于0.1核的CPU。\n\n我们目前的打分模型是一个混合的，试图减少搁浅的资源 —— 一些因为这台机器上资源没被全部用掉而剩下的。比起“最佳匹配”，这个模型提供了3%-5%的打包效率提升(在[78]里面定义的)\n\n如果一台机器在打分后没有足够的资源运行新的task，Borg会驱逐(preempts)低优先级的任务，从最低优先级往上踢，直到资源够用。我们把被踢掉的task放到scheduler的等待(pending)队列里面去，而不是迁移或冬眠这些task。\n\ntask启动延迟(从job提交到task运行之间的时间段)是被我们持续关注的。这个时间差别很大，一般来说是25s。包安装耗费了这里面80%的时间：一个已知的瓶颈就是对本地硬盘的争抢。为了减少task启动时间，scheduler希望机器上已经有足够的包(程序和数据)：大部分包是只读的所以可以被分享和缓存。这是唯一一种Borg scheduler支持的数据本地化方式。顺便说一下，Borg分发包到机器的办法是树形的和BT类型的协议。\n\n另外，scheduler用了某些技术来扩散到几万台机器的cell里面。($3.4)\n\n## 3.3 Borglet\n\nBorglet是部署在cell的每台机器上的本地Borg代理程序。它启动停止task；如果task失败就重启；通过修改OS内核设置来管理本地资源；滚动debug日志；把本机的状态上报给Borgmaster和其他监控系统。\n\nBorgmaster每过几秒就会轮询所有的Borglet来获取机器当前的状态还有发送任何请求。这让Borgmaster能控制交流频率，避免一个显式的流控机制，而且防止了恢复风暴[9].\n\n选举出来的master负责发送消息给Borglet并且根据响应更新cell的状态。为了性能可扩展，每个Borgmaster副本会运行一个无状态的连接分配(link shard)来处理和特定几个Borglet的交流；这个分配会在Borgmaster选举的时候重新计算。为了保证弹性，Borglet把所有状态都报上来，但是link shard会聚合和压缩这些信息到状态机，来减少选举出来的master的负载。\n\n如果Borglet几次没有响应轮询请求，将会被标记为挂了(down)，然后上面跑的task会被重新分配到其他机器。如果通讯恢复，Borgmaster会让这个Borglet杀掉已经被分配出去的task，来避免重复。Borglet会继续常规的操作即使和Borgmaster恢复联系，所以目前跑的task和service保持运行以防所有的Borgmaster挂了。\n\n## 3.4 可扩展性\n\n我们还不知道Borg的可扩展性极限在哪里，每次我们碰到一个极限，我们就越过去。一个单独的Borgmaster可以管理一个cell里面几千台机器，若干个cell可以处理10000个任务每分钟。一个繁忙的Borgmaster使用10-14个CPU核以及50GB内存。我们用了几项技术来获得这种扩展性。\n\n早期的Borgmaster有一个简单的，同步的循环来处理请求、调度tasks，和Borglet通信。为了处理大的cell，我们把scheduler分出来作为一个单独的进程，然后就可以和别的Borgmaster功能并行的跑，别的Borgmaster可以开副本来容错。一个scheduler副本操作一份cell的状态拷贝。它重复地：从选举出来的master获取状态改变(包括所有的分配的和pending的工作)；更新自己的本地拷贝，做调度工作来分配task；告诉选举出来的master这些分配。master会接受这些信息然后应用之，除非这些信息不适合(例如，过时了)，这些会在scheduler的下一个循环里面处理。这一切都符合Omega[69]的乐观并行策略精神，而且我们最近真的给Borg添加这种功能，对不同的工作负载用不同的scheduler来调度。\n\n为了改进响应时间，我们增加了一些独立线程和Borglet通信、响应只读RPC。为了更高的性能，我们分享(分区)这些请求给5个Borgmaster副本$3.3。最后，这让99%的UI响应在1s以内，而95%的Borglet轮询在10s以内。\n\n一些让Borg scheduler更加可扩展的东西：\n\n分数缓存：评估一台机器的可用性和分数是比较昂贵的，所以Borg会一直缓存分数直到这个机器或者task变化了——例如，这台机器上的task结束了，一些属性修改了，或者task的需求改变了。忽略小的资源变化让缓存保质期变长。\n\n同级别均化处理：同一个Borg job的task一般来说有相同的需求和资源，所以不用一个个等待的task每次都去找可用机器，这会把所有可用的机器打n次分。Borg会对相同级别的task找一遍可用机器打一次分。\n\n适度随机：把一个大的Cell里面的所有机器都去衡量一遍可用性和打分是比较浪费的。所以scheduler会随机的检查机器，找到足够多的可用机器去打分，然后挑出最好的一个。这会减少task进入和离开系统时的打分次数和缓存失效。适度随机有点像Sparrow [65]的批处理采样技术，同样要面对优先级、驱逐、非同构系统和包安装的耗费。\n\n在我们的实验中($5)，调度整个cell的工作负载要花几百秒，但不用上面几项技术的话会花3天以上的时间。一般来说，一个在线的调度从等待队列里面花半秒就能搞定。\n\n# 4. 可用性\n\n![Fig. 3](/img/borg-fig-03.png)\n\n在大型分布式系统里面故障是很常见的[10,11,12]。图3展示了在15个cell里面task驱逐的原因。在Borg上跑的应用需要能处理这种事件，应用要支持开副本、存储数据到分布式存储这些技术，并能定期的做快照。即使这样，我们也尽可能的缓和这些事件造成的影响。例如，Borg：\n\n自动的重新调度被驱逐的task，如果需要放到新机器上运行\n通过把一个job分散到不同的可用域里面去，例如机器、机架、供电域\n在机器、OS升级这些维护性工作时，降低在同一时刻的一个job中的task的关闭率\n使用声明式的目标状态表示和幂等的状态改变做操作，这样故障的客户端可以无损的重新启动或安全的遗忘请求\n对于失联的机器上的task，限制一定的比率去重新调度，因为很难去区分大规模的机器故障和网络分区\n避免特定的会造成崩溃的task:机器的匹配\ncritical级别的中间数据写到本地硬盘的日志保存task很重要，就算这个task所属的alloc被终止或调度到其他机器上，也要恢复出来做。用户可以设置系统保持重复尝试多久：若干天是比较合理的做法。\n一个关键的Borg设计特性是：就算Borgmaster或者Borglet挂了，task也会继续运行下去。不过，保持master运行也很重要，因为在它挂的时候新的jobs不能提交，或者结束的无法更新状态，故障的机器上的task也不能重新调度。\n\nBorgmaster使用组合的技术在实践中保证99.99%的可用性：副本技术应对机器故障；管理控制应对超载；部署实例时用简单、底层的工具去减少外部依赖(译者：我猜测是rsync或者scp这种工具)。每个cell和其他cell都是独立的，这样减少了误操作关联和故障传染。为了达到这个目的，所以我们不搞大cell。\n\n# 5. 使用效率\n\nBorg的一个主要目的就是有效的利用Google的机器舰队，这可是一大笔财务投资：让效率提升几个百分点就能省下几百万美元。这一节讨论了和计算了一些Borg使用的技术和策略。\n\n## 5.1 测度方法论\n\n我们的job部署是有资源约束的，而且很少碰到负载高峰，我们的机器是异构的，我们从service job回收利用的资源跑batch job。所以，为了测量我们需要一个比“平均利用率”更抽象的标准。在做了一些实验后我们选择了cell密度(cell compaction)：给定一个负载，我们不断的从零开始(这样可以避免被一个倒霉的配置卡住)，部署到尽可能小的Cell里面去，直到再也不能从这个cell里面抽机器出来。这提供了一个清晰的终止条件，并促进了无陷阱的自动化比较，这里的陷阱指的是综合化的工作负载和建模[31]。一个定量的比较和估算技术可以看[78]，有不少微妙的细节。\n\n我们不可能在线上的cell做性能实验，所以我们用了Fauxmaster来达到高保真的模拟效果，使用了真的在线cell的负载数据包括所有的约束、实际限制、保留和常用数据($5.5)。这些数据从2014-10-1 14:00 PDT的Borg快照(checkpoints)里面提取出来。(其他快照也产生类似的结论)。我们选取了15个Borg cell来出报告，先排除了特殊目的的、测试的、小的(<5000机器)的cell，然后从剩下的各种量级大小的cell中平均取样。\n\n在压缩cell实验中为了保持机器异构性，我们随机选择去掉的机器。为了保持工作负载的异构性，我们保留了所有负载，除了那些对服务和存储需要有特定需求的。我们把那些需要超过一半cell的job的硬限制改成软的，允许不超过0.2%的task持续的pending如果它们过于挑剔机器；广泛的测试表明这些结果是可重复的。如果我们需要一个大的cell，就把原cell复制扩大；如果我们需要更多的cell，就复制几份cell。\n\n所有的实验都每个cell重复11次，用不同的随机数发生器。在图上，我们用一个横线来表示最少和最多需要的机器，然后选择90%这个位置作为结果，平均或者居中的结论不会代表一个系统管理员会做的最优选择。我们相信cell压缩提供了一个公平一致的方式去比较调度策略：好的策略只需要更少的机器来跑相同的负载。\n\n我们的实验聚焦在调度(打包)某个时间点的一个负载，而不是重放一段长期的工作踪迹。这部分是因为复制一个开放和关闭的队列模型比较困难，部分是因为传统的一段时间内跑完的指标和我们环境的长期跑服务不一样，部分是因为这样比较起来比较明确，部分是因为我们相信怎么整都差不多，部分是因为我们在消费20万个Borg CPU来做测试——即使在Google的量级，这也不是一个小数目(译者：就你丫理由多！)\n\n![Fig. 4](/img/borg-fig-04.png)\n\n在生产环境下，我们谨慎的留下了一些顶部空间给负载的增加，比如一些“黑天鹅”时间，负载高峰，机器故障，硬件升级，以及大范围故障(供电进灰)。图4显示了我们在现实世界中可以把cell压缩到多小。上面的基线是用来表示压缩大小的。\n\n## 5.2 Cell的共享使用\n\n几乎我们所有的机器都同时跑prod和non-prod的task：在共享Borg cell里有98%的机器同时跑这2种task，在所有Borg管理的机器里面有83%同时跑这2种task(我们有一些专用的Cell跑特定任务)。\n\n![Fig. 5](/img/borg-fig-05.png)\n\n鉴于很多其他的组织把面向用户应用和批处理应用在不同的集群上运行，我们设想一下如果我们也这么干会发生什么情况。图5展现了在一个中等大小的Cell上分开跑我们prod和non-prod的工作负载将需要20-30%多的机器。这是因为prod的job通常会保留一些资源来应对极少发生的负载高峰，但实际上在大多情况下不会用这些资源。Borg把这批资源回收利用了($5.5)来跑很多non-prod的工作，所以最终我们只需要更少的机器。\n\n![Fig. 6](/img/borg-fig-06.png)\n\n大部分Borg cell被几千个用户共享使用。图6展现了为什么。对这个测试，如果一个用户消费超过了10TiB内存(或100TiB)，我们就把这个用户的工作负载分离到一个单独的Cell里面去。我们目前的策略展现了它的威力：即使我们设置了这么高的阈值(来分离)，也需要2-16倍多的Cell，和20-150%多的机器。资源池的方案再次有效地节省了开销。\n\n但是，或许把很多不相关的用户和job类型打包放到一台机器上，会造成CPU冲突，然后就需要更多的机器进行补偿？为了验证这一点，我们看一下在同一台机器，锁定时钟周期，每指令循环数CPI(cycles per instruction)在不同环境的task下是怎么变化的。在这种情况下，CPI是一个可比较的指标而且可以代表冲突度量，因为2倍的CPI意味着CPU密集型程序要跑2倍的时间。这些数据是从一周内12000个随机的prod的task中获取的，用硬件测量工具[83]取的，并且对采样做了权重，这样每秒CPU都是平等的。测试结果不是非常明显。\n\n我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及(强相关)这个机器上同时跑的task数量；每往一台机器上增加1个task，就会增加0.3%的CPI(线性模型过滤数据)；增加一台10%的CPU使用率，就会增加小于2%的CPI。即使这已经是一个统计意义显著的正相关性，也只是解释了我们在CPI度量上看到的5%的变化，还有其他的因素支配着这个变化，例如应用程序固有的差别和特殊的干涉图案[24,83]。\n\n比较我们从共享Cell和少数只跑几种应用的专用Cell获取的CPI采样，我们看到共享Cell里面的CPI平均值为1.58(σ=0.35,方差)，专用Cell的CPI平均值是1.53(σ=0.32,方差).也就是说，共享Cell的性能差3%。\n\n为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差(或许对冲突更敏感的程序会被挪到专用Cell里面去)，我们观察了Borglet的CPI，在所有Cell的所有机器上都会被运行。我们发现专用Cell的CPI平均值是1.20(σ=0.29,方差)，而共享Cell里面的CPI平均值为1.43(σ=0.45,方差)，暗示了在专用Cell上运行程序会比在共享Cell上快1.19倍，这就超过了CPU使用量轻负载的这个因素，轻微的有利于专用Cell。\n\n这些实验确定了仓库级别的性能测试是比较微妙的，加强了[51]中的观察，并且得出了共享并没有显著的增加程序运行的开销。\n\n不过，就算我们假设用了我们结果中最不好的数据，共享还是有益的：比起CPU的降速，在各个方案里面减少机器更重要，这会带来减少所有资源的开销，包括内存和硬盘，不仅仅是CPU。\n\n## 5.3 大Cell\n\n![Fig. 7](/img/borg-fig-07.png)\n\nGoogle建立了大Cell，为了允许大的任务运行，也是为了降低资源碎片。我们通过把负载从一个cell分到多个小cell上来测试后面那个效应(降低碎片效应)，随机的把job用round-robin方式分配出去。图7展示了用很多小cell会明显的需要更多机器。\n\n## 5.4 资源请求粒度\n\n![Fig. 8](/img/borg-fig-08.png)\n\nBorg用户请求的CPU单位是千分之一核，内存和硬盘单位是byte。(1核是一个CPU的超线程，在不同机器类型中的一个通用单位)。图8展现了这个粒度的好处：CPU核和内存只有少数的“最佳击球点”，以及这些资源很少的相关性。这个分布和[68]里面的基本差不多，除了我们看到大内存的请求在90%这个线上。\n\n![Fig. 9](/img/borg-fig-09.png)\n\n提供一个固定尺寸的容器和虚拟机，在IaaS(infrastructure-as-a-service)提供商里面或许是比较流行的，但不符合我们的需求。为了展现这一点，我们把CPU核和内存限制做成一个个尺寸，然后把prod的job按照大一点最近的尺寸去跑(取这2个维度的平方值之和最近，也就是2维图上的直线)，0.5核的CPU,1G的内存为差值。图9显示了一般情况下我们需要30-50%多的资源来运行。上限来自于把大的task跑在一整台机器上，这些task即使扩大四倍也没办法在原有Cell上压缩跑。下限是允许这些task等待(pending)。(这比[37]里面的数据要大100%，因为我们支持超过4中尺寸而且允许CPU和内存无限扩张)。\n\n## 5.5 资源再利用\n\n一个job可以声明一个限制资源，是每个task能强制保证的资源上限。Borg会先检查这个限制是不是在用户的配额内，然后检查具体的机器是否有那么多资源来调度这个task。有的用户会买超过他们需要的配额，也有用户会的task实际需要更多的资源去跑，因为Borg会杀掉那些需要更多的内存和硬盘空间的task，或者卡住CPU使用率不上去。另外，一些task偶尔需要使用他们的所有资源(例如，在一天的高峰期或者受到了一个拒绝服务攻击)，大多时候用不上那么多资源。\n\n比起把那些分出来但不用的资源浪费掉，我们估计了一个task会用多少资源然后把其他的资源回收再利用给那些可以忍受低质量资源的工作，例如批处理job。这整个过程被叫做资源再利用(resource reclamation)。这个估值叫做task自留地资源(reservation)，被Borgmaster每过几秒就计算一次，是Borglet抓取的细粒度资源消费用率。最初的自留地资源被设置的和资源限制一样大；在300s之后，也就是启动那个阶段，自留地资源会缓慢的下降到实际用量加上一个安全值。自留地资源在实际用量超过它的时候会迅速上升。\n\nBorg调度器(scheduler)使用限制资源来计算prod task的可用性($3.2)，所以这些task从来不依赖于回收的资源，也不提供超售的资源；对于non-prod的task，使用了目前运行task的自留地资源，这么新的task可以被调度到回收资源。\n\n一台机器有可能因为自留地预估错度而导致运行时资源不足 —— 即使所有的task都在限制资源之内跑。如果这种情况发生了，我们杀掉或者限制non-prod task，从来不对prod task下手。\n\n![Fig. 10](/img/borg-fig-10.png)\n\n图10展示了如果没有资源再利用会需要更多的机器。在一个中等大小的Cell上大概有20%的工作负载跑在回收资源上。\n\n![Fig. 11](/img/borg-fig-11.png)\n\n图11可以看到更多的细节，包括回收资源、实际使用资源和限制资源的比例。一个超内存限制的task首先会被重新调度，不管优先级有多高，所以这样就很少有task会超过内存限制。另一方面，CPU使用率是可以轻易被卡住的，所以短期的超过自留地资源的高峰时没什么损害的。\n\n图11暗示了资源再利用可能是没必要的保守：在自留地和实际使用中间有一大片差距。为了测试这一点，我们选择了一个生产cell然后调试它的预估参数到一个激进策略上，把安全区划小点，然后做了一个介于激进和基本之间的中庸策略跑，然后恢复到基本策略。\n\n![Fig. 12](/img/borg-fig-12.png)\n\n图12展现了结果。第二周自留地资源和实际资源的差值是最小的，比第三周要小，最大的是第一和第四周。和预期的一样，周2和周3的OOM率有一个轻微的提升。在复查了这个结果后，我们觉得利大于弊，于是把中庸策略的参数放到其他cell上部署运行。\n\n# 6. 隔离性\n\n50%的机器跑9个以上的task；最忙的10%的机器大概跑25个task，4500个线程[83]。虽然在应用间共享机器会增加使用率，也需要一个比较好的机制来保证task之间不互相冲突。包括安全和性能都不能互相冲突。\n\n## 6.1 安全隔离\n\n我们使用Linux chroot监狱作为同一台机器不同task之间主要的安全隔离机制。为了允许远程debug，我们以前会分发ssh key来自动给用户权限去访问跑他们task的机器，现在不这么干了。对大多数用户来说，现在提供的是borgssh命令，这个程序和Borglet协同，来构建一个ssh shell，这个shell和task运行在同样的chroot和cgroup下，这样限制就更加严格了。\n\nVM和安全沙箱技术被使用在外部的软件上，在Google’s AppEngine (GAE) [38]和Google Compute Engine (GCE)环境下。我们把KVM进程中的每个hosted VM按照一个Borg task运行。\n\n## 6.2 性能隔离\n\n早期的Borglet使用了一种相对原始粗暴的资源隔离措施：事后内存、硬盘、CPU使用率检查，然后终止使用过多内存和硬盘的task，或者把用太多CPU的激进task通过Linux CPU优先级降下来。不过，很多粗暴的task还是很轻易的能影响同台机器上其他task的性能，然后很多用户就会多申请资源来让Borg减少调度的task数量，然后会导致系统资源利用率降低。资源回收可以弥补一些损失，但不是全部，因为要保证资源安全红线。在极端情况下，用户请求使用专用的机器或者cell。\n\n目前，所有Borg task都跑在Linux cgroup-based资源容器[17,58,62]里面，Borglet操作这些容器的设置，这样就增强了控制因为操作系统内核在起作用。即使这样，偶尔还是有低级别的资源冲突(例如内存带宽和L3缓存污染)还是会发生，见[60,83]\n\n为了搞定超负荷和超请求，Borg task有一个应用阶级(appclass)。最主要的区分在于延迟敏感latency-sensitive (LS)的应用和其他应用的区别，其他应用我们在文章里面叫batch。LS task是包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS task得到最高有待，可以为了这个把batch task一次饿个几秒种。\n\n第二个区分在于可压缩资源(例如CPU循环，disk I/O带宽)都是速率性的可以被回收的，对于一个task可以降低这些资源的量而不去杀掉task；和不可压缩资源(例如内存、硬盘空间)这些一般来说不杀掉task就没法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会杀掉task，从低优先级开始杀，直到剩下的自留地资源够用。如果机器用完了可压缩资源，Borglet会卡住使用率这样当短期高峰来到时不用杀掉任何task。如果情况没有改善，Borgmaster会从这个机器上去除一个或多个task。\n\nBorglet的用户空间控制循环在未来预期的基础上给prod task分配内存，在内存压力基础上给non-prod task分配内存；从内核事件来处理Out-of-Memory (OOM)；杀掉那些想获取超过自身限制内存的task，或者在一个超负载的机器上实际超过负载时。Linux的积极文件缓存策略让我们的实现更负载一点，因为精确计算内存用量会麻烦很多。\n\n为了增强性能隔离，LS task可以独占整个物理CPU核，不让别的LS task来用他们。batch task可以在任何核上面跑，不过他们只被分配了很少的和LS task共享的资源。Borglet动态的调整贪婪LS task的资源限制来保证他们不会把batch task饿上几分钟，有选择的在需要时使用CFS带宽控制[75]；光有共享是不行的，我们有多个优先级。\n\n![Fig. 13](/img/borg-fig-13.png)\n\n就像Leverich [56]，我们发现标准的Linux CPU调度(CFS)需要大幅调整来支持低延迟和高使用率。为了减少调度延迟，我们版本的CFS使用了额外的每cgroup历史[16]，允许LS task驱逐batch task，并且避免多个LS task跑在一个CPU上的调度量子效应(scheduling quantum，译者：或许指的是互相冲突？)。幸运的是，大多我们的应用使用的每个线程处理一个请求模型，这样就缓和了持久负载不均衡。我们节俭地使用cpusets来分配CPU核给有特殊延迟需求的应用。这些措施的一部分结果展现在图13里面。我们持续在这方面投入，增加了线程部署和CPU管理包括NUMA超线程、能源觉察(例如[81])，增加Borglet的控制精确度。\n\nTask被允许在他们的限制范围内消费资源。其中大部分task甚至被允许去使用更多的可压缩资源例如CPU，充分利用没有被使用的资源。大概5%的LS task禁止这么做，主要是为了增加可预测性；小于1%的batch task也禁止。使用超量内存默认是被禁止的，因为这会增加task被杀的概率，不过即使这样，10%的LS task打开了这个限制，79%的batch task也开了因为这事MapReduce框架默认的。这事对资源再回收($5.5)的一个补偿。Batch task很乐意使用没有被用起来的内存，也乐意不时的释放一些可回收的内存：大多情况下这跑的很好，即使有时候batch task会被急需资源的LS task杀掉。\n\n【编者的话】最后两章探讨的是相关工作和改进。从中可以看到从Borg到Kubernetes，他们也做了不少思考，而这方面的工作远远没有完善，一直在进行中。期待大家都能从Google的实践中学到一些东西，并分享出来。\n\n# 7. 相关工作\n\n资源调度在各个领域已经被研究了数十年了，包括在广域HPC超算集群中，在工作站网络中，在大规模服务器集群中。我们主要聚焦在最相关的大规模服务器集群这个领域。\n\n最近的一些研究分析了集群趋势，来自于Yahoo、Google、和Facebook[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载在规模和异构化方面碰到的挑战。[69]包含了这些集群管理架构的分类。\n\nApache Mesos [45]把资源管理和应用部署做了分离，资源管理由中心管理器(类似于Bormaster+scheduler)和多种类的“框架”比如Hadoop [41]和Spark [73]，使用offer-based的机制。Borg则主要把这些几种在一起，使用request-based的机制，可以大规模扩展。DRF [29, 35, 36, 66]策略是内赋在Mesos里的；Borg则使用优先级和配额认证来替代。Mesos开发者已经宣布了他们的雄心壮志：推测性资源分配和回收，然后把[69]里面的问题都解决。\n\nYARN [76]是一个Hadoop中心集群管理。每个应用都有一个管理器和中央资源管理器谈判；这和2008年开始Google MapReduce从Borg获取资源如出一辙。YARN的资源管理器最近才能容错。一个相关的开源项目是Hadoop Capacity Scheduler [42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近被扩展成支持多种资源类型、优先级、驱逐、和高级权限控制[21]。俄罗斯方块原型[40]支持了最大完工时间觉察的job打包。\n\nFacebook的Tupperware [64]，是一个类Borg系统来调度cgroup容器；虽然只有少量资料泄露，看起来他也提供资源回收利用功能。Twitter有一个开源的Aurora[5]，一个类Borg的长进程调度器，跑在Mesos智商，有一个类似于Borg的配置语言和状态机。\n\n来自于微软的Autopilot[48]提供了“自动化的软件部署和开通；系统监控，以及在软硬件故障时的修复操作”给微软集群。Borg生态系统提供了相同的特性，不过还有没说完的；Isaard [48]概括和很多我们想拥护的最佳实践。\n\nQuincy[49]使用了一个网络流模型来提供公平性和数据局部性在几百个节点的DAG数据处理上。Borg用的是配额和优先级在上万台机器上把资源分配给用户。Quincy处理直接执行图在Borg之上。\n\nCosmos [44]聚焦在批处理上，重点在于用户获得对集群捐献的资源进行公平获取。它使用一个每job的管理器来获取资源；没有更多公开的细节。\n\n微软的Apollo系统[13]使用了一个每job的调度器给短期存活的batch job使用，在和Borg差不多量级的集群下获取高流量输出。Apollo使用了一个低优先级后台任务随机执行策略来增加资源利用率，代价是有多天的延迟。Apollo几点提供一个预测矩阵，关于启动时间为两个资源维度的函数。然后调度器会综合计算启动开销、远程数据获取开销来决定部署到哪里，然后用一个随机延时来避免冲突。Borg用的是中央调度器来决定部署位置，给予优先级分配处理更多的资源维度，而且更关注高可用、长期跑的应用；Apollo也许可以处理更多的task请求并发。\n\n阿里巴巴的Fuxi(译者：也就是伏羲啦) [84]支撑数据分析的负载，从2009年开始运行。就像Borgmaster，一个中央的FuxiMaster(也是做了高可用多副本)从节点上获取可用的资源信息、接受应用的资源请求，然后做匹配。伏羲增加了和Borg完全相反的调度策略：伏羲把最新的可用资源分配给队列里面请求的任务。就像Mesos，伏羲允许定义“虚拟资源”类型。只有系统的工作负载输出是公开的。\n\nOmega [69]支持多并行，特别是“铅垂线”策略，粗略相当于Borgmaster加上它的持久存储和link shards(连接分配)。Omega调度器用的是乐观并行的方式去控制一个共享的cell观察和预期状态，把这些状态放在一个中央的存储里面，和Borglet用独立的连接器进行同步。Omega架构。Omage架构是被设计出来给多种不同的工作负载，这些工作负载都有自己的应用定义的RPC接口、状态机和调度策略(例如长期跑的服务端程序、多个框架下的batch job、存储基础设施、GCE上的虚拟机)。形成对比的是，Borg提供了一种“万灵药”，同样的RPC接口、状态机语义、调度策略，随着时间流逝规模和复杂度增加，需要支持更多的不同方式的负载，而可可扩展性目前来说还不算一个问题($3.4)\n\nGoogle的开源Kubernetes系统[53]把应用放在Docker容器内[28]，分发到多机器上。它可以跑在物理机(和Borg一样)或跑在其他云比如GCE提供的主机上。Kubernetes的开发者和Borg是同一拨人而且正在狂开发中。Google提供了一个云主机版本叫Google Container Engine [39]。我们会在下一节里面讨论从Borg中学到了哪些东西用在了Kubernetes上。\n\n在高性能计算社区有一些这个领域的长期传统工作(e.g., Maui, Moab, Platform LSF [2, 47, 50])；但是这和Google Cell所需要的规模、工作负载、容错性是完全不一样的。大概来说，这些系统通过让很多任务等待在一个长队列里面来获取极高的资源利用率。\n\n虚拟化提供商例如VMware [77]和数据中心方案提供商例如HP and IBM [46]给了一个大概在1000台机器量级的集群解决方案。另外，一些研究小组用几种方式提升了资源调度质量(e.g., [25, 40, 72, 74])。\n\n最后，就像我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]写了如何做故障计划、多租户、健康检查、权限控制、和重启动性来获得更大的机器数/操作员比。Borg的设计哲学也是这样的，让我们的一个SRE能支撑超过万台机器。\n\n# 8. 经验教训和未来工作\n\n在这一节中我们会聊一些十年以来我们在生产环境操作Borg得到的定性经验，然后描述下这些观察结果是怎么改善Kubernete[53]的设计。\n\n## 8.1 教训\n\n我们会从一些受到吐槽的Borg特性开始，然后说说Kubernetes是怎么干的。\n\n**Jobs是唯一的task分组的机制。**Borg没有天然的方法去管理多个job组成单个实体，或者去指向相关的服务实例(例如，金丝雀和生产跟踪)。作为hack，用户把他们的服务拓扑编码写在job名字里面，然后用更高层的工具区解析这些名字。这个问题的另外一面是，没办法去指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级和改变job的实例数。\n\n为了避免这些困难，Kubernetes不用job这个概念，而是用标签(label)来管理它的调度单位(pods)，标签是任意的键值对，用户可以把标签打在系统的所有对象上。这样，对于一个Borg job，就可以在pod上打上job:jobname这样的标签，其他的有用的分组也可以用标签来表示，例如服务、层级、发布类型(生产、测试、阶段)。Kubernetes用标签选择这种方式来选取对象，完成操作。这样就比固定的job分组更加灵活好用。\n\n**一台机器一个IP把事情弄复杂了。**在Borg里面，所有一台机器上的task都使用同一个IP地址，然后共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；task必须先声明他们需要多少端口，然后了解启动的时候哪些可以用；Borglet必须完成端口隔离；命名和RPC系统必须和IP一样处理端口。\n\n非常感谢Linux namespace，虚拟机，IPv6和软件定义网络SDN。Kubernetes可以用一种更用户友好的方式来消解这些复杂性：所有pod和service都可以有一个自己的IP地址，允许开发者选择端口而不是委托基础设施来帮他们选择，这些就消除了基础设置管理端口的复杂性。\n\n**给资深用户优化而忽略了初级用户。**Borg提供了一大堆针对“资深用户”的特性这样他们可以仔细的调试怎么跑他们的程序(BCL有230个参数的选项)：开始的目的是为了支持Google的大资源用户，提升他们的效率会带来更大的效益。但是很不幸的是这么复杂的API让初级用户用起来很复杂，约束了他们的进步。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中来决定合理的配置。这就让皮实的应用从实验中获得了自由：即使自动化出了麻烦的问题也不会导致灾难。\n\n## 8.2 经验\n\n另一方面，有不少Borg的设计是非常有益的，而且经历了时间考验。\n\n**Allocs是有用的。**Borg alloc抽象导出了广泛使用的logsaver样式($2.4)和另一个流行样式：定期数据载入更新的web server。Allocs和packages允许这些辅助服务能被一个独立的小组开发。Kubernetes相对于alloc的设计是pod，是一个多个容器共享的资源封装，总是被调度到同一台机器上。Kubernetes用pod里面的辅助容器来替代alloc里面的task，不过思想是一样的。\n\n**集群管理比task管理要做更多的事。**虽然Borg的主要角色是管理tasks和机器的生命周期，但Borg上的应用还是从其他的集群服务中收益良多，例如命名和负载均衡。Kubernetes用service抽象来支持命名和负载均衡：service有一个名字，用标签选择器来选择多个pod。在底下，Kubernetes自动的在这个service所拥有的pod之间自动负载均衡，然后在pod挂掉后被重新调度到其他机器上的时候也保持跟踪来做负载均衡。\n\n**反观自省是至关重要的。**虽然Borg基本上是“just works”的，但当有出了问题后，找到这个问题的根源是非常有挑战性的。一个关键设计抉择是Borg把所有的debug信息暴露给用户而不是隐藏：Borg有几千个用户，所以“自助”是debug的第一步。虽然这会让我们很难抛弃一些用户依赖的内部策略，但这还是成功的，而且我们没有找到其他现实的替代方式。为了管理这么巨量的资源，我们提供了几层UI和debug工具，这样就可以升入研究基础设施本身和应用的错误日志和事件细节。\n\nKubernetes也希望重现很多Borg的自探查技术。例如它和cAdvisor [15] 一切发型用于资源监控，用Elasticsearch/Kibana [30] 和 Fluentd [32]来做日志聚合。从master可以获取一个对象的状态快照。Kubernetes有一个一致的所有组件都能用的事件记录机制(例如pod被调度、容器挂了)，这样客户端就能访问。\n\n**master是分布式系统的核心.**Borgmaster原来被设计成一个单一的系统，但是后来，它变成了服务生态和用户job的核心。比方说，我们把调度器和主UI(Sigma)分离出来成为单独的进程，然后增加了权限控制、纵向横向扩展、重打包task、周期性job提交(cron)、工作流管理，系统操作存档用于离线查询。最后，这些让我们能够提升工作负载和特性集，而无需牺牲性能和可维护性。\n\nKubernetes的架构走的更远一些：它有一个API服务在核心，仅仅负责处理请求和维护底下的对象的状态。集群管理逻辑做成了一个小的、微服务类型的客户端程序和API服务通信，其中的副本管理器(replication controller)，维护在故障情况下pod的服务数量，还有节点管理器(node controller)，管理机器生命周期。\n\n## 8.3 总结\n\n在过去十年间所有几乎所有的Google集群负载都移到了Borg上。我们将会持续改进，并把学到的东西应用到Kubernetes上。\n\n#鸣谢\n\n这篇文章的作者同时也评审了这篇文章。但是几十个设计、实现、维护Borg组件和生态系统工程师才是这个系统成功的关键。我们在这里列表设计、实现、操作Borgmaster和Borglet的主要人员。如有遗漏抱歉。\n\nBorgmaster主设计师和实现者有Jeremy Dion和Mark Vandevoorde，还有Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu, Monika Henzinger。Borglet的主要设计实现者是Paul Menage。\n\n其他贡献者包括Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, OnufryWojtaszczyk, Patrick Johnson, Pedro Valenzuela, PiotrWitusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, TomaszWozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.\n\nBorg SRE团队也是非常重要的，包括Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, and Viraj Alankar。Borg配置语言(BCL)和borgcfg工具是Marcel van Lohuizen, Robert Griesemer制作的。\n\n谢谢我们的审稿人(尤其是especially Eric Brewer, Malte Schwarzkopf and Tom Rodeheffer)，以及我们的牧师Christos Kozyrakis，对这篇论文的反馈。\n\n#参考文献\n\n[1] O. A. Abdul-Rahman and K. Aida. Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon. In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.\n\n[2] Adaptive Computing Enterprises Inc., Provo, UT. MauiScheduler Administrator’s Guide, 3.2 edition, 2011.\n\n[3] T. Akidau, A. Balikov, K. Bekiro˘glu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. MillWheel: fault-tolerant stream processing at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.\n\n[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. An opportunity cost approach for job assignment in a scalable computing cluster. IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.\n\n[5] Apache Aurora.http://aurora.incubator.apache.org/, 2014.\n\n[6] Aurora Configuration Tutorial. https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014.\n\n[7] AWS. Amazon Web Services VM Instances. http://aws.amazon.com/ec2/instance-types/, 2014.\n\n[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. Megastore: Providing scalable, highly available storage for interactive services. In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.\n\n[9] M. Baker and J. Ousterhout. Availability in the Sprite distributed file system. Operating Systems Review,25(2):95–98, Apr. 1991.\n\n[10] L. A. Barroso, J. Clidaras, and U. H¨olzle. The datacenter as a computer: an introduction to the design of warehouse-scale machines. Morgan Claypool Publishers, 2nd edition, 2013.\n\n[11] L. A. Barroso, J. Dean, and U. Holzle. Web search for a planet: the Google cluster architecture. In IEEE Micro, pages 22–28, 2003.\n\n[12] I. Bokharouss. GCL Viewer: a study in improving the understanding of GCL programs. Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.\n\n[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. Apollo: scalable and coordinated scheduling for cloud-scale computing. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.\n\n[14] M. Burrows. The Chubby lock service for loosely-coupled distributed systems. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.\n\n[15] cAdvisor. https://github.com/google/cadvisor, 2014\n\n[16] CFS per-entity load patches. http://lwn.net/Articles/531853, 2013.\n\n[17] cgroups. http://en.wikipedia.org/wiki/Cgroups, 2014.\n\n[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. FlumeJava: easy, efficient data-parallel pipelines. In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.\n\n[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. Bigtable: a distributed storage system for structured data. ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.\n\n[20] Y. Chen, S. Alspaugh, and R. H. Katz. Design insights for MapReduce from diverse production workloads. Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.\n\n[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. Reservation-based scheduling: if you’re late don’t blame us! In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.\n\n[22] J. Dean and L. A. Barroso. The tail at scale. Communications of the ACM, 56(2):74–80, Feb. 2012.\n\n[23] J. Dean and S. Ghemawat. MapReduce: simplified data processing on large clusters. Communications of the ACM, 51(1):107–113, 2008.\n\n[24] C. Delimitrou and C. Kozyrakis. Paragon: QoS-aware scheduling for heterogeneous datacenters. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.\n\n[25] C. Delimitrou and C. Kozyrakis. Quasar: resource-efficient and QoS-aware cluster management. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.\n\n[26] S. Di, D. Kondo, and W. Cirne. Characterization and comparison of cloud versus Grid workloads. In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.\n\n[27] S. Di, D. Kondo, and C. Franck. Characterizing cloud applications on a Google data center. In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.\n\n[28] Docker Project. https://www.docker.io/, 2014.\n\n[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. No justified complaints: on fair sharing of multiple resources. In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.\n\n[30] ElasticSearch. http://www.elasticsearch.org, 2014.\n\n[31] D. G. Feitelson. Workload Modeling for Computer Systems Performance Evaluation. Cambridge University Press, 2014.\n\n[32] Fluentd. http://www.fluentd.org/, 2014.\n\n[33] GCE. Google Compute Engine. http: //cloud.google.com/products/compute-engine/, 2014.\n\n[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. The Google File System. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.\n\n[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. Dominant Resource Fairness: fair allocation of multiple resource types. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.\n\n[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. Choosy: max-min fair sharing for datacenter jobs with constraints. In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.\n\n[37] D. Gmach, J. Rolia, and L. Cherkasova. Selling T-shirts and time shares in the cloud. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.\n\n[38] Google App Engine. http://cloud.google.com/AppEngine, 2014.\n\n[39] Google Container Engine (GKE). https://cloud.google.com/container-engine/, 2015.\n\n[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. Multi-resource packing for cluster schedulers. In Proc. ACM SIGCOMM, Aug. 2014.\n\n[41] Apache Hadoop Project. http://hadoop.apache.org/, 2009.\n\n[42] Hadoop MapReduce Next Generation – Capacity Scheduler. http: //hadoop.apache.org/docs/r2.2.0/hadoop-yarn/ hadoop-yarn-site/CapacityScheduler.html, 2013.\n\n[43] J. Hamilton. On designing and deploying internet-scale services. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.\n\n[44] P. Helland. Cosmos: big data and big challenges. http://research.microsoft.com/en-us/events/ fs2011/helland_cosmos_big_data_and_big\\ _challenges.pdf, 2011.\n\n[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. Mesos: a platform for fine-grained resource sharing in the data center. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.\n\n[46] IBM Platform Computing. http://www-03.ibm.com/ systems/technicalcomputing/platformcomputing/ products/clustermanager/index.html.\n\n[47] S. Iqbal, R. Gupta, and Y.-C. Fang. Planning considerations for job scheduling in HPC clusters. Dell Power Solutions, Feb. 2005.\n\n[48] M. Isaard. Autopilot: Automatic data center management. ACM SIGOPS Operating Systems Review, 41(2), 2007.\n\n[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. Quincy: fair scheduling for distributed computing clusters. In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.\n\n[50] D. B. Jackson, Q. Snell, and M. J. Clement. Core algorithms of the Maui scheduler. In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.\n\n[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. Measuring interference between live datacenter applications. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.\n\n[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. An analysis of traces from a production MapReduce cluster. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.\n\n[53] Kubernetes. http://kubernetes.io, Aug. 2014.\n\n[54] Kernel Based Virtual Machine. http://www.linux-kvm.org.\n\n[55] L. Lamport. The part-time parliament. ACM Trans. on Computer Systems, 16(2):133–169, May 1998.\n\n[56] J. Leverich and C. Kozyrakis. Reconciling high server utilization and sub-millisecond quality-of-service. In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.\n\n[57] Z. Liu and S. Cho. Characterizing machines and workloads on a Google cluster. In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.\n\n[58] Google LMCTFY project (let me contain that for you). http://github.com/google/lmctfy, 2014.\n\n[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. Pregel: a system for large-scale graph processing. In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.\n\n[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations. In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.\n\n[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. Dremel: interactive analysis of web-scale datasets. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.\n\n[62] P. Menage. Linux control groups. http://www.kernel. org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.\n\n[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. Towards characterizing cloud backend workloads: insights from Google compute clusters. ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.\n\n[64] A. Narayanan. Tupperware: containerized deployment at Facebook. http://www.slideshare.net/dotCloud/ tupperware-containerized-deployment-at-facebook, June 2014.\n\n[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. Sparrow: distributed, low latency scheduling. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.\n\n[66] D. C. Parkes, A. D. Procaccia, and N. Shah. Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities. In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.\n\n[67] Protocol buffers. https: //developers.google.com/protocol-buffers/, and https://github.com/google/protobuf/., 2014.\n\n[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. Heterogeneity and dynamicity of clouds at scale: Google trace analysis. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n\n[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. Omega: flexible, scalable schedulers for large compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n\n[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. Modeling and synthesizing task placement constraints in Google compute clusters. In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.\n\n[71] E. Shmueli and D. G. Feitelson. On simulation and design of parallel-systems schedulers: are we doing the right thing? IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.\n\n[72] A. Singh, M. Korupolu, and D. Mohapatra. Server-storage virtualization: integration and load balancing in data centers. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.\n\n[73] Apache Spark Project. http://spark.apache.org/, 2014.\n\n[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n\n[75] P. Turner, B. Rao, and N. Rao. CPU bandwidth control for CFS. In Proc. Linux Symposium, pages 245–254, July 2010.\n\n[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. Apache Hadoop YARN: Yet Another Resource Negotiator. In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.\n\n[77] VMware VCloud Suite. http://www.vmware.com/products/vcloud-suite/.\n\n[78] A. Verma, M. Korupolu, and J. Wilkes. Evaluating job packing in warehouse-scale computing. In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.\n\n[79] W. Whitt. Open and closed models for networks of queues. AT&T Bell Labs Technical Journal, 63(9), Nov. 1984.\n\n[80] J. Wilkes. More Google cluster data. http://googleresearch.blogspot.com/2011/11/ more-google-cluster-data.html, Nov. 2011.\n\n[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. HaPPy: Hyperthread-aware power profiling dynamically. In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.\n\n[82] Q. Zhang, J. Hellerstein, and R. Boutaba. Characterizing task usage shapes in Google’s compute clusters. In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.\n\n[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. CPI2: CPU performance isolation for shared compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n\n[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. Fuxi: a fault-tolerant resource management and job scheduling system at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.\n\n# 勘误 2015-04-23\n\n自从胶片版定稿后，我们发现了若干疏忽和歧义。\n\n## 用户视角\n\nSRE干的比SA(system administration)要多得多：他们是Google生产服务的负责工程师。他们设计和实现软件，包括自动化系统、管理应用、底层基础设施服务来保证Google这个量级的高可靠和高性能。\n\n## 鸣谢\n\n我们不小心忽略了Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, and Pavanish Nirula。\n\n## 参考文献\n\n[1] Michael Litzkow, Miron Livny, and Matt Mutka. \"Condor - A Hunter of Idle Workstations\". In Proc. Int'l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.\n\n[2] Rajesh Raman, Miron Livny, and Marvin Solomon. \"Matchmaking: Distributed Resource Management for High Throughput Computing\". In Proc. Int'l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.\n\n","slug":"eurosys15-borg-cn","published":1,"updated":"2017-11-01T13:05:25.684Z","_id":"cj9h1rchv00001k4fu8mpogyw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>发表于EuroSys 2015的 <strong><em>Large-scale cluster management at Google with Borg</em></strong> 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。</p>\n<a id=\"more\"></a>\n<hr>\n<p><strong>Large-scale cl uster management at Google with Borg</strong></p>\n<p>作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes</p>\n<p><a href=\"http://research.google.com/pubs/pub43438.html\" target=\"_blank\" rel=\"external\">http://research.google.com/pubs/pub43438.html</a> 或 直接 <a href=\"/doc/EuroSys15_Borg.pdf\">下载PDF全文</a></p>\n<p>译者：难易 <a href=\"http://my.oschina.net/HardySimpson\" target=\"_blank\" rel=\"external\">http://my.oschina.net/HardySimpson</a></p>\n<p>EuroSys’15, <a href=\"http://dx.doi.org/10.1145/2741948.2741964\" target=\"_blank\" rel=\"external\">http://dx.doi.org/10.1145/2741948.2741964</a></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>谷歌的Borg系统群集管理器运行几十万个以上的jobs，来自几千个不同的应用，跨多个集群，每个集群有上万个机器。</p>\n<p>它通过管理控制、高效的任务包装、超售、和进程级别性能隔离实现了高利用率。它支持高可用性应用程序与运行时功能，最大限度地减少故障恢复时间，减少相关故障概率的调度策略。Borg简化了用户生活，通过提供一个声明性的工作规范语言，名称服务集成，实时作业监控，和分析和模拟系统行为的工具。</p>\n<p>我们将会展现Borg系统架构和特点，重要的设计决策，定量分析它的一些策略，和十年以来的运维经验和学到的东西。</p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>集群管理系统我们内部叫Borg，它管理、调度、开始、重启和监控谷歌运行的应用程序的生命周期。本文介绍它是怎么做到这些的。</p>\n<p>Borg提供了三个主要的好处：它（1）隐藏资源管理和故障处理细节，使其用户可以专注于应用开发；（2）高可靠性和高可用性的操作，并支持应用程序做到高可靠高可用；（3）让我们在跨数以万计的机器上有效运行。Borg不是第一个来解决这些问题的系统，但它是在这个规模，这种程度的弹性和完整性下运行的为数不多的几个系统之一。</p>\n<p>本文围绕这些主题来编写，包括了我们在生产环境运行十年的一些功力。</p>\n<p><img src=\"/img/borg-fig-01.png\" alt=\"Fig. 1\"></p>\n<h1 id=\"2-用户视角\"><a href=\"#2-用户视角\" class=\"headerlink\" title=\"2.用户视角\"></a>2.用户视角</h1><p>Borg的用户是谷歌开发人员和系统管理员(网站可靠性工程师 SRE)，他们运行谷歌应用与服务。用户以job的方式提交他们的工作给Borg，job由一个或多个task组成，每个task含有同样的二进制程序。一个job在一个Borg的Cell里面跑，一个Cell是包括了多台机器的单元。这一节主要讲用户视角下的Borg系统。</p>\n<h2 id=\"2-1-工作负载\"><a href=\"#2-1-工作负载\" class=\"headerlink\" title=\"2.1 工作负载\"></a>2.1 工作负载</h2><p>Borg Cell主要运行两种异构的工作负载。第一种是长期的服务，应该“永远”运行下去，并处理短时间的敏感请求（几微秒到几百毫秒）。这种服务是面向终端用户的产品如Gmail、Google Docs、网页搜索，内部基础设施服务（例如，Bigtable）。第二种是批处理任务，需要几秒到几天来完成，对短期性能波动不敏感。在一个Cell上混合运行了这两种负载，取决于他们的主要租户（比如说，有些Cell就是专门用来跑密集的批处理任务的）。工作负载也随着时间会产生变化：批处理任务做完就好，终端用户服务的负载是以每天为周期的。Borg需要把这两种情况都处理好。</p>\n<p>Borg有一个2011年5月的负载数据[80]，已经被广泛的分析了[68,26，27，57，1]。</p>\n<p>最近几年，很多应用框架是搭建在Borg上的，包括我们内部的MapReduce[23]、flumejava[18]、Millwheel[3]、Pregel[59]。这中间的大部分都是有一个控制器，可以提交job。前2个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和他的后继者CFS、Bigtable[19]、Megastore[8]都是跑在Borg上的。</p>\n<p>在这篇文章里面，我们把高优先级的Borg的jobs定义为生产(prod)，剩下的是非生产的(non-prod)。大多长期服务是prod的，大部分批处理任务是non-prod的。在一个典型的Cell里面，prod job分配了70%的CPU资源然后实际用了60%；分配了55%的内存资源然后实际用了85%。在$5.5会展示分配和实际值的差是很重要的。</p>\n<h2 id=\"2-2-集群和Cell\"><a href=\"#2-2-集群和Cell\" class=\"headerlink\" title=\"2.2 集群和Cell\"></a>2.2 集群和Cell</h2><p>一个Cell里面的所有机器都属于单个集群，集群是由高性能的数据中心级别的光纤网络连接起来的。一个集群安装在数据中心的一座楼里面，n座楼合在一起成为一个site。一个集群通常包括一个大的Cell还有一些小的或测试性质的Cell。我们尽量避免任何单点故障。</p>\n<p>在测试的Cell之外，我们中等大小的Cell大概包括10000台机器；一些Cell还要大很多。一个Cell中的机器在很多方面都是异构的：大小(CPU,RAM,disk,network)、处理器类型、性能以及外部IP地址或flash存储。Borg隔离了这些差异，让用户单纯的选择用哪个Cell来跑任务，分配资源、安装程序和其它依赖、监控系统的健康并在故障时重启。</p>\n<p>(译者：Cell其实就是逻辑上的集群)</p>\n<h2 id=\"2-3-job和task\"><a href=\"#2-3-job和task\" class=\"headerlink\" title=\"2.3 job和task\"></a>2.3 job和task</h2><p>一个Borg的job的属性有：名字、拥有者和有多少个task。job可以有一些约束，来指定这个job跑在什么架构的处理器、操作系统版本、是否有外部IP。约束可以是硬的或者软的。一个job可以指定在另一个job跑完后再开始。一个job只在一个Cell里面跑。</p>\n<p>每个task包括了一组linux进程，跑在一台机器的一个容器内[62]。大部分Borg的工作负载没有跑在虚拟机(VM)里面，因为我们不想付出虚拟化的代价。而且，Borg在设计的时候还没硬件虚拟化什么事儿哪。</p>\n<p>task也有一些属性，包括资源用量，在job中的排序。大多task的属性和job的通用task属性是一样的，也可以被覆盖 —— 例如，提供task专用的命令行参数，包括CPU核、内存、磁盘空间、磁盘访问速度、TCP端口等等，这些都是可以分别设置并按照一个好的粒度提供。我们不提供固定的资源的单元。Borg程序都是静态编译的，这样在跑的环境下就没有依赖，这些程序都被打成一个包，包括二进制和数据文件，能被Borg安装起来。</p>\n<p>用户通过RPC来操作Borg的job，大多是从命令行工具，或者从我们的监控系统($2.6)。大多job描述文件是用一种申明式配置文件BCL – GCL[12]的一个变种，会产生一个protobuf文件[67]。BCL有一些自己的关键字。GCL提供了lambda表达式来允许计算，这样就能让应用在环境里面调整自己的配置。上万个BCL配置文件超过一千行长，系统中累计跑了了千万行BCL。Borg的job配置很类似于Aurora配置文件[6]。</p>\n<p><img src=\"/img/borg-fig-02.png\" alt=\"Fig. 2\"></p>\n<p>图2展现了job的和task的状态机和生命周期。</p>\n<p>用户可以在运行时改变一个job中的task的属性，通过推送一个新的job配置给Borg。这个新的配置命令Borg更新task的规格。这就像是跑一个轻量级的，非原子性的事务，而且可以在提交后轻易再改回来。更新是滚动式的，在更新中可以限制task重启的数量，如果有太多task停掉，操作可以终止。</p>\n<p>一些task更新，例如更新二进制程序，需要task重启；另外一些例如修改资源需求和限制会导致这个机器不适合跑现有的task，需要停止task再重新调度到别的机器上；还有一些例如修改优先级是可以不用重启或者移动task的。</p>\n<p>task需要能够接受Unix的SIGTERM信号，在他们被强制发送SIGKILL之前，这样就有时间去做清理、保存状态、结束现有请求执行、拒绝新请求。实际的notice的delay bound。实践中，80%的task能正常处理终止信号。</p>\n<h2 id=\"2-4-Allocs\"><a href=\"#2-4-Allocs\" class=\"headerlink\" title=\"2.4 Allocs\"></a>2.4 Allocs</h2><p>Borg的alloc(allocation的缩写)是在单台机器上的一组保留的资源配额，用来让一个或更多的task跑；这些资源一直分配在那边，无论有没有被用。allocs可以被分配出来给未来的task，用来保持资源在停止一个task和重启这个task之间，用来聚集不同jobs的tasks到同一台机器上——例如一个web server实例和附加的，用于把serverURL日志发送到一个分布式文件系统的日志搜集实例。一个alloc的资源管理方式和一台机器上的资源管理方式是类似的；多个tasks在一个alloc上跑并共享资源。如果一个alloc必须被重新定位到其他的机器上，那么它的task也要跟着重新调度。</p>\n<p>一个alloc set就像一个job：它是一组allocs保留了多台机器上的资源。一旦alloc set被创建，一个或多个jobs就可以被提交进去跑。简而言之，我们会用task来表示一个alloc或者一个top-level task(一个alloc之外的)，用job来表示一个job或者alloc set。</p>\n<h2 id=\"2-5-优先级、配额和管理控制\"><a href=\"#2-5-优先级、配额和管理控制\" class=\"headerlink\" title=\"2.5 优先级、配额和管理控制\"></a>2.5 优先级、配额和管理控制</h2><p>当有超量的工作负载在运行的时候会发生什么事情？我们的解决方案是优先级和配额。</p>\n<p>所有job都有优先级，一个小的正整数。高优先级的task可以优先获取资源，即使后面被杀掉。Borg定义了不重叠的优先级段给不同任务用，包括(优先级降序)：监控、生产、批任务、高性能(测试或免费)。在这篇文章里面，prod的jobs是在监控和生产段。</p>\n<p>虽然一个降级的task总会在cell的其他地方找到一席之地。降级瀑布也有可能会发生，就是一个task降下来之后，把下面运行的task再挤到别的机器上，如此往复。为了避免这种情况，我们禁止了prod级task互相排挤。合理粒度的优先级在其他场景下也很有用——MapReduce的master跑的优先级比worker高一点，来保证他们的可用性。</p>\n<p>优先级是jobs的相对重要性，决定了jobs在一个cell里面是跑还是等(pending)。配额则是用来决定jobs是否运行被调度。配额就是一组资源(CPU, RAM, disk)的数量在一个指定的优先级、一个指定的时间段(月这个量级)。数量决定了这个用户的job可以用的最多资源(例子：20TB内存和prod优先级从现在到7月在xx cell内)。配额检查是管理控制的一部分，不是调度层的：配额不足的任务在提交的时候就会被拒绝。</p>\n<p>高优先级的配额总是花费的比低优先级要多。prod级的配额是被限制为一个cell里面实际的资源量，所以用户提交了prod级的job的配额时，可以期待这个job一定会跑，去掉一些碎片外。即使这样，我们鼓励用户多买一点比自己需要多一点的配额，很多用户超买是因为他们的应用程序的用户数量增长后需要的配额就大了。对于超买，我们的应对方案是低优先级资源的超售：所有用户在0优先级都可以用无限的配额，虽然在实际运行中这种情况很难跑起来。一个低优先级的job在资源不足时会保持等(pending)状态。</p>\n<p>配额分配在Borg系统之外，和我们的物理资源计划有关。这些资源计划在不同的数据中心产生不同的价格和配额。用户jobs只在有足够配额和足够优先级之后才能启动。配额的使用让Dominant Resource Fairness(DRF)[29, 35, 36, 66]不是那么必要了。</p>\n<p>Borg有一个容量系统给一些特殊权限给某些用户，例如，允许管理员删除或修改cell里面的job，或者允许用户区访问特定的内核特性或者让Borg对自己的job不做资源估算($5.5)。</p>\n<h2 id=\"2-6-命名和监控\"><a href=\"#2-6-命名和监控\" class=\"headerlink\" title=\"2.6 命名和监控\"></a>2.6 命名和监控</h2><p>光是创建和部署task是不够的：一个服务的客户端和其他系统需要能找到它们，即使它换了个地方。为了搞定这一点，Borg创造了一个稳定的“Borg name Service”(BNS)名字给每个task，这个名字包括了cell名字，job名字，和task编号。Borg把task的主机名和端口写入到一个持久化高可用文件里，以BNS名为文件名，放在Chubby[14]上。这个文件被我们的RPC系统使用，用来发现task的终端地址。BNS名称也是task的DNS名的基础构成部分，所以，cc cell的ubar用户的jfoo job的第50个task的DNS名称会是50.jfoo.ubar.cc.borg.google.com。Borg同时还会把job的大小和task的健康信息写入到Chubby在任何情况改变时，这样负载均衡就能知道怎么去路由请求了。</p>\n<p>几乎所有的Borg的task都会包含一个内置的HTTP服务，用来发布健康信息和几千个性能指标(例如RPC延时)。Borg监控这些健康检查URL，把其中响应超时的和error的task重启。其他数据也被监控工具追踪并在Dashboards上展示，当服务级别对象(SLO)出问题时就会报警。</p>\n<p>用户可以使用一个名叫Sigma的web UI，用来检查他们所有的job状态，一个特殊的cell，或者深入到某个job的某个task的资源用率，详细日志，操作历史，和最终命运。我们的应用产生大量的日志，都会被自动的滚动来避免塞满硬盘，会在一个task结束后保留一小段时间用来debug。如果一个job没有被跑起来，Borg会提供一个为什么挂起的解释，指导用户怎么修改这个job的资源需求来符合目前这个cell的情况。我们发布资源的使用方针，按照这个方针来做就容易被调度起来。</p>\n<p>Borg记录所有的job提交和task时间，以及每task的资源使用细节在基础存储服务里面。这个存储服务有一个分布式的只读的SQL-like的交互式接口，通过Dremel[61]提供出来。这些数据在实时使用、debug、系统查错和长期容量规划上都很有用。这些数据也是Google集群负载追踪的数据来源之一[80].</p>\n<p>所有这些特性帮助用户理解和debug Borg的行为和管理他们的job，并且帮助我们的SRE每个人管理超过上万台机器。</p>\n<h1 id=\"3-Borg架构\"><a href=\"#3-Borg架构\" class=\"headerlink\" title=\"3. Borg架构\"></a>3. Borg架构</h1><p>一个Borg的Cell包括一堆机器，一个逻辑的中心控制服务叫做Borgmaster，和在每台机器上跑的Borglet的agent进程(见图1)。所有Borg的组件都是用C++写的。</p>\n<p><img src=\"/img/borg-fig-01.png\" alt=\"Fig. 1\"></p>\n<h2 id=\"3-1-Borgmaster\"><a href=\"#3-1-Borgmaster\" class=\"headerlink\" title=\"3.1 Borgmaster\"></a>3.1 Borgmaster</h2><p>Cell的Borgmaster由2个进程组成，主的Borgmaster进程和一个单独的scheduler($3.2)。主的Borgmaster处理所有客户端的RPC请求，例如修改状态(创建job)，提供数据读取服务(查找job)。它同时管理系统中所有组件(机器、task、allocs等等)的状态机，和Borglet通信，并且提供一个Sigma的备份Web UI。</p>\n<p>Borgmaster在逻辑上是一个单进程，但实际上开了5个副本。每个副本维护了一个内存级别的cell状态拷贝，这些状态同时被记录在一个高可用、分布式、Paxos-based存储[55]放在这些副本的本地硬盘上。在一个cell里面，一个单独的被选举出来的master同时用于Paxos leader和状态修改器，用来处理所有改变cell状态的请求，例如提交一个job或者在一个机器上终止一个task。当cell启动或前一个master挂了时，Paxos算法会选举出一个master；这需要一个Chubby锁然后其他系统可以找到master。选举一个master或者换一个新的需要的典型事件是10s，但需要大概1分钟才能让一个大的cell内生效，因为一些内存状态要重构。当一个副本从网络隔离中恢复时，需要动态的从其他Paxos副本中重新同步自己的状态。</p>\n<p>某个时刻的Borgmaster的状态被称为checkpoint，会被以快照形式+change log形式保存在Paxos存储里面。checkpoints有很多用途，包括把Borgmaster的状态恢复到以前的任意时刻(例如在处理一个请求之前，用来解决软件缺陷)；极端情况下手动修改checkpoints，形成一个持续的事件日志供今后用；或用于线下的在线仿真。</p>\n<p>一个高仿真的Borgmaster叫Fauxmaster，可以用来读取checkpoint文件，包括一份完整的Borgmaster的代码，和Borglet的存根接口。它接受RPC来改变状态机和执行操作，例如调度所有阻塞的tasks，我们用它来debug错误，和它交互就和Borgmaster交互是一样的，同样我们也有一个仿真的Borglet可以用checkpoint重放真实的交互。用户可以单步调试看到系统中的所有过去的改变。Fauxmaster在这种情况下也很有用：多个这个类型的job比较合适？以及在改变cell配置前做一个安全检查(这个操作会把任何关键jobs给踢掉吗？)</p>\n<h2 id=\"3-2-调度-schedule\"><a href=\"#3-2-调度-schedule\" class=\"headerlink\" title=\"3.2 调度 schedule\"></a>3.2 调度 schedule</h2><p>当一个job被提交的时候，Borgmaster会把它持久化的存储在Paxos存储上，然后把这个job的task放到等待(pending)的队列里面去。这个队列会被scheduler异步的扫描，然后分发task到有充足资源的机器上。scheduler主要是处理task的，不是job。扫描从高优先级到低优先级，在同个优先级上用round-robin的方式处理，以保证用户之间的公平性和避免头上的大job阻塞住。调度算法有2个部分：可行性检查(feasibility checking)，找到一台能跑task的机器，和打分(scoring)，找个一个最合适的机器。</p>\n<p>在可行性检查这个阶段，scheduler会找到一组机器，都满足task的约束而且有足够可用的资源 —— 包括了一些已经分配给低优先级任务的可以被腾出来的资源。在打分阶段，scheduler会找到其中“最好”的机器。这个分数包括了用户的偏好，但主要是被内置的标准：例如最小化的倒腾其他task，找到已经有这个task安装包的，在电力和出错的可用域之间尽可能分散的，在单台机器上混合高低优先级的task以保证高峰期扩容的。</p>\n<p>Borg原来用E-PVM[4]的变种算法来打分，在异构的资源上生成一个单一的分数，在调度一个task时最小化系统的改变。但在实践中，E-PVM最后把负载平均分配到所有机器，把扩展空间留给高峰期 —— 但这么做的代价是增加了碎片，尤其是对于大的task需要大部分机器的时候；我们有时候给这种分配取绰号叫“最差匹配”。</p>\n<p>分配策略光谱的另一端是“最佳匹配”，把机器塞任务塞的越紧越好。这样就能留下一些空的机器给用户jobs(他们也跑存储服务)，所以处理大task就比较直接了，不过，紧分配会惩罚那些对自己所需资源预估不足的用户。这种策略会伤害爆发负载的应用，而且对需要低CPU的批处理任务特别不友好，这些任务可以被轻易调度到不用的资源上：20%的non-prod task需要小于0.1核的CPU。</p>\n<p>我们目前的打分模型是一个混合的，试图减少搁浅的资源 —— 一些因为这台机器上资源没被全部用掉而剩下的。比起“最佳匹配”，这个模型提供了3%-5%的打包效率提升(在[78]里面定义的)</p>\n<p>如果一台机器在打分后没有足够的资源运行新的task，Borg会驱逐(preempts)低优先级的任务，从最低优先级往上踢，直到资源够用。我们把被踢掉的task放到scheduler的等待(pending)队列里面去，而不是迁移或冬眠这些task。</p>\n<p>task启动延迟(从job提交到task运行之间的时间段)是被我们持续关注的。这个时间差别很大，一般来说是25s。包安装耗费了这里面80%的时间：一个已知的瓶颈就是对本地硬盘的争抢。为了减少task启动时间，scheduler希望机器上已经有足够的包(程序和数据)：大部分包是只读的所以可以被分享和缓存。这是唯一一种Borg scheduler支持的数据本地化方式。顺便说一下，Borg分发包到机器的办法是树形的和BT类型的协议。</p>\n<p>另外，scheduler用了某些技术来扩散到几万台机器的cell里面。($3.4)</p>\n<h2 id=\"3-3-Borglet\"><a href=\"#3-3-Borglet\" class=\"headerlink\" title=\"3.3 Borglet\"></a>3.3 Borglet</h2><p>Borglet是部署在cell的每台机器上的本地Borg代理程序。它启动停止task；如果task失败就重启；通过修改OS内核设置来管理本地资源；滚动debug日志；把本机的状态上报给Borgmaster和其他监控系统。</p>\n<p>Borgmaster每过几秒就会轮询所有的Borglet来获取机器当前的状态还有发送任何请求。这让Borgmaster能控制交流频率，避免一个显式的流控机制，而且防止了恢复风暴[9].</p>\n<p>选举出来的master负责发送消息给Borglet并且根据响应更新cell的状态。为了性能可扩展，每个Borgmaster副本会运行一个无状态的连接分配(link shard)来处理和特定几个Borglet的交流；这个分配会在Borgmaster选举的时候重新计算。为了保证弹性，Borglet把所有状态都报上来，但是link shard会聚合和压缩这些信息到状态机，来减少选举出来的master的负载。</p>\n<p>如果Borglet几次没有响应轮询请求，将会被标记为挂了(down)，然后上面跑的task会被重新分配到其他机器。如果通讯恢复，Borgmaster会让这个Borglet杀掉已经被分配出去的task，来避免重复。Borglet会继续常规的操作即使和Borgmaster恢复联系，所以目前跑的task和service保持运行以防所有的Borgmaster挂了。</p>\n<h2 id=\"3-4-可扩展性\"><a href=\"#3-4-可扩展性\" class=\"headerlink\" title=\"3.4 可扩展性\"></a>3.4 可扩展性</h2><p>我们还不知道Borg的可扩展性极限在哪里，每次我们碰到一个极限，我们就越过去。一个单独的Borgmaster可以管理一个cell里面几千台机器，若干个cell可以处理10000个任务每分钟。一个繁忙的Borgmaster使用10-14个CPU核以及50GB内存。我们用了几项技术来获得这种扩展性。</p>\n<p>早期的Borgmaster有一个简单的，同步的循环来处理请求、调度tasks，和Borglet通信。为了处理大的cell，我们把scheduler分出来作为一个单独的进程，然后就可以和别的Borgmaster功能并行的跑，别的Borgmaster可以开副本来容错。一个scheduler副本操作一份cell的状态拷贝。它重复地：从选举出来的master获取状态改变(包括所有的分配的和pending的工作)；更新自己的本地拷贝，做调度工作来分配task；告诉选举出来的master这些分配。master会接受这些信息然后应用之，除非这些信息不适合(例如，过时了)，这些会在scheduler的下一个循环里面处理。这一切都符合Omega[69]的乐观并行策略精神，而且我们最近真的给Borg添加这种功能，对不同的工作负载用不同的scheduler来调度。</p>\n<p>为了改进响应时间，我们增加了一些独立线程和Borglet通信、响应只读RPC。为了更高的性能，我们分享(分区)这些请求给5个Borgmaster副本$3.3。最后，这让99%的UI响应在1s以内，而95%的Borglet轮询在10s以内。</p>\n<p>一些让Borg scheduler更加可扩展的东西：</p>\n<p>分数缓存：评估一台机器的可用性和分数是比较昂贵的，所以Borg会一直缓存分数直到这个机器或者task变化了——例如，这台机器上的task结束了，一些属性修改了，或者task的需求改变了。忽略小的资源变化让缓存保质期变长。</p>\n<p>同级别均化处理：同一个Borg job的task一般来说有相同的需求和资源，所以不用一个个等待的task每次都去找可用机器，这会把所有可用的机器打n次分。Borg会对相同级别的task找一遍可用机器打一次分。</p>\n<p>适度随机：把一个大的Cell里面的所有机器都去衡量一遍可用性和打分是比较浪费的。所以scheduler会随机的检查机器，找到足够多的可用机器去打分，然后挑出最好的一个。这会减少task进入和离开系统时的打分次数和缓存失效。适度随机有点像Sparrow [65]的批处理采样技术，同样要面对优先级、驱逐、非同构系统和包安装的耗费。</p>\n<p>在我们的实验中($5)，调度整个cell的工作负载要花几百秒，但不用上面几项技术的话会花3天以上的时间。一般来说，一个在线的调度从等待队列里面花半秒就能搞定。</p>\n<h1 id=\"4-可用性\"><a href=\"#4-可用性\" class=\"headerlink\" title=\"4. 可用性\"></a>4. 可用性</h1><p><img src=\"/img/borg-fig-03.png\" alt=\"Fig. 3\"></p>\n<p>在大型分布式系统里面故障是很常见的[10,11,12]。图3展示了在15个cell里面task驱逐的原因。在Borg上跑的应用需要能处理这种事件，应用要支持开副本、存储数据到分布式存储这些技术，并能定期的做快照。即使这样，我们也尽可能的缓和这些事件造成的影响。例如，Borg：</p>\n<p>自动的重新调度被驱逐的task，如果需要放到新机器上运行<br>通过把一个job分散到不同的可用域里面去，例如机器、机架、供电域<br>在机器、OS升级这些维护性工作时，降低在同一时刻的一个job中的task的关闭率<br>使用声明式的目标状态表示和幂等的状态改变做操作，这样故障的客户端可以无损的重新启动或安全的遗忘请求<br>对于失联的机器上的task，限制一定的比率去重新调度，因为很难去区分大规模的机器故障和网络分区<br>避免特定的会造成崩溃的task:机器的匹配<br>critical级别的中间数据写到本地硬盘的日志保存task很重要，就算这个task所属的alloc被终止或调度到其他机器上，也要恢复出来做。用户可以设置系统保持重复尝试多久：若干天是比较合理的做法。<br>一个关键的Borg设计特性是：就算Borgmaster或者Borglet挂了，task也会继续运行下去。不过，保持master运行也很重要，因为在它挂的时候新的jobs不能提交，或者结束的无法更新状态，故障的机器上的task也不能重新调度。</p>\n<p>Borgmaster使用组合的技术在实践中保证99.99%的可用性：副本技术应对机器故障；管理控制应对超载；部署实例时用简单、底层的工具去减少外部依赖(译者：我猜测是rsync或者scp这种工具)。每个cell和其他cell都是独立的，这样减少了误操作关联和故障传染。为了达到这个目的，所以我们不搞大cell。</p>\n<h1 id=\"5-使用效率\"><a href=\"#5-使用效率\" class=\"headerlink\" title=\"5. 使用效率\"></a>5. 使用效率</h1><p>Borg的一个主要目的就是有效的利用Google的机器舰队，这可是一大笔财务投资：让效率提升几个百分点就能省下几百万美元。这一节讨论了和计算了一些Borg使用的技术和策略。</p>\n<h2 id=\"5-1-测度方法论\"><a href=\"#5-1-测度方法论\" class=\"headerlink\" title=\"5.1 测度方法论\"></a>5.1 测度方法论</h2><p>我们的job部署是有资源约束的，而且很少碰到负载高峰，我们的机器是异构的，我们从service job回收利用的资源跑batch job。所以，为了测量我们需要一个比“平均利用率”更抽象的标准。在做了一些实验后我们选择了cell密度(cell compaction)：给定一个负载，我们不断的从零开始(这样可以避免被一个倒霉的配置卡住)，部署到尽可能小的Cell里面去，直到再也不能从这个cell里面抽机器出来。这提供了一个清晰的终止条件，并促进了无陷阱的自动化比较，这里的陷阱指的是综合化的工作负载和建模[31]。一个定量的比较和估算技术可以看[78]，有不少微妙的细节。</p>\n<p>我们不可能在线上的cell做性能实验，所以我们用了Fauxmaster来达到高保真的模拟效果，使用了真的在线cell的负载数据包括所有的约束、实际限制、保留和常用数据($5.5)。这些数据从2014-10-1 14:00 PDT的Borg快照(checkpoints)里面提取出来。(其他快照也产生类似的结论)。我们选取了15个Borg cell来出报告，先排除了特殊目的的、测试的、小的(&lt;5000机器)的cell，然后从剩下的各种量级大小的cell中平均取样。</p>\n<p>在压缩cell实验中为了保持机器异构性，我们随机选择去掉的机器。为了保持工作负载的异构性，我们保留了所有负载，除了那些对服务和存储需要有特定需求的。我们把那些需要超过一半cell的job的硬限制改成软的，允许不超过0.2%的task持续的pending如果它们过于挑剔机器；广泛的测试表明这些结果是可重复的。如果我们需要一个大的cell，就把原cell复制扩大；如果我们需要更多的cell，就复制几份cell。</p>\n<p>所有的实验都每个cell重复11次，用不同的随机数发生器。在图上，我们用一个横线来表示最少和最多需要的机器，然后选择90%这个位置作为结果，平均或者居中的结论不会代表一个系统管理员会做的最优选择。我们相信cell压缩提供了一个公平一致的方式去比较调度策略：好的策略只需要更少的机器来跑相同的负载。</p>\n<p>我们的实验聚焦在调度(打包)某个时间点的一个负载，而不是重放一段长期的工作踪迹。这部分是因为复制一个开放和关闭的队列模型比较困难，部分是因为传统的一段时间内跑完的指标和我们环境的长期跑服务不一样，部分是因为这样比较起来比较明确，部分是因为我们相信怎么整都差不多，部分是因为我们在消费20万个Borg CPU来做测试——即使在Google的量级，这也不是一个小数目(译者：就你丫理由多！)</p>\n<p><img src=\"/img/borg-fig-04.png\" alt=\"Fig. 4\"></p>\n<p>在生产环境下，我们谨慎的留下了一些顶部空间给负载的增加，比如一些“黑天鹅”时间，负载高峰，机器故障，硬件升级，以及大范围故障(供电进灰)。图4显示了我们在现实世界中可以把cell压缩到多小。上面的基线是用来表示压缩大小的。</p>\n<h2 id=\"5-2-Cell的共享使用\"><a href=\"#5-2-Cell的共享使用\" class=\"headerlink\" title=\"5.2 Cell的共享使用\"></a>5.2 Cell的共享使用</h2><p>几乎我们所有的机器都同时跑prod和non-prod的task：在共享Borg cell里有98%的机器同时跑这2种task，在所有Borg管理的机器里面有83%同时跑这2种task(我们有一些专用的Cell跑特定任务)。</p>\n<p><img src=\"/img/borg-fig-05.png\" alt=\"Fig. 5\"></p>\n<p>鉴于很多其他的组织把面向用户应用和批处理应用在不同的集群上运行，我们设想一下如果我们也这么干会发生什么情况。图5展现了在一个中等大小的Cell上分开跑我们prod和non-prod的工作负载将需要20-30%多的机器。这是因为prod的job通常会保留一些资源来应对极少发生的负载高峰，但实际上在大多情况下不会用这些资源。Borg把这批资源回收利用了($5.5)来跑很多non-prod的工作，所以最终我们只需要更少的机器。</p>\n<p><img src=\"/img/borg-fig-06.png\" alt=\"Fig. 6\"></p>\n<p>大部分Borg cell被几千个用户共享使用。图6展现了为什么。对这个测试，如果一个用户消费超过了10TiB内存(或100TiB)，我们就把这个用户的工作负载分离到一个单独的Cell里面去。我们目前的策略展现了它的威力：即使我们设置了这么高的阈值(来分离)，也需要2-16倍多的Cell，和20-150%多的机器。资源池的方案再次有效地节省了开销。</p>\n<p>但是，或许把很多不相关的用户和job类型打包放到一台机器上，会造成CPU冲突，然后就需要更多的机器进行补偿？为了验证这一点，我们看一下在同一台机器，锁定时钟周期，每指令循环数CPI(cycles per instruction)在不同环境的task下是怎么变化的。在这种情况下，CPI是一个可比较的指标而且可以代表冲突度量，因为2倍的CPI意味着CPU密集型程序要跑2倍的时间。这些数据是从一周内12000个随机的prod的task中获取的，用硬件测量工具[83]取的，并且对采样做了权重，这样每秒CPU都是平等的。测试结果不是非常明显。</p>\n<p>我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及(强相关)这个机器上同时跑的task数量；每往一台机器上增加1个task，就会增加0.3%的CPI(线性模型过滤数据)；增加一台10%的CPU使用率，就会增加小于2%的CPI。即使这已经是一个统计意义显著的正相关性，也只是解释了我们在CPI度量上看到的5%的变化，还有其他的因素支配着这个变化，例如应用程序固有的差别和特殊的干涉图案[24,83]。</p>\n<p>比较我们从共享Cell和少数只跑几种应用的专用Cell获取的CPI采样，我们看到共享Cell里面的CPI平均值为1.58(σ=0.35,方差)，专用Cell的CPI平均值是1.53(σ=0.32,方差).也就是说，共享Cell的性能差3%。</p>\n<p>为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差(或许对冲突更敏感的程序会被挪到专用Cell里面去)，我们观察了Borglet的CPI，在所有Cell的所有机器上都会被运行。我们发现专用Cell的CPI平均值是1.20(σ=0.29,方差)，而共享Cell里面的CPI平均值为1.43(σ=0.45,方差)，暗示了在专用Cell上运行程序会比在共享Cell上快1.19倍，这就超过了CPU使用量轻负载的这个因素，轻微的有利于专用Cell。</p>\n<p>这些实验确定了仓库级别的性能测试是比较微妙的，加强了[51]中的观察，并且得出了共享并没有显著的增加程序运行的开销。</p>\n<p>不过，就算我们假设用了我们结果中最不好的数据，共享还是有益的：比起CPU的降速，在各个方案里面减少机器更重要，这会带来减少所有资源的开销，包括内存和硬盘，不仅仅是CPU。</p>\n<h2 id=\"5-3-大Cell\"><a href=\"#5-3-大Cell\" class=\"headerlink\" title=\"5.3 大Cell\"></a>5.3 大Cell</h2><p><img src=\"/img/borg-fig-07.png\" alt=\"Fig. 7\"></p>\n<p>Google建立了大Cell，为了允许大的任务运行，也是为了降低资源碎片。我们通过把负载从一个cell分到多个小cell上来测试后面那个效应(降低碎片效应)，随机的把job用round-robin方式分配出去。图7展示了用很多小cell会明显的需要更多机器。</p>\n<h2 id=\"5-4-资源请求粒度\"><a href=\"#5-4-资源请求粒度\" class=\"headerlink\" title=\"5.4 资源请求粒度\"></a>5.4 资源请求粒度</h2><p><img src=\"/img/borg-fig-08.png\" alt=\"Fig. 8\"></p>\n<p>Borg用户请求的CPU单位是千分之一核，内存和硬盘单位是byte。(1核是一个CPU的超线程，在不同机器类型中的一个通用单位)。图8展现了这个粒度的好处：CPU核和内存只有少数的“最佳击球点”，以及这些资源很少的相关性。这个分布和[68]里面的基本差不多，除了我们看到大内存的请求在90%这个线上。</p>\n<p><img src=\"/img/borg-fig-09.png\" alt=\"Fig. 9\"></p>\n<p>提供一个固定尺寸的容器和虚拟机，在IaaS(infrastructure-as-a-service)提供商里面或许是比较流行的，但不符合我们的需求。为了展现这一点，我们把CPU核和内存限制做成一个个尺寸，然后把prod的job按照大一点最近的尺寸去跑(取这2个维度的平方值之和最近，也就是2维图上的直线)，0.5核的CPU,1G的内存为差值。图9显示了一般情况下我们需要30-50%多的资源来运行。上限来自于把大的task跑在一整台机器上，这些task即使扩大四倍也没办法在原有Cell上压缩跑。下限是允许这些task等待(pending)。(这比[37]里面的数据要大100%，因为我们支持超过4中尺寸而且允许CPU和内存无限扩张)。</p>\n<h2 id=\"5-5-资源再利用\"><a href=\"#5-5-资源再利用\" class=\"headerlink\" title=\"5.5 资源再利用\"></a>5.5 资源再利用</h2><p>一个job可以声明一个限制资源，是每个task能强制保证的资源上限。Borg会先检查这个限制是不是在用户的配额内，然后检查具体的机器是否有那么多资源来调度这个task。有的用户会买超过他们需要的配额，也有用户会的task实际需要更多的资源去跑，因为Borg会杀掉那些需要更多的内存和硬盘空间的task，或者卡住CPU使用率不上去。另外，一些task偶尔需要使用他们的所有资源(例如，在一天的高峰期或者受到了一个拒绝服务攻击)，大多时候用不上那么多资源。</p>\n<p>比起把那些分出来但不用的资源浪费掉，我们估计了一个task会用多少资源然后把其他的资源回收再利用给那些可以忍受低质量资源的工作，例如批处理job。这整个过程被叫做资源再利用(resource reclamation)。这个估值叫做task自留地资源(reservation)，被Borgmaster每过几秒就计算一次，是Borglet抓取的细粒度资源消费用率。最初的自留地资源被设置的和资源限制一样大；在300s之后，也就是启动那个阶段，自留地资源会缓慢的下降到实际用量加上一个安全值。自留地资源在实际用量超过它的时候会迅速上升。</p>\n<p>Borg调度器(scheduler)使用限制资源来计算prod task的可用性($3.2)，所以这些task从来不依赖于回收的资源，也不提供超售的资源；对于non-prod的task，使用了目前运行task的自留地资源，这么新的task可以被调度到回收资源。</p>\n<p>一台机器有可能因为自留地预估错度而导致运行时资源不足 —— 即使所有的task都在限制资源之内跑。如果这种情况发生了，我们杀掉或者限制non-prod task，从来不对prod task下手。</p>\n<p><img src=\"/img/borg-fig-10.png\" alt=\"Fig. 10\"></p>\n<p>图10展示了如果没有资源再利用会需要更多的机器。在一个中等大小的Cell上大概有20%的工作负载跑在回收资源上。</p>\n<p><img src=\"/img/borg-fig-11.png\" alt=\"Fig. 11\"></p>\n<p>图11可以看到更多的细节，包括回收资源、实际使用资源和限制资源的比例。一个超内存限制的task首先会被重新调度，不管优先级有多高，所以这样就很少有task会超过内存限制。另一方面，CPU使用率是可以轻易被卡住的，所以短期的超过自留地资源的高峰时没什么损害的。</p>\n<p>图11暗示了资源再利用可能是没必要的保守：在自留地和实际使用中间有一大片差距。为了测试这一点，我们选择了一个生产cell然后调试它的预估参数到一个激进策略上，把安全区划小点，然后做了一个介于激进和基本之间的中庸策略跑，然后恢复到基本策略。</p>\n<p><img src=\"/img/borg-fig-12.png\" alt=\"Fig. 12\"></p>\n<p>图12展现了结果。第二周自留地资源和实际资源的差值是最小的，比第三周要小，最大的是第一和第四周。和预期的一样，周2和周3的OOM率有一个轻微的提升。在复查了这个结果后，我们觉得利大于弊，于是把中庸策略的参数放到其他cell上部署运行。</p>\n<h1 id=\"6-隔离性\"><a href=\"#6-隔离性\" class=\"headerlink\" title=\"6. 隔离性\"></a>6. 隔离性</h1><p>50%的机器跑9个以上的task；最忙的10%的机器大概跑25个task，4500个线程[83]。虽然在应用间共享机器会增加使用率，也需要一个比较好的机制来保证task之间不互相冲突。包括安全和性能都不能互相冲突。</p>\n<h2 id=\"6-1-安全隔离\"><a href=\"#6-1-安全隔离\" class=\"headerlink\" title=\"6.1 安全隔离\"></a>6.1 安全隔离</h2><p>我们使用Linux chroot监狱作为同一台机器不同task之间主要的安全隔离机制。为了允许远程debug，我们以前会分发ssh key来自动给用户权限去访问跑他们task的机器，现在不这么干了。对大多数用户来说，现在提供的是borgssh命令，这个程序和Borglet协同，来构建一个ssh shell，这个shell和task运行在同样的chroot和cgroup下，这样限制就更加严格了。</p>\n<p>VM和安全沙箱技术被使用在外部的软件上，在Google’s AppEngine (GAE) [38]和Google Compute Engine (GCE)环境下。我们把KVM进程中的每个hosted VM按照一个Borg task运行。</p>\n<h2 id=\"6-2-性能隔离\"><a href=\"#6-2-性能隔离\" class=\"headerlink\" title=\"6.2 性能隔离\"></a>6.2 性能隔离</h2><p>早期的Borglet使用了一种相对原始粗暴的资源隔离措施：事后内存、硬盘、CPU使用率检查，然后终止使用过多内存和硬盘的task，或者把用太多CPU的激进task通过Linux CPU优先级降下来。不过，很多粗暴的task还是很轻易的能影响同台机器上其他task的性能，然后很多用户就会多申请资源来让Borg减少调度的task数量，然后会导致系统资源利用率降低。资源回收可以弥补一些损失，但不是全部，因为要保证资源安全红线。在极端情况下，用户请求使用专用的机器或者cell。</p>\n<p>目前，所有Borg task都跑在Linux cgroup-based资源容器[17,58,62]里面，Borglet操作这些容器的设置，这样就增强了控制因为操作系统内核在起作用。即使这样，偶尔还是有低级别的资源冲突(例如内存带宽和L3缓存污染)还是会发生，见[60,83]</p>\n<p>为了搞定超负荷和超请求，Borg task有一个应用阶级(appclass)。最主要的区分在于延迟敏感latency-sensitive (LS)的应用和其他应用的区别，其他应用我们在文章里面叫batch。LS task是包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS task得到最高有待，可以为了这个把batch task一次饿个几秒种。</p>\n<p>第二个区分在于可压缩资源(例如CPU循环，disk I/O带宽)都是速率性的可以被回收的，对于一个task可以降低这些资源的量而不去杀掉task；和不可压缩资源(例如内存、硬盘空间)这些一般来说不杀掉task就没法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会杀掉task，从低优先级开始杀，直到剩下的自留地资源够用。如果机器用完了可压缩资源，Borglet会卡住使用率这样当短期高峰来到时不用杀掉任何task。如果情况没有改善，Borgmaster会从这个机器上去除一个或多个task。</p>\n<p>Borglet的用户空间控制循环在未来预期的基础上给prod task分配内存，在内存压力基础上给non-prod task分配内存；从内核事件来处理Out-of-Memory (OOM)；杀掉那些想获取超过自身限制内存的task，或者在一个超负载的机器上实际超过负载时。Linux的积极文件缓存策略让我们的实现更负载一点，因为精确计算内存用量会麻烦很多。</p>\n<p>为了增强性能隔离，LS task可以独占整个物理CPU核，不让别的LS task来用他们。batch task可以在任何核上面跑，不过他们只被分配了很少的和LS task共享的资源。Borglet动态的调整贪婪LS task的资源限制来保证他们不会把batch task饿上几分钟，有选择的在需要时使用CFS带宽控制[75]；光有共享是不行的，我们有多个优先级。</p>\n<p><img src=\"/img/borg-fig-13.png\" alt=\"Fig. 13\"></p>\n<p>就像Leverich [56]，我们发现标准的Linux CPU调度(CFS)需要大幅调整来支持低延迟和高使用率。为了减少调度延迟，我们版本的CFS使用了额外的每cgroup历史[16]，允许LS task驱逐batch task，并且避免多个LS task跑在一个CPU上的调度量子效应(scheduling quantum，译者：或许指的是互相冲突？)。幸运的是，大多我们的应用使用的每个线程处理一个请求模型，这样就缓和了持久负载不均衡。我们节俭地使用cpusets来分配CPU核给有特殊延迟需求的应用。这些措施的一部分结果展现在图13里面。我们持续在这方面投入，增加了线程部署和CPU管理包括NUMA超线程、能源觉察(例如[81])，增加Borglet的控制精确度。</p>\n<p>Task被允许在他们的限制范围内消费资源。其中大部分task甚至被允许去使用更多的可压缩资源例如CPU，充分利用没有被使用的资源。大概5%的LS task禁止这么做，主要是为了增加可预测性；小于1%的batch task也禁止。使用超量内存默认是被禁止的，因为这会增加task被杀的概率，不过即使这样，10%的LS task打开了这个限制，79%的batch task也开了因为这事MapReduce框架默认的。这事对资源再回收($5.5)的一个补偿。Batch task很乐意使用没有被用起来的内存，也乐意不时的释放一些可回收的内存：大多情况下这跑的很好，即使有时候batch task会被急需资源的LS task杀掉。</p>\n<p>【编者的话】最后两章探讨的是相关工作和改进。从中可以看到从Borg到Kubernetes，他们也做了不少思考，而这方面的工作远远没有完善，一直在进行中。期待大家都能从Google的实践中学到一些东西，并分享出来。</p>\n<h1 id=\"7-相关工作\"><a href=\"#7-相关工作\" class=\"headerlink\" title=\"7. 相关工作\"></a>7. 相关工作</h1><p>资源调度在各个领域已经被研究了数十年了，包括在广域HPC超算集群中，在工作站网络中，在大规模服务器集群中。我们主要聚焦在最相关的大规模服务器集群这个领域。</p>\n<p>最近的一些研究分析了集群趋势，来自于Yahoo、Google、和Facebook[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载在规模和异构化方面碰到的挑战。[69]包含了这些集群管理架构的分类。</p>\n<p>Apache Mesos [45]把资源管理和应用部署做了分离，资源管理由中心管理器(类似于Bormaster+scheduler)和多种类的“框架”比如Hadoop [41]和Spark [73]，使用offer-based的机制。Borg则主要把这些几种在一起，使用request-based的机制，可以大规模扩展。DRF [29, 35, 36, 66]策略是内赋在Mesos里的；Borg则使用优先级和配额认证来替代。Mesos开发者已经宣布了他们的雄心壮志：推测性资源分配和回收，然后把[69]里面的问题都解决。</p>\n<p>YARN [76]是一个Hadoop中心集群管理。每个应用都有一个管理器和中央资源管理器谈判；这和2008年开始Google MapReduce从Borg获取资源如出一辙。YARN的资源管理器最近才能容错。一个相关的开源项目是Hadoop Capacity Scheduler [42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近被扩展成支持多种资源类型、优先级、驱逐、和高级权限控制[21]。俄罗斯方块原型[40]支持了最大完工时间觉察的job打包。</p>\n<p>Facebook的Tupperware [64]，是一个类Borg系统来调度cgroup容器；虽然只有少量资料泄露，看起来他也提供资源回收利用功能。Twitter有一个开源的Aurora[5]，一个类Borg的长进程调度器，跑在Mesos智商，有一个类似于Borg的配置语言和状态机。</p>\n<p>来自于微软的Autopilot[48]提供了“自动化的软件部署和开通；系统监控，以及在软硬件故障时的修复操作”给微软集群。Borg生态系统提供了相同的特性，不过还有没说完的；Isaard [48]概括和很多我们想拥护的最佳实践。</p>\n<p>Quincy[49]使用了一个网络流模型来提供公平性和数据局部性在几百个节点的DAG数据处理上。Borg用的是配额和优先级在上万台机器上把资源分配给用户。Quincy处理直接执行图在Borg之上。</p>\n<p>Cosmos [44]聚焦在批处理上，重点在于用户获得对集群捐献的资源进行公平获取。它使用一个每job的管理器来获取资源；没有更多公开的细节。</p>\n<p>微软的Apollo系统[13]使用了一个每job的调度器给短期存活的batch job使用，在和Borg差不多量级的集群下获取高流量输出。Apollo使用了一个低优先级后台任务随机执行策略来增加资源利用率，代价是有多天的延迟。Apollo几点提供一个预测矩阵，关于启动时间为两个资源维度的函数。然后调度器会综合计算启动开销、远程数据获取开销来决定部署到哪里，然后用一个随机延时来避免冲突。Borg用的是中央调度器来决定部署位置，给予优先级分配处理更多的资源维度，而且更关注高可用、长期跑的应用；Apollo也许可以处理更多的task请求并发。</p>\n<p>阿里巴巴的Fuxi(译者：也就是伏羲啦) [84]支撑数据分析的负载，从2009年开始运行。就像Borgmaster，一个中央的FuxiMaster(也是做了高可用多副本)从节点上获取可用的资源信息、接受应用的资源请求，然后做匹配。伏羲增加了和Borg完全相反的调度策略：伏羲把最新的可用资源分配给队列里面请求的任务。就像Mesos，伏羲允许定义“虚拟资源”类型。只有系统的工作负载输出是公开的。</p>\n<p>Omega [69]支持多并行，特别是“铅垂线”策略，粗略相当于Borgmaster加上它的持久存储和link shards(连接分配)。Omega调度器用的是乐观并行的方式去控制一个共享的cell观察和预期状态，把这些状态放在一个中央的存储里面，和Borglet用独立的连接器进行同步。Omega架构。Omage架构是被设计出来给多种不同的工作负载，这些工作负载都有自己的应用定义的RPC接口、状态机和调度策略(例如长期跑的服务端程序、多个框架下的batch job、存储基础设施、GCE上的虚拟机)。形成对比的是，Borg提供了一种“万灵药”，同样的RPC接口、状态机语义、调度策略，随着时间流逝规模和复杂度增加，需要支持更多的不同方式的负载，而可可扩展性目前来说还不算一个问题($3.4)</p>\n<p>Google的开源Kubernetes系统[53]把应用放在Docker容器内[28]，分发到多机器上。它可以跑在物理机(和Borg一样)或跑在其他云比如GCE提供的主机上。Kubernetes的开发者和Borg是同一拨人而且正在狂开发中。Google提供了一个云主机版本叫Google Container Engine [39]。我们会在下一节里面讨论从Borg中学到了哪些东西用在了Kubernetes上。</p>\n<p>在高性能计算社区有一些这个领域的长期传统工作(e.g., Maui, Moab, Platform LSF [2, 47, 50])；但是这和Google Cell所需要的规模、工作负载、容错性是完全不一样的。大概来说，这些系统通过让很多任务等待在一个长队列里面来获取极高的资源利用率。</p>\n<p>虚拟化提供商例如VMware [77]和数据中心方案提供商例如HP and IBM [46]给了一个大概在1000台机器量级的集群解决方案。另外，一些研究小组用几种方式提升了资源调度质量(e.g., [25, 40, 72, 74])。</p>\n<p>最后，就像我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]写了如何做故障计划、多租户、健康检查、权限控制、和重启动性来获得更大的机器数/操作员比。Borg的设计哲学也是这样的，让我们的一个SRE能支撑超过万台机器。</p>\n<h1 id=\"8-经验教训和未来工作\"><a href=\"#8-经验教训和未来工作\" class=\"headerlink\" title=\"8. 经验教训和未来工作\"></a>8. 经验教训和未来工作</h1><p>在这一节中我们会聊一些十年以来我们在生产环境操作Borg得到的定性经验，然后描述下这些观察结果是怎么改善Kubernete[53]的设计。</p>\n<h2 id=\"8-1-教训\"><a href=\"#8-1-教训\" class=\"headerlink\" title=\"8.1 教训\"></a>8.1 教训</h2><p>我们会从一些受到吐槽的Borg特性开始，然后说说Kubernetes是怎么干的。</p>\n<p><strong>Jobs是唯一的task分组的机制。</strong>Borg没有天然的方法去管理多个job组成单个实体，或者去指向相关的服务实例(例如，金丝雀和生产跟踪)。作为hack，用户把他们的服务拓扑编码写在job名字里面，然后用更高层的工具区解析这些名字。这个问题的另外一面是，没办法去指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级和改变job的实例数。</p>\n<p>为了避免这些困难，Kubernetes不用job这个概念，而是用标签(label)来管理它的调度单位(pods)，标签是任意的键值对，用户可以把标签打在系统的所有对象上。这样，对于一个Borg job，就可以在pod上打上job:jobname这样的标签，其他的有用的分组也可以用标签来表示，例如服务、层级、发布类型(生产、测试、阶段)。Kubernetes用标签选择这种方式来选取对象，完成操作。这样就比固定的job分组更加灵活好用。</p>\n<p><strong>一台机器一个IP把事情弄复杂了。</strong>在Borg里面，所有一台机器上的task都使用同一个IP地址，然后共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；task必须先声明他们需要多少端口，然后了解启动的时候哪些可以用；Borglet必须完成端口隔离；命名和RPC系统必须和IP一样处理端口。</p>\n<p>非常感谢Linux namespace，虚拟机，IPv6和软件定义网络SDN。Kubernetes可以用一种更用户友好的方式来消解这些复杂性：所有pod和service都可以有一个自己的IP地址，允许开发者选择端口而不是委托基础设施来帮他们选择，这些就消除了基础设置管理端口的复杂性。</p>\n<p><strong>给资深用户优化而忽略了初级用户。</strong>Borg提供了一大堆针对“资深用户”的特性这样他们可以仔细的调试怎么跑他们的程序(BCL有230个参数的选项)：开始的目的是为了支持Google的大资源用户，提升他们的效率会带来更大的效益。但是很不幸的是这么复杂的API让初级用户用起来很复杂，约束了他们的进步。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中来决定合理的配置。这就让皮实的应用从实验中获得了自由：即使自动化出了麻烦的问题也不会导致灾难。</p>\n<h2 id=\"8-2-经验\"><a href=\"#8-2-经验\" class=\"headerlink\" title=\"8.2 经验\"></a>8.2 经验</h2><p>另一方面，有不少Borg的设计是非常有益的，而且经历了时间考验。</p>\n<p><strong>Allocs是有用的。</strong>Borg alloc抽象导出了广泛使用的logsaver样式($2.4)和另一个流行样式：定期数据载入更新的web server。Allocs和packages允许这些辅助服务能被一个独立的小组开发。Kubernetes相对于alloc的设计是pod，是一个多个容器共享的资源封装，总是被调度到同一台机器上。Kubernetes用pod里面的辅助容器来替代alloc里面的task，不过思想是一样的。</p>\n<p><strong>集群管理比task管理要做更多的事。</strong>虽然Borg的主要角色是管理tasks和机器的生命周期，但Borg上的应用还是从其他的集群服务中收益良多，例如命名和负载均衡。Kubernetes用service抽象来支持命名和负载均衡：service有一个名字，用标签选择器来选择多个pod。在底下，Kubernetes自动的在这个service所拥有的pod之间自动负载均衡，然后在pod挂掉后被重新调度到其他机器上的时候也保持跟踪来做负载均衡。</p>\n<p><strong>反观自省是至关重要的。</strong>虽然Borg基本上是“just works”的，但当有出了问题后，找到这个问题的根源是非常有挑战性的。一个关键设计抉择是Borg把所有的debug信息暴露给用户而不是隐藏：Borg有几千个用户，所以“自助”是debug的第一步。虽然这会让我们很难抛弃一些用户依赖的内部策略，但这还是成功的，而且我们没有找到其他现实的替代方式。为了管理这么巨量的资源，我们提供了几层UI和debug工具，这样就可以升入研究基础设施本身和应用的错误日志和事件细节。</p>\n<p>Kubernetes也希望重现很多Borg的自探查技术。例如它和cAdvisor [15] 一切发型用于资源监控，用Elasticsearch/Kibana [30] 和 Fluentd [32]来做日志聚合。从master可以获取一个对象的状态快照。Kubernetes有一个一致的所有组件都能用的事件记录机制(例如pod被调度、容器挂了)，这样客户端就能访问。</p>\n<p><strong>master是分布式系统的核心.</strong>Borgmaster原来被设计成一个单一的系统，但是后来，它变成了服务生态和用户job的核心。比方说，我们把调度器和主UI(Sigma)分离出来成为单独的进程，然后增加了权限控制、纵向横向扩展、重打包task、周期性job提交(cron)、工作流管理，系统操作存档用于离线查询。最后，这些让我们能够提升工作负载和特性集，而无需牺牲性能和可维护性。</p>\n<p>Kubernetes的架构走的更远一些：它有一个API服务在核心，仅仅负责处理请求和维护底下的对象的状态。集群管理逻辑做成了一个小的、微服务类型的客户端程序和API服务通信，其中的副本管理器(replication controller)，维护在故障情况下pod的服务数量，还有节点管理器(node controller)，管理机器生命周期。</p>\n<h2 id=\"8-3-总结\"><a href=\"#8-3-总结\" class=\"headerlink\" title=\"8.3 总结\"></a>8.3 总结</h2><p>在过去十年间所有几乎所有的Google集群负载都移到了Borg上。我们将会持续改进，并把学到的东西应用到Kubernetes上。</p>\n<p>#鸣谢</p>\n<p>这篇文章的作者同时也评审了这篇文章。但是几十个设计、实现、维护Borg组件和生态系统工程师才是这个系统成功的关键。我们在这里列表设计、实现、操作Borgmaster和Borglet的主要人员。如有遗漏抱歉。</p>\n<p>Borgmaster主设计师和实现者有Jeremy Dion和Mark Vandevoorde，还有Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu, Monika Henzinger。Borglet的主要设计实现者是Paul Menage。</p>\n<p>其他贡献者包括Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, OnufryWojtaszczyk, Patrick Johnson, Pedro Valenzuela, PiotrWitusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, TomaszWozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.</p>\n<p>Borg SRE团队也是非常重要的，包括Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, and Viraj Alankar。Borg配置语言(BCL)和borgcfg工具是Marcel van Lohuizen, Robert Griesemer制作的。</p>\n<p>谢谢我们的审稿人(尤其是especially Eric Brewer, Malte Schwarzkopf and Tom Rodeheffer)，以及我们的牧师Christos Kozyrakis，对这篇论文的反馈。</p>\n<p>#参考文献</p>\n<p>[1] O. A. Abdul-Rahman and K. Aida. Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon. In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.</p>\n<p>[2] Adaptive Computing Enterprises Inc., Provo, UT. MauiScheduler Administrator’s Guide, 3.2 edition, 2011.</p>\n<p>[3] T. Akidau, A. Balikov, K. Bekiro˘glu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. MillWheel: fault-tolerant stream processing at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.</p>\n<p>[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. An opportunity cost approach for job assignment in a scalable computing cluster. IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.</p>\n<p>[5] Apache Aurora.<a href=\"http://aurora.incubator.apache.org/\" target=\"_blank\" rel=\"external\">http://aurora.incubator.apache.org/</a>, 2014.</p>\n<p>[6] Aurora Configuration Tutorial. <a href=\"https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014\" target=\"_blank\" rel=\"external\">https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014</a>.</p>\n<p>[7] AWS. Amazon Web Services VM Instances. <a href=\"http://aws.amazon.com/ec2/instance-types/\" target=\"_blank\" rel=\"external\">http://aws.amazon.com/ec2/instance-types/</a>, 2014.</p>\n<p>[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. Megastore: Providing scalable, highly available storage for interactive services. In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.</p>\n<p>[9] M. Baker and J. Ousterhout. Availability in the Sprite distributed file system. Operating Systems Review,25(2):95–98, Apr. 1991.</p>\n<p>[10] L. A. Barroso, J. Clidaras, and U. H¨olzle. The datacenter as a computer: an introduction to the design of warehouse-scale machines. Morgan Claypool Publishers, 2nd edition, 2013.</p>\n<p>[11] L. A. Barroso, J. Dean, and U. Holzle. Web search for a planet: the Google cluster architecture. In IEEE Micro, pages 22–28, 2003.</p>\n<p>[12] I. Bokharouss. GCL Viewer: a study in improving the understanding of GCL programs. Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.</p>\n<p>[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. Apollo: scalable and coordinated scheduling for cloud-scale computing. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.</p>\n<p>[14] M. Burrows. The Chubby lock service for loosely-coupled distributed systems. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.</p>\n<p>[15] cAdvisor. <a href=\"https://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">https://github.com/google/cadvisor</a>, 2014</p>\n<p>[16] CFS per-entity load patches. <a href=\"http://lwn.net/Articles/531853\" target=\"_blank\" rel=\"external\">http://lwn.net/Articles/531853</a>, 2013.</p>\n<p>[17] cgroups. <a href=\"http://en.wikipedia.org/wiki/Cgroups\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Cgroups</a>, 2014.</p>\n<p>[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. FlumeJava: easy, efficient data-parallel pipelines. In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.</p>\n<p>[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. Bigtable: a distributed storage system for structured data. ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.</p>\n<p>[20] Y. Chen, S. Alspaugh, and R. H. Katz. Design insights for MapReduce from diverse production workloads. Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.</p>\n<p>[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. Reservation-based scheduling: if you’re late don’t blame us! In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.</p>\n<p>[22] J. Dean and L. A. Barroso. The tail at scale. Communications of the ACM, 56(2):74–80, Feb. 2012.</p>\n<p>[23] J. Dean and S. Ghemawat. MapReduce: simplified data processing on large clusters. Communications of the ACM, 51(1):107–113, 2008.</p>\n<p>[24] C. Delimitrou and C. Kozyrakis. Paragon: QoS-aware scheduling for heterogeneous datacenters. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.</p>\n<p>[25] C. Delimitrou and C. Kozyrakis. Quasar: resource-efficient and QoS-aware cluster management. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.</p>\n<p>[26] S. Di, D. Kondo, and W. Cirne. Characterization and comparison of cloud versus Grid workloads. In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.</p>\n<p>[27] S. Di, D. Kondo, and C. Franck. Characterizing cloud applications on a Google data center. In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.</p>\n<p>[28] Docker Project. <a href=\"https://www.docker.io/\" target=\"_blank\" rel=\"external\">https://www.docker.io/</a>, 2014.</p>\n<p>[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. No justified complaints: on fair sharing of multiple resources. In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.</p>\n<p>[30] ElasticSearch. <a href=\"http://www.elasticsearch.org\" target=\"_blank\" rel=\"external\">http://www.elasticsearch.org</a>, 2014.</p>\n<p>[31] D. G. Feitelson. Workload Modeling for Computer Systems Performance Evaluation. Cambridge University Press, 2014.</p>\n<p>[32] Fluentd. <a href=\"http://www.fluentd.org/\" target=\"_blank\" rel=\"external\">http://www.fluentd.org/</a>, 2014.</p>\n<p>[33] GCE. Google Compute Engine. http: //cloud.google.com/products/compute-engine/, 2014.</p>\n<p>[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. The Google File System. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.</p>\n<p>[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. Dominant Resource Fairness: fair allocation of multiple resource types. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.</p>\n<p>[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. Choosy: max-min fair sharing for datacenter jobs with constraints. In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.</p>\n<p>[37] D. Gmach, J. Rolia, and L. Cherkasova. Selling T-shirts and time shares in the cloud. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.</p>\n<p>[38] Google App Engine. <a href=\"http://cloud.google.com/AppEngine\" target=\"_blank\" rel=\"external\">http://cloud.google.com/AppEngine</a>, 2014.</p>\n<p>[39] Google Container Engine (GKE). <a href=\"https://cloud.google.com/container-engine/\" target=\"_blank\" rel=\"external\">https://cloud.google.com/container-engine/</a>, 2015.</p>\n<p>[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. Multi-resource packing for cluster schedulers. In Proc. ACM SIGCOMM, Aug. 2014.</p>\n<p>[41] Apache Hadoop Project. <a href=\"http://hadoop.apache.org/\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/</a>, 2009.</p>\n<p>[42] Hadoop MapReduce Next Generation – Capacity Scheduler. http: //hadoop.apache.org/docs/r2.2.0/hadoop-yarn/ hadoop-yarn-site/CapacityScheduler.html, 2013.</p>\n<p>[43] J. Hamilton. On designing and deploying internet-scale services. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.</p>\n<p>[44] P. Helland. Cosmos: big data and big challenges. <a href=\"http://research.microsoft.com/en-us/events/\" target=\"_blank\" rel=\"external\">http://research.microsoft.com/en-us/events/</a> fs2011/helland_cosmos_big_data_and_big\\ _challenges.pdf, 2011.</p>\n<p>[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. Mesos: a platform for fine-grained resource sharing in the data center. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.</p>\n<p>[46] IBM Platform Computing. <a href=\"http://www-03.ibm.com/\" target=\"_blank\" rel=\"external\">http://www-03.ibm.com/</a> systems/technicalcomputing/platformcomputing/ products/clustermanager/index.html.</p>\n<p>[47] S. Iqbal, R. Gupta, and Y.-C. Fang. Planning considerations for job scheduling in HPC clusters. Dell Power Solutions, Feb. 2005.</p>\n<p>[48] M. Isaard. Autopilot: Automatic data center management. ACM SIGOPS Operating Systems Review, 41(2), 2007.</p>\n<p>[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. Quincy: fair scheduling for distributed computing clusters. In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.</p>\n<p>[50] D. B. Jackson, Q. Snell, and M. J. Clement. Core algorithms of the Maui scheduler. In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.</p>\n<p>[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. Measuring interference between live datacenter applications. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.</p>\n<p>[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. An analysis of traces from a production MapReduce cluster. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.</p>\n<p>[53] Kubernetes. <a href=\"http://kubernetes.io\" target=\"_blank\" rel=\"external\">http://kubernetes.io</a>, Aug. 2014.</p>\n<p>[54] Kernel Based Virtual Machine. <a href=\"http://www.linux-kvm.org\" target=\"_blank\" rel=\"external\">http://www.linux-kvm.org</a>.</p>\n<p>[55] L. Lamport. The part-time parliament. ACM Trans. on Computer Systems, 16(2):133–169, May 1998.</p>\n<p>[56] J. Leverich and C. Kozyrakis. Reconciling high server utilization and sub-millisecond quality-of-service. In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.</p>\n<p>[57] Z. Liu and S. Cho. Characterizing machines and workloads on a Google cluster. In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.</p>\n<p>[58] Google LMCTFY project (let me contain that for you). <a href=\"http://github.com/google/lmctfy\" target=\"_blank\" rel=\"external\">http://github.com/google/lmctfy</a>, 2014.</p>\n<p>[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. Pregel: a system for large-scale graph processing. In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.</p>\n<p>[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations. In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.</p>\n<p>[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. Dremel: interactive analysis of web-scale datasets. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.</p>\n<p>[62] P. Menage. Linux control groups. <a href=\"http://www.kernel\" target=\"_blank\" rel=\"external\">http://www.kernel</a>. org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.</p>\n<p>[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. Towards characterizing cloud backend workloads: insights from Google compute clusters. ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.</p>\n<p>[64] A. Narayanan. Tupperware: containerized deployment at Facebook. <a href=\"http://www.slideshare.net/dotCloud/\" target=\"_blank\" rel=\"external\">http://www.slideshare.net/dotCloud/</a> tupperware-containerized-deployment-at-facebook, June 2014.</p>\n<p>[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. Sparrow: distributed, low latency scheduling. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.</p>\n<p>[66] D. C. Parkes, A. D. Procaccia, and N. Shah. Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities. In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.</p>\n<p>[67] Protocol buffers. https: //developers.google.com/protocol-buffers/, and <a href=\"https://github.com/google/protobuf/\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/</a>., 2014.</p>\n<p>[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. Heterogeneity and dynamicity of clouds at scale: Google trace analysis. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.</p>\n<p>[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. Omega: flexible, scalable schedulers for large compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.</p>\n<p>[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. Modeling and synthesizing task placement constraints in Google compute clusters. In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.</p>\n<p>[71] E. Shmueli and D. G. Feitelson. On simulation and design of parallel-systems schedulers: are we doing the right thing? IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.</p>\n<p>[72] A. Singh, M. Korupolu, and D. Mohapatra. Server-storage virtualization: integration and load balancing in data centers. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.</p>\n<p>[73] Apache Spark Project. <a href=\"http://spark.apache.org/\" target=\"_blank\" rel=\"external\">http://spark.apache.org/</a>, 2014.</p>\n<p>[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.</p>\n<p>[75] P. Turner, B. Rao, and N. Rao. CPU bandwidth control for CFS. In Proc. Linux Symposium, pages 245–254, July 2010.</p>\n<p>[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. Apache Hadoop YARN: Yet Another Resource Negotiator. In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.</p>\n<p>[77] VMware VCloud Suite. <a href=\"http://www.vmware.com/products/vcloud-suite/\" target=\"_blank\" rel=\"external\">http://www.vmware.com/products/vcloud-suite/</a>.</p>\n<p>[78] A. Verma, M. Korupolu, and J. Wilkes. Evaluating job packing in warehouse-scale computing. In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.</p>\n<p>[79] W. Whitt. Open and closed models for networks of queues. AT&amp;T Bell Labs Technical Journal, 63(9), Nov. 1984.</p>\n<p>[80] J. Wilkes. More Google cluster data. <a href=\"http://googleresearch.blogspot.com/2011/11/\" target=\"_blank\" rel=\"external\">http://googleresearch.blogspot.com/2011/11/</a> more-google-cluster-data.html, Nov. 2011.</p>\n<p>[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. HaPPy: Hyperthread-aware power profiling dynamically. In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.</p>\n<p>[82] Q. Zhang, J. Hellerstein, and R. Boutaba. Characterizing task usage shapes in Google’s compute clusters. In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.</p>\n<p>[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. CPI2: CPU performance isolation for shared compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.</p>\n<p>[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. Fuxi: a fault-tolerant resource management and job scheduling system at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.</p>\n<h1 id=\"勘误-2015-04-23\"><a href=\"#勘误-2015-04-23\" class=\"headerlink\" title=\"勘误 2015-04-23\"></a>勘误 2015-04-23</h1><p>自从胶片版定稿后，我们发现了若干疏忽和歧义。</p>\n<h2 id=\"用户视角\"><a href=\"#用户视角\" class=\"headerlink\" title=\"用户视角\"></a>用户视角</h2><p>SRE干的比SA(system administration)要多得多：他们是Google生产服务的负责工程师。他们设计和实现软件，包括自动化系统、管理应用、底层基础设施服务来保证Google这个量级的高可靠和高性能。</p>\n<h2 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h2><p>我们不小心忽略了Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, and Pavanish Nirula。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] Michael Litzkow, Miron Livny, and Matt Mutka. “Condor - A Hunter of Idle Workstations”. In Proc. Int’l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.</p>\n<p>[2] Rajesh Raman, Miron Livny, and Marvin Solomon. “Matchmaking: Distributed Resource Management for High Throughput Computing”. In Proc. Int’l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.</p>\n","site":{"data":{}},"excerpt":"<p>发表于EuroSys 2015的 <strong><em>Large-scale cluster management at Google with Borg</em></strong> 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。</p>","more":"<hr>\n<p><strong>Large-scale cl uster management at Google with Borg</strong></p>\n<p>作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes</p>\n<p><a href=\"http://research.google.com/pubs/pub43438.html\" target=\"_blank\" rel=\"external\">http://research.google.com/pubs/pub43438.html</a> 或 直接 <a href=\"/doc/EuroSys15_Borg.pdf\">下载PDF全文</a></p>\n<p>译者：难易 <a href=\"http://my.oschina.net/HardySimpson\" target=\"_blank\" rel=\"external\">http://my.oschina.net/HardySimpson</a></p>\n<p>EuroSys’15, <a href=\"http://dx.doi.org/10.1145/2741948.2741964\" target=\"_blank\" rel=\"external\">http://dx.doi.org/10.1145/2741948.2741964</a></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>谷歌的Borg系统群集管理器运行几十万个以上的jobs，来自几千个不同的应用，跨多个集群，每个集群有上万个机器。</p>\n<p>它通过管理控制、高效的任务包装、超售、和进程级别性能隔离实现了高利用率。它支持高可用性应用程序与运行时功能，最大限度地减少故障恢复时间，减少相关故障概率的调度策略。Borg简化了用户生活，通过提供一个声明性的工作规范语言，名称服务集成，实时作业监控，和分析和模拟系统行为的工具。</p>\n<p>我们将会展现Borg系统架构和特点，重要的设计决策，定量分析它的一些策略，和十年以来的运维经验和学到的东西。</p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>集群管理系统我们内部叫Borg，它管理、调度、开始、重启和监控谷歌运行的应用程序的生命周期。本文介绍它是怎么做到这些的。</p>\n<p>Borg提供了三个主要的好处：它（1）隐藏资源管理和故障处理细节，使其用户可以专注于应用开发；（2）高可靠性和高可用性的操作，并支持应用程序做到高可靠高可用；（3）让我们在跨数以万计的机器上有效运行。Borg不是第一个来解决这些问题的系统，但它是在这个规模，这种程度的弹性和完整性下运行的为数不多的几个系统之一。</p>\n<p>本文围绕这些主题来编写，包括了我们在生产环境运行十年的一些功力。</p>\n<p><img src=\"/img/borg-fig-01.png\" alt=\"Fig. 1\"></p>\n<h1 id=\"2-用户视角\"><a href=\"#2-用户视角\" class=\"headerlink\" title=\"2.用户视角\"></a>2.用户视角</h1><p>Borg的用户是谷歌开发人员和系统管理员(网站可靠性工程师 SRE)，他们运行谷歌应用与服务。用户以job的方式提交他们的工作给Borg，job由一个或多个task组成，每个task含有同样的二进制程序。一个job在一个Borg的Cell里面跑，一个Cell是包括了多台机器的单元。这一节主要讲用户视角下的Borg系统。</p>\n<h2 id=\"2-1-工作负载\"><a href=\"#2-1-工作负载\" class=\"headerlink\" title=\"2.1 工作负载\"></a>2.1 工作负载</h2><p>Borg Cell主要运行两种异构的工作负载。第一种是长期的服务，应该“永远”运行下去，并处理短时间的敏感请求（几微秒到几百毫秒）。这种服务是面向终端用户的产品如Gmail、Google Docs、网页搜索，内部基础设施服务（例如，Bigtable）。第二种是批处理任务，需要几秒到几天来完成，对短期性能波动不敏感。在一个Cell上混合运行了这两种负载，取决于他们的主要租户（比如说，有些Cell就是专门用来跑密集的批处理任务的）。工作负载也随着时间会产生变化：批处理任务做完就好，终端用户服务的负载是以每天为周期的。Borg需要把这两种情况都处理好。</p>\n<p>Borg有一个2011年5月的负载数据[80]，已经被广泛的分析了[68,26，27，57，1]。</p>\n<p>最近几年，很多应用框架是搭建在Borg上的，包括我们内部的MapReduce[23]、flumejava[18]、Millwheel[3]、Pregel[59]。这中间的大部分都是有一个控制器，可以提交job。前2个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和他的后继者CFS、Bigtable[19]、Megastore[8]都是跑在Borg上的。</p>\n<p>在这篇文章里面，我们把高优先级的Borg的jobs定义为生产(prod)，剩下的是非生产的(non-prod)。大多长期服务是prod的，大部分批处理任务是non-prod的。在一个典型的Cell里面，prod job分配了70%的CPU资源然后实际用了60%；分配了55%的内存资源然后实际用了85%。在$5.5会展示分配和实际值的差是很重要的。</p>\n<h2 id=\"2-2-集群和Cell\"><a href=\"#2-2-集群和Cell\" class=\"headerlink\" title=\"2.2 集群和Cell\"></a>2.2 集群和Cell</h2><p>一个Cell里面的所有机器都属于单个集群，集群是由高性能的数据中心级别的光纤网络连接起来的。一个集群安装在数据中心的一座楼里面，n座楼合在一起成为一个site。一个集群通常包括一个大的Cell还有一些小的或测试性质的Cell。我们尽量避免任何单点故障。</p>\n<p>在测试的Cell之外，我们中等大小的Cell大概包括10000台机器；一些Cell还要大很多。一个Cell中的机器在很多方面都是异构的：大小(CPU,RAM,disk,network)、处理器类型、性能以及外部IP地址或flash存储。Borg隔离了这些差异，让用户单纯的选择用哪个Cell来跑任务，分配资源、安装程序和其它依赖、监控系统的健康并在故障时重启。</p>\n<p>(译者：Cell其实就是逻辑上的集群)</p>\n<h2 id=\"2-3-job和task\"><a href=\"#2-3-job和task\" class=\"headerlink\" title=\"2.3 job和task\"></a>2.3 job和task</h2><p>一个Borg的job的属性有：名字、拥有者和有多少个task。job可以有一些约束，来指定这个job跑在什么架构的处理器、操作系统版本、是否有外部IP。约束可以是硬的或者软的。一个job可以指定在另一个job跑完后再开始。一个job只在一个Cell里面跑。</p>\n<p>每个task包括了一组linux进程，跑在一台机器的一个容器内[62]。大部分Borg的工作负载没有跑在虚拟机(VM)里面，因为我们不想付出虚拟化的代价。而且，Borg在设计的时候还没硬件虚拟化什么事儿哪。</p>\n<p>task也有一些属性，包括资源用量，在job中的排序。大多task的属性和job的通用task属性是一样的，也可以被覆盖 —— 例如，提供task专用的命令行参数，包括CPU核、内存、磁盘空间、磁盘访问速度、TCP端口等等，这些都是可以分别设置并按照一个好的粒度提供。我们不提供固定的资源的单元。Borg程序都是静态编译的，这样在跑的环境下就没有依赖，这些程序都被打成一个包，包括二进制和数据文件，能被Borg安装起来。</p>\n<p>用户通过RPC来操作Borg的job，大多是从命令行工具，或者从我们的监控系统($2.6)。大多job描述文件是用一种申明式配置文件BCL – GCL[12]的一个变种，会产生一个protobuf文件[67]。BCL有一些自己的关键字。GCL提供了lambda表达式来允许计算，这样就能让应用在环境里面调整自己的配置。上万个BCL配置文件超过一千行长，系统中累计跑了了千万行BCL。Borg的job配置很类似于Aurora配置文件[6]。</p>\n<p><img src=\"/img/borg-fig-02.png\" alt=\"Fig. 2\"></p>\n<p>图2展现了job的和task的状态机和生命周期。</p>\n<p>用户可以在运行时改变一个job中的task的属性，通过推送一个新的job配置给Borg。这个新的配置命令Borg更新task的规格。这就像是跑一个轻量级的，非原子性的事务，而且可以在提交后轻易再改回来。更新是滚动式的，在更新中可以限制task重启的数量，如果有太多task停掉，操作可以终止。</p>\n<p>一些task更新，例如更新二进制程序，需要task重启；另外一些例如修改资源需求和限制会导致这个机器不适合跑现有的task，需要停止task再重新调度到别的机器上；还有一些例如修改优先级是可以不用重启或者移动task的。</p>\n<p>task需要能够接受Unix的SIGTERM信号，在他们被强制发送SIGKILL之前，这样就有时间去做清理、保存状态、结束现有请求执行、拒绝新请求。实际的notice的delay bound。实践中，80%的task能正常处理终止信号。</p>\n<h2 id=\"2-4-Allocs\"><a href=\"#2-4-Allocs\" class=\"headerlink\" title=\"2.4 Allocs\"></a>2.4 Allocs</h2><p>Borg的alloc(allocation的缩写)是在单台机器上的一组保留的资源配额，用来让一个或更多的task跑；这些资源一直分配在那边，无论有没有被用。allocs可以被分配出来给未来的task，用来保持资源在停止一个task和重启这个task之间，用来聚集不同jobs的tasks到同一台机器上——例如一个web server实例和附加的，用于把serverURL日志发送到一个分布式文件系统的日志搜集实例。一个alloc的资源管理方式和一台机器上的资源管理方式是类似的；多个tasks在一个alloc上跑并共享资源。如果一个alloc必须被重新定位到其他的机器上，那么它的task也要跟着重新调度。</p>\n<p>一个alloc set就像一个job：它是一组allocs保留了多台机器上的资源。一旦alloc set被创建，一个或多个jobs就可以被提交进去跑。简而言之，我们会用task来表示一个alloc或者一个top-level task(一个alloc之外的)，用job来表示一个job或者alloc set。</p>\n<h2 id=\"2-5-优先级、配额和管理控制\"><a href=\"#2-5-优先级、配额和管理控制\" class=\"headerlink\" title=\"2.5 优先级、配额和管理控制\"></a>2.5 优先级、配额和管理控制</h2><p>当有超量的工作负载在运行的时候会发生什么事情？我们的解决方案是优先级和配额。</p>\n<p>所有job都有优先级，一个小的正整数。高优先级的task可以优先获取资源，即使后面被杀掉。Borg定义了不重叠的优先级段给不同任务用，包括(优先级降序)：监控、生产、批任务、高性能(测试或免费)。在这篇文章里面，prod的jobs是在监控和生产段。</p>\n<p>虽然一个降级的task总会在cell的其他地方找到一席之地。降级瀑布也有可能会发生，就是一个task降下来之后，把下面运行的task再挤到别的机器上，如此往复。为了避免这种情况，我们禁止了prod级task互相排挤。合理粒度的优先级在其他场景下也很有用——MapReduce的master跑的优先级比worker高一点，来保证他们的可用性。</p>\n<p>优先级是jobs的相对重要性，决定了jobs在一个cell里面是跑还是等(pending)。配额则是用来决定jobs是否运行被调度。配额就是一组资源(CPU, RAM, disk)的数量在一个指定的优先级、一个指定的时间段(月这个量级)。数量决定了这个用户的job可以用的最多资源(例子：20TB内存和prod优先级从现在到7月在xx cell内)。配额检查是管理控制的一部分，不是调度层的：配额不足的任务在提交的时候就会被拒绝。</p>\n<p>高优先级的配额总是花费的比低优先级要多。prod级的配额是被限制为一个cell里面实际的资源量，所以用户提交了prod级的job的配额时，可以期待这个job一定会跑，去掉一些碎片外。即使这样，我们鼓励用户多买一点比自己需要多一点的配额，很多用户超买是因为他们的应用程序的用户数量增长后需要的配额就大了。对于超买，我们的应对方案是低优先级资源的超售：所有用户在0优先级都可以用无限的配额，虽然在实际运行中这种情况很难跑起来。一个低优先级的job在资源不足时会保持等(pending)状态。</p>\n<p>配额分配在Borg系统之外，和我们的物理资源计划有关。这些资源计划在不同的数据中心产生不同的价格和配额。用户jobs只在有足够配额和足够优先级之后才能启动。配额的使用让Dominant Resource Fairness(DRF)[29, 35, 36, 66]不是那么必要了。</p>\n<p>Borg有一个容量系统给一些特殊权限给某些用户，例如，允许管理员删除或修改cell里面的job，或者允许用户区访问特定的内核特性或者让Borg对自己的job不做资源估算($5.5)。</p>\n<h2 id=\"2-6-命名和监控\"><a href=\"#2-6-命名和监控\" class=\"headerlink\" title=\"2.6 命名和监控\"></a>2.6 命名和监控</h2><p>光是创建和部署task是不够的：一个服务的客户端和其他系统需要能找到它们，即使它换了个地方。为了搞定这一点，Borg创造了一个稳定的“Borg name Service”(BNS)名字给每个task，这个名字包括了cell名字，job名字，和task编号。Borg把task的主机名和端口写入到一个持久化高可用文件里，以BNS名为文件名，放在Chubby[14]上。这个文件被我们的RPC系统使用，用来发现task的终端地址。BNS名称也是task的DNS名的基础构成部分，所以，cc cell的ubar用户的jfoo job的第50个task的DNS名称会是50.jfoo.ubar.cc.borg.google.com。Borg同时还会把job的大小和task的健康信息写入到Chubby在任何情况改变时，这样负载均衡就能知道怎么去路由请求了。</p>\n<p>几乎所有的Borg的task都会包含一个内置的HTTP服务，用来发布健康信息和几千个性能指标(例如RPC延时)。Borg监控这些健康检查URL，把其中响应超时的和error的task重启。其他数据也被监控工具追踪并在Dashboards上展示，当服务级别对象(SLO)出问题时就会报警。</p>\n<p>用户可以使用一个名叫Sigma的web UI，用来检查他们所有的job状态，一个特殊的cell，或者深入到某个job的某个task的资源用率，详细日志，操作历史，和最终命运。我们的应用产生大量的日志，都会被自动的滚动来避免塞满硬盘，会在一个task结束后保留一小段时间用来debug。如果一个job没有被跑起来，Borg会提供一个为什么挂起的解释，指导用户怎么修改这个job的资源需求来符合目前这个cell的情况。我们发布资源的使用方针，按照这个方针来做就容易被调度起来。</p>\n<p>Borg记录所有的job提交和task时间，以及每task的资源使用细节在基础存储服务里面。这个存储服务有一个分布式的只读的SQL-like的交互式接口，通过Dremel[61]提供出来。这些数据在实时使用、debug、系统查错和长期容量规划上都很有用。这些数据也是Google集群负载追踪的数据来源之一[80].</p>\n<p>所有这些特性帮助用户理解和debug Borg的行为和管理他们的job，并且帮助我们的SRE每个人管理超过上万台机器。</p>\n<h1 id=\"3-Borg架构\"><a href=\"#3-Borg架构\" class=\"headerlink\" title=\"3. Borg架构\"></a>3. Borg架构</h1><p>一个Borg的Cell包括一堆机器，一个逻辑的中心控制服务叫做Borgmaster，和在每台机器上跑的Borglet的agent进程(见图1)。所有Borg的组件都是用C++写的。</p>\n<p><img src=\"/img/borg-fig-01.png\" alt=\"Fig. 1\"></p>\n<h2 id=\"3-1-Borgmaster\"><a href=\"#3-1-Borgmaster\" class=\"headerlink\" title=\"3.1 Borgmaster\"></a>3.1 Borgmaster</h2><p>Cell的Borgmaster由2个进程组成，主的Borgmaster进程和一个单独的scheduler($3.2)。主的Borgmaster处理所有客户端的RPC请求，例如修改状态(创建job)，提供数据读取服务(查找job)。它同时管理系统中所有组件(机器、task、allocs等等)的状态机，和Borglet通信，并且提供一个Sigma的备份Web UI。</p>\n<p>Borgmaster在逻辑上是一个单进程，但实际上开了5个副本。每个副本维护了一个内存级别的cell状态拷贝，这些状态同时被记录在一个高可用、分布式、Paxos-based存储[55]放在这些副本的本地硬盘上。在一个cell里面，一个单独的被选举出来的master同时用于Paxos leader和状态修改器，用来处理所有改变cell状态的请求，例如提交一个job或者在一个机器上终止一个task。当cell启动或前一个master挂了时，Paxos算法会选举出一个master；这需要一个Chubby锁然后其他系统可以找到master。选举一个master或者换一个新的需要的典型事件是10s，但需要大概1分钟才能让一个大的cell内生效，因为一些内存状态要重构。当一个副本从网络隔离中恢复时，需要动态的从其他Paxos副本中重新同步自己的状态。</p>\n<p>某个时刻的Borgmaster的状态被称为checkpoint，会被以快照形式+change log形式保存在Paxos存储里面。checkpoints有很多用途，包括把Borgmaster的状态恢复到以前的任意时刻(例如在处理一个请求之前，用来解决软件缺陷)；极端情况下手动修改checkpoints，形成一个持续的事件日志供今后用；或用于线下的在线仿真。</p>\n<p>一个高仿真的Borgmaster叫Fauxmaster，可以用来读取checkpoint文件，包括一份完整的Borgmaster的代码，和Borglet的存根接口。它接受RPC来改变状态机和执行操作，例如调度所有阻塞的tasks，我们用它来debug错误，和它交互就和Borgmaster交互是一样的，同样我们也有一个仿真的Borglet可以用checkpoint重放真实的交互。用户可以单步调试看到系统中的所有过去的改变。Fauxmaster在这种情况下也很有用：多个这个类型的job比较合适？以及在改变cell配置前做一个安全检查(这个操作会把任何关键jobs给踢掉吗？)</p>\n<h2 id=\"3-2-调度-schedule\"><a href=\"#3-2-调度-schedule\" class=\"headerlink\" title=\"3.2 调度 schedule\"></a>3.2 调度 schedule</h2><p>当一个job被提交的时候，Borgmaster会把它持久化的存储在Paxos存储上，然后把这个job的task放到等待(pending)的队列里面去。这个队列会被scheduler异步的扫描，然后分发task到有充足资源的机器上。scheduler主要是处理task的，不是job。扫描从高优先级到低优先级，在同个优先级上用round-robin的方式处理，以保证用户之间的公平性和避免头上的大job阻塞住。调度算法有2个部分：可行性检查(feasibility checking)，找到一台能跑task的机器，和打分(scoring)，找个一个最合适的机器。</p>\n<p>在可行性检查这个阶段，scheduler会找到一组机器，都满足task的约束而且有足够可用的资源 —— 包括了一些已经分配给低优先级任务的可以被腾出来的资源。在打分阶段，scheduler会找到其中“最好”的机器。这个分数包括了用户的偏好，但主要是被内置的标准：例如最小化的倒腾其他task，找到已经有这个task安装包的，在电力和出错的可用域之间尽可能分散的，在单台机器上混合高低优先级的task以保证高峰期扩容的。</p>\n<p>Borg原来用E-PVM[4]的变种算法来打分，在异构的资源上生成一个单一的分数，在调度一个task时最小化系统的改变。但在实践中，E-PVM最后把负载平均分配到所有机器，把扩展空间留给高峰期 —— 但这么做的代价是增加了碎片，尤其是对于大的task需要大部分机器的时候；我们有时候给这种分配取绰号叫“最差匹配”。</p>\n<p>分配策略光谱的另一端是“最佳匹配”，把机器塞任务塞的越紧越好。这样就能留下一些空的机器给用户jobs(他们也跑存储服务)，所以处理大task就比较直接了，不过，紧分配会惩罚那些对自己所需资源预估不足的用户。这种策略会伤害爆发负载的应用，而且对需要低CPU的批处理任务特别不友好，这些任务可以被轻易调度到不用的资源上：20%的non-prod task需要小于0.1核的CPU。</p>\n<p>我们目前的打分模型是一个混合的，试图减少搁浅的资源 —— 一些因为这台机器上资源没被全部用掉而剩下的。比起“最佳匹配”，这个模型提供了3%-5%的打包效率提升(在[78]里面定义的)</p>\n<p>如果一台机器在打分后没有足够的资源运行新的task，Borg会驱逐(preempts)低优先级的任务，从最低优先级往上踢，直到资源够用。我们把被踢掉的task放到scheduler的等待(pending)队列里面去，而不是迁移或冬眠这些task。</p>\n<p>task启动延迟(从job提交到task运行之间的时间段)是被我们持续关注的。这个时间差别很大，一般来说是25s。包安装耗费了这里面80%的时间：一个已知的瓶颈就是对本地硬盘的争抢。为了减少task启动时间，scheduler希望机器上已经有足够的包(程序和数据)：大部分包是只读的所以可以被分享和缓存。这是唯一一种Borg scheduler支持的数据本地化方式。顺便说一下，Borg分发包到机器的办法是树形的和BT类型的协议。</p>\n<p>另外，scheduler用了某些技术来扩散到几万台机器的cell里面。($3.4)</p>\n<h2 id=\"3-3-Borglet\"><a href=\"#3-3-Borglet\" class=\"headerlink\" title=\"3.3 Borglet\"></a>3.3 Borglet</h2><p>Borglet是部署在cell的每台机器上的本地Borg代理程序。它启动停止task；如果task失败就重启；通过修改OS内核设置来管理本地资源；滚动debug日志；把本机的状态上报给Borgmaster和其他监控系统。</p>\n<p>Borgmaster每过几秒就会轮询所有的Borglet来获取机器当前的状态还有发送任何请求。这让Borgmaster能控制交流频率，避免一个显式的流控机制，而且防止了恢复风暴[9].</p>\n<p>选举出来的master负责发送消息给Borglet并且根据响应更新cell的状态。为了性能可扩展，每个Borgmaster副本会运行一个无状态的连接分配(link shard)来处理和特定几个Borglet的交流；这个分配会在Borgmaster选举的时候重新计算。为了保证弹性，Borglet把所有状态都报上来，但是link shard会聚合和压缩这些信息到状态机，来减少选举出来的master的负载。</p>\n<p>如果Borglet几次没有响应轮询请求，将会被标记为挂了(down)，然后上面跑的task会被重新分配到其他机器。如果通讯恢复，Borgmaster会让这个Borglet杀掉已经被分配出去的task，来避免重复。Borglet会继续常规的操作即使和Borgmaster恢复联系，所以目前跑的task和service保持运行以防所有的Borgmaster挂了。</p>\n<h2 id=\"3-4-可扩展性\"><a href=\"#3-4-可扩展性\" class=\"headerlink\" title=\"3.4 可扩展性\"></a>3.4 可扩展性</h2><p>我们还不知道Borg的可扩展性极限在哪里，每次我们碰到一个极限，我们就越过去。一个单独的Borgmaster可以管理一个cell里面几千台机器，若干个cell可以处理10000个任务每分钟。一个繁忙的Borgmaster使用10-14个CPU核以及50GB内存。我们用了几项技术来获得这种扩展性。</p>\n<p>早期的Borgmaster有一个简单的，同步的循环来处理请求、调度tasks，和Borglet通信。为了处理大的cell，我们把scheduler分出来作为一个单独的进程，然后就可以和别的Borgmaster功能并行的跑，别的Borgmaster可以开副本来容错。一个scheduler副本操作一份cell的状态拷贝。它重复地：从选举出来的master获取状态改变(包括所有的分配的和pending的工作)；更新自己的本地拷贝，做调度工作来分配task；告诉选举出来的master这些分配。master会接受这些信息然后应用之，除非这些信息不适合(例如，过时了)，这些会在scheduler的下一个循环里面处理。这一切都符合Omega[69]的乐观并行策略精神，而且我们最近真的给Borg添加这种功能，对不同的工作负载用不同的scheduler来调度。</p>\n<p>为了改进响应时间，我们增加了一些独立线程和Borglet通信、响应只读RPC。为了更高的性能，我们分享(分区)这些请求给5个Borgmaster副本$3.3。最后，这让99%的UI响应在1s以内，而95%的Borglet轮询在10s以内。</p>\n<p>一些让Borg scheduler更加可扩展的东西：</p>\n<p>分数缓存：评估一台机器的可用性和分数是比较昂贵的，所以Borg会一直缓存分数直到这个机器或者task变化了——例如，这台机器上的task结束了，一些属性修改了，或者task的需求改变了。忽略小的资源变化让缓存保质期变长。</p>\n<p>同级别均化处理：同一个Borg job的task一般来说有相同的需求和资源，所以不用一个个等待的task每次都去找可用机器，这会把所有可用的机器打n次分。Borg会对相同级别的task找一遍可用机器打一次分。</p>\n<p>适度随机：把一个大的Cell里面的所有机器都去衡量一遍可用性和打分是比较浪费的。所以scheduler会随机的检查机器，找到足够多的可用机器去打分，然后挑出最好的一个。这会减少task进入和离开系统时的打分次数和缓存失效。适度随机有点像Sparrow [65]的批处理采样技术，同样要面对优先级、驱逐、非同构系统和包安装的耗费。</p>\n<p>在我们的实验中($5)，调度整个cell的工作负载要花几百秒，但不用上面几项技术的话会花3天以上的时间。一般来说，一个在线的调度从等待队列里面花半秒就能搞定。</p>\n<h1 id=\"4-可用性\"><a href=\"#4-可用性\" class=\"headerlink\" title=\"4. 可用性\"></a>4. 可用性</h1><p><img src=\"/img/borg-fig-03.png\" alt=\"Fig. 3\"></p>\n<p>在大型分布式系统里面故障是很常见的[10,11,12]。图3展示了在15个cell里面task驱逐的原因。在Borg上跑的应用需要能处理这种事件，应用要支持开副本、存储数据到分布式存储这些技术，并能定期的做快照。即使这样，我们也尽可能的缓和这些事件造成的影响。例如，Borg：</p>\n<p>自动的重新调度被驱逐的task，如果需要放到新机器上运行<br>通过把一个job分散到不同的可用域里面去，例如机器、机架、供电域<br>在机器、OS升级这些维护性工作时，降低在同一时刻的一个job中的task的关闭率<br>使用声明式的目标状态表示和幂等的状态改变做操作，这样故障的客户端可以无损的重新启动或安全的遗忘请求<br>对于失联的机器上的task，限制一定的比率去重新调度，因为很难去区分大规模的机器故障和网络分区<br>避免特定的会造成崩溃的task:机器的匹配<br>critical级别的中间数据写到本地硬盘的日志保存task很重要，就算这个task所属的alloc被终止或调度到其他机器上，也要恢复出来做。用户可以设置系统保持重复尝试多久：若干天是比较合理的做法。<br>一个关键的Borg设计特性是：就算Borgmaster或者Borglet挂了，task也会继续运行下去。不过，保持master运行也很重要，因为在它挂的时候新的jobs不能提交，或者结束的无法更新状态，故障的机器上的task也不能重新调度。</p>\n<p>Borgmaster使用组合的技术在实践中保证99.99%的可用性：副本技术应对机器故障；管理控制应对超载；部署实例时用简单、底层的工具去减少外部依赖(译者：我猜测是rsync或者scp这种工具)。每个cell和其他cell都是独立的，这样减少了误操作关联和故障传染。为了达到这个目的，所以我们不搞大cell。</p>\n<h1 id=\"5-使用效率\"><a href=\"#5-使用效率\" class=\"headerlink\" title=\"5. 使用效率\"></a>5. 使用效率</h1><p>Borg的一个主要目的就是有效的利用Google的机器舰队，这可是一大笔财务投资：让效率提升几个百分点就能省下几百万美元。这一节讨论了和计算了一些Borg使用的技术和策略。</p>\n<h2 id=\"5-1-测度方法论\"><a href=\"#5-1-测度方法论\" class=\"headerlink\" title=\"5.1 测度方法论\"></a>5.1 测度方法论</h2><p>我们的job部署是有资源约束的，而且很少碰到负载高峰，我们的机器是异构的，我们从service job回收利用的资源跑batch job。所以，为了测量我们需要一个比“平均利用率”更抽象的标准。在做了一些实验后我们选择了cell密度(cell compaction)：给定一个负载，我们不断的从零开始(这样可以避免被一个倒霉的配置卡住)，部署到尽可能小的Cell里面去，直到再也不能从这个cell里面抽机器出来。这提供了一个清晰的终止条件，并促进了无陷阱的自动化比较，这里的陷阱指的是综合化的工作负载和建模[31]。一个定量的比较和估算技术可以看[78]，有不少微妙的细节。</p>\n<p>我们不可能在线上的cell做性能实验，所以我们用了Fauxmaster来达到高保真的模拟效果，使用了真的在线cell的负载数据包括所有的约束、实际限制、保留和常用数据($5.5)。这些数据从2014-10-1 14:00 PDT的Borg快照(checkpoints)里面提取出来。(其他快照也产生类似的结论)。我们选取了15个Borg cell来出报告，先排除了特殊目的的、测试的、小的(&lt;5000机器)的cell，然后从剩下的各种量级大小的cell中平均取样。</p>\n<p>在压缩cell实验中为了保持机器异构性，我们随机选择去掉的机器。为了保持工作负载的异构性，我们保留了所有负载，除了那些对服务和存储需要有特定需求的。我们把那些需要超过一半cell的job的硬限制改成软的，允许不超过0.2%的task持续的pending如果它们过于挑剔机器；广泛的测试表明这些结果是可重复的。如果我们需要一个大的cell，就把原cell复制扩大；如果我们需要更多的cell，就复制几份cell。</p>\n<p>所有的实验都每个cell重复11次，用不同的随机数发生器。在图上，我们用一个横线来表示最少和最多需要的机器，然后选择90%这个位置作为结果，平均或者居中的结论不会代表一个系统管理员会做的最优选择。我们相信cell压缩提供了一个公平一致的方式去比较调度策略：好的策略只需要更少的机器来跑相同的负载。</p>\n<p>我们的实验聚焦在调度(打包)某个时间点的一个负载，而不是重放一段长期的工作踪迹。这部分是因为复制一个开放和关闭的队列模型比较困难，部分是因为传统的一段时间内跑完的指标和我们环境的长期跑服务不一样，部分是因为这样比较起来比较明确，部分是因为我们相信怎么整都差不多，部分是因为我们在消费20万个Borg CPU来做测试——即使在Google的量级，这也不是一个小数目(译者：就你丫理由多！)</p>\n<p><img src=\"/img/borg-fig-04.png\" alt=\"Fig. 4\"></p>\n<p>在生产环境下，我们谨慎的留下了一些顶部空间给负载的增加，比如一些“黑天鹅”时间，负载高峰，机器故障，硬件升级，以及大范围故障(供电进灰)。图4显示了我们在现实世界中可以把cell压缩到多小。上面的基线是用来表示压缩大小的。</p>\n<h2 id=\"5-2-Cell的共享使用\"><a href=\"#5-2-Cell的共享使用\" class=\"headerlink\" title=\"5.2 Cell的共享使用\"></a>5.2 Cell的共享使用</h2><p>几乎我们所有的机器都同时跑prod和non-prod的task：在共享Borg cell里有98%的机器同时跑这2种task，在所有Borg管理的机器里面有83%同时跑这2种task(我们有一些专用的Cell跑特定任务)。</p>\n<p><img src=\"/img/borg-fig-05.png\" alt=\"Fig. 5\"></p>\n<p>鉴于很多其他的组织把面向用户应用和批处理应用在不同的集群上运行，我们设想一下如果我们也这么干会发生什么情况。图5展现了在一个中等大小的Cell上分开跑我们prod和non-prod的工作负载将需要20-30%多的机器。这是因为prod的job通常会保留一些资源来应对极少发生的负载高峰，但实际上在大多情况下不会用这些资源。Borg把这批资源回收利用了($5.5)来跑很多non-prod的工作，所以最终我们只需要更少的机器。</p>\n<p><img src=\"/img/borg-fig-06.png\" alt=\"Fig. 6\"></p>\n<p>大部分Borg cell被几千个用户共享使用。图6展现了为什么。对这个测试，如果一个用户消费超过了10TiB内存(或100TiB)，我们就把这个用户的工作负载分离到一个单独的Cell里面去。我们目前的策略展现了它的威力：即使我们设置了这么高的阈值(来分离)，也需要2-16倍多的Cell，和20-150%多的机器。资源池的方案再次有效地节省了开销。</p>\n<p>但是，或许把很多不相关的用户和job类型打包放到一台机器上，会造成CPU冲突，然后就需要更多的机器进行补偿？为了验证这一点，我们看一下在同一台机器，锁定时钟周期，每指令循环数CPI(cycles per instruction)在不同环境的task下是怎么变化的。在这种情况下，CPI是一个可比较的指标而且可以代表冲突度量，因为2倍的CPI意味着CPU密集型程序要跑2倍的时间。这些数据是从一周内12000个随机的prod的task中获取的，用硬件测量工具[83]取的，并且对采样做了权重，这样每秒CPU都是平等的。测试结果不是非常明显。</p>\n<p>我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及(强相关)这个机器上同时跑的task数量；每往一台机器上增加1个task，就会增加0.3%的CPI(线性模型过滤数据)；增加一台10%的CPU使用率，就会增加小于2%的CPI。即使这已经是一个统计意义显著的正相关性，也只是解释了我们在CPI度量上看到的5%的变化，还有其他的因素支配着这个变化，例如应用程序固有的差别和特殊的干涉图案[24,83]。</p>\n<p>比较我们从共享Cell和少数只跑几种应用的专用Cell获取的CPI采样，我们看到共享Cell里面的CPI平均值为1.58(σ=0.35,方差)，专用Cell的CPI平均值是1.53(σ=0.32,方差).也就是说，共享Cell的性能差3%。</p>\n<p>为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差(或许对冲突更敏感的程序会被挪到专用Cell里面去)，我们观察了Borglet的CPI，在所有Cell的所有机器上都会被运行。我们发现专用Cell的CPI平均值是1.20(σ=0.29,方差)，而共享Cell里面的CPI平均值为1.43(σ=0.45,方差)，暗示了在专用Cell上运行程序会比在共享Cell上快1.19倍，这就超过了CPU使用量轻负载的这个因素，轻微的有利于专用Cell。</p>\n<p>这些实验确定了仓库级别的性能测试是比较微妙的，加强了[51]中的观察，并且得出了共享并没有显著的增加程序运行的开销。</p>\n<p>不过，就算我们假设用了我们结果中最不好的数据，共享还是有益的：比起CPU的降速，在各个方案里面减少机器更重要，这会带来减少所有资源的开销，包括内存和硬盘，不仅仅是CPU。</p>\n<h2 id=\"5-3-大Cell\"><a href=\"#5-3-大Cell\" class=\"headerlink\" title=\"5.3 大Cell\"></a>5.3 大Cell</h2><p><img src=\"/img/borg-fig-07.png\" alt=\"Fig. 7\"></p>\n<p>Google建立了大Cell，为了允许大的任务运行，也是为了降低资源碎片。我们通过把负载从一个cell分到多个小cell上来测试后面那个效应(降低碎片效应)，随机的把job用round-robin方式分配出去。图7展示了用很多小cell会明显的需要更多机器。</p>\n<h2 id=\"5-4-资源请求粒度\"><a href=\"#5-4-资源请求粒度\" class=\"headerlink\" title=\"5.4 资源请求粒度\"></a>5.4 资源请求粒度</h2><p><img src=\"/img/borg-fig-08.png\" alt=\"Fig. 8\"></p>\n<p>Borg用户请求的CPU单位是千分之一核，内存和硬盘单位是byte。(1核是一个CPU的超线程，在不同机器类型中的一个通用单位)。图8展现了这个粒度的好处：CPU核和内存只有少数的“最佳击球点”，以及这些资源很少的相关性。这个分布和[68]里面的基本差不多，除了我们看到大内存的请求在90%这个线上。</p>\n<p><img src=\"/img/borg-fig-09.png\" alt=\"Fig. 9\"></p>\n<p>提供一个固定尺寸的容器和虚拟机，在IaaS(infrastructure-as-a-service)提供商里面或许是比较流行的，但不符合我们的需求。为了展现这一点，我们把CPU核和内存限制做成一个个尺寸，然后把prod的job按照大一点最近的尺寸去跑(取这2个维度的平方值之和最近，也就是2维图上的直线)，0.5核的CPU,1G的内存为差值。图9显示了一般情况下我们需要30-50%多的资源来运行。上限来自于把大的task跑在一整台机器上，这些task即使扩大四倍也没办法在原有Cell上压缩跑。下限是允许这些task等待(pending)。(这比[37]里面的数据要大100%，因为我们支持超过4中尺寸而且允许CPU和内存无限扩张)。</p>\n<h2 id=\"5-5-资源再利用\"><a href=\"#5-5-资源再利用\" class=\"headerlink\" title=\"5.5 资源再利用\"></a>5.5 资源再利用</h2><p>一个job可以声明一个限制资源，是每个task能强制保证的资源上限。Borg会先检查这个限制是不是在用户的配额内，然后检查具体的机器是否有那么多资源来调度这个task。有的用户会买超过他们需要的配额，也有用户会的task实际需要更多的资源去跑，因为Borg会杀掉那些需要更多的内存和硬盘空间的task，或者卡住CPU使用率不上去。另外，一些task偶尔需要使用他们的所有资源(例如，在一天的高峰期或者受到了一个拒绝服务攻击)，大多时候用不上那么多资源。</p>\n<p>比起把那些分出来但不用的资源浪费掉，我们估计了一个task会用多少资源然后把其他的资源回收再利用给那些可以忍受低质量资源的工作，例如批处理job。这整个过程被叫做资源再利用(resource reclamation)。这个估值叫做task自留地资源(reservation)，被Borgmaster每过几秒就计算一次，是Borglet抓取的细粒度资源消费用率。最初的自留地资源被设置的和资源限制一样大；在300s之后，也就是启动那个阶段，自留地资源会缓慢的下降到实际用量加上一个安全值。自留地资源在实际用量超过它的时候会迅速上升。</p>\n<p>Borg调度器(scheduler)使用限制资源来计算prod task的可用性($3.2)，所以这些task从来不依赖于回收的资源，也不提供超售的资源；对于non-prod的task，使用了目前运行task的自留地资源，这么新的task可以被调度到回收资源。</p>\n<p>一台机器有可能因为自留地预估错度而导致运行时资源不足 —— 即使所有的task都在限制资源之内跑。如果这种情况发生了，我们杀掉或者限制non-prod task，从来不对prod task下手。</p>\n<p><img src=\"/img/borg-fig-10.png\" alt=\"Fig. 10\"></p>\n<p>图10展示了如果没有资源再利用会需要更多的机器。在一个中等大小的Cell上大概有20%的工作负载跑在回收资源上。</p>\n<p><img src=\"/img/borg-fig-11.png\" alt=\"Fig. 11\"></p>\n<p>图11可以看到更多的细节，包括回收资源、实际使用资源和限制资源的比例。一个超内存限制的task首先会被重新调度，不管优先级有多高，所以这样就很少有task会超过内存限制。另一方面，CPU使用率是可以轻易被卡住的，所以短期的超过自留地资源的高峰时没什么损害的。</p>\n<p>图11暗示了资源再利用可能是没必要的保守：在自留地和实际使用中间有一大片差距。为了测试这一点，我们选择了一个生产cell然后调试它的预估参数到一个激进策略上，把安全区划小点，然后做了一个介于激进和基本之间的中庸策略跑，然后恢复到基本策略。</p>\n<p><img src=\"/img/borg-fig-12.png\" alt=\"Fig. 12\"></p>\n<p>图12展现了结果。第二周自留地资源和实际资源的差值是最小的，比第三周要小，最大的是第一和第四周。和预期的一样，周2和周3的OOM率有一个轻微的提升。在复查了这个结果后，我们觉得利大于弊，于是把中庸策略的参数放到其他cell上部署运行。</p>\n<h1 id=\"6-隔离性\"><a href=\"#6-隔离性\" class=\"headerlink\" title=\"6. 隔离性\"></a>6. 隔离性</h1><p>50%的机器跑9个以上的task；最忙的10%的机器大概跑25个task，4500个线程[83]。虽然在应用间共享机器会增加使用率，也需要一个比较好的机制来保证task之间不互相冲突。包括安全和性能都不能互相冲突。</p>\n<h2 id=\"6-1-安全隔离\"><a href=\"#6-1-安全隔离\" class=\"headerlink\" title=\"6.1 安全隔离\"></a>6.1 安全隔离</h2><p>我们使用Linux chroot监狱作为同一台机器不同task之间主要的安全隔离机制。为了允许远程debug，我们以前会分发ssh key来自动给用户权限去访问跑他们task的机器，现在不这么干了。对大多数用户来说，现在提供的是borgssh命令，这个程序和Borglet协同，来构建一个ssh shell，这个shell和task运行在同样的chroot和cgroup下，这样限制就更加严格了。</p>\n<p>VM和安全沙箱技术被使用在外部的软件上，在Google’s AppEngine (GAE) [38]和Google Compute Engine (GCE)环境下。我们把KVM进程中的每个hosted VM按照一个Borg task运行。</p>\n<h2 id=\"6-2-性能隔离\"><a href=\"#6-2-性能隔离\" class=\"headerlink\" title=\"6.2 性能隔离\"></a>6.2 性能隔离</h2><p>早期的Borglet使用了一种相对原始粗暴的资源隔离措施：事后内存、硬盘、CPU使用率检查，然后终止使用过多内存和硬盘的task，或者把用太多CPU的激进task通过Linux CPU优先级降下来。不过，很多粗暴的task还是很轻易的能影响同台机器上其他task的性能，然后很多用户就会多申请资源来让Borg减少调度的task数量，然后会导致系统资源利用率降低。资源回收可以弥补一些损失，但不是全部，因为要保证资源安全红线。在极端情况下，用户请求使用专用的机器或者cell。</p>\n<p>目前，所有Borg task都跑在Linux cgroup-based资源容器[17,58,62]里面，Borglet操作这些容器的设置，这样就增强了控制因为操作系统内核在起作用。即使这样，偶尔还是有低级别的资源冲突(例如内存带宽和L3缓存污染)还是会发生，见[60,83]</p>\n<p>为了搞定超负荷和超请求，Borg task有一个应用阶级(appclass)。最主要的区分在于延迟敏感latency-sensitive (LS)的应用和其他应用的区别，其他应用我们在文章里面叫batch。LS task是包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS task得到最高有待，可以为了这个把batch task一次饿个几秒种。</p>\n<p>第二个区分在于可压缩资源(例如CPU循环，disk I/O带宽)都是速率性的可以被回收的，对于一个task可以降低这些资源的量而不去杀掉task；和不可压缩资源(例如内存、硬盘空间)这些一般来说不杀掉task就没法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会杀掉task，从低优先级开始杀，直到剩下的自留地资源够用。如果机器用完了可压缩资源，Borglet会卡住使用率这样当短期高峰来到时不用杀掉任何task。如果情况没有改善，Borgmaster会从这个机器上去除一个或多个task。</p>\n<p>Borglet的用户空间控制循环在未来预期的基础上给prod task分配内存，在内存压力基础上给non-prod task分配内存；从内核事件来处理Out-of-Memory (OOM)；杀掉那些想获取超过自身限制内存的task，或者在一个超负载的机器上实际超过负载时。Linux的积极文件缓存策略让我们的实现更负载一点，因为精确计算内存用量会麻烦很多。</p>\n<p>为了增强性能隔离，LS task可以独占整个物理CPU核，不让别的LS task来用他们。batch task可以在任何核上面跑，不过他们只被分配了很少的和LS task共享的资源。Borglet动态的调整贪婪LS task的资源限制来保证他们不会把batch task饿上几分钟，有选择的在需要时使用CFS带宽控制[75]；光有共享是不行的，我们有多个优先级。</p>\n<p><img src=\"/img/borg-fig-13.png\" alt=\"Fig. 13\"></p>\n<p>就像Leverich [56]，我们发现标准的Linux CPU调度(CFS)需要大幅调整来支持低延迟和高使用率。为了减少调度延迟，我们版本的CFS使用了额外的每cgroup历史[16]，允许LS task驱逐batch task，并且避免多个LS task跑在一个CPU上的调度量子效应(scheduling quantum，译者：或许指的是互相冲突？)。幸运的是，大多我们的应用使用的每个线程处理一个请求模型，这样就缓和了持久负载不均衡。我们节俭地使用cpusets来分配CPU核给有特殊延迟需求的应用。这些措施的一部分结果展现在图13里面。我们持续在这方面投入，增加了线程部署和CPU管理包括NUMA超线程、能源觉察(例如[81])，增加Borglet的控制精确度。</p>\n<p>Task被允许在他们的限制范围内消费资源。其中大部分task甚至被允许去使用更多的可压缩资源例如CPU，充分利用没有被使用的资源。大概5%的LS task禁止这么做，主要是为了增加可预测性；小于1%的batch task也禁止。使用超量内存默认是被禁止的，因为这会增加task被杀的概率，不过即使这样，10%的LS task打开了这个限制，79%的batch task也开了因为这事MapReduce框架默认的。这事对资源再回收($5.5)的一个补偿。Batch task很乐意使用没有被用起来的内存，也乐意不时的释放一些可回收的内存：大多情况下这跑的很好，即使有时候batch task会被急需资源的LS task杀掉。</p>\n<p>【编者的话】最后两章探讨的是相关工作和改进。从中可以看到从Borg到Kubernetes，他们也做了不少思考，而这方面的工作远远没有完善，一直在进行中。期待大家都能从Google的实践中学到一些东西，并分享出来。</p>\n<h1 id=\"7-相关工作\"><a href=\"#7-相关工作\" class=\"headerlink\" title=\"7. 相关工作\"></a>7. 相关工作</h1><p>资源调度在各个领域已经被研究了数十年了，包括在广域HPC超算集群中，在工作站网络中，在大规模服务器集群中。我们主要聚焦在最相关的大规模服务器集群这个领域。</p>\n<p>最近的一些研究分析了集群趋势，来自于Yahoo、Google、和Facebook[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载在规模和异构化方面碰到的挑战。[69]包含了这些集群管理架构的分类。</p>\n<p>Apache Mesos [45]把资源管理和应用部署做了分离，资源管理由中心管理器(类似于Bormaster+scheduler)和多种类的“框架”比如Hadoop [41]和Spark [73]，使用offer-based的机制。Borg则主要把这些几种在一起，使用request-based的机制，可以大规模扩展。DRF [29, 35, 36, 66]策略是内赋在Mesos里的；Borg则使用优先级和配额认证来替代。Mesos开发者已经宣布了他们的雄心壮志：推测性资源分配和回收，然后把[69]里面的问题都解决。</p>\n<p>YARN [76]是一个Hadoop中心集群管理。每个应用都有一个管理器和中央资源管理器谈判；这和2008年开始Google MapReduce从Borg获取资源如出一辙。YARN的资源管理器最近才能容错。一个相关的开源项目是Hadoop Capacity Scheduler [42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近被扩展成支持多种资源类型、优先级、驱逐、和高级权限控制[21]。俄罗斯方块原型[40]支持了最大完工时间觉察的job打包。</p>\n<p>Facebook的Tupperware [64]，是一个类Borg系统来调度cgroup容器；虽然只有少量资料泄露，看起来他也提供资源回收利用功能。Twitter有一个开源的Aurora[5]，一个类Borg的长进程调度器，跑在Mesos智商，有一个类似于Borg的配置语言和状态机。</p>\n<p>来自于微软的Autopilot[48]提供了“自动化的软件部署和开通；系统监控，以及在软硬件故障时的修复操作”给微软集群。Borg生态系统提供了相同的特性，不过还有没说完的；Isaard [48]概括和很多我们想拥护的最佳实践。</p>\n<p>Quincy[49]使用了一个网络流模型来提供公平性和数据局部性在几百个节点的DAG数据处理上。Borg用的是配额和优先级在上万台机器上把资源分配给用户。Quincy处理直接执行图在Borg之上。</p>\n<p>Cosmos [44]聚焦在批处理上，重点在于用户获得对集群捐献的资源进行公平获取。它使用一个每job的管理器来获取资源；没有更多公开的细节。</p>\n<p>微软的Apollo系统[13]使用了一个每job的调度器给短期存活的batch job使用，在和Borg差不多量级的集群下获取高流量输出。Apollo使用了一个低优先级后台任务随机执行策略来增加资源利用率，代价是有多天的延迟。Apollo几点提供一个预测矩阵，关于启动时间为两个资源维度的函数。然后调度器会综合计算启动开销、远程数据获取开销来决定部署到哪里，然后用一个随机延时来避免冲突。Borg用的是中央调度器来决定部署位置，给予优先级分配处理更多的资源维度，而且更关注高可用、长期跑的应用；Apollo也许可以处理更多的task请求并发。</p>\n<p>阿里巴巴的Fuxi(译者：也就是伏羲啦) [84]支撑数据分析的负载，从2009年开始运行。就像Borgmaster，一个中央的FuxiMaster(也是做了高可用多副本)从节点上获取可用的资源信息、接受应用的资源请求，然后做匹配。伏羲增加了和Borg完全相反的调度策略：伏羲把最新的可用资源分配给队列里面请求的任务。就像Mesos，伏羲允许定义“虚拟资源”类型。只有系统的工作负载输出是公开的。</p>\n<p>Omega [69]支持多并行，特别是“铅垂线”策略，粗略相当于Borgmaster加上它的持久存储和link shards(连接分配)。Omega调度器用的是乐观并行的方式去控制一个共享的cell观察和预期状态，把这些状态放在一个中央的存储里面，和Borglet用独立的连接器进行同步。Omega架构。Omage架构是被设计出来给多种不同的工作负载，这些工作负载都有自己的应用定义的RPC接口、状态机和调度策略(例如长期跑的服务端程序、多个框架下的batch job、存储基础设施、GCE上的虚拟机)。形成对比的是，Borg提供了一种“万灵药”，同样的RPC接口、状态机语义、调度策略，随着时间流逝规模和复杂度增加，需要支持更多的不同方式的负载，而可可扩展性目前来说还不算一个问题($3.4)</p>\n<p>Google的开源Kubernetes系统[53]把应用放在Docker容器内[28]，分发到多机器上。它可以跑在物理机(和Borg一样)或跑在其他云比如GCE提供的主机上。Kubernetes的开发者和Borg是同一拨人而且正在狂开发中。Google提供了一个云主机版本叫Google Container Engine [39]。我们会在下一节里面讨论从Borg中学到了哪些东西用在了Kubernetes上。</p>\n<p>在高性能计算社区有一些这个领域的长期传统工作(e.g., Maui, Moab, Platform LSF [2, 47, 50])；但是这和Google Cell所需要的规模、工作负载、容错性是完全不一样的。大概来说，这些系统通过让很多任务等待在一个长队列里面来获取极高的资源利用率。</p>\n<p>虚拟化提供商例如VMware [77]和数据中心方案提供商例如HP and IBM [46]给了一个大概在1000台机器量级的集群解决方案。另外，一些研究小组用几种方式提升了资源调度质量(e.g., [25, 40, 72, 74])。</p>\n<p>最后，就像我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]写了如何做故障计划、多租户、健康检查、权限控制、和重启动性来获得更大的机器数/操作员比。Borg的设计哲学也是这样的，让我们的一个SRE能支撑超过万台机器。</p>\n<h1 id=\"8-经验教训和未来工作\"><a href=\"#8-经验教训和未来工作\" class=\"headerlink\" title=\"8. 经验教训和未来工作\"></a>8. 经验教训和未来工作</h1><p>在这一节中我们会聊一些十年以来我们在生产环境操作Borg得到的定性经验，然后描述下这些观察结果是怎么改善Kubernete[53]的设计。</p>\n<h2 id=\"8-1-教训\"><a href=\"#8-1-教训\" class=\"headerlink\" title=\"8.1 教训\"></a>8.1 教训</h2><p>我们会从一些受到吐槽的Borg特性开始，然后说说Kubernetes是怎么干的。</p>\n<p><strong>Jobs是唯一的task分组的机制。</strong>Borg没有天然的方法去管理多个job组成单个实体，或者去指向相关的服务实例(例如，金丝雀和生产跟踪)。作为hack，用户把他们的服务拓扑编码写在job名字里面，然后用更高层的工具区解析这些名字。这个问题的另外一面是，没办法去指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级和改变job的实例数。</p>\n<p>为了避免这些困难，Kubernetes不用job这个概念，而是用标签(label)来管理它的调度单位(pods)，标签是任意的键值对，用户可以把标签打在系统的所有对象上。这样，对于一个Borg job，就可以在pod上打上job:jobname这样的标签，其他的有用的分组也可以用标签来表示，例如服务、层级、发布类型(生产、测试、阶段)。Kubernetes用标签选择这种方式来选取对象，完成操作。这样就比固定的job分组更加灵活好用。</p>\n<p><strong>一台机器一个IP把事情弄复杂了。</strong>在Borg里面，所有一台机器上的task都使用同一个IP地址，然后共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；task必须先声明他们需要多少端口，然后了解启动的时候哪些可以用；Borglet必须完成端口隔离；命名和RPC系统必须和IP一样处理端口。</p>\n<p>非常感谢Linux namespace，虚拟机，IPv6和软件定义网络SDN。Kubernetes可以用一种更用户友好的方式来消解这些复杂性：所有pod和service都可以有一个自己的IP地址，允许开发者选择端口而不是委托基础设施来帮他们选择，这些就消除了基础设置管理端口的复杂性。</p>\n<p><strong>给资深用户优化而忽略了初级用户。</strong>Borg提供了一大堆针对“资深用户”的特性这样他们可以仔细的调试怎么跑他们的程序(BCL有230个参数的选项)：开始的目的是为了支持Google的大资源用户，提升他们的效率会带来更大的效益。但是很不幸的是这么复杂的API让初级用户用起来很复杂，约束了他们的进步。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中来决定合理的配置。这就让皮实的应用从实验中获得了自由：即使自动化出了麻烦的问题也不会导致灾难。</p>\n<h2 id=\"8-2-经验\"><a href=\"#8-2-经验\" class=\"headerlink\" title=\"8.2 经验\"></a>8.2 经验</h2><p>另一方面，有不少Borg的设计是非常有益的，而且经历了时间考验。</p>\n<p><strong>Allocs是有用的。</strong>Borg alloc抽象导出了广泛使用的logsaver样式($2.4)和另一个流行样式：定期数据载入更新的web server。Allocs和packages允许这些辅助服务能被一个独立的小组开发。Kubernetes相对于alloc的设计是pod，是一个多个容器共享的资源封装，总是被调度到同一台机器上。Kubernetes用pod里面的辅助容器来替代alloc里面的task，不过思想是一样的。</p>\n<p><strong>集群管理比task管理要做更多的事。</strong>虽然Borg的主要角色是管理tasks和机器的生命周期，但Borg上的应用还是从其他的集群服务中收益良多，例如命名和负载均衡。Kubernetes用service抽象来支持命名和负载均衡：service有一个名字，用标签选择器来选择多个pod。在底下，Kubernetes自动的在这个service所拥有的pod之间自动负载均衡，然后在pod挂掉后被重新调度到其他机器上的时候也保持跟踪来做负载均衡。</p>\n<p><strong>反观自省是至关重要的。</strong>虽然Borg基本上是“just works”的，但当有出了问题后，找到这个问题的根源是非常有挑战性的。一个关键设计抉择是Borg把所有的debug信息暴露给用户而不是隐藏：Borg有几千个用户，所以“自助”是debug的第一步。虽然这会让我们很难抛弃一些用户依赖的内部策略，但这还是成功的，而且我们没有找到其他现实的替代方式。为了管理这么巨量的资源，我们提供了几层UI和debug工具，这样就可以升入研究基础设施本身和应用的错误日志和事件细节。</p>\n<p>Kubernetes也希望重现很多Borg的自探查技术。例如它和cAdvisor [15] 一切发型用于资源监控，用Elasticsearch/Kibana [30] 和 Fluentd [32]来做日志聚合。从master可以获取一个对象的状态快照。Kubernetes有一个一致的所有组件都能用的事件记录机制(例如pod被调度、容器挂了)，这样客户端就能访问。</p>\n<p><strong>master是分布式系统的核心.</strong>Borgmaster原来被设计成一个单一的系统，但是后来，它变成了服务生态和用户job的核心。比方说，我们把调度器和主UI(Sigma)分离出来成为单独的进程，然后增加了权限控制、纵向横向扩展、重打包task、周期性job提交(cron)、工作流管理，系统操作存档用于离线查询。最后，这些让我们能够提升工作负载和特性集，而无需牺牲性能和可维护性。</p>\n<p>Kubernetes的架构走的更远一些：它有一个API服务在核心，仅仅负责处理请求和维护底下的对象的状态。集群管理逻辑做成了一个小的、微服务类型的客户端程序和API服务通信，其中的副本管理器(replication controller)，维护在故障情况下pod的服务数量，还有节点管理器(node controller)，管理机器生命周期。</p>\n<h2 id=\"8-3-总结\"><a href=\"#8-3-总结\" class=\"headerlink\" title=\"8.3 总结\"></a>8.3 总结</h2><p>在过去十年间所有几乎所有的Google集群负载都移到了Borg上。我们将会持续改进，并把学到的东西应用到Kubernetes上。</p>\n<p>#鸣谢</p>\n<p>这篇文章的作者同时也评审了这篇文章。但是几十个设计、实现、维护Borg组件和生态系统工程师才是这个系统成功的关键。我们在这里列表设计、实现、操作Borgmaster和Borglet的主要人员。如有遗漏抱歉。</p>\n<p>Borgmaster主设计师和实现者有Jeremy Dion和Mark Vandevoorde，还有Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu, Monika Henzinger。Borglet的主要设计实现者是Paul Menage。</p>\n<p>其他贡献者包括Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, OnufryWojtaszczyk, Patrick Johnson, Pedro Valenzuela, PiotrWitusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, TomaszWozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.</p>\n<p>Borg SRE团队也是非常重要的，包括Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, and Viraj Alankar。Borg配置语言(BCL)和borgcfg工具是Marcel van Lohuizen, Robert Griesemer制作的。</p>\n<p>谢谢我们的审稿人(尤其是especially Eric Brewer, Malte Schwarzkopf and Tom Rodeheffer)，以及我们的牧师Christos Kozyrakis，对这篇论文的反馈。</p>\n<p>#参考文献</p>\n<p>[1] O. A. Abdul-Rahman and K. Aida. Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon. In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.</p>\n<p>[2] Adaptive Computing Enterprises Inc., Provo, UT. MauiScheduler Administrator’s Guide, 3.2 edition, 2011.</p>\n<p>[3] T. Akidau, A. Balikov, K. Bekiro˘glu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. MillWheel: fault-tolerant stream processing at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.</p>\n<p>[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. An opportunity cost approach for job assignment in a scalable computing cluster. IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.</p>\n<p>[5] Apache Aurora.<a href=\"http://aurora.incubator.apache.org/\" target=\"_blank\" rel=\"external\">http://aurora.incubator.apache.org/</a>, 2014.</p>\n<p>[6] Aurora Configuration Tutorial. <a href=\"https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014\" target=\"_blank\" rel=\"external\">https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/,2014</a>.</p>\n<p>[7] AWS. Amazon Web Services VM Instances. <a href=\"http://aws.amazon.com/ec2/instance-types/\" target=\"_blank\" rel=\"external\">http://aws.amazon.com/ec2/instance-types/</a>, 2014.</p>\n<p>[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. Megastore: Providing scalable, highly available storage for interactive services. In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.</p>\n<p>[9] M. Baker and J. Ousterhout. Availability in the Sprite distributed file system. Operating Systems Review,25(2):95–98, Apr. 1991.</p>\n<p>[10] L. A. Barroso, J. Clidaras, and U. H¨olzle. The datacenter as a computer: an introduction to the design of warehouse-scale machines. Morgan Claypool Publishers, 2nd edition, 2013.</p>\n<p>[11] L. A. Barroso, J. Dean, and U. Holzle. Web search for a planet: the Google cluster architecture. In IEEE Micro, pages 22–28, 2003.</p>\n<p>[12] I. Bokharouss. GCL Viewer: a study in improving the understanding of GCL programs. Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.</p>\n<p>[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. Apollo: scalable and coordinated scheduling for cloud-scale computing. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.</p>\n<p>[14] M. Burrows. The Chubby lock service for loosely-coupled distributed systems. In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.</p>\n<p>[15] cAdvisor. <a href=\"https://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">https://github.com/google/cadvisor</a>, 2014</p>\n<p>[16] CFS per-entity load patches. <a href=\"http://lwn.net/Articles/531853\" target=\"_blank\" rel=\"external\">http://lwn.net/Articles/531853</a>, 2013.</p>\n<p>[17] cgroups. <a href=\"http://en.wikipedia.org/wiki/Cgroups\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Cgroups</a>, 2014.</p>\n<p>[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. FlumeJava: easy, efficient data-parallel pipelines. In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.</p>\n<p>[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. Bigtable: a distributed storage system for structured data. ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.</p>\n<p>[20] Y. Chen, S. Alspaugh, and R. H. Katz. Design insights for MapReduce from diverse production workloads. Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.</p>\n<p>[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. Reservation-based scheduling: if you’re late don’t blame us! In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.</p>\n<p>[22] J. Dean and L. A. Barroso. The tail at scale. Communications of the ACM, 56(2):74–80, Feb. 2012.</p>\n<p>[23] J. Dean and S. Ghemawat. MapReduce: simplified data processing on large clusters. Communications of the ACM, 51(1):107–113, 2008.</p>\n<p>[24] C. Delimitrou and C. Kozyrakis. Paragon: QoS-aware scheduling for heterogeneous datacenters. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.</p>\n<p>[25] C. Delimitrou and C. Kozyrakis. Quasar: resource-efficient and QoS-aware cluster management. In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.</p>\n<p>[26] S. Di, D. Kondo, and W. Cirne. Characterization and comparison of cloud versus Grid workloads. In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.</p>\n<p>[27] S. Di, D. Kondo, and C. Franck. Characterizing cloud applications on a Google data center. In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.</p>\n<p>[28] Docker Project. <a href=\"https://www.docker.io/\" target=\"_blank\" rel=\"external\">https://www.docker.io/</a>, 2014.</p>\n<p>[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. No justified complaints: on fair sharing of multiple resources. In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.</p>\n<p>[30] ElasticSearch. <a href=\"http://www.elasticsearch.org\" target=\"_blank\" rel=\"external\">http://www.elasticsearch.org</a>, 2014.</p>\n<p>[31] D. G. Feitelson. Workload Modeling for Computer Systems Performance Evaluation. Cambridge University Press, 2014.</p>\n<p>[32] Fluentd. <a href=\"http://www.fluentd.org/\" target=\"_blank\" rel=\"external\">http://www.fluentd.org/</a>, 2014.</p>\n<p>[33] GCE. Google Compute Engine. http: //cloud.google.com/products/compute-engine/, 2014.</p>\n<p>[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. The Google File System. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.</p>\n<p>[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. Dominant Resource Fairness: fair allocation of multiple resource types. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.</p>\n<p>[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. Choosy: max-min fair sharing for datacenter jobs with constraints. In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.</p>\n<p>[37] D. Gmach, J. Rolia, and L. Cherkasova. Selling T-shirts and time shares in the cloud. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.</p>\n<p>[38] Google App Engine. <a href=\"http://cloud.google.com/AppEngine\" target=\"_blank\" rel=\"external\">http://cloud.google.com/AppEngine</a>, 2014.</p>\n<p>[39] Google Container Engine (GKE). <a href=\"https://cloud.google.com/container-engine/\" target=\"_blank\" rel=\"external\">https://cloud.google.com/container-engine/</a>, 2015.</p>\n<p>[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. Multi-resource packing for cluster schedulers. In Proc. ACM SIGCOMM, Aug. 2014.</p>\n<p>[41] Apache Hadoop Project. <a href=\"http://hadoop.apache.org/\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/</a>, 2009.</p>\n<p>[42] Hadoop MapReduce Next Generation – Capacity Scheduler. http: //hadoop.apache.org/docs/r2.2.0/hadoop-yarn/ hadoop-yarn-site/CapacityScheduler.html, 2013.</p>\n<p>[43] J. Hamilton. On designing and deploying internet-scale services. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.</p>\n<p>[44] P. Helland. Cosmos: big data and big challenges. <a href=\"http://research.microsoft.com/en-us/events/\" target=\"_blank\" rel=\"external\">http://research.microsoft.com/en-us/events/</a> fs2011/helland_cosmos_big_data_and_big\\ _challenges.pdf, 2011.</p>\n<p>[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. Mesos: a platform for fine-grained resource sharing in the data center. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.</p>\n<p>[46] IBM Platform Computing. <a href=\"http://www-03.ibm.com/\" target=\"_blank\" rel=\"external\">http://www-03.ibm.com/</a> systems/technicalcomputing/platformcomputing/ products/clustermanager/index.html.</p>\n<p>[47] S. Iqbal, R. Gupta, and Y.-C. Fang. Planning considerations for job scheduling in HPC clusters. Dell Power Solutions, Feb. 2005.</p>\n<p>[48] M. Isaard. Autopilot: Automatic data center management. ACM SIGOPS Operating Systems Review, 41(2), 2007.</p>\n<p>[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. Quincy: fair scheduling for distributed computing clusters. In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.</p>\n<p>[50] D. B. Jackson, Q. Snell, and M. J. Clement. Core algorithms of the Maui scheduler. In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.</p>\n<p>[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. Measuring interference between live datacenter applications. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.</p>\n<p>[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. An analysis of traces from a production MapReduce cluster. In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.</p>\n<p>[53] Kubernetes. <a href=\"http://kubernetes.io\" target=\"_blank\" rel=\"external\">http://kubernetes.io</a>, Aug. 2014.</p>\n<p>[54] Kernel Based Virtual Machine. <a href=\"http://www.linux-kvm.org\" target=\"_blank\" rel=\"external\">http://www.linux-kvm.org</a>.</p>\n<p>[55] L. Lamport. The part-time parliament. ACM Trans. on Computer Systems, 16(2):133–169, May 1998.</p>\n<p>[56] J. Leverich and C. Kozyrakis. Reconciling high server utilization and sub-millisecond quality-of-service. In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.</p>\n<p>[57] Z. Liu and S. Cho. Characterizing machines and workloads on a Google cluster. In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.</p>\n<p>[58] Google LMCTFY project (let me contain that for you). <a href=\"http://github.com/google/lmctfy\" target=\"_blank\" rel=\"external\">http://github.com/google/lmctfy</a>, 2014.</p>\n<p>[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. Pregel: a system for large-scale graph processing. In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.</p>\n<p>[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations. In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.</p>\n<p>[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. Dremel: interactive analysis of web-scale datasets. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.</p>\n<p>[62] P. Menage. Linux control groups. <a href=\"http://www.kernel\" target=\"_blank\" rel=\"external\">http://www.kernel</a>. org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.</p>\n<p>[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. Towards characterizing cloud backend workloads: insights from Google compute clusters. ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.</p>\n<p>[64] A. Narayanan. Tupperware: containerized deployment at Facebook. <a href=\"http://www.slideshare.net/dotCloud/\" target=\"_blank\" rel=\"external\">http://www.slideshare.net/dotCloud/</a> tupperware-containerized-deployment-at-facebook, June 2014.</p>\n<p>[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. Sparrow: distributed, low latency scheduling. In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.</p>\n<p>[66] D. C. Parkes, A. D. Procaccia, and N. Shah. Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities. In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.</p>\n<p>[67] Protocol buffers. https: //developers.google.com/protocol-buffers/, and <a href=\"https://github.com/google/protobuf/\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/</a>., 2014.</p>\n<p>[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. Heterogeneity and dynamicity of clouds at scale: Google trace analysis. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.</p>\n<p>[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. Omega: flexible, scalable schedulers for large compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.</p>\n<p>[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. Modeling and synthesizing task placement constraints in Google compute clusters. In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.</p>\n<p>[71] E. Shmueli and D. G. Feitelson. On simulation and design of parallel-systems schedulers: are we doing the right thing? IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.</p>\n<p>[72] A. Singh, M. Korupolu, and D. Mohapatra. Server-storage virtualization: integration and load balancing in data centers. In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.</p>\n<p>[73] Apache Spark Project. <a href=\"http://spark.apache.org/\" target=\"_blank\" rel=\"external\">http://spark.apache.org/</a>, 2014.</p>\n<p>[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds. In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.</p>\n<p>[75] P. Turner, B. Rao, and N. Rao. CPU bandwidth control for CFS. In Proc. Linux Symposium, pages 245–254, July 2010.</p>\n<p>[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. Apache Hadoop YARN: Yet Another Resource Negotiator. In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.</p>\n<p>[77] VMware VCloud Suite. <a href=\"http://www.vmware.com/products/vcloud-suite/\" target=\"_blank\" rel=\"external\">http://www.vmware.com/products/vcloud-suite/</a>.</p>\n<p>[78] A. Verma, M. Korupolu, and J. Wilkes. Evaluating job packing in warehouse-scale computing. In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.</p>\n<p>[79] W. Whitt. Open and closed models for networks of queues. AT&amp;T Bell Labs Technical Journal, 63(9), Nov. 1984.</p>\n<p>[80] J. Wilkes. More Google cluster data. <a href=\"http://googleresearch.blogspot.com/2011/11/\" target=\"_blank\" rel=\"external\">http://googleresearch.blogspot.com/2011/11/</a> more-google-cluster-data.html, Nov. 2011.</p>\n<p>[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. HaPPy: Hyperthread-aware power profiling dynamically. In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.</p>\n<p>[82] Q. Zhang, J. Hellerstein, and R. Boutaba. Characterizing task usage shapes in Google’s compute clusters. In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.</p>\n<p>[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. CPI2: CPU performance isolation for shared compute clusters. In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.</p>\n<p>[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. Fuxi: a fault-tolerant resource management and job scheduling system at internet scale. In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.</p>\n<h1 id=\"勘误-2015-04-23\"><a href=\"#勘误-2015-04-23\" class=\"headerlink\" title=\"勘误 2015-04-23\"></a>勘误 2015-04-23</h1><p>自从胶片版定稿后，我们发现了若干疏忽和歧义。</p>\n<h2 id=\"用户视角\"><a href=\"#用户视角\" class=\"headerlink\" title=\"用户视角\"></a>用户视角</h2><p>SRE干的比SA(system administration)要多得多：他们是Google生产服务的负责工程师。他们设计和实现软件，包括自动化系统、管理应用、底层基础设施服务来保证Google这个量级的高可靠和高性能。</p>\n<h2 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h2><p>我们不小心忽略了Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, and Pavanish Nirula。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[1] Michael Litzkow, Miron Livny, and Matt Mutka. “Condor - A Hunter of Idle Workstations”. In Proc. Int’l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.</p>\n<p>[2] Rajesh Raman, Miron Livny, and Marvin Solomon. “Matchmaking: Distributed Resource Management for High Throughput Computing”. In Proc. Int’l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj9dmd1ml0000wo4fqxkuxuji","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dmd1n4000cwo4flx7oqk2i"},{"post_id":"cj9dn7wlx0000nw4fqs7jy8gb","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dn7wm20001nw4f4wxpf4ib"},{"post_id":"cj9dn7xwj0002nw4fwze7kykl","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn7xwl0003nw4fmmj0tpb2"},{"post_id":"cj9dn7z670004nw4f9nw0wzzg","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dn7z680005nw4f22o40gxa"},{"post_id":"cj9dn80i40006nw4fwl23neyr","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dn80i70007nw4fozusjd21"},{"post_id":"cj9dn82600008nw4fxavhc3ah","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dn82610009nw4fun7v84jq"},{"post_id":"cj9dn8ewb0000n84fz67ajj30","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn8ewf0001n84fhfmj0jem"},{"post_id":"cj9dn8g7e0002n84fo34yqd7e","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dn8g7g0003n84fobd1svvg"},{"post_id":"cj9dn8h180004n84foej5oi5z","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn8h190005n84fm3ze8hga"},{"post_id":"cj9dn8uaz0000344ft0eq2ti0","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn8ub30001344fi793to2m"},{"post_id":"cj9dn8vjv0002344fsvl6ts8s","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn8vjx0003344f57grsz23"},{"post_id":"cj9dn8y360004344fhs8g5pbz","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn8y370005344f3mqicbh6"},{"post_id":"cj9dn9e100000ig4f7g7it0c3","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn9e130001ig4fyuanrwqt"},{"post_id":"cj9dn9e150002ig4fed2r9n6i","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn9e170004ig4fww7da2va"},{"post_id":"cj9dn9e160003ig4f4y0ulzbz","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn9e180005ig4f6r70pz3f"},{"post_id":"cj9dn9nsj0000zk4ffsg8mc4f","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn9nso0001zk4fs225zhtt"},{"post_id":"cj9dn9w7d0000cc4ftqx4wpk7","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dn9w7l0001cc4fc4771b8o"},{"post_id":"cj9dnebp40000d84flsyplach","category_id":"cj9dmd1ms0002wo4f5thbb00a","_id":"cj9dnebp80001d84flb8r24xn"},{"post_id":"cj9dnel0c0000s04fyl499ly8","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9dnel0d0001s04fq2vr88fg"},{"post_id":"cj9h1rchv00001k4fu8mpogyw","category_id":"cj9dmd1n5000fwo4fawkdzefn","_id":"cj9h1rci400011k4ftpikago3"}],"PostTag":[],"Tag":[]}}