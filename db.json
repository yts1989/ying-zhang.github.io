{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/borg-fig-04.png","path":"img/borg-fig-04.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-10.png","path":"img/borg-fig-10.png","modified":0,"renderable":0},{"_id":"source/img/ccf_sum.png","path":"img/ccf_sum.png","modified":0,"renderable":0},{"_id":"source/img/phree-structure.jpg","path":"img/phree-structure.jpg","modified":0,"renderable":0},{"_id":"source/img/pubs.png","path":"img/pubs.png","modified":0,"renderable":0},{"_id":"source/img/pxe-boot-config.png","path":"img/pxe-boot-config.png","modified":0,"renderable":0},{"_id":"source/img/pxe-boot-menu.png","path":"img/pxe-boot-menu.png","modified":0,"renderable":0},{"_id":"source/img/sftp.png","path":"img/sftp.png","modified":0,"renderable":0},{"_id":"source/img/spanner-availability.png","path":"img/spanner-availability.png","modified":0,"renderable":0},{"_id":"source/img/spotlitght-design.jpg","path":"img/spotlitght-design.jpg","modified":0,"renderable":0},{"_id":"source/img/udpn-baidu-ime.png","path":"img/udpn-baidu-ime.png","modified":0,"renderable":0},{"_id":"source/img/udpn-demo.png","path":"img/udpn-demo.png","modified":0,"renderable":0},{"_id":"source/img/vbox-headless.png","path":"img/vbox-headless.png","modified":0,"renderable":0},{"_id":"source/img/vbox-hostonly-nic.png","path":"img/vbox-hostonly-nic.png","modified":0,"renderable":0},{"_id":"source/img/vbox-snapshot.png","path":"img/vbox-snapshot.png","modified":0,"renderable":0},{"_id":"source/img/vboxconf-hostonly.png","path":"img/vboxconf-hostonly.png","modified":0,"renderable":0},{"_id":"source/img/vboxconf-NatNetwork.png","path":"img/vboxconf-NatNetwork.png","modified":0,"renderable":0},{"_id":"source/img/vboxsetting-net.png","path":"img/vboxsetting-net.png","modified":0,"renderable":0},{"_id":"source/img/vboxsetting-store.png","path":"img/vboxsetting-store.png","modified":0,"renderable":0},{"_id":"source/img/vczh-on-config.png","path":"img/vczh-on-config.png","modified":0,"renderable":0},{"_id":"source/img/vm-tty.png","path":"img/vm-tty.png","modified":0,"renderable":0},{"_id":"source/img/vmware-snapshot.png","path":"img/vmware-snapshot.png","modified":0,"renderable":0},{"_id":"source/img/vnet.png","path":"img/vnet.png","modified":0,"renderable":0},{"_id":"source/img/wifi-router.png","path":"img/wifi-router.png","modified":0,"renderable":0},{"_id":"source/img/win-mstsc-svr.png","path":"img/win-mstsc-svr.png","modified":0,"renderable":0},{"_id":"source/img/win-mstsc.png","path":"img/win-mstsc.png","modified":0,"renderable":0},{"_id":"source/img/win-share.png","path":"img/win-share.png","modified":0,"renderable":0},{"_id":"source/img/xshell-prop.png","path":"img/xshell-prop.png","modified":0,"renderable":0},{"_id":"source/img/xshell-key.png","path":"img/xshell-key.png","modified":0,"renderable":0},{"_id":"source/img/xshell-ui.png","path":"img/xshell-ui.png","modified":0,"renderable":0},{"_id":"source/img/zhuge.jpg","path":"img/zhuge.jpg","modified":0,"renderable":0},{"_id":"source/doc/cobbler-setting.txt","path":"doc/cobbler-setting.txt","modified":0,"renderable":0},{"_id":"source/doc/crack_xls_vb.txt","path":"doc/crack_xls_vb.txt","modified":0,"renderable":0},{"_id":"source/doc/ifcfg-ens33","path":"doc/ifcfg-ens33","modified":0,"renderable":0},{"_id":"source/doc/win10.reg","path":"doc/win10.reg","modified":0,"renderable":0},{"_id":"source/img/borg-fig-01.png","path":"img/borg-fig-01.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-03.png","path":"img/borg-fig-03.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-02.png","path":"img/borg-fig-02.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-06.png","path":"img/borg-fig-06.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-08.png","path":"img/borg-fig-08.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-09.png","path":"img/borg-fig-09.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-firmament-fig2.png","path":"img/osdi16-firmament-fig2.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-morpheus.png","path":"img/osdi16-morpheus.png","modified":0,"renderable":0},{"_id":"source/img/phree.jpg","path":"img/phree.jpg","modified":0,"renderable":0},{"_id":"source/img/scholar_adv.png","path":"img/scholar_adv.png","modified":0,"renderable":0},{"_id":"source/img/sock5-proxy.png","path":"img/sock5-proxy.png","modified":0,"renderable":0},{"_id":"source/img/smb.png","path":"img/smb.png","modified":0,"renderable":0},{"_id":"source/img/spotlitght-spec.png","path":"img/spotlitght-spec.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-fig2.png","path":"img/tpds15-job-taxonomy-fig2.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-group.png","path":"img/tpds15-job-taxonomy-group.png","modified":0,"renderable":0},{"_id":"source/img/udpn-ms-map.png","path":"img/udpn-ms-map.png","modified":0,"renderable":0},{"_id":"source/img/vnet-vxlan.png","path":"img/vnet-vxlan.png","modified":0,"renderable":0},{"_id":"source/doc/ccf_all_in_one_2017-02-25.xlsx","path":"doc/ccf_all_in_one_2017-02-25.xlsx","modified":0,"renderable":0},{"_id":"source/img/4books_IMG_20150328_201923.jpg","path":"img/4books_IMG_20150328_201923.jpg","modified":0,"renderable":0},{"_id":"source/img/borg-fig-05.png","path":"img/borg-fig-05.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-07.png","path":"img/borg-fig-07.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-08-09.png","path":"img/borg-fig-08-09.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-10-11.png","path":"img/borg-fig-10-11.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-11.png","path":"img/borg-fig-11.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-12.png","path":"img/borg-fig-12.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-13.png","path":"img/borg-fig-13.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-carbyne.png","path":"img/osdi16-carbyne.png","modified":0,"renderable":0},{"_id":"source/img/tpds15-job-taxonomy-fig1.png","path":"img/tpds15-job-taxonomy-fig1.png","modified":0,"renderable":0},{"_id":"source/doc/Spanner-TrueTime-CAP.docx","path":"doc/Spanner-TrueTime-CAP.docx","modified":0,"renderable":0},{"_id":"themes/jane/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jane/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/borg-fig-08-09-10-11.png","path":"img/borg-fig-08-09-10-11.png","modified":0,"renderable":0},{"_id":"source/img/hpc-feature-alg.png","path":"img/hpc-feature-alg.png","modified":0,"renderable":0},{"_id":"source/img/osdi16-harvest.png","path":"img/osdi16-harvest.png","modified":0,"renderable":0},{"_id":"source/img/udpn-iflyrec-meeting.png","path":"img/udpn-iflyrec-meeting.png","modified":0,"renderable":0},{"_id":"source/img/udpn-iflyrec-rec.png","path":"img/udpn-iflyrec-rec.png","modified":0,"renderable":0},{"_id":"source/img/vnet-pk.png","path":"img/vnet-pk.png","modified":0,"renderable":0},{"_id":"source/doc/ccf-all-in-one-2017-02-25.html","path":"doc/ccf-all-in-one-2017-02-25.html","modified":0,"renderable":0},{"_id":"source/doc/shuang_pin_udpn_cheetsheet.pdf","path":"doc/shuang_pin_udpn_cheetsheet.pdf","modified":0,"renderable":0},{"_id":"source/img/osdi16-firmament-blog-table.png","path":"img/osdi16-firmament-blog-table.png","modified":0,"renderable":0},{"_id":"themes/jane/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/jane/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"source/img/xpen-shape.jpg","path":"img/xpen-shape.jpg","modified":0,"renderable":0},{"_id":"source/img/spanner-books.jpg","path":"img/spanner-books.jpg","modified":0,"renderable":0},{"_id":"source/doc/SCI_E_Web_of_Science.pdf","path":"doc/SCI_E_Web_of_Science.pdf","modified":0,"renderable":0},{"_id":"source/doc/Spanner-TrueTime-CAP.pdf","path":"doc/Spanner-TrueTime-CAP.pdf","modified":0,"renderable":0},{"_id":"source/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","path":"doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","modified":0,"renderable":0},{"_id":"source/img/lib.png","path":"img/lib.png","modified":0,"renderable":0},{"_id":"source/doc/EuroSys15_Borg.pdf","path":"doc/EuroSys15_Borg.pdf","modified":0,"renderable":0},{"_id":"source/doc/EuroSys15_Borg_CN_Ying_201711.pdf","path":"doc/EuroSys15_Borg_CN_Ying_201711.pdf","modified":0,"renderable":0},{"_id":"source/img/google_dc1.jpg","path":"img/google_dc1.jpg","modified":0,"renderable":0},{"_id":"source/img/google_dc2.jpg","path":"img/google_dc2.jpg","modified":0,"renderable":0},{"_id":"source/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","path":"doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","modified":0,"renderable":0},{"_id":"source/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","path":"doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","modified":0,"renderable":0},{"_id":"source/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","path":"doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","modified":0,"renderable":0},{"_id":"source/doc/graduate_student_huang_yihua_2011_ppt.pdf","path":"doc/graduate_student_huang_yihua_2011_ppt.pdf","modified":0,"renderable":0},{"_id":"source/doc/walden.pdf","path":"doc/walden.pdf","modified":0,"renderable":0},{"_id":"source/doc/mpich-3.2-build.tar.gz","path":"doc/mpich-3.2-build.tar.gz","modified":0,"renderable":0},{"_id":"source/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","path":"doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"themes/jane/.gitignore","hash":"95f03058c57e530d66593f3a5feaa7e77c21a385","modified":1485230759000},{"_id":"themes/jane/LICENSE","hash":"adc990ffa703c0bb86fd4a6ad4dce182f7caf0d2","modified":1485230759000},{"_id":"themes/jane/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1485230759000},{"_id":"themes/jane/README.md","hash":"ea0c739c2241216eead290f2570d5e61c14b26c8","modified":1485230759000},{"_id":"themes/jane/_config.yml","hash":"e827d0d3c3d29763fa7a1cc6056eaaae62d2dc16","modified":1495079023776},{"_id":"themes/jane/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1485230759000},{"_id":"source/_posts/a-story-of-stylus.md","hash":"a2abf5418a9398deede18f8b387ec4a0dc2839da","modified":1510067794632},{"_id":"source/_posts/ccf-all-in-one.md","hash":"d2a3fd398c4f3a94f91ec3fca36d5e054788ea6f","modified":1509331686698},{"_id":"source/_posts/cobbler-pxe.md","hash":"080d393a66e0c19940bc25f3074acbfddc0e05c0","modified":1509331683321},{"_id":"source/_posts/hello-hexo.md","hash":"770c488d336d2d5dec5e9b8425a3dc8f4cec9b46","modified":1510068987105},{"_id":"source/_posts/docker-image-spec-v1.2.md","hash":"a0510c77943e8e9bc15aab522d7ca5d73183f154","modified":1509334867104},{"_id":"source/_posts/install-ubuntu.md","hash":"bbb30300d3b12054b07df7c39537c4616ddfbd80","modified":1509331672591},{"_id":"source/_posts/install-win-10.md","hash":"c0bc82ee6f30299e8a7e79b9b45f0cd69afbf087","modified":1509334943339},{"_id":"source/_posts/install-linpack-xhpl.md","hash":"fb34fef166f0599ee15b7e9a02f9de9bcc99e381","modified":1509334878346},{"_id":"source/_posts/remote.md","hash":"209f7c5dd6045d0dec33fbbcb2e2f5abb2d27ff6","modified":1509331665881},{"_id":"source/_posts/obstinate-are-the-trammels.md","hash":"afc53ed2f5509b42a21392537ffd53fbfdc52f77","modified":1509334934856},{"_id":"source/_posts/setup-nat-x-route.md","hash":"c4ff4368b485d3701cf3c70df7fbc4f144eb95c4","modified":1509334926185},{"_id":"source/_posts/setup-squid-proxy.md","hash":"43d5fbabb73fcdfa2e65f3cdc0c45c3c432af86c","modified":1509331643292},{"_id":"source/_posts/udpnuurufa.md","hash":"2076a8670cd63ca3a9a5db570f68df258e9bbf2e","modified":1509331573717},{"_id":"source/_posts/spanner-truetime-cap.md","hash":"8cdd3691bda2c08487830924b0d0dc030c8c9754","modified":1509334916842},{"_id":"source/_posts/vm-disk.md","hash":"2bb1097af6a57531ef818fac93644051bd1d4923","modified":1509334910175},{"_id":"source/_posts/vm-net-2.md","hash":"bd21c7791e8e9c82370a7ec14d71354aedff6f58","modified":1509334903317},{"_id":"source/_posts/vm-net.md","hash":"ae5f3ea5581e14b75af28e4305acf4ddf0f9df99","modified":1509334895085},{"_id":"source/_posts/we-love-paper.md","hash":"3906af94d0e48fe3ad19c05ac9f3bccb00d7fe84","modified":1512217332879},{"_id":"source/_posts/win-vhd-boot.md","hash":"e2702572e322c5ee5adbb95673c6e7fa24002c5e","modified":1509335000473},{"_id":"source/img/borg-fig-04.png","hash":"04737888441f199eb2b2682382a700c192bc2238","modified":1509540530961},{"_id":"source/img/borg-fig-10.png","hash":"5487dcb3873aed8e2fa589a84014b86f79ab6f84","modified":1509540418631},{"_id":"source/img/ccf_sum.png","hash":"17e7753baf957a2957a618208782b331f866e7f1","modified":1495089884723},{"_id":"source/img/phree-structure.jpg","hash":"30a0f63fa34cc2347df69a4fbc46ae949a359ea4","modified":1495304733624},{"_id":"source/img/pubs.png","hash":"1fc6cddbc0c1be58c31db5e93defee407f2d3922","modified":1495089884739},{"_id":"source/img/pxe-boot-config.png","hash":"b95615d4bb5f3bddfd935bb39d8f175f7bbccc7b","modified":1495089884739},{"_id":"source/img/pxe-boot-menu.png","hash":"15933bf27545906ea1c64bb50c2c121e5d32250b","modified":1495089884739},{"_id":"source/img/sftp.png","hash":"7373204fba311d4bbc2a1304ae5100699380ca6d","modified":1495089884739},{"_id":"source/img/spanner-availability.png","hash":"b279e4c2968ec7fac756513fbcb481f58001d325","modified":1495089884739},{"_id":"source/img/spotlitght-design.jpg","hash":"2f7c5d89dea1871848d4fe4bbd2571e9ce5e60b7","modified":1508071646436},{"_id":"source/img/udpn-baidu-ime.png","hash":"6b1c7fd246ac1da9fa0f30629b67ad751385e59b","modified":1495089884754},{"_id":"source/img/udpn-demo.png","hash":"f8330f796c3ae26a4cf868198bb8c1ef109d9a3b","modified":1495089884754},{"_id":"source/img/vbox-headless.png","hash":"f80ff69fc94dae4a97e3af79be242aae83f0b38b","modified":1504250960404},{"_id":"source/img/vbox-hostonly-nic.png","hash":"cb704943d0a7cf2c96c35c466f8192280278bbbe","modified":1495089884754},{"_id":"source/img/vbox-snapshot.png","hash":"96c2748ced55acd07d6a7394240b46095eb6ca25","modified":1495089884754},{"_id":"source/img/vboxconf-hostonly.png","hash":"faaf51e8bbd50faebb98b4cb001f3fd259edfc6f","modified":1495089884754},{"_id":"source/img/vboxconf-NatNetwork.png","hash":"2431472e03648fc9d3a4087b79dfddf2ee7e1c4a","modified":1495089884754},{"_id":"source/img/vboxsetting-net.png","hash":"effe5b8616f55bad9ecea8d8d52dd79ce1aa3957","modified":1495089884754},{"_id":"source/img/vboxsetting-store.png","hash":"6886271d1e0f59245216e96c507432cbee83ccad","modified":1495089884754},{"_id":"source/img/vczh-on-config.png","hash":"bd28ac541389f4357a55f681e0bfe8022b7d2cf3","modified":1495089884754},{"_id":"source/img/vm-tty.png","hash":"b005e82faf82e8f194317913516db984cd519632","modified":1495089884754},{"_id":"source/img/vmware-snapshot.png","hash":"c9391e15ccb4f1f6542634ad4a20e90b6941ba4a","modified":1495089884754},{"_id":"source/img/vnet.png","hash":"d94f637a8d638ef044a4eb2c399c22d75ee80285","modified":1495089884754},{"_id":"source/img/wifi-router.png","hash":"7aaa176ae16e574fac4f7a7861ffd6cbe13c258c","modified":1495089884754},{"_id":"source/img/win-mstsc-svr.png","hash":"454f2246ab116191aae15f458e2b78b605e7827e","modified":1495089884754},{"_id":"source/img/win-mstsc.png","hash":"3f631d2d7653ca872508d052bb7c819d341d809b","modified":1495089884754},{"_id":"source/img/win-share.png","hash":"1f942562e7930612939a728265315b6db4f68d47","modified":1495089884754},{"_id":"source/img/xshell-prop.png","hash":"637a498356615c059d19143a95a17f324fbf6b50","modified":1504248205719},{"_id":"source/img/xshell-key.png","hash":"18f9d471cf3de56ef325f10c6f0eb17f588a1689","modified":1495089884754},{"_id":"source/img/xshell-ui.png","hash":"d60047895e00970596430de0666228ddc922d1f1","modified":1504248323853},{"_id":"source/img/zhuge.jpg","hash":"b6819904a87d60784c282c166d9dde57e28e2fde","modified":1495089884754},{"_id":"source/doc/cobbler-setting.txt","hash":"507e3403def7ed5cae195a487d7aa03c42a251d0","modified":1495089884692},{"_id":"source/doc/crack_xls_vb.txt","hash":"667c8a9b1c69a61926020a490fec259ae1a15086","modified":1495089884692},{"_id":"source/doc/ifcfg-ens33","hash":"e0641b4695e366b26423a750c1c826eed4340d5b","modified":1495089884708},{"_id":"source/doc/win10.reg","hash":"50983212c92d0833e3139146f5e144151a9ea049","modified":1507963754955},{"_id":"themes/jane/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1485230759000},{"_id":"themes/jane/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1485230759000},{"_id":"themes/jane/layout/layout.ejs","hash":"57a2290d59da470c618201b6d19c1805359bd6c3","modified":1485230759000},{"_id":"themes/jane/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1485230759000},{"_id":"themes/jane/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1485230759000},{"_id":"themes/jane/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1485230759000},{"_id":"themes/jane/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1485230759000},{"_id":"themes/jane/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1485230759000},{"_id":"source/_posts/eurosys15-borg-cn.md","hash":"f7edcd87f7becff75065a338858d209302db73d6","modified":1512313176639},{"_id":"source/img/borg-fig-01.png","hash":"c085d12f87dd9f216590243ba7d96fc3bf9449ed","modified":1509540325395},{"_id":"source/img/borg-fig-03.png","hash":"dc4c4d0cc207bb57b4708b419982c3d6837fe382","modified":1509540506296},{"_id":"source/img/borg-fig-02.png","hash":"bd44d8696571aca91b1cd806e2e781a613e5d0b5","modified":1509540453513},{"_id":"source/img/borg-fig-06.png","hash":"f697b41dc44a5bf290d3cacc4a2a63382b3964ca","modified":1509540595637},{"_id":"source/img/borg-fig-08.png","hash":"e21f2fc66a9cf786505dad770027951af79e8da3","modified":1509540644983},{"_id":"source/img/borg-fig-09.png","hash":"b2a7ab4d1895fdb51be607a543fce1e105e419b4","modified":1509540664676},{"_id":"source/img/osdi16-firmament-fig2.png","hash":"d068b6fa4329f220766c06668bc215a8709a03df","modified":1495089884739},{"_id":"source/img/osdi16-morpheus.png","hash":"0b181cf535dc99cac51a348949f6c437d633fb10","modified":1495089884739},{"_id":"source/img/phree.jpg","hash":"996fed0e72973c85df38d84f2ea1689bdfe59de4","modified":1495309307522},{"_id":"source/img/scholar_adv.png","hash":"9597042c1dae98b1da7c1b9b4cd440840ac98eb1","modified":1495089884739},{"_id":"source/img/sock5-proxy.png","hash":"165f6cd9972eec88507f7723bd20ab5531e6bd7d","modified":1495089884739},{"_id":"source/img/smb.png","hash":"a2cafa61ae8bc92f4840216fc3a4c65876d1baf4","modified":1495089884739},{"_id":"source/img/spotlitght-spec.png","hash":"eae78e4243da526a92243b471920e45ebf9fe36b","modified":1508071704737},{"_id":"source/img/tpds15-job-taxonomy-fig2.png","hash":"3d13644cee2af40c2674a9462a28f83282b8c6d6","modified":1495089884754},{"_id":"source/img/tpds15-job-taxonomy-group.png","hash":"e4b4e184d1c9675ee1447e4ffc57b36fd72fe613","modified":1495089884754},{"_id":"source/img/udpn-ms-map.png","hash":"64fdff00586fd43395714ff6e3787377b1958577","modified":1495089884754},{"_id":"source/img/vnet-vxlan.png","hash":"5547ebdd1e6899fe0d89cfc785101a8d309f0771","modified":1495089884754},{"_id":"source/doc/ccf_all_in_one_2017-02-25.xlsx","hash":"525b9b89801ec6f8416968758a99c77a22031b30","modified":1511266438328},{"_id":"source/img/4books_IMG_20150328_201923.jpg","hash":"b385ae658704c3fae24e9fa902d9e52f389e01e0","modified":1453673640000},{"_id":"source/img/borg-fig-05.png","hash":"1b915af9703de11c65e61e9c451780169431da55","modified":1509540572139},{"_id":"source/img/borg-fig-07.png","hash":"81f7935f42da15d962a0ca3fc621b5536c0c7ce4","modified":1509540620635},{"_id":"source/img/borg-fig-08-09.png","hash":"19fe5740594f9c7880ea49a8b2e5fa1f70c366d0","modified":1510050240259},{"_id":"source/img/borg-fig-10-11.png","hash":"f546f8c62996a7248a6a15d15aae5dcf495c5a38","modified":1510050015669},{"_id":"source/img/borg-fig-11.png","hash":"96883ab2a7810cc13180ad3dc869cc3accf7da79","modified":1509540402477},{"_id":"source/img/borg-fig-12.png","hash":"50ed9722b529d7f4b8ad41a7267749ce57d54396","modified":1495089884723},{"_id":"source/img/borg-fig-13.png","hash":"b73c2e8c8c69e99237c12f4aa577976a02eaec51","modified":1509540684039},{"_id":"source/img/osdi16-carbyne.png","hash":"ab7c6851b20f436059a3af637e52a9cb91f0f483","modified":1495089884739},{"_id":"source/img/tpds15-job-taxonomy-fig1.png","hash":"adb7741820cdb1d61adc9b441b0cf43a5c243ce3","modified":1495089884754},{"_id":"source/doc/Spanner-TrueTime-CAP.docx","hash":"6dffed178fbd971285b07b2433f4f773c13a18e5","modified":1495089884629},{"_id":"themes/jane/layout/_partial/after-footer.ejs","hash":"c22cce4a6a2dd353e7f6b1249518841e943c8e3b","modified":1485230759000},{"_id":"themes/jane/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1485230759000},{"_id":"themes/jane/layout/_partial/article.ejs","hash":"a09d83726a01a0c711315a1bda0de293e522464f","modified":1485230759000},{"_id":"themes/jane/layout/_partial/archive.ejs","hash":"d7de6421497ffaf65e4f5fe4bed71fcea51fde80","modified":1485230759000},{"_id":"themes/jane/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1485230759000},{"_id":"themes/jane/layout/_partial/head.ejs","hash":"da9a4ab32efc44c098f317fe64e2335989929b0e","modified":1485230759000},{"_id":"themes/jane/layout/_partial/footer.ejs","hash":"d1c793152d40e68bf45f8df2efb3dbc96bae4b76","modified":1495078599689},{"_id":"themes/jane/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1485230759000},{"_id":"themes/jane/layout/_partial/sidebar.ejs","hash":"21424708437807559837cfc5111533737b8fe2cb","modified":1495079485437},{"_id":"themes/jane/source/css/_extend.styl","hash":"ac23ccf2c0891f1729c185787e25df026039c763","modified":1488986785616},{"_id":"themes/jane/source/css/_variables.styl","hash":"b978ba8916b5839126f4856f23e4075e18f9147a","modified":1488986835902},{"_id":"themes/jane/source/css/style.styl","hash":"e2f059b929fa16ba55f4cff4473d7a5d9e5c8f41","modified":1510068533090},{"_id":"themes/jane/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1485230759000},{"_id":"themes/jane/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1485230759000},{"_id":"themes/jane/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1485230759000},{"_id":"themes/jane/source/js/script.js","hash":"453cdbc4259e13ee09def0e26afaff146f7ad501","modified":1485230759000},{"_id":"source/img/avatar.png","hash":"c46fce9b0905d4c5bf131475bc083c6faef6edfa","modified":1495089884723},{"_id":"source/img/borg-fig-08-09-10-11.png","hash":"1eeab50d8d718aef97d1e337cc46aad8a3078230","modified":1510212651759},{"_id":"source/img/hpc-feature-alg.png","hash":"97d1be0e9f9d0064350e37b7ba0091b8bfa8342f","modified":1495089884739},{"_id":"source/img/osdi16-harvest.png","hash":"0ef7746a98c2012ea274816105a0f8c19497a732","modified":1495089884739},{"_id":"source/img/udpn-iflyrec-meeting.png","hash":"bd5243cbb4998673506d223abb620afca6ea5e1b","modified":1495089884754},{"_id":"source/img/udpn-iflyrec-rec.png","hash":"fd820c873189a8983bd34a325f81269e232ccb94","modified":1495089884754},{"_id":"source/img/vnet-pk.png","hash":"13ca0863dea5b1fe55fbe3bfbcf900ea949c65d8","modified":1495089884754},{"_id":"source/doc/ccf-all-in-one-2017-02-25.html","hash":"ad600613364fe7484369d3c7633441b66e080d1b","modified":1511266452451},{"_id":"source/doc/shuang_pin_udpn_cheetsheet.pdf","hash":"ec6375d75961f29c59c79aac1b92c515305162c1","modified":1495089884723},{"_id":"source/img/osdi16-firmament-blog-table.png","hash":"73ad6d3e8707b94b88bb26f2ab6a27fe7664728a","modified":1495089884739},{"_id":"themes/jane/layout/_partial/post/category.ejs","hash":"d636f12e4a8ef3d48284cb9ec9679faddea9158a","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/nav.ejs","hash":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1485230759000},{"_id":"themes/jane/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/archive.styl","hash":"cc77d17b4614882a2821369d8fb668819abe3708","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/article.styl","hash":"06b6fb383cc2c33728ad30e2f0e38c5d7da6c637","modified":1488986465173},{"_id":"themes/jane/source/css/_partial/comment.styl","hash":"d5240c7b85e225af1b91dc3847c2061f5ab3e1b7","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/highlight.styl","hash":"3cf6eba8e88a4049d5b1709eb478ba2a83267c51","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/mobile.styl","hash":"728bf47a1542503cdc4ec080749fb5bbaf642a7f","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/footer.styl","hash":"50f0a8c85fa225e4711fbf92989da95080efde89","modified":1485230759000},{"_id":"themes/jane/source/css/_partial/sidebar.styl","hash":"2fbfce80dbbae0172cf51ac51c49bf1ab69664ad","modified":1510067573364},{"_id":"themes/jane/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1485230759000},{"_id":"themes/jane/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.eot","hash":"6ba3575b2f32b5fdc491a5cbeff19ec1a2258ce0","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.ttf","hash":"0936fdc72603dd9adc5a71ae46f8c00bcba7e629","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.svg","hash":"6ddf1044a70a0c388c9b8327cc8950d5e84e9df4","modified":1485230759000},{"_id":"themes/jane/source/css/fonts/iconfont.woff","hash":"f105bd41ff679f1faa9bebb6f618426309c7033c","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1485230759000},{"_id":"themes/jane/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1485230759000},{"_id":"source/img/xpen-shape.jpg","hash":"7cda0cd632a18cdaf23d3633ccec805b2b48ef34","modified":1495301051449},{"_id":"source/img/spanner-books.jpg","hash":"ebc68d4bc51e95b292d737c79e14bd5566392481","modified":1495089884739},{"_id":"source/doc/SCI_E_Web_of_Science.pdf","hash":"c714865cb741a15ce2835b003b6f35ad207d7635","modified":1495089884629},{"_id":"source/doc/Spanner-TrueTime-CAP.pdf","hash":"939a92b3b541073a3dc8b62c0dab4a3c64c73a0a","modified":1495089884629},{"_id":"source/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","hash":"595cc33bdfb97ea09aca32864c2a94b7fba9bd1a","modified":1495089884723},{"_id":"source/img/lib.png","hash":"880d4f1a7a81eb01b2f0801e540e0cfe11452cf1","modified":1495089884739},{"_id":"source/doc/EuroSys15_Borg.pdf","hash":"fb89af8a8f76615d31c5dac0e880541284341b7f","modified":1484721483119},{"_id":"source/doc/EuroSys15_Borg_CN_Ying_201711.pdf","hash":"175fa98706f5629249447c5b93f43f43955b20a9","modified":1512313194385},{"_id":"source/img/google_dc1.jpg","hash":"6f647095c1ade1517c727885262cb2f4d6f70d83","modified":1495089884723},{"_id":"source/img/google_dc2.jpg","hash":"302e62a664e1267c30ddec0e44b3d390256a2825","modified":1495089884739},{"_id":"source/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","hash":"112c3ba9ec4331d5504eac59aa5bc019e0e6931e","modified":1495089884629},{"_id":"source/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","hash":"6585e262ba11c8ffe0fdb78a7cb19f53252aff45","modified":1495089884629},{"_id":"source/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","hash":"bb38ab082d8f318af46259d1f924637e2bd06379","modified":1495089884692},{"_id":"source/doc/graduate_student_huang_yihua_2011_ppt.pdf","hash":"ec8770c44b40cda40950bb8b5b0b534221228089","modified":1495089884708},{"_id":"source/doc/walden.pdf","hash":"6e3601a6d83e10019e3c9d205c37d7005044f53c","modified":1496759333281},{"_id":"source/doc/mpich-3.2-build.tar.gz","hash":"baaa16daa824b48783125161de795a667d8e91a3","modified":1495089884723},{"_id":"source/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","hash":"b7a2a7830d4779df793a52a8a7ac4c72eed28dcf","modified":1495089884676},{"_id":"public/atom.xml","hash":"3284ab12053cf4b323319e81554832cdaaf2cebf","modified":1512468470727},{"_id":"public/misc/2017/setup-squid-proxy/index.html","hash":"4c4c100c3fa716c769d2e1b75d41a5aac1b7b16d","modified":1510214151170},{"_id":"public/misc/2017/ccf-all-in-one/index.html","hash":"9505d65e11adb9e06e065a291e8122f9d66a14c3","modified":1510214151170},{"_id":"public/cloud/2016/win-vhd-boot/index.html","hash":"0917a7c7b461af970fd5d03d09ce6caafae3b86d","modified":1510214151170},{"_id":"public/misc/2016/udpnuurufa/index.html","hash":"75dac169b58d87dae9533eb37371a109b1f9bca0","modified":1510214151171},{"_id":"public/misc/2016/obstinate-are-the-trammels/index.html","hash":"bd3f2bc49739f70f510c7246d2bbcea84d4775e9","modified":1510214151171},{"_id":"public/archives/index.html","hash":"05aabd9922824d414b3d2d1e1949cd6b75b16db9","modified":1512468470967},{"_id":"public/archives/2016/index.html","hash":"0a90c5353db69fcf7781bb18bad2a3a32fa56fe3","modified":1510214151171},{"_id":"public/archives/2016/05/index.html","hash":"d2ec48e9482c8c4f0e4e3edb5a6b412813613e97","modified":1510214151171},{"_id":"public/archives/2016/06/index.html","hash":"b528a820da87584493d12e132c8a4108eb6c7be2","modified":1510214151171},{"_id":"public/archives/2016/09/index.html","hash":"5e504c4fdc6bb08fab86c6b14a8f1a6444e5b166","modified":1510214151171},{"_id":"public/archives/2017/index.html","hash":"b67257b98f770fc27203f560e678a1d2cfde1efb","modified":1512468470967},{"_id":"public/archives/2017/02/index.html","hash":"6ffdc76188a4b2859c234d997b061dcc8dfea717","modified":1510214151171},{"_id":"public/archives/2017/03/index.html","hash":"9ad7b2edb9e86431ccac89e73e55fda99fe05eaf","modified":1510214151171},{"_id":"public/archives/2017/04/index.html","hash":"560f89d41c2ca24d72c53a8489af4b8914326e11","modified":1510214151171},{"_id":"public/archives/2017/05/index.html","hash":"6338dd43cdb50db51e3142bca8392d6a7c7215c5","modified":1510214151171},{"_id":"public/archives/2017/10/index.html","hash":"4cc6024fa54f87e47f12122a685f380d6ddac1df","modified":1510214151171},{"_id":"public/categories/misc/index.html","hash":"d1d0632cd238a0defeda85ffe0f6a5fe044ab248","modified":1510214151171},{"_id":"public/categories/cloud/index.html","hash":"2fd272aca7b8d42569fcd20fc17071d0e24b7d10","modified":1512468470977},{"_id":"public/cloud/2017/eurosys15-borg-cn/index.html","hash":"cc9ade339322aed9176454948e5e3fe8dbe3a83b","modified":1512468470977},{"_id":"public/cloud/2017/docker-image-spec-v1.2/index.html","hash":"fcd2638f8caa2608994fac2ece154062227e8e3e","modified":1510214151173},{"_id":"public/misc/2017/setup-nat-x-route/index.html","hash":"073a3e1d9dfb8569c9487dcb0bc0cbc3acf92c93","modified":1510214151173},{"_id":"public/misc/2017/install-linpack-xhpl/index.html","hash":"d68dc773a7eada9375d865b7cc3a11756c905f60","modified":1510214151174},{"_id":"public/cloud/2017/vm-net-2/index.html","hash":"866da3e924e54705f6376f1ee5ab0abe8fedde98","modified":1510214151174},{"_id":"public/misc/2017/cobbler-pxe/index.html","hash":"c3ac6a039bbe17b1b6c0caf05eaf547c125a501a","modified":1510214151174},{"_id":"public/cloud/2017/spanner-truetime-cap/index.html","hash":"d76ad4ed633d2e59553a1c4838482f187b5657f6","modified":1510214151174},{"_id":"public/misc/2016/we-love-paper/index.html","hash":"5b8239f36fe623d3278823e0275b834dfcc0689b","modified":1512217686916},{"_id":"public/cloud/2016/vm-disk/index.html","hash":"00b6c758ab529a4f5def0dbfc29b398e1fa2cee9","modified":1510214151174},{"_id":"public/cloud/2016/vm-net/index.html","hash":"b7c8d0df42e7edf26348ac83e3238bc9bf4b14e7","modified":1510214151174},{"_id":"public/misc/2016/remote/index.html","hash":"9ebfbd78a09d12f0636232a44ab054825bce36ae","modified":1510214151174},{"_id":"public/misc/2016/install-win-10/index.html","hash":"4eb770517b63234a54518f65f7690e908996851e","modified":1510214151174},{"_id":"public/misc/2016/install-ubuntu/index.html","hash":"40da5bd704bbe36d10085bc33169e9710637320f","modified":1510214151174},{"_id":"public/misc/2016/hello-hexo/index.html","hash":"b0531e208833110c7c4b92b18e77e0e969c70d33","modified":1510214151174},{"_id":"public/misc/2016/a-story-of-stylus/index.html","hash":"02d217022b4bfd16cb278f0cb208f408d2b782d2","modified":1510214151174},{"_id":"public/index.html","hash":"bb772f7ebfb23cd7ca748dcbbf0a2879f2809804","modified":1512468470977},{"_id":"public/img/borg-fig-04.png","hash":"04737888441f199eb2b2682382a700c192bc2238","modified":1510214151205},{"_id":"public/img/borg-fig-10.png","hash":"5487dcb3873aed8e2fa589a84014b86f79ab6f84","modified":1510214151205},{"_id":"public/img/ccf_sum.png","hash":"17e7753baf957a2957a618208782b331f866e7f1","modified":1510214151205},{"_id":"public/img/phree-structure.jpg","hash":"30a0f63fa34cc2347df69a4fbc46ae949a359ea4","modified":1510214151205},{"_id":"public/img/pubs.png","hash":"1fc6cddbc0c1be58c31db5e93defee407f2d3922","modified":1510214151205},{"_id":"public/img/pxe-boot-config.png","hash":"b95615d4bb5f3bddfd935bb39d8f175f7bbccc7b","modified":1510214151205},{"_id":"public/img/pxe-boot-menu.png","hash":"15933bf27545906ea1c64bb50c2c121e5d32250b","modified":1510214151205},{"_id":"public/img/sftp.png","hash":"7373204fba311d4bbc2a1304ae5100699380ca6d","modified":1510214151205},{"_id":"public/img/spanner-availability.png","hash":"b279e4c2968ec7fac756513fbcb481f58001d325","modified":1510214151205},{"_id":"public/img/spotlitght-design.jpg","hash":"2f7c5d89dea1871848d4fe4bbd2571e9ce5e60b7","modified":1510214151205},{"_id":"public/img/vbox-headless.png","hash":"f80ff69fc94dae4a97e3af79be242aae83f0b38b","modified":1510214151206},{"_id":"public/img/udpn-demo.png","hash":"f8330f796c3ae26a4cf868198bb8c1ef109d9a3b","modified":1510214151206},{"_id":"public/img/udpn-baidu-ime.png","hash":"6b1c7fd246ac1da9fa0f30629b67ad751385e59b","modified":1510214151206},{"_id":"public/img/vbox-hostonly-nic.png","hash":"cb704943d0a7cf2c96c35c466f8192280278bbbe","modified":1510214151206},{"_id":"public/img/vboxconf-hostonly.png","hash":"faaf51e8bbd50faebb98b4cb001f3fd259edfc6f","modified":1510214151206},{"_id":"public/img/vbox-snapshot.png","hash":"96c2748ced55acd07d6a7394240b46095eb6ca25","modified":1510214151206},{"_id":"public/img/vboxconf-NatNetwork.png","hash":"2431472e03648fc9d3a4087b79dfddf2ee7e1c4a","modified":1510214151206},{"_id":"public/img/vboxsetting-net.png","hash":"effe5b8616f55bad9ecea8d8d52dd79ce1aa3957","modified":1510214151206},{"_id":"public/img/vboxsetting-store.png","hash":"6886271d1e0f59245216e96c507432cbee83ccad","modified":1510214151206},{"_id":"public/img/vczh-on-config.png","hash":"bd28ac541389f4357a55f681e0bfe8022b7d2cf3","modified":1510214151206},{"_id":"public/img/vmware-snapshot.png","hash":"c9391e15ccb4f1f6542634ad4a20e90b6941ba4a","modified":1510214151206},{"_id":"public/img/vm-tty.png","hash":"b005e82faf82e8f194317913516db984cd519632","modified":1510214151206},{"_id":"public/img/vnet.png","hash":"d94f637a8d638ef044a4eb2c399c22d75ee80285","modified":1510214151206},{"_id":"public/img/wifi-router.png","hash":"7aaa176ae16e574fac4f7a7861ffd6cbe13c258c","modified":1510214151206},{"_id":"public/img/win-mstsc-svr.png","hash":"454f2246ab116191aae15f458e2b78b605e7827e","modified":1510214151206},{"_id":"public/img/win-mstsc.png","hash":"3f631d2d7653ca872508d052bb7c819d341d809b","modified":1510214151206},{"_id":"public/img/xshell-prop.png","hash":"637a498356615c059d19143a95a17f324fbf6b50","modified":1510214151206},{"_id":"public/img/win-share.png","hash":"1f942562e7930612939a728265315b6db4f68d47","modified":1510214151206},{"_id":"public/img/xshell-key.png","hash":"18f9d471cf3de56ef325f10c6f0eb17f588a1689","modified":1510214151206},{"_id":"public/doc/cobbler-setting.txt","hash":"507e3403def7ed5cae195a487d7aa03c42a251d0","modified":1510214151206},{"_id":"public/img/zhuge.jpg","hash":"b6819904a87d60784c282c166d9dde57e28e2fde","modified":1510214151206},{"_id":"public/doc/crack_xls_vb.txt","hash":"667c8a9b1c69a61926020a490fec259ae1a15086","modified":1510214151206},{"_id":"public/img/xshell-ui.png","hash":"d60047895e00970596430de0666228ddc922d1f1","modified":1510214151206},{"_id":"public/doc/ifcfg-ens33","hash":"e0641b4695e366b26423a750c1c826eed4340d5b","modified":1510214151207},{"_id":"public/doc/win10.reg","hash":"50983212c92d0833e3139146f5e144151a9ea049","modified":1510214151207},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1510214151207},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1510214151207},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1510214151207},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1510214151207},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1510214151207},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1510214151207},{"_id":"public/css/fonts/iconfont.eot","hash":"6ba3575b2f32b5fdc491a5cbeff19ec1a2258ce0","modified":1510214151207},{"_id":"public/css/fonts/iconfont.ttf","hash":"0936fdc72603dd9adc5a71ae46f8c00bcba7e629","modified":1510214151207},{"_id":"public/css/fonts/iconfont.svg","hash":"6ddf1044a70a0c388c9b8327cc8950d5e84e9df4","modified":1510214151207},{"_id":"public/css/fonts/iconfont.woff","hash":"f105bd41ff679f1faa9bebb6f618426309c7033c","modified":1510214151207},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1510214151207},{"_id":"public/img/borg-fig-03.png","hash":"dc4c4d0cc207bb57b4708b419982c3d6837fe382","modified":1510214151571},{"_id":"public/img/borg-fig-01.png","hash":"c085d12f87dd9f216590243ba7d96fc3bf9449ed","modified":1510214151571},{"_id":"public/img/borg-fig-02.png","hash":"bd44d8696571aca91b1cd806e2e781a613e5d0b5","modified":1510214151573},{"_id":"public/img/borg-fig-06.png","hash":"f697b41dc44a5bf290d3cacc4a2a63382b3964ca","modified":1510214151573},{"_id":"public/img/borg-fig-09.png","hash":"b2a7ab4d1895fdb51be607a543fce1e105e419b4","modified":1510214151573},{"_id":"public/img/osdi16-firmament-fig2.png","hash":"d068b6fa4329f220766c06668bc215a8709a03df","modified":1510214151573},{"_id":"public/img/borg-fig-08.png","hash":"e21f2fc66a9cf786505dad770027951af79e8da3","modified":1510214151573},{"_id":"public/img/osdi16-morpheus.png","hash":"0b181cf535dc99cac51a348949f6c437d633fb10","modified":1510214151573},{"_id":"public/img/phree.jpg","hash":"996fed0e72973c85df38d84f2ea1689bdfe59de4","modified":1510214151573},{"_id":"public/img/scholar_adv.png","hash":"9597042c1dae98b1da7c1b9b4cd440840ac98eb1","modified":1510214151573},{"_id":"public/img/sock5-proxy.png","hash":"165f6cd9972eec88507f7723bd20ab5531e6bd7d","modified":1510214151574},{"_id":"public/img/smb.png","hash":"a2cafa61ae8bc92f4840216fc3a4c65876d1baf4","modified":1510214151574},{"_id":"public/img/spotlitght-spec.png","hash":"eae78e4243da526a92243b471920e45ebf9fe36b","modified":1510214151574},{"_id":"public/img/tpds15-job-taxonomy-fig2.png","hash":"3d13644cee2af40c2674a9462a28f83282b8c6d6","modified":1510214151574},{"_id":"public/img/tpds15-job-taxonomy-group.png","hash":"e4b4e184d1c9675ee1447e4ffc57b36fd72fe613","modified":1510214151574},{"_id":"public/img/udpn-ms-map.png","hash":"64fdff00586fd43395714ff6e3787377b1958577","modified":1510214151574},{"_id":"public/doc/ccf_all_in_one_2017-02-25.xlsx","hash":"684520981f114a3907eda9c6f36f43c883479813","modified":1510214151574},{"_id":"public/img/vnet-vxlan.png","hash":"5547ebdd1e6899fe0d89cfc785101a8d309f0771","modified":1510214151574},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1510214151580},{"_id":"public/js/script.js","hash":"453cdbc4259e13ee09def0e26afaff146f7ad501","modified":1510214151580},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1510214151580},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1510214151580},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1510214151580},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1510214151580},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1510214151580},{"_id":"public/css/style.css","hash":"cdb8182534ec8f519c6423ad3dda24c3e13dbc55","modified":1510214151580},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1510214151580},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1510214151580},{"_id":"public/img/4books_IMG_20150328_201923.jpg","hash":"b385ae658704c3fae24e9fa902d9e52f389e01e0","modified":1510214151580},{"_id":"public/img/borg-fig-07.png","hash":"81f7935f42da15d962a0ca3fc621b5536c0c7ce4","modified":1510214151580},{"_id":"public/img/borg-fig-08-09.png","hash":"19fe5740594f9c7880ea49a8b2e5fa1f70c366d0","modified":1510214151580},{"_id":"public/img/borg-fig-05.png","hash":"1b915af9703de11c65e61e9c451780169431da55","modified":1510214151580},{"_id":"public/img/borg-fig-10-11.png","hash":"f546f8c62996a7248a6a15d15aae5dcf495c5a38","modified":1510214151580},{"_id":"public/img/borg-fig-11.png","hash":"96883ab2a7810cc13180ad3dc869cc3accf7da79","modified":1510214151581},{"_id":"public/img/borg-fig-12.png","hash":"50ed9722b529d7f4b8ad41a7267749ce57d54396","modified":1510214151581},{"_id":"public/img/borg-fig-13.png","hash":"b73c2e8c8c69e99237c12f4aa577976a02eaec51","modified":1510214151581},{"_id":"public/img/osdi16-carbyne.png","hash":"ab7c6851b20f436059a3af637e52a9cb91f0f483","modified":1510214151581},{"_id":"public/img/tpds15-job-taxonomy-fig1.png","hash":"adb7741820cdb1d61adc9b441b0cf43a5c243ce3","modified":1510214151581},{"_id":"public/doc/Spanner-TrueTime-CAP.docx","hash":"6dffed178fbd971285b07b2433f4f773c13a18e5","modified":1510214151581},{"_id":"public/img/avatar.png","hash":"c46fce9b0905d4c5bf131475bc083c6faef6edfa","modified":1510214151585},{"_id":"public/img/borg-fig-08-09-10-11.png","hash":"1eeab50d8d718aef97d1e337cc46aad8a3078230","modified":1510214151585},{"_id":"public/img/hpc-feature-alg.png","hash":"97d1be0e9f9d0064350e37b7ba0091b8bfa8342f","modified":1510214151585},{"_id":"public/img/osdi16-harvest.png","hash":"0ef7746a98c2012ea274816105a0f8c19497a732","modified":1510214151585},{"_id":"public/img/vnet-pk.png","hash":"13ca0863dea5b1fe55fbe3bfbcf900ea949c65d8","modified":1510214151586},{"_id":"public/img/udpn-iflyrec-rec.png","hash":"fd820c873189a8983bd34a325f81269e232ccb94","modified":1510214151586},{"_id":"public/img/udpn-iflyrec-meeting.png","hash":"bd5243cbb4998673506d223abb620afca6ea5e1b","modified":1510214151586},{"_id":"public/doc/ccf-all-in-one-2017-02-25.html","hash":"d251ab8f29dca1209b29cc88d26239442967029c","modified":1510214151586},{"_id":"public/doc/shuang_pin_udpn_cheetsheet.pdf","hash":"ec6375d75961f29c59c79aac1b92c515305162c1","modified":1510214151586},{"_id":"public/img/osdi16-firmament-blog-table.png","hash":"73ad6d3e8707b94b88bb26f2ab6a27fe7664728a","modified":1510214151592},{"_id":"public/img/xpen-shape.jpg","hash":"7cda0cd632a18cdaf23d3633ccec805b2b48ef34","modified":1510214151595},{"_id":"public/img/spanner-books.jpg","hash":"ebc68d4bc51e95b292d737c79e14bd5566392481","modified":1510214151610},{"_id":"public/doc/SCI_E_Web_of_Science.pdf","hash":"c714865cb741a15ce2835b003b6f35ad207d7635","modified":1510214151638},{"_id":"public/doc/Spanner-TrueTime-CAP.pdf","hash":"939a92b3b541073a3dc8b62c0dab4a3c64c73a0a","modified":1510214151691},{"_id":"public/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf","hash":"595cc33bdfb97ea09aca32864c2a94b7fba9bd1a","modified":1510214151693},{"_id":"public/img/lib.png","hash":"880d4f1a7a81eb01b2f0801e540e0cfe11452cf1","modified":1510214151695},{"_id":"public/doc/EuroSys15_Borg.pdf","hash":"fb89af8a8f76615d31c5dac0e880541284341b7f","modified":1510214151696},{"_id":"public/doc/EuroSys15_Borg_CN_Ying_201711.pdf","hash":"175fa98706f5629249447c5b93f43f43955b20a9","modified":1512313282861},{"_id":"public/img/google_dc1.jpg","hash":"6f647095c1ade1517c727885262cb2f4d6f70d83","modified":1510214151710},{"_id":"public/img/google_dc2.jpg","hash":"302e62a664e1267c30ddec0e44b3d390256a2825","modified":1510214151711},{"_id":"public/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf","hash":"112c3ba9ec4331d5504eac59aa5bc019e0e6931e","modified":1510214151715},{"_id":"public/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf","hash":"6585e262ba11c8ffe0fdb78a7cb19f53252aff45","modified":1510214151721},{"_id":"public/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf","hash":"bb38ab082d8f318af46259d1f924637e2bd06379","modified":1510214151728},{"_id":"public/doc/graduate_student_huang_yihua_2011_ppt.pdf","hash":"ec8770c44b40cda40950bb8b5b0b534221228089","modified":1510214151729},{"_id":"public/doc/walden.pdf","hash":"6e3601a6d83e10019e3c9d205c37d7005044f53c","modified":1510214151732},{"_id":"public/doc/mpich-3.2-build.tar.gz","hash":"baaa16daa824b48783125161de795a667d8e91a3","modified":1510214151747},{"_id":"public/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf","hash":"b7a2a7830d4779df793a52a8a7ac4c72eed28dcf","modified":1510214151760},{"_id":"source/_posts/setup-tensorflow-gpu-centos7.md","hash":"10bfcdbafad146b78050d93faf555c1382639d2c","modified":1512468343946},{"_id":"public/archives/2017/12/index.html","hash":"5b6c7ef0d97aa7fa9e821fddbc48b882bd1f5e51","modified":1512468470979},{"_id":"public/cloud/2017/setup-tensorflow-gpu-centos7/index.html","hash":"439baf5e6740820377c09d0cda00d288618a400a","modified":1512468470979}],"Category":[{"name":"misc","_id":"cj9s6hmgj00029s4fafs34nd5"},{"name":"cloud","_id":"cj9s6hmh0000e9s4fdh18ogks"}],"Data":[],"Page":[],"Post":[{"title":"如果有一支笔","date":"2016-05-19T16:00:00.000Z","_content":"\n这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“[就差一个软件工程师了](https://www.zhihu.com/question/22989105)”的悲伤的故事（其实还缺一个硬件工程师）。\n为了清净，把日期改了，手工置底。\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n- [xPen](#xpen)\n    - [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)\n    - [结构设计](#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)\n        - [基于光电原理](#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86)\n        - [基于陀螺仪，加速度计](#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1)\n        - [xPen的设计考虑](#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91)\n        - [其它考虑](#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91)\n- [其它，四年之路](#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF)\n- [罗技的spotlight](#%E7%BD%97%E6%8A%80%E7%9A%84spotlight)\n\n<!-- /TOC -->\n\n\n\n# xPen\n[鼠标](https://en.wikipedia.org/wiki/Computer_mouse)是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种[光笔（1955年）](https://en.wikipedia.org/wiki/Light_pen)的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。\n近些年的Surface，iPad等设备也有[配套的笔](https://en.wikipedia.org/wiki/Stylus_%28computing%29)，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 **板子** 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。\n我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 **悬着保持离板子几毫米的距离**，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。\n我的想法是设计一种笔式的输入设备，暂叫 **xPen** 吧（好没创意），不再需要配套的 **板子**，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。\n\n## 应用场景\n这样说来 **xPen** 比现有的笔式设备只是少了配套的 **板子**，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。\n\n## 结构设计\n设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。\n> 说起来似乎很简单，但不清楚具体算法是如何高效实现的。\n\n比较微妙的是，\n+ 鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。\n+ 鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。\n+ 鼠标的形状设计隐含着 **前后朝向** 的区分。\n\n与鼠标不同，传统的笔式设备定位功能是靠配套的 **板子** 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。\n\n### 基于光电原理\n\n没有了 **板子** ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：\n\n（Chrome浏览器请单击一下视频，才能允许播放Flash）\n\n这是[QQ视频的一个国内产品](https://v.qq.com/x/page/o0300z5or2g.html)，有美女哦，广告也就忍了吧~~\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n\n下面的是[B站的一个视频](http://www.bilibili.com/video/av7709459/)，介绍的是国外的 [Phree](https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper)。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\nPhree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。\n\n### 基于陀螺仪，加速度计\n[姿态传感器](https://www.zhihu.com/question/28532904)有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和[平板中比较普遍](https://www.zhihu.com/question/52083051)了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。\n下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：\n+ MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；\n+ THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；\n+ 上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波\n+ 中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召\n+ 华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威\n\n### xPen的设计考虑\n既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？\n\n+ xPen主要是针对 **水平的桌面上使用的场景**，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；\n+ xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） **重置内部的位置状态，避免导航场景中误差积累的问题**；\n+ xPen有一个 **压感笔尖**。当压感笔尖存在压力输出，对应为“移动光标”；压力 **超过一定阈值**，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 **压力阈值** 是可以通过实验统计获得的，当然用户也可以修改。**压感笔尖和笔式的外形是xPen的关键**；\n+ 对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 **触摸板** 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；\n+ 如果侧面增加一小块 **触摸板** 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；\n+ 笔的形状是为了适合书写，而且一定要是 **扁的**，不能是 **圆的**，这样才能确定 **前后朝向**，所以最好是前后不对称的，比如横截面做成 **扁的水滴状**；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。\n\n![Phree](/img/phree.jpg)\n\n![Phree](/img/phree-structure.jpg)\n\n![xPen的外形参照](/img/xpen-shape.jpg)\n\n### 其它考虑\n+ 不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；\n+ 不要增加激光，同样是不能保证激光点与PC的光标同步；\n+ 不要过分强调手写识别：\n  + Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；\n  + 突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；\n+ Phree视频中，\n  + 随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；\n  + 支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；\n  + 带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；\n  + 不过，增加麦克风以支持录音应该是比较合适的；\n  + xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。\n+ 姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。\n\n# 其它，四年之路\n\n2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 **[飞鼠](http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0)**，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 **使用姿态传感器的笔式鼠标的想法**，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 **压感笔尖**。\n想法基本就是这样了，因为在复习，就放在一边了。\n考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。\n再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。\n然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。\n我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。\n其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。\n\n# 罗技的spotlight\n一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是[罗技的spotlight](https://item.jd.com/4674246.html)，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个**笔尖**，不需要用户一直按某个键就可以了！\n\nYeah！\n\n只可惜不是我把它造出来~~\n\n![](/img/spotlitght-design.jpg)\n\n![](/img/spotlitght-spec.png)","source":"_posts/a-story-of-stylus.md","raw":"title: 如果有一支笔\ncategory: [misc]\ntags: \ndate: 2016-05-20\n---\n\n这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“[就差一个软件工程师了](https://www.zhihu.com/question/22989105)”的悲伤的故事（其实还缺一个硬件工程师）。\n为了清净，把日期改了，手工置底。\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n- [xPen](#xpen)\n    - [应用场景](#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)\n    - [结构设计](#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1)\n        - [基于光电原理](#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86)\n        - [基于陀螺仪，加速度计](#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1)\n        - [xPen的设计考虑](#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91)\n        - [其它考虑](#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91)\n- [其它，四年之路](#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF)\n- [罗技的spotlight](#%E7%BD%97%E6%8A%80%E7%9A%84spotlight)\n\n<!-- /TOC -->\n\n\n\n# xPen\n[鼠标](https://en.wikipedia.org/wiki/Computer_mouse)是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种[光笔（1955年）](https://en.wikipedia.org/wiki/Light_pen)的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。\n近些年的Surface，iPad等设备也有[配套的笔](https://en.wikipedia.org/wiki/Stylus_%28computing%29)，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 **板子** 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。\n我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 **悬着保持离板子几毫米的距离**，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。\n我的想法是设计一种笔式的输入设备，暂叫 **xPen** 吧（好没创意），不再需要配套的 **板子**，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。\n\n## 应用场景\n这样说来 **xPen** 比现有的笔式设备只是少了配套的 **板子**，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。\n\n## 结构设计\n设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。\n> 说起来似乎很简单，但不清楚具体算法是如何高效实现的。\n\n比较微妙的是，\n+ 鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。\n+ 鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。\n+ 鼠标的形状设计隐含着 **前后朝向** 的区分。\n\n与鼠标不同，传统的笔式设备定位功能是靠配套的 **板子** 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。\n\n### 基于光电原理\n\n没有了 **板子** ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：\n\n（Chrome浏览器请单击一下视频，才能允许播放Flash）\n\n这是[QQ视频的一个国内产品](https://v.qq.com/x/page/o0300z5or2g.html)，有美女哦，广告也就忍了吧~~\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n\n下面的是[B站的一个视频](http://www.bilibili.com/video/av7709459/)，介绍的是国外的 [Phree](https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper)。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\nPhree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。\n\n### 基于陀螺仪，加速度计\n[姿态传感器](https://www.zhihu.com/question/28532904)有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和[平板中比较普遍](https://www.zhihu.com/question/52083051)了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。\n下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：\n+ MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；\n+ THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；\n+ 上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波\n+ 中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召\n+ 华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威\n\n### xPen的设计考虑\n既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？\n\n+ xPen主要是针对 **水平的桌面上使用的场景**，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；\n+ xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） **重置内部的位置状态，避免导航场景中误差积累的问题**；\n+ xPen有一个 **压感笔尖**。当压感笔尖存在压力输出，对应为“移动光标”；压力 **超过一定阈值**，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 **压力阈值** 是可以通过实验统计获得的，当然用户也可以修改。**压感笔尖和笔式的外形是xPen的关键**；\n+ 对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 **触摸板** 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；\n+ 如果侧面增加一小块 **触摸板** 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；\n+ 笔的形状是为了适合书写，而且一定要是 **扁的**，不能是 **圆的**，这样才能确定 **前后朝向**，所以最好是前后不对称的，比如横截面做成 **扁的水滴状**；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。\n\n![Phree](/img/phree.jpg)\n\n![Phree](/img/phree-structure.jpg)\n\n![xPen的外形参照](/img/xpen-shape.jpg)\n\n### 其它考虑\n+ 不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；\n+ 不要增加激光，同样是不能保证激光点与PC的光标同步；\n+ 不要过分强调手写识别：\n  + Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；\n  + 突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；\n+ Phree视频中，\n  + 随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；\n  + 支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；\n  + 带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；\n  + 不过，增加麦克风以支持录音应该是比较合适的；\n  + xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。\n+ 姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。\n\n# 其它，四年之路\n\n2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 **[飞鼠](http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0)**，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 **使用姿态传感器的笔式鼠标的想法**，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 **压感笔尖**。\n想法基本就是这样了，因为在复习，就放在一边了。\n考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。\n再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。\n然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。\n我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。\n其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。\n\n# 罗技的spotlight\n一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是[罗技的spotlight](https://item.jd.com/4674246.html)，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个**笔尖**，不需要用户一直按某个键就可以了！\n\nYeah！\n\n只可惜不是我把它造出来~~\n\n![](/img/spotlitght-design.jpg)\n\n![](/img/spotlitght-spec.png)","slug":"a-story-of-stylus","published":1,"updated":"2017-11-07T15:16:34.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmga00009s4fdy053yf9","content":"<p>这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“<a href=\"https://www.zhihu.com/question/22989105\" target=\"_blank\" rel=\"external\">就差一个软件工程师了</a>”的悲伤的故事（其实还缺一个硬件工程师）。<br>为了清净，把日期改了，手工置底。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<pre><code>- [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n</code></pre><ul>\n<li><a href=\"#xpen\">xPen</a><ul>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">应用场景</a></li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\">结构设计</a><ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86\">基于光电原理</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1\">基于陀螺仪，加速度计</a></li>\n<li><a href=\"#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91\">xPen的设计考虑</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91\">其它考虑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF\">其它，四年之路</a></li>\n<li><a href=\"#%E7%BD%97%E6%8A%80%E7%9A%84spotlight\">罗技的spotlight</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"xPen\"><a href=\"#xPen\" class=\"headerlink\" title=\"xPen\"></a>xPen</h1><p><a href=\"https://en.wikipedia.org/wiki/Computer_mouse\" target=\"_blank\" rel=\"external\">鼠标</a>是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种<a href=\"https://en.wikipedia.org/wiki/Light_pen\" target=\"_blank\" rel=\"external\">光笔（1955年）</a>的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。<br>近些年的Surface，iPad等设备也有<a href=\"https://en.wikipedia.org/wiki/Stylus_%28computing%29\" target=\"_blank\" rel=\"external\">配套的笔</a>，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 <strong>板子</strong> 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。<br>我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 <strong>悬着保持离板子几毫米的距离</strong>，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。<br>我的想法是设计一种笔式的输入设备，暂叫 <strong>xPen</strong> 吧（好没创意），不再需要配套的 <strong>板子</strong>，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>这样说来 <strong>xPen</strong> 比现有的笔式设备只是少了配套的 <strong>板子</strong>，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。</p>\n<h2 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h2><p>设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。</p>\n<blockquote>\n<p>说起来似乎很简单，但不清楚具体算法是如何高效实现的。</p>\n</blockquote>\n<p>比较微妙的是，</p>\n<ul>\n<li>鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。</li>\n<li>鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。</li>\n<li>鼠标的形状设计隐含着 <strong>前后朝向</strong> 的区分。</li>\n</ul>\n<p>与鼠标不同，传统的笔式设备定位功能是靠配套的 <strong>板子</strong> 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。</p>\n<h3 id=\"基于光电原理\"><a href=\"#基于光电原理\" class=\"headerlink\" title=\"基于光电原理\"></a>基于光电原理</h3><p>没有了 <strong>板子</strong> ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：</p>\n<p>（Chrome浏览器请单击一下视频，才能允许播放Flash）</p>\n<p>这是<a href=\"https://v.qq.com/x/page/o0300z5or2g.html\" target=\"_blank\" rel=\"external\">QQ视频的一个国内产品</a>，有美女哦，广告也就忍了吧~~</p>\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowfullscreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\">\n\n<p>下面的是<a href=\"http://www.bilibili.com/video/av7709459/\" target=\"_blank\" rel=\"external\">B站的一个视频</a>，介绍的是国外的 <a href=\"https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper\" target=\"_blank\" rel=\"external\">Phree</a>。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。</p>\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\">\n\n<p>Phree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。</p>\n<h3 id=\"基于陀螺仪，加速度计\"><a href=\"#基于陀螺仪，加速度计\" class=\"headerlink\" title=\"基于陀螺仪，加速度计\"></a>基于陀螺仪，加速度计</h3><p><a href=\"https://www.zhihu.com/question/28532904\" target=\"_blank\" rel=\"external\">姿态传感器</a>有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和<a href=\"https://www.zhihu.com/question/52083051\" target=\"_blank\" rel=\"external\">平板中比较普遍</a>了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。<br>下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：</p>\n<ul>\n<li>MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；</li>\n<li>THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；</li>\n<li>上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波</li>\n<li>中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召</li>\n<li>华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威</li>\n</ul>\n<h3 id=\"xPen的设计考虑\"><a href=\"#xPen的设计考虑\" class=\"headerlink\" title=\"xPen的设计考虑\"></a>xPen的设计考虑</h3><p>既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？</p>\n<ul>\n<li>xPen主要是针对 <strong>水平的桌面上使用的场景</strong>，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；</li>\n<li>xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） <strong>重置内部的位置状态，避免导航场景中误差积累的问题</strong>；</li>\n<li>xPen有一个 <strong>压感笔尖</strong>。当压感笔尖存在压力输出，对应为“移动光标”；压力 <strong>超过一定阈值</strong>，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 <strong>压力阈值</strong> 是可以通过实验统计获得的，当然用户也可以修改。<strong>压感笔尖和笔式的外形是xPen的关键</strong>；</li>\n<li>对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 <strong>触摸板</strong> 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；</li>\n<li>如果侧面增加一小块 <strong>触摸板</strong> 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；</li>\n<li>笔的形状是为了适合书写，而且一定要是 <strong>扁的</strong>，不能是 <strong>圆的</strong>，这样才能确定 <strong>前后朝向</strong>，所以最好是前后不对称的，比如横截面做成 <strong>扁的水滴状</strong>；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。</li>\n</ul>\n<p><img src=\"/img/phree.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/phree-structure.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/xpen-shape.jpg\" alt=\"xPen的外形参照\"></p>\n<h3 id=\"其它考虑\"><a href=\"#其它考虑\" class=\"headerlink\" title=\"其它考虑\"></a>其它考虑</h3><ul>\n<li>不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；</li>\n<li>不要增加激光，同样是不能保证激光点与PC的光标同步；</li>\n<li>不要过分强调手写识别：<ul>\n<li>Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；</li>\n<li>突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；</li>\n</ul>\n</li>\n<li>Phree视频中，<ul>\n<li>随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；</li>\n<li>支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；</li>\n<li>带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；</li>\n<li>不过，增加麦克风以支持录音应该是比较合适的；</li>\n<li>xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。</li>\n</ul>\n</li>\n<li>姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。</li>\n</ul>\n<h1 id=\"其它，四年之路\"><a href=\"#其它，四年之路\" class=\"headerlink\" title=\"其它，四年之路\"></a>其它，四年之路</h1><p>2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 <strong><a href=\"http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0\" target=\"_blank\" rel=\"external\">飞鼠</a></strong>，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 <strong>使用姿态传感器的笔式鼠标的想法</strong>，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 <strong>压感笔尖</strong>。<br>想法基本就是这样了，因为在复习，就放在一边了。<br>考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。<br>再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。<br>然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。<br>我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。<br>其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。</p>\n<h1 id=\"罗技的spotlight\"><a href=\"#罗技的spotlight\" class=\"headerlink\" title=\"罗技的spotlight\"></a>罗技的spotlight</h1><p>一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是<a href=\"https://item.jd.com/4674246.html\" target=\"_blank\" rel=\"external\">罗技的spotlight</a>，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个<strong>笔尖</strong>，不需要用户一直按某个键就可以了！</p>\n<p>Yeah！</p>\n<p>只可惜不是我把它造出来~~</p>\n<p><img src=\"/img/spotlitght-design.jpg\" alt=\"\"></p>\n<p><img src=\"/img/spotlitght-spec.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>这是一个我四年前的想法，但一直没有实现。所以说，这也是一个“<a href=\"https://www.zhihu.com/question/22989105\" target=\"_blank\" rel=\"external\">就差一个软件工程师了</a>”的悲伤的故事（其实还缺一个硬件工程师）。<br>为了清净，把日期改了，手工置底。</p>","more":"<!-- TOC -->\n<pre><code>- [title: 如果有一支笔](#title-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E6%94%AF%E7%AC%94)\n</code></pre><ul>\n<li><a href=\"#xpen\">xPen</a><ul>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">应用场景</a></li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\">结构设计</a><ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E5%85%89%E7%94%B5%E5%8E%9F%E7%90%86\">基于光电原理</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E9%99%80%E8%9E%BA%E4%BB%AA%EF%BC%8C%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1\">基于陀螺仪，加速度计</a></li>\n<li><a href=\"#xpen%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91\">xPen的设计考虑</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E8%80%83%E8%99%91\">其它考虑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%EF%BC%8C%E5%9B%9B%E5%B9%B4%E4%B9%8B%E8%B7%AF\">其它，四年之路</a></li>\n<li><a href=\"#%E7%BD%97%E6%8A%80%E7%9A%84spotlight\">罗技的spotlight</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"xPen\"><a href=\"#xPen\" class=\"headerlink\" title=\"xPen\"></a>xPen</h1><p><a href=\"https://en.wikipedia.org/wiki/Computer_mouse\" target=\"_blank\" rel=\"external\">鼠标</a>是图形用户界面的主要输入设备。其实在鼠标（1968年原型诞生）之前，还有一种<a href=\"https://en.wikipedia.org/wiki/Light_pen\" target=\"_blank\" rel=\"external\">光笔（1955年）</a>的设备。光笔需要直接在屏幕上操作，其实跟现在的电容笔+触摸板用法差不多，但显然不如鼠标放在桌上操作舒服，现在很少有人听说过这种设备了。笔式输入设备的特点是能提供类似书写的体验，用鼠标写一个字的体验是相当别扭的，但是如果把鼠标做成一个笔的形状，工作原理没有变化，但感觉上就会方便多了。<br>近些年的Surface，iPad等设备也有<a href=\"https://en.wikipedia.org/wiki/Stylus_%28computing%29\" target=\"_blank\" rel=\"external\">配套的笔</a>，更早就有PC上用来绘画的的数码笔/绘图笔（Wacom），但普通用户对这些设备都接触不多。这些笔都要有一个 <strong>板子</strong> 来配套，与传统的纸笔对应，一是不方便，二是增加了整体成本。另外，可能用户对笔式输入设备的印象局限在手写或绘图场景，其实它是可以像鼠标那样来操作GUI的光标的，但用户购买这些设备显然是为了手写或绘图。<br>我曾经买过一个几百元的低档数位板，它的鼠标模式需要一直将笔 <strong>悬着保持离板子几毫米的距离</strong>，用起来是很累的，其实如果没有运行支持绘图的应用，完全可以将笔在板子上移动的操作对应为鼠标的移动光标操作。<br>我的想法是设计一种笔式的输入设备，暂叫 <strong>xPen</strong> 吧（好没创意），不再需要配套的 <strong>板子</strong>，只要笔本身即可；当然要以无线的方式连接PC，也可以用到触摸平板等设备上，但主要是面向PC用户，目标是取代鼠标，既提供基础的移动光标功能，也提供手写和绘图等高级功能。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>这样说来 <strong>xPen</strong> 比现有的笔式设备只是少了配套的 <strong>板子</strong>，功能是相近的，要想让普通用户接受，除了价格和使用体验，还要讲好故事，介绍一些更合适的应用场景。在传统的PC办公场景，要把代替鼠标的移动光标功能作为主要功能，而手写和绘图则是增强功能，这样才能引起普通用户的兴趣，而不只是笔式设备的传统用户；教育应该是最适合的一个场景，因为数理化等学科的公式符号等不容易通过键盘鼠标输入，对手写功能有比较强的需求；课堂和会议演示中在ppt手写批注也是一个比较好的场景，理想的情况是能够取代黑板的位置。</p>\n<h2 id=\"结构设计\"><a href=\"#结构设计\" class=\"headerlink\" title=\"结构设计\"></a>结构设计</h2><p>设计xPen，首先需要了解一下我们熟悉的鼠标的工作原理。鼠标的有两个主要组件：定位组件，左右两个按键和中间的滚轮（也是中键）。定位组件是底部的光电模组，激光照射在桌面上，反射到光电传感器，通过比较传感器相邻两次接收的图像，可以计算出鼠标的位移变化（Δx，Δy），即可控制屏幕上的光标按比例移动。</p>\n<blockquote>\n<p>说起来似乎很简单，但不清楚具体算法是如何高效实现的。</p>\n</blockquote>\n<p>比较微妙的是，</p>\n<ul>\n<li>鼠标的物理位置与屏幕光标是相对的，如果拿起鼠标移动一段距离，屏幕上的光标一般是保持不动的；再把鼠标放到桌面上移动，屏幕的光标则从刚才保持的位置开始移动。</li>\n<li>鼠标的物理移动距离与屏幕光标的移动距离有一个换算比例，用户很快就能适应这个换算过程。</li>\n<li>鼠标的形状设计隐含着 <strong>前后朝向</strong> 的区分。</li>\n</ul>\n<p>与鼠标不同，传统的笔式设备定位功能是靠配套的 <strong>板子</strong> 实现的。对于近几年常见的触摸平板，使用手指或笔时，定位都是屏幕的绝对位置；虽然绘图板与屏幕直接存在位置比例变换，但对绘图板而言也是绝对定位。绝对定位的情况就不需要考虑前后朝向的问题了。</p>\n<h3 id=\"基于光电原理\"><a href=\"#基于光电原理\" class=\"headerlink\" title=\"基于光电原理\"></a>基于光电原理</h3><p>没有了 <strong>板子</strong> ，xPen如何实现定位呢？其实已经有把鼠标光电模组小型化后改成的“笔”，原理跟鼠标一样，比如下面两种：</p>\n<p>（Chrome浏览器请单击一下视频，才能允许播放Flash）</p>\n<p>这是<a href=\"https://v.qq.com/x/page/o0300z5or2g.html\" target=\"_blank\" rel=\"external\">QQ视频的一个国内产品</a>，有美女哦，广告也就忍了吧~~</p>\n<embed src=\"https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o0300z5or2g&auto=0\" allowfullscreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\">\n\n<p>下面的是<a href=\"http://www.bilibili.com/video/av7709459/\" target=\"_blank\" rel=\"external\">B站的一个视频</a>，介绍的是国外的 <a href=\"https://www.kickstarter.com/projects/1958554063/phree-make-the-world-your-paper\" target=\"_blank\" rel=\"external\">Phree</a>。这个产品做的很接近我的想法，但这个视频故事没讲好，说服力不够。</p>\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"//static.hdslb.com/miniloader.swf\" flashvars=\"aid=7709459&page=1\" pluginspage=\"//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\">\n\n<p>Phree是最近推出的产品，明显比上面那个国内的产品漂亮多了，而且没有侧面的一堆按键。如果完全照搬鼠标的设计，手写时还需要按着左键，体验还是不够方便的。笔尖不够尖的话，也影响手写的体验。</p>\n<h3 id=\"基于陀螺仪，加速度计\"><a href=\"#基于陀螺仪，加速度计\" class=\"headerlink\" title=\"基于陀螺仪，加速度计\"></a>基于陀螺仪，加速度计</h3><p><a href=\"https://www.zhihu.com/question/28532904\" target=\"_blank\" rel=\"external\">姿态传感器</a>有3轴（陀螺仪或加速度计，x/y/z三个方向）、6轴（陀螺仪+加速度计）、9轴（陀螺仪+加速度计+磁场），在手机和<a href=\"https://www.zhihu.com/question/52083051\" target=\"_blank\" rel=\"external\">平板中比较普遍</a>了，无人机也是用它来定位和导航的（结合GPS）。陀螺仪（Gyroscope，测量角速度）和加速度计（Accelerometer）是根据力学原理来测量和计算位置的变化的。<br>下面几篇文章就是用手机内置的位置传感器实现空中鼠标或笔的功能：</p>\n<ul>\n<li>MobiHeld09 - PhonePoint Pen - using mobile phones to write in air 和 MobiSys11 - Using mobile phones to write in air，使用的是诺基亚N95；</li>\n<li>THMS15 - GyroPen - Gyroscopes for Pen-Input With Mobile Phones（Youtube有演示视频）；</li>\n<li>上海交大08 - 基于微加速度计的Air-Mouse的研究 - 姜晓波</li>\n<li>中科大09 - 基于加速度传感器的电子笔系统的设计 - 王庆召</li>\n<li>华中科技14 - 基于MEMS惯性传感器的空中输入笔研究 - 赵威</li>\n</ul>\n<h3 id=\"xPen的设计考虑\"><a href=\"#xPen的设计考虑\" class=\"headerlink\" title=\"xPen的设计考虑\"></a>xPen的设计考虑</h3><p>既然都有产品和文章了，当然还有很多专利，那xPen还能想到什么不一样的地方呢？</p>\n<ul>\n<li>xPen主要是针对 <strong>水平的桌面上使用的场景</strong>，而不是在空中的Air Mouse，因为在桌面上书写更自然，而且后者不够频繁；</li>\n<li>xPen使用陀螺仪和加速度计这种姿态传感器来定位，而不是光电传感器，因为姿态传感器感知的参数更多，潜在的发展方向也更多；鼠标的相对定位特性允许在姿态传感器静止时（其实可以是任何随机时刻） <strong>重置内部的位置状态，避免导航场景中误差积累的问题</strong>；</li>\n<li>xPen有一个 <strong>压感笔尖</strong>。当压感笔尖存在压力输出，对应为“移动光标”；压力 <strong>超过一定阈值</strong>，对应为拖动或书写（特定App下）。这样就不用像鼠标那样书写时需要一直按着左键了；也不像有的数位板，对频繁的控制光标操作却需要保持笔尖悬空。模式切换的 <strong>压力阈值</strong> 是可以通过实验统计获得的，当然用户也可以修改。<strong>压感笔尖和笔式的外形是xPen的关键</strong>；</li>\n<li>对应鼠标的左右键和滚轮，xPen通过压力大小切换为鼠标的移动或拖动；对单击、双击，可以设计笔尖的点击，这跟Phree的思路是差不多的，但它的笔尖就是一个左键，不是连续输出数值（实际是10 bits的1024个等级，或12 bits的4096级）的压力传感器；但只有一个笔尖，右击、滚轮就需要另想办法了，可以在侧面增加右键，而滚轮功能可以用一块 <strong>触摸板</strong> 来实现；也可以定义类似鼠标手势，但需要对操作习惯做出较大的改变；</li>\n<li>如果侧面增加一小块 <strong>触摸板</strong> 来对应鼠标的滚轮的话，其实触摸板也可以识别点击操作对应右击；触摸板的位置既要方便操作，又要避免误触，需要仔细考虑；</li>\n<li>笔的形状是为了适合书写，而且一定要是 <strong>扁的</strong>，不能是 <strong>圆的</strong>，这样才能确定 <strong>前后朝向</strong>，所以最好是前后不对称的，比如横截面做成 <strong>扁的水滴状</strong>；如果横截面做成前后对称的，通过算法来猜哪头是朝前的应该也能实现，或者也可以通过触摸板来感知哪端更靠近手掌。此外，外形设计还要保证有足够的容积，提供内置锂电池的空间。</li>\n</ul>\n<p><img src=\"/img/phree.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/phree-structure.jpg\" alt=\"Phree\"></p>\n<p><img src=\"/img/xpen-shape.jpg\" alt=\"xPen的外形参照\"></p>\n<h3 id=\"其它考虑\"><a href=\"#其它考虑\" class=\"headerlink\" title=\"其它考虑\"></a>其它考虑</h3><ul>\n<li>不要再笔尖放上油墨笔芯，因为不能也没必要把油墨书写的内容传到PC，增加这个功能只会增加困惑；</li>\n<li>不要增加激光，同样是不能保证激光点与PC的光标同步；</li>\n<li>不要过分强调手写识别：<ul>\n<li>Windows内置了Digital Ink，配合Office OneNote，可以高效地保存和传输手写内容。书写过程中等待机器识别及修正结果会对用户产生干扰，不如保持手写原样，让人们自己去识别，除非用户选择将其识别为文本；</li>\n<li>突出代替鼠标的功能，才能被普通用户接受，而支持手写则是增值的附加功能。即便单纯的笔状外形，也比鼠标让手腕放松，人体工程学体验更好；</li>\n</ul>\n</li>\n<li>Phree视频中，<ul>\n<li>随时随地书写并不太吸引人：录音，拍照应该是更合适的随时记录想法的手段；</li>\n<li>支持多设备也不太有说服力，手机和触摸平板本身的触控体验应该更好；</li>\n<li>带LCD显示屏，支持语音电话其实也是不太会经常用到的功能，作为卖点不会加分；</li>\n<li>不过，增加麦克风以支持录音应该是比较合适的；</li>\n<li>xPen应定位于能感知多种参数的输入设备，不要集成太多功能；更合适的场景是PC办公，教育，演示等。</li>\n</ul>\n</li>\n<li>姿态传感器的性能：因为人的手移动是比较缓慢的，加速度也不会太大，从而感知角速度的陀螺仪更能反映运动状态。不确定传感器的精度是否能满足要求，但从手机内置的传感器来看还是比较乐观的。</li>\n</ul>\n<h1 id=\"其它，四年之路\"><a href=\"#其它，四年之路\" class=\"headerlink\" title=\"其它，四年之路\"></a>其它，四年之路</h1><p>2013年，我在嘉兴复习备战考研。当时买了一个华为的电视盒子，虽然上面的大部分App都是针对电视遥控器的方向键设计的，但也安装了几个针对触摸屏的普通App，再额外使用一个无线鼠标来操作这些App固然是可以的，但当时就想，有没有可能让遥控器来模拟鼠标操作，结果一搜还真有，就是参考了Wii手柄的，使用陀螺仪的 <strong><a href=\"http://www.lefant.com.cn/products/%E4%B9%90%E5%B8%86f9-%E7%A9%BA%E4%B8%AD%E9%A3%9E%E9%BC%A0\" target=\"_blank\" rel=\"external\">飞鼠</a></strong>，买来一个体验一下，虽然可以在空中控制电视屏幕上的光标，但感觉定位不够准确，而且提着胳膊来遥控还是比较累的。为了偷懒，就把飞鼠放在茶几上移动，也能控制光标。于是就有了 <strong>使用姿态传感器的笔式鼠标的想法</strong>，再仔细考虑，就发现不能照搬鼠标按键的设计，于是就想应该使用 <strong>压感笔尖</strong>。<br>想法基本就是这样了，因为在复习，就放在一边了。<br>考研结束后换了带陀螺仪的手机，试验了一下灵敏度，感觉还是足够的，无奈我是个水货，既是编程渣，又不通硬件。后来开始读研，入学不久就真实感受到了自己的差距，毕业基本无望，又想起这个茬，似乎可以申请一个专利来应付毕业，当时确实查过不少专利，庆幸还没有完全一样的想法。找两个老板说了这个想法，不知是我没说清楚或者说的时候没有激情，还是老板不感兴趣，被果断否决了。一个老板还提到已经有类似的产品了，可以让用户像普通的笔那样手写内容，保存起来，然后把内容再传到PC上。我去搜索了一下，感觉最接近他的说法的是Livescribe了（当时还没有Phree）。Livescribe需要在它的专用带特定模式的纸上写字才行，实在不觉得比手机拍照方便多少。<br>再后来jyy师兄给了我一个小Idea，发了一篇C文，结果就转博了……真是自不量力，越走越黑。毕业无望的想法越来越频繁的出现，于是xPen的想法竟成了救命稻草一样的东西，来安慰自己不是没有一点想法也没有，隔一段时间也会看看有没有类似的产品出现，目前最接近的就是Phree了。<br>然而，实际上即便我把它做出来了（当然是不可能做到的），估计对我毕业拿学位也没有什么帮助，毕竟不是本学科的；虽然被老板否决了，其实还是可以申请专利的，而且也相信只要写了申请，基本就能通过，但还是觉得把它写到blog上吧。<br>我要抛开这棵稻草，不要原地打转了，要尽快向前游啊。<br>其实不用看到这篇博客，也应该会有人想到类似的想法的。希望有人能做出这样的产品，像鼠标那样方便亿万的用户。</p>\n<h1 id=\"罗技的spotlight\"><a href=\"#罗技的spotlight\" class=\"headerlink\" title=\"罗技的spotlight\"></a>罗技的spotlight</h1><p>一天晚上（2017-10-15），Wei老师拿来他新买的激光笔给我看，是<a href=\"https://item.jd.com/4674246.html\" target=\"_blank\" rel=\"external\">罗技的spotlight</a>，京东卖699元，比Phree便宜多了。他说这个激光笔居然没有激光。我一看，这个不就是没有笔尖的xPen嘛，当然就跟他解释为什么没有激光头！如果一直按着Spotlight最上面那个按键，它就通过内置的3D加速度计和陀螺仪控制屏幕上的光标，相当于一个悬空的无线鼠标，体验了一下，非常平滑流畅，macOS无需安装驱动，Windows 10插上USB接收器还会自动提示安装附加功能驱动（在系统光标上添加一个大黄圈，让光标更显著）。这说明xPen在技术上没有问题了，只要在Spotlight上加一个<strong>笔尖</strong>，不需要用户一直按某个键就可以了！</p>\n<p>Yeah！</p>\n<p>只可惜不是我把它造出来~~</p>\n<p><img src=\"/img/spotlitght-design.jpg\" alt=\"\"></p>\n<p><img src=\"/img/spotlitght-spec.png\" alt=\"\"></p>"},{"title":"Hello Hexo！","date":"2016-09-14T16:00:00.000Z","_content":"欢迎访问。\n本博客使用[Hexo](http://hexo.io/)生成。本文记录了设置过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [简介](#%E7%AE%80%E4%BB%8B)\n- [在Ubuntu 16.04上安装所需程序](#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [在Windows 10上安装所需程序](#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [初次设置](#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE)\n    - [初始化博客文件夹](#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9)\n    - [安装rss插件，git插件，math插件](#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6)\n    - [设置 `_config.yml`](#%E8%AE%BE%E7%BD%AE-configyml)\n    - [使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)](#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane)\n    - [文件结构](#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84)\n    - [修改`scaffold/post.md`模板](#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF)\n    - [修改 hexo-server默认的4000端口号为80](#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80)\n- [hexo 基本操作](#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)\n    - [常用命令](#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)\n    - [撰写文章](#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0)\n    - [发布静态html的博客网站到 Github](#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github)\n    - [为整个blog建立repo](#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo)\n    - [克隆已有的blog项目](#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE)\n- [Tips](#tips)\n    - [编辑数学公式](#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F)\n    - [设置代码块不显示行号](#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7)\n\n<!-- /TOC -->\n\n# 简介\n\n[Hexo](https://hexo.io/)是一个基于[Node.js](https://nodejs.org/)的博客生成工具。它把 [Markdown 格式](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.\nhexo有多种博客主题可选，这里使用了 [jane 主题](https://github.com/hejianxian/hexo-theme-jane)。\n[Github](https://github.com)提供了`https://[github-userId].github.io` 这样的二级域名的静态html站点的托管服务，还可以通过`CNAME`设置自己的域名（需向域名服务商购买）。\n\n下面的设置过程参考了[hexo简易教程](http://mclspace.com/2014/10/19/about-hexo/) 和 [hexo_install_config](http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/)。\n\n\n# 在Ubuntu 16.04上安装所需程序\n\n如果是桌面版的Ubuntu，打开终端（快捷键为`Ctrl+Alt+T`），执行下面的命令。\n\n## 安装git\n\n```\nsudo apt install git\n```\n\n设置 git\n\n```\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n```\n\ngit默认使用`~/.ssh`下的 key，需要在Github上注册对应的public key才能提交代码。\n\n## 安装node.js\n\na. 从Node.js官网 https://nodejs.org/en/download/ 下载Linux-x64系统的二进制安装包，解压到`/usr/local/`。\n\n```\ncd ~\nver=v6.9.2\nwget https://nodejs.org/dist/${ver}/node-${ver}-linux-x64.tar.xz\n\ntar axf node-${ver}-linux-x64.tar.xz\ncd node-${ver}-linux-x64/\nsudo cp -r ./ /usr/local/\ncd ..\nrm -rf node-${ver}-linux-x64.tar.xz\n```\n\nb. 通过添加软件源的方式\n参考[Installing Node.js via package manager](https://nodejs.org/en/download/package-manager/)，\n\n```\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt install -y nodejs\n\nsudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等\n```\n\n## 安装hexo\n\n```\nsudo npm install hexo-cli -g\n```\n\n# 在Windows 10上安装所需程序\n\n## 安装git\n\n从git官网 https://git-scm.com/downloads 下载Windows 系统的[git客户端安装程序](https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe) 。\n执行安装程序，建议\n+ 将其安装到`C:\\git`这样比较短的路径下，方便以后敲命令，\n+ 并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，\n+ 还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。\n\n>安装git的同时会安装[MinGW(Minimalist GNU for Windows)](http://www.mingw.org/)，上面的选项会把git和MinGW的可执行程序添加到`PATH`环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。\n>安装git后，`C:\\git\\usr\\bin`下面的`.exe`程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。\n\n打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。\nWindows系统上git默认使用`C:\\Users\\[UserName]\\.ssh`下的 key。\n> 以`.`开头的文件夹需要在命令窗口执行`mkdir`来创建。\n\n## 安装node.js\n从Node.js https://nodejs.org/en/download/ 下载[Windows x64系统的二进制安装包](https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi) 。\n执行安装程序，建议将其安装到`C:\\nodejs`，并选择将其添加到`PATH`路径中。\n\n## 安装hexo\n打开命令窗口，执行下面的命令\n```\nnpm install hexo-cli -g\n```\n\n# 初次设置\n\n## 初始化博客文件夹\n```\nhexo init blog\n```\n\n在Github创建一个名为`[github-userId].github.io`的项目。\n\n## 安装rss插件，git插件，math插件\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-deployer-git   --save\nnpm install hexo-math           --save\n```\n\n## 设置 `_config.yml`\n\n在 `_config.yml` 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：\n\n```\n## Themes: https://hexo.io/themes/\ntheme: jane\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:ying-zhang/ying-zhang.github.io.git\n  branch: master\n```\n\n## 使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)\n这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到`themes/`文件夹。\n直接在主题文件中修改了等宽字体，及正文的宽度。\n顺便删除默认主题landscape。\n\n> 对jane主题的修改：将侧栏移到左侧，这个在项目repo已经[有人提过issue](https://github.com/hejianxian/hexo-theme-jane/issues/5)，作者的方案需要手动修改`style.sty`，跟我摸索发现的一样，我还修改了滚动条显示的样式。\n\n\n## 文件结构\n\n| 文件/文件夹     |       说明     |\n| --------------- | -------------- |\n| `_config.yml`   | 博客的主配置文件 |\n| `.deploy_git/`  | 用于push到Github、heroku等的git仓库，里面有与`public/`相同的内容及`.git`的记录 |\n| `public/`       | 生成的完整的静态html网站，执行 `hexo clean` 会清除此文件夹 |\n| `scaffolds/`    | 里面有三个`.md`文件，其中`post.md`是博客文章的默认模板 |\n| `node_modules/` | 每个blog的文件夹中安装的hexo插件 |\n| `source/`       | 撰写的博客文章要放在`source/_post`下，`source/`文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 `public/`。可以在这里新建一个 `img/` 文件夹用于保存图片，文章中可以用`![图片说明](/img/image.png)`这样的代码来插入图片。 |\n| `themes/`       | 存放主题相关文件，各主题也有自己的`_config.yml。` |\n\n\n## 修改`scaffold/post.md`模板\n增加catagory，tags，及摘要和正文的分割线`<!--more-->`。\n> 注意，Markdown对空格和空行敏感。\n\n```\n---\ntitle: {{ title }}\ndate: {{ date }}\ncategory: misc\ntags: [tag1, tag2]\n---\n摘要部分\n<!--more-->\n---\n正文部分\n```\n\n## 修改 hexo-server默认的4000端口号为80\n如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。\n需修改`node_modules/hexo-server/index.js` 第8行 `port`。\n比如我的机器名是z，在chrome地址栏直接输入 `z/` 即可，ie则需要输入 http://z/\n\n# hexo 基本操作\n\n## 常用命令\n\n{% codeblock line_number:false%}\nhexo s     # server   本地预览，http://localhost:4000 。\nhexo d     # deploy   部署整个网站到heroku\nhexo g     # generate 生成静态html\n\nhexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。\nhexo d -g  # 依次执行生成和部署\n\nhexo clean # 删除 public/ 文件夹下所有内容\n{% endcodeblock %}\n\n## 撰写文章\n执行下面的命令，在`source/_posts/`下生成名为 `New-Post.md` 的文件。\n也可以通过常规的文件操作在`source/_posts/`下新建一个 `New-Post.md` 文件。\n\n{% codeblock line_number:false%}\nhexo n \"New Post\"\n{% endcodeblock %}\n\n更多详情可参考[使用hexo写作](http://hexo.io/docs/writing.html)的文档。\n\n## 发布静态html的博客网站到 Github\n{% codeblock line_number:false%}\nhexo d -g\n{% endcodeblock %}\n\n## 为整个blog建立repo\n\nHexo可以将生成的静态html博客网站发布到git仓库，但不会同步`source/`下源文件，`_config.yml`设置等。\n如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。\n为此，为已经设置好的博客建立一个新的git repo。\n\n{% codeblock line_number:false%}\ncd blog/\ngit init\n{% endcodeblock %}\n\n编辑`.gitignore`如下。\n{% codeblock line_number:false%}\n.DS_Store\nThumbs.db\nnode_modules/\nthemes/\npublic/\n.deploy_git/\n.npmignore\n{% endcodeblock %}\n> 注意：把`node_modules/`和`themes/`排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成`node_modules.7z` 和 `themes.7z` 会包括在git repo中。\n\n\n在Github创建一个名为`blog`的项目，\n{% codeblock line_number:false%}\ngit add .\ngit commit -m \"Init\"\ngit remote add github git@github.com:ying-zhang/blog.git\ngit push -u github master\n{% endcodeblock %}\n\n## 克隆已有的blog项目\n当然需要已经安装好git，nodejs和hexo。\n{% codeblock line_number:false%}\ngit clone git@github.com:ying-zhang/blog.git\ncd blog\n\ngit remote rename origin github\n\n7z x node_modules.7z    # 不要忘了这一步\n7z x themes.7z\n{% endcodeblock %}\n\n# Tips\n\nWindows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用VS Code编辑器。\n\n## 编辑数学公式\n注意，需要`hexo-math`插件，但这个插件的作者已经停止维护了，不知有什么替代的。\n```\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n```\n\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n\n## 设置代码块不显示行号\n```\n{% codeblock line_number:false%}\necho \"Hello Hexo!\"\n{% endcodeblock %}\n```\n\n---\n\n飞鸟集 第128\n\n>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。\n\n所以，就随便写吧。\n","source":"_posts/hello-hexo.md","raw":"title: Hello Hexo！\ncategory: misc\ndate: 2016-09-15\ntags:\n\n---\n欢迎访问。\n本博客使用[Hexo](http://hexo.io/)生成。本文记录了设置过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [简介](#%E7%AE%80%E4%BB%8B)\n- [在Ubuntu 16.04上安装所需程序](#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [在Windows 10上安装所需程序](#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F)\n    - [安装git](#%E5%AE%89%E8%A3%85git)\n    - [安装node.js](#%E5%AE%89%E8%A3%85nodejs)\n    - [安装hexo](#%E5%AE%89%E8%A3%85hexo)\n- [初次设置](#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE)\n    - [初始化博客文件夹](#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9)\n    - [安装rss插件，git插件，math插件](#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6)\n    - [设置 `_config.yml`](#%E8%AE%BE%E7%BD%AE-configyml)\n    - [使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)](#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane)\n    - [文件结构](#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84)\n    - [修改`scaffold/post.md`模板](#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF)\n    - [修改 hexo-server默认的4000端口号为80](#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80)\n- [hexo 基本操作](#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)\n    - [常用命令](#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)\n    - [撰写文章](#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0)\n    - [发布静态html的博客网站到 Github](#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github)\n    - [为整个blog建立repo](#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo)\n    - [克隆已有的blog项目](#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE)\n- [Tips](#tips)\n    - [编辑数学公式](#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F)\n    - [设置代码块不显示行号](#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7)\n\n<!-- /TOC -->\n\n# 简介\n\n[Hexo](https://hexo.io/)是一个基于[Node.js](https://nodejs.org/)的博客生成工具。它把 [Markdown 格式](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.\nhexo有多种博客主题可选，这里使用了 [jane 主题](https://github.com/hejianxian/hexo-theme-jane)。\n[Github](https://github.com)提供了`https://[github-userId].github.io` 这样的二级域名的静态html站点的托管服务，还可以通过`CNAME`设置自己的域名（需向域名服务商购买）。\n\n下面的设置过程参考了[hexo简易教程](http://mclspace.com/2014/10/19/about-hexo/) 和 [hexo_install_config](http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/)。\n\n\n# 在Ubuntu 16.04上安装所需程序\n\n如果是桌面版的Ubuntu，打开终端（快捷键为`Ctrl+Alt+T`），执行下面的命令。\n\n## 安装git\n\n```\nsudo apt install git\n```\n\n设置 git\n\n```\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n```\n\ngit默认使用`~/.ssh`下的 key，需要在Github上注册对应的public key才能提交代码。\n\n## 安装node.js\n\na. 从Node.js官网 https://nodejs.org/en/download/ 下载Linux-x64系统的二进制安装包，解压到`/usr/local/`。\n\n```\ncd ~\nver=v6.9.2\nwget https://nodejs.org/dist/${ver}/node-${ver}-linux-x64.tar.xz\n\ntar axf node-${ver}-linux-x64.tar.xz\ncd node-${ver}-linux-x64/\nsudo cp -r ./ /usr/local/\ncd ..\nrm -rf node-${ver}-linux-x64.tar.xz\n```\n\nb. 通过添加软件源的方式\n参考[Installing Node.js via package manager](https://nodejs.org/en/download/package-manager/)，\n\n```\ncurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -\nsudo apt install -y nodejs\n\nsudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等\n```\n\n## 安装hexo\n\n```\nsudo npm install hexo-cli -g\n```\n\n# 在Windows 10上安装所需程序\n\n## 安装git\n\n从git官网 https://git-scm.com/downloads 下载Windows 系统的[git客户端安装程序](https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe) 。\n执行安装程序，建议\n+ 将其安装到`C:\\git`这样比较短的路径下，方便以后敲命令，\n+ 并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，\n+ 还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。\n\n>安装git的同时会安装[MinGW(Minimalist GNU for Windows)](http://www.mingw.org/)，上面的选项会把git和MinGW的可执行程序添加到`PATH`环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。\n>安装git后，`C:\\git\\usr\\bin`下面的`.exe`程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。\n\n打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。\nWindows系统上git默认使用`C:\\Users\\[UserName]\\.ssh`下的 key。\n> 以`.`开头的文件夹需要在命令窗口执行`mkdir`来创建。\n\n## 安装node.js\n从Node.js https://nodejs.org/en/download/ 下载[Windows x64系统的二进制安装包](https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi) 。\n执行安装程序，建议将其安装到`C:\\nodejs`，并选择将其添加到`PATH`路径中。\n\n## 安装hexo\n打开命令窗口，执行下面的命令\n```\nnpm install hexo-cli -g\n```\n\n# 初次设置\n\n## 初始化博客文件夹\n```\nhexo init blog\n```\n\n在Github创建一个名为`[github-userId].github.io`的项目。\n\n## 安装rss插件，git插件，math插件\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-deployer-git   --save\nnpm install hexo-math           --save\n```\n\n## 设置 `_config.yml`\n\n在 `_config.yml` 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：\n\n```\n## Themes: https://hexo.io/themes/\ntheme: jane\n\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:ying-zhang/ying-zhang.github.io.git\n  branch: master\n```\n\n## 使用[jane主题](https://github.com/hejianxian/hexo-theme-jane)\n这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到`themes/`文件夹。\n直接在主题文件中修改了等宽字体，及正文的宽度。\n顺便删除默认主题landscape。\n\n> 对jane主题的修改：将侧栏移到左侧，这个在项目repo已经[有人提过issue](https://github.com/hejianxian/hexo-theme-jane/issues/5)，作者的方案需要手动修改`style.sty`，跟我摸索发现的一样，我还修改了滚动条显示的样式。\n\n\n## 文件结构\n\n| 文件/文件夹     |       说明     |\n| --------------- | -------------- |\n| `_config.yml`   | 博客的主配置文件 |\n| `.deploy_git/`  | 用于push到Github、heroku等的git仓库，里面有与`public/`相同的内容及`.git`的记录 |\n| `public/`       | 生成的完整的静态html网站，执行 `hexo clean` 会清除此文件夹 |\n| `scaffolds/`    | 里面有三个`.md`文件，其中`post.md`是博客文章的默认模板 |\n| `node_modules/` | 每个blog的文件夹中安装的hexo插件 |\n| `source/`       | 撰写的博客文章要放在`source/_post`下，`source/`文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 `public/`。可以在这里新建一个 `img/` 文件夹用于保存图片，文章中可以用`![图片说明](/img/image.png)`这样的代码来插入图片。 |\n| `themes/`       | 存放主题相关文件，各主题也有自己的`_config.yml。` |\n\n\n## 修改`scaffold/post.md`模板\n增加catagory，tags，及摘要和正文的分割线`<!--more-->`。\n> 注意，Markdown对空格和空行敏感。\n\n```\n---\ntitle: {{ title }}\ndate: {{ date }}\ncategory: misc\ntags: [tag1, tag2]\n---\n摘要部分\n<!--more-->\n---\n正文部分\n```\n\n## 修改 hexo-server默认的4000端口号为80\n如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。\n需修改`node_modules/hexo-server/index.js` 第8行 `port`。\n比如我的机器名是z，在chrome地址栏直接输入 `z/` 即可，ie则需要输入 http://z/\n\n# hexo 基本操作\n\n## 常用命令\n\n{% codeblock line_number:false%}\nhexo s     # server   本地预览，http://localhost:4000 。\nhexo d     # deploy   部署整个网站到heroku\nhexo g     # generate 生成静态html\n\nhexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。\nhexo d -g  # 依次执行生成和部署\n\nhexo clean # 删除 public/ 文件夹下所有内容\n{% endcodeblock %}\n\n## 撰写文章\n执行下面的命令，在`source/_posts/`下生成名为 `New-Post.md` 的文件。\n也可以通过常规的文件操作在`source/_posts/`下新建一个 `New-Post.md` 文件。\n\n{% codeblock line_number:false%}\nhexo n \"New Post\"\n{% endcodeblock %}\n\n更多详情可参考[使用hexo写作](http://hexo.io/docs/writing.html)的文档。\n\n## 发布静态html的博客网站到 Github\n{% codeblock line_number:false%}\nhexo d -g\n{% endcodeblock %}\n\n## 为整个blog建立repo\n\nHexo可以将生成的静态html博客网站发布到git仓库，但不会同步`source/`下源文件，`_config.yml`设置等。\n如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。\n为此，为已经设置好的博客建立一个新的git repo。\n\n{% codeblock line_number:false%}\ncd blog/\ngit init\n{% endcodeblock %}\n\n编辑`.gitignore`如下。\n{% codeblock line_number:false%}\n.DS_Store\nThumbs.db\nnode_modules/\nthemes/\npublic/\n.deploy_git/\n.npmignore\n{% endcodeblock %}\n> 注意：把`node_modules/`和`themes/`排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成`node_modules.7z` 和 `themes.7z` 会包括在git repo中。\n\n\n在Github创建一个名为`blog`的项目，\n{% codeblock line_number:false%}\ngit add .\ngit commit -m \"Init\"\ngit remote add github git@github.com:ying-zhang/blog.git\ngit push -u github master\n{% endcodeblock %}\n\n## 克隆已有的blog项目\n当然需要已经安装好git，nodejs和hexo。\n{% codeblock line_number:false%}\ngit clone git@github.com:ying-zhang/blog.git\ncd blog\n\ngit remote rename origin github\n\n7z x node_modules.7z    # 不要忘了这一步\n7z x themes.7z\n{% endcodeblock %}\n\n# Tips\n\nWindows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用VS Code编辑器。\n\n## 编辑数学公式\n注意，需要`hexo-math`插件，但这个插件的作者已经停止维护了，不知有什么替代的。\n```\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n```\n\n{% math %}\n\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =& \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le& \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=& \\log_2\\sum_i{Q_i} \\\\\n=& 0\n\\end{align*}\n{% endmath %}\n\n## 设置代码块不显示行号\n```\n{% codeblock line_number:false%}\necho \"Hello Hexo!\"\n{% endcodeblock %}\n```\n\n---\n\n飞鸟集 第128\n\n>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。\n\n所以，就随便写吧。\n","slug":"hello-hexo","published":1,"updated":"2017-11-07T15:36:27.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgf00019s4fubvyf7lw","content":"<p>欢迎访问。<br>本博客使用<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>生成。本文记录了设置过程。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E7%AE%80%E4%BB%8B\">简介</a></li>\n<li><a href=\"#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Ubuntu 16.04上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Windows 10上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE\">初次设置</a><ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9\">初始化博客文件夹</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6\">安装rss插件，git插件，math插件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE-configyml\">设置 <code>_config.yml</code></a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane\">使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\">文件结构</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF\">修改<code>scaffold/post.md</code>模板</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80\">修改 hexo-server默认的4000端口号为80</a></li>\n</ul>\n</li>\n<li><a href=\"#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">hexo 基本操作</a><ul>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">常用命令</a></li>\n<li><a href=\"#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0\">撰写文章</a></li>\n<li><a href=\"#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github\">发布静态html的博客网站到 Github</a></li>\n<li><a href=\"#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo\">为整个blog建立repo</a></li>\n<li><a href=\"#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE\">克隆已有的blog项目</a></li>\n</ul>\n</li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F\">编辑数学公式</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7\">设置代码块不显示行号</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>是一个基于<a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>的博客生成工具。它把 <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\" rel=\"external\">Markdown 格式</a>的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.<br>hexo有多种博客主题可选，这里使用了 <a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane 主题</a>。<br><a href=\"https://github.com\" target=\"_blank\" rel=\"external\">Github</a>提供了<code>https://[github-userId].github.io</code> 这样的二级域名的静态html站点的托管服务，还可以通过<code>CNAME</code>设置自己的域名（需向域名服务商购买）。</p>\n<p>下面的设置过程参考了<a href=\"http://mclspace.com/2014/10/19/about-hexo/\" target=\"_blank\" rel=\"external\">hexo简易教程</a> 和 <a href=\"http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/\" target=\"_blank\" rel=\"external\">hexo_install_config</a>。</p>\n<h1 id=\"在Ubuntu-16-04上安装所需程序\"><a href=\"#在Ubuntu-16-04上安装所需程序\" class=\"headerlink\" title=\"在Ubuntu 16.04上安装所需程序\"></a>在Ubuntu 16.04上安装所需程序</h1><p>如果是桌面版的Ubuntu，打开终端（快捷键为<code>Ctrl+Alt+T</code>），执行下面的命令。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install git</div></pre></td></tr></table></figure>\n<p>设置 git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div></pre></td></tr></table></figure>\n<p>git默认使用<code>~/.ssh</code>下的 key，需要在Github上注册对应的public key才能提交代码。</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>a. 从Node.js官网 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载Linux-x64系统的二进制安装包，解压到<code>/usr/local/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">ver=v6.9.2</div><div class=\"line\">wget https://nodejs.org/dist/$&#123;ver&#125;/node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\"></div><div class=\"line\">tar axf node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\">cd node-$&#123;ver&#125;-linux-x64/</div><div class=\"line\">sudo cp -r ./ /usr/local/</div><div class=\"line\">cd ..</div><div class=\"line\">rm -rf node-$&#123;ver&#125;-linux-x64.tar.xz</div></pre></td></tr></table></figure>\n<p>b. 通过添加软件源的方式<br>参考<a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"external\">Installing Node.js via package manager</a>，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</div><div class=\"line\">sudo apt install -y nodejs</div><div class=\"line\"></div><div class=\"line\">sudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等</div></pre></td></tr></table></figure>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<h1 id=\"在Windows-10上安装所需程序\"><a href=\"#在Windows-10上安装所需程序\" class=\"headerlink\" title=\"在Windows 10上安装所需程序\"></a>在Windows 10上安装所需程序</h1><h2 id=\"安装git-1\"><a href=\"#安装git-1\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>从git官网 <a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">https://git-scm.com/downloads</a> 下载Windows 系统的<a href=\"https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe\" target=\"_blank\" rel=\"external\">git客户端安装程序</a> 。<br>执行安装程序，建议</p>\n<ul>\n<li>将其安装到<code>C:\\git</code>这样比较短的路径下，方便以后敲命令，</li>\n<li>并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，</li>\n<li>还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。</li>\n</ul>\n<blockquote>\n<p>安装git的同时会安装<a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"external\">MinGW(Minimalist GNU for Windows)</a>，上面的选项会把git和MinGW的可执行程序添加到<code>PATH</code>环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。<br>安装git后，<code>C:\\git\\usr\\bin</code>下面的<code>.exe</code>程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。</p>\n</blockquote>\n<p>打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。<br>Windows系统上git默认使用<code>C:\\Users\\[UserName]\\.ssh</code>下的 key。</p>\n<blockquote>\n<p>以<code>.</code>开头的文件夹需要在命令窗口执行<code>mkdir</code>来创建。</p>\n</blockquote>\n<h2 id=\"安装node-js-1\"><a href=\"#安装node-js-1\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>从Node.js <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载<a href=\"https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi\" target=\"_blank\" rel=\"external\">Windows x64系统的二进制安装包</a> 。<br>执行安装程序，建议将其安装到<code>C:\\nodejs</code>，并选择将其添加到<code>PATH</code>路径中。</p>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>打开命令窗口，执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>\n<h1 id=\"初次设置\"><a href=\"#初次设置\" class=\"headerlink\" title=\"初次设置\"></a>初次设置</h1><h2 id=\"初始化博客文件夹\"><a href=\"#初始化博客文件夹\" class=\"headerlink\" title=\"初始化博客文件夹\"></a>初始化博客文件夹</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure>\n<p>在Github创建一个名为<code>[github-userId].github.io</code>的项目。</p>\n<h2 id=\"安装rss插件，git插件，math插件\"><a href=\"#安装rss插件，git插件，math插件\" class=\"headerlink\" title=\"安装rss插件，git插件，math插件\"></a>安装rss插件，git插件，math插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-generator-feed --save</div><div class=\"line\">npm install hexo-deployer-git   --save</div><div class=\"line\">npm install hexo-math           --save</div></pre></td></tr></table></figure>\n<h2 id=\"设置-config-yml\"><a href=\"#设置-config-yml\" class=\"headerlink\" title=\"设置 _config.yml\"></a>设置 <code>_config.yml</code></h2><p>在 <code>_config.yml</code> 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: jane</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:ying-zhang/ying-zhang.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h2 id=\"使用jane主题\"><a href=\"#使用jane主题\" class=\"headerlink\" title=\"使用jane主题\"></a>使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></h2><p>这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到<code>themes/</code>文件夹。<br>直接在主题文件中修改了等宽字体，及正文的宽度。<br>顺便删除默认主题landscape。</p>\n<blockquote>\n<p>对jane主题的修改：将侧栏移到左侧，这个在项目repo已经<a href=\"https://github.com/hejianxian/hexo-theme-jane/issues/5\" target=\"_blank\" rel=\"external\">有人提过issue</a>，作者的方案需要手动修改<code>style.sty</code>，跟我摸索发现的一样，我还修改了滚动条显示的样式。</p>\n</blockquote>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_config.yml</code></td>\n<td>博客的主配置文件</td>\n</tr>\n<tr>\n<td><code>.deploy_git/</code></td>\n<td>用于push到Github、heroku等的git仓库，里面有与<code>public/</code>相同的内容及<code>.git</code>的记录</td>\n</tr>\n<tr>\n<td><code>public/</code></td>\n<td>生成的完整的静态html网站，执行 <code>hexo clean</code> 会清除此文件夹</td>\n</tr>\n<tr>\n<td><code>scaffolds/</code></td>\n<td>里面有三个<code>.md</code>文件，其中<code>post.md</code>是博客文章的默认模板</td>\n</tr>\n<tr>\n<td><code>node_modules/</code></td>\n<td>每个blog的文件夹中安装的hexo插件</td>\n</tr>\n<tr>\n<td><code>source/</code></td>\n<td>撰写的博客文章要放在<code>source/_post</code>下，<code>source/</code>文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 <code>public/</code>。可以在这里新建一个 <code>img/</code> 文件夹用于保存图片，文章中可以用<code>![图片说明](/img/image.png)</code>这样的代码来插入图片。</td>\n</tr>\n<tr>\n<td><code>themes/</code></td>\n<td>存放主题相关文件，各主题也有自己的<code>_config.yml。</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修改scaffold-post-md模板\"><a href=\"#修改scaffold-post-md模板\" class=\"headerlink\" title=\"修改scaffold/post.md模板\"></a>修改<code>scaffold/post.md</code>模板</h2><p>增加catagory，tags，及摘要和正文的分割线<code>&lt;!--more--&gt;</code>。</p>\n<blockquote>\n<p>注意，Markdown对空格和空行敏感。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: &#123;&#123; title &#125;&#125;</div><div class=\"line\">date: &#123;&#123; date &#125;&#125;</div><div class=\"line\">category: misc</div><div class=\"line\">tags: [tag1, tag2]</div><div class=\"line\">---</div><div class=\"line\">摘要部分</div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\">---</div><div class=\"line\">正文部分</div></pre></td></tr></table></figure>\n<h2 id=\"修改-hexo-server默认的4000端口号为80\"><a href=\"#修改-hexo-server默认的4000端口号为80\" class=\"headerlink\" title=\"修改 hexo-server默认的4000端口号为80\"></a>修改 hexo-server默认的4000端口号为80</h2><p>如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。<br>需修改<code>node_modules/hexo-server/index.js</code> 第8行 <code>port</code>。<br>比如我的机器名是z，在chrome地址栏直接输入 <code>z/</code> 即可，ie则需要输入 <a href=\"http://z/\" target=\"_blank\" rel=\"external\">http://z/</a></p>\n<h1 id=\"hexo-基本操作\"><a href=\"#hexo-基本操作\" class=\"headerlink\" title=\"hexo 基本操作\"></a>hexo 基本操作</h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo s     # server   本地预览，http://localhost:4000 。</div><div class=\"line\">hexo d     # deploy   部署整个网站到heroku</div><div class=\"line\">hexo g     # generate 生成静态html</div><div class=\"line\"></div><div class=\"line\">hexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。</div><div class=\"line\">hexo d -g  # 依次执行生成和部署</div><div class=\"line\"></div><div class=\"line\">hexo clean # 删除 public/ 文件夹下所有内容</div></pre></td></tr></table></figure>\n<h2 id=\"撰写文章\"><a href=\"#撰写文章\" class=\"headerlink\" title=\"撰写文章\"></a>撰写文章</h2><p>执行下面的命令，在<code>source/_posts/</code>下生成名为 <code>New-Post.md</code> 的文件。<br>也可以通过常规的文件操作在<code>source/_posts/</code>下新建一个 <code>New-Post.md</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo n &quot;New Post&quot;</div></pre></td></tr></table></figure>\n<p>更多详情可参考<a href=\"http://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">使用hexo写作</a>的文档。</p>\n<h2 id=\"发布静态html的博客网站到-Github\"><a href=\"#发布静态html的博客网站到-Github\" class=\"headerlink\" title=\"发布静态html的博客网站到 Github\"></a>发布静态html的博客网站到 Github</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure>\n<h2 id=\"为整个blog建立repo\"><a href=\"#为整个blog建立repo\" class=\"headerlink\" title=\"为整个blog建立repo\"></a>为整个blog建立repo</h2><p>Hexo可以将生成的静态html博客网站发布到git仓库，但不会同步<code>source/</code>下源文件，<code>_config.yml</code>设置等。<br>如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。<br>为此，为已经设置好的博客建立一个新的git repo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd blog/</div><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>编辑<code>.gitignore</code>如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">node_modules/</div><div class=\"line\">themes/</div><div class=\"line\">public/</div><div class=\"line\">.deploy_git/</div><div class=\"line\">.npmignore</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：把<code>node_modules/</code>和<code>themes/</code>排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成<code>node_modules.7z</code> 和 <code>themes.7z</code> 会包括在git repo中。</p>\n</blockquote>\n<p>在Github创建一个名为<code>blog</code>的项目，<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;Init&quot;</div><div class=\"line\">git remote add github git@github.com:ying-zhang/blog.git</div><div class=\"line\">git push -u github master</div></pre></td></tr></table></figure></p>\n<h2 id=\"克隆已有的blog项目\"><a href=\"#克隆已有的blog项目\" class=\"headerlink\" title=\"克隆已有的blog项目\"></a>克隆已有的blog项目</h2><p>当然需要已经安装好git，nodejs和hexo。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ying-zhang/blog.git</div><div class=\"line\">cd blog</div><div class=\"line\"></div><div class=\"line\">git remote rename origin github</div><div class=\"line\"></div><div class=\"line\">7z x node_modules.7z    # 不要忘了这一步</div><div class=\"line\">7z x themes.7z</div></pre></td></tr></table></figure></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p>Windows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用VS Code编辑器。</p>\n<h2 id=\"编辑数学公式\"><a href=\"#编辑数学公式\" class=\"headerlink\" title=\"编辑数学公式\"></a>编辑数学公式</h2><p>注意，需要<code>hexo-math</code>插件，但这个插件的作者已经停止维护了，不知有什么替代的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% math %&#125;</div><div class=\"line\">\\begin&#123;align*&#125;</div><div class=\"line\">-\\sum_i&#123;P_i\\log_2\\frac&#123;P_i&#125;&#123;Q_i&#125;&#125; =&amp; \\sum_i&#123;P_i\\log_2\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\\\</div><div class=\"line\">\\le&amp; \\log_2\\sum_i&#123;P_i\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\tag&#123;Jensen 不等式&#125; \\\\</div><div class=\"line\">=&amp; \\log_2\\sum_i&#123;Q_i&#125; \\\\</div><div class=\"line\">=&amp; 0</div><div class=\"line\">\\end&#123;align*&#125;</div><div class=\"line\">&#123;% endmath %&#125;</div></pre></td></tr></table></figure></p>\n<span>$$\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =&amp; \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le&amp; \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=&amp; \\log_2\\sum_i{Q_i} \\\\\n=&amp; 0\n\\end{align*}$$</span><!-- Has MathJax -->\n<h2 id=\"设置代码块不显示行号\"><a href=\"#设置代码块不显示行号\" class=\"headerlink\" title=\"设置代码块不显示行号\"></a>设置代码块不显示行号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% codeblock line_number:false%&#125;</div><div class=\"line\">echo &quot;Hello Hexo!&quot;</div><div class=\"line\">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>飞鸟集 第128</p>\n<blockquote>\n<p>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。</p>\n</blockquote>\n<p>所以，就随便写吧。</p>\n","site":{"data":{}},"excerpt":"<p>欢迎访问。<br>本博客使用<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>生成。本文记录了设置过程。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E7%AE%80%E4%BB%8B\">简介</a></li>\n<li><a href=\"#%E5%9C%A8ubuntu-1604%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Ubuntu 16.04上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8windows-10%E4%B8%8A%E5%AE%89%E8%A3%85%E6%89%80%E9%9C%80%E7%A8%8B%E5%BA%8F\">在Windows 10上安装所需程序</a><ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85git\">安装git</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85nodejs\">安装node.js</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85hexo\">安装hexo</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9D%E6%AC%A1%E8%AE%BE%E7%BD%AE\">初次设置</a><ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E5%A4%B9\">初始化博客文件夹</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85rss%E6%8F%92%E4%BB%B6%EF%BC%8Cgit%E6%8F%92%E4%BB%B6%EF%BC%8Cmath%E6%8F%92%E4%BB%B6\">安装rss插件，git插件，math插件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE-configyml\">设置 <code>_config.yml</code></a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8jane%E4%B8%BB%E9%A2%98httpsgithubcomhejianxianhexo-theme-jane\">使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></a></li>\n<li><a href=\"#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\">文件结构</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9scaffoldpostmd%E6%A8%A1%E6%9D%BF\">修改<code>scaffold/post.md</code>模板</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9-hexo-server%E9%BB%98%E8%AE%A4%E7%9A%844000%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%BA80\">修改 hexo-server默认的4000端口号为80</a></li>\n</ul>\n</li>\n<li><a href=\"#hexo-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\">hexo 基本操作</a><ul>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">常用命令</a></li>\n<li><a href=\"#%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0\">撰写文章</a></li>\n<li><a href=\"#%E5%8F%91%E5%B8%83%E9%9D%99%E6%80%81html%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%88%B0-github\">发布静态html的博客网站到 Github</a></li>\n<li><a href=\"#%E4%B8%BA%E6%95%B4%E4%B8%AAblog%E5%BB%BA%E7%AB%8Brepo\">为整个blog建立repo</a></li>\n<li><a href=\"#%E5%85%8B%E9%9A%86%E5%B7%B2%E6%9C%89%E7%9A%84blog%E9%A1%B9%E7%9B%AE\">克隆已有的blog项目</a></li>\n</ul>\n</li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F\">编辑数学公式</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7\">设置代码块不显示行号</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p><a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>是一个基于<a href=\"https://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>的博客生成工具。它把 <a href=\"https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\" target=\"_blank\" rel=\"external\">Markdown 格式</a>的博客文章(Post)转换成一个静态的html博客网站，除了生成文章正文的html页面，还生成了博客列表，分类，tag等辅助页面.<br>hexo有多种博客主题可选，这里使用了 <a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane 主题</a>。<br><a href=\"https://github.com\" target=\"_blank\" rel=\"external\">Github</a>提供了<code>https://[github-userId].github.io</code> 这样的二级域名的静态html站点的托管服务，还可以通过<code>CNAME</code>设置自己的域名（需向域名服务商购买）。</p>\n<p>下面的设置过程参考了<a href=\"http://mclspace.com/2014/10/19/about-hexo/\" target=\"_blank\" rel=\"external\">hexo简易教程</a> 和 <a href=\"http://methor.github.io/%E5%B7%A5%E5%85%B7/hexo/hexo-install-config/\" target=\"_blank\" rel=\"external\">hexo_install_config</a>。</p>\n<h1 id=\"在Ubuntu-16-04上安装所需程序\"><a href=\"#在Ubuntu-16-04上安装所需程序\" class=\"headerlink\" title=\"在Ubuntu 16.04上安装所需程序\"></a>在Ubuntu 16.04上安装所需程序</h1><p>如果是桌面版的Ubuntu，打开终端（快捷键为<code>Ctrl+Alt+T</code>），执行下面的命令。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt install git</div></pre></td></tr></table></figure>\n<p>设置 git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div></pre></td></tr></table></figure>\n<p>git默认使用<code>~/.ssh</code>下的 key，需要在Github上注册对应的public key才能提交代码。</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>a. 从Node.js官网 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载Linux-x64系统的二进制安装包，解压到<code>/usr/local/</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">ver=v6.9.2</div><div class=\"line\">wget https://nodejs.org/dist/$&#123;ver&#125;/node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\"></div><div class=\"line\">tar axf node-$&#123;ver&#125;-linux-x64.tar.xz</div><div class=\"line\">cd node-$&#123;ver&#125;-linux-x64/</div><div class=\"line\">sudo cp -r ./ /usr/local/</div><div class=\"line\">cd ..</div><div class=\"line\">rm -rf node-$&#123;ver&#125;-linux-x64.tar.xz</div></pre></td></tr></table></figure>\n<p>b. 通过添加软件源的方式<br>参考<a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"external\">Installing Node.js via package manager</a>，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</div><div class=\"line\">sudo apt install -y nodejs</div><div class=\"line\"></div><div class=\"line\">sudo apt install -y build-essential #如果npm安装的包需要在本地编译，则需要安装编译工具如gcc等</div></pre></td></tr></table></figure>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<h1 id=\"在Windows-10上安装所需程序\"><a href=\"#在Windows-10上安装所需程序\" class=\"headerlink\" title=\"在Windows 10上安装所需程序\"></a>在Windows 10上安装所需程序</h1><h2 id=\"安装git-1\"><a href=\"#安装git-1\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>从git官网 <a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">https://git-scm.com/downloads</a> 下载Windows 系统的<a href=\"https://github.com/git-for-windows/git/releases/download/v2.10.0.windows.1/Git-2.10.0-64-bit.exe\" target=\"_blank\" rel=\"external\">git客户端安装程序</a> 。<br>执行安装程序，建议</p>\n<ul>\n<li>将其安装到<code>C:\\git</code>这样比较短的路径下，方便以后敲命令，</li>\n<li>并且选择 Use Git and optional Unix tools from the Windows Command Prompt ，</li>\n<li>还要在 How should Git treat line endings in text files? （处理换行符）选项中选择 Checkout as-is, commit Unix-style line endings 。</li>\n</ul>\n<blockquote>\n<p>安装git的同时会安装<a href=\"http://www.mingw.org/\" target=\"_blank\" rel=\"external\">MinGW(Minimalist GNU for Windows)</a>，上面的选项会把git和MinGW的可执行程序添加到<code>PATH</code>环境变量中，这样就可以方便地在Windows命令行窗口直接使用git和其它常用的Unix命令了。<br>安装git后，<code>C:\\git\\usr\\bin</code>下面的<code>.exe</code>程序就是MinGW支持的Unix命令，如bash, ls, mv, cp, grep, cat, sort, head, tail, wc, vim, tar, curl, ssh, scp等。</p>\n</blockquote>\n<p>打开命令窗口（快捷键为Win+X，C或A），参考上面Ubuntu系统的命令设置git 的用户名，Email。<br>Windows系统上git默认使用<code>C:\\Users\\[UserName]\\.ssh</code>下的 key。</p>\n<blockquote>\n<p>以<code>.</code>开头的文件夹需要在命令窗口执行<code>mkdir</code>来创建。</p>\n</blockquote>\n<h2 id=\"安装node-js-1\"><a href=\"#安装node-js-1\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>从Node.js <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">https://nodejs.org/en/download/</a> 下载<a href=\"https://nodejs.org/dist/v4.5.0/node-v4.5.0-x64.msi\" target=\"_blank\" rel=\"external\">Windows x64系统的二进制安装包</a> 。<br>执行安装程序，建议将其安装到<code>C:\\nodejs</code>，并选择将其添加到<code>PATH</code>路径中。</p>\n<h2 id=\"安装hexo-1\"><a href=\"#安装hexo-1\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><p>打开命令窗口，执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure></p>\n<h1 id=\"初次设置\"><a href=\"#初次设置\" class=\"headerlink\" title=\"初次设置\"></a>初次设置</h1><h2 id=\"初始化博客文件夹\"><a href=\"#初始化博客文件夹\" class=\"headerlink\" title=\"初始化博客文件夹\"></a>初始化博客文件夹</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure>\n<p>在Github创建一个名为<code>[github-userId].github.io</code>的项目。</p>\n<h2 id=\"安装rss插件，git插件，math插件\"><a href=\"#安装rss插件，git插件，math插件\" class=\"headerlink\" title=\"安装rss插件，git插件，math插件\"></a>安装rss插件，git插件，math插件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-generator-feed --save</div><div class=\"line\">npm install hexo-deployer-git   --save</div><div class=\"line\">npm install hexo-math           --save</div></pre></td></tr></table></figure>\n<h2 id=\"设置-config-yml\"><a href=\"#设置-config-yml\" class=\"headerlink\" title=\"设置 _config.yml\"></a>设置 <code>_config.yml</code></h2><p>在 <code>_config.yml</code> 修改博客名，固定链接格式，主题，deploy的repo等。部分设置如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">## Themes: https://hexo.io/themes/</div><div class=\"line\">theme: jane</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:ying-zhang/ying-zhang.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<h2 id=\"使用jane主题\"><a href=\"#使用jane主题\" class=\"headerlink\" title=\"使用jane主题\"></a>使用<a href=\"https://github.com/hejianxian/hexo-theme-jane\" target=\"_blank\" rel=\"external\">jane主题</a></h2><p>这里没有使用git clone来下载 jane 主题的代码库，而是直接下载代码库的zip文件，解压到<code>themes/</code>文件夹。<br>直接在主题文件中修改了等宽字体，及正文的宽度。<br>顺便删除默认主题landscape。</p>\n<blockquote>\n<p>对jane主题的修改：将侧栏移到左侧，这个在项目repo已经<a href=\"https://github.com/hejianxian/hexo-theme-jane/issues/5\" target=\"_blank\" rel=\"external\">有人提过issue</a>，作者的方案需要手动修改<code>style.sty</code>，跟我摸索发现的一样，我还修改了滚动条显示的样式。</p>\n</blockquote>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><table>\n<thead>\n<tr>\n<th>文件/文件夹</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_config.yml</code></td>\n<td>博客的主配置文件</td>\n</tr>\n<tr>\n<td><code>.deploy_git/</code></td>\n<td>用于push到Github、heroku等的git仓库，里面有与<code>public/</code>相同的内容及<code>.git</code>的记录</td>\n</tr>\n<tr>\n<td><code>public/</code></td>\n<td>生成的完整的静态html网站，执行 <code>hexo clean</code> 会清除此文件夹</td>\n</tr>\n<tr>\n<td><code>scaffolds/</code></td>\n<td>里面有三个<code>.md</code>文件，其中<code>post.md</code>是博客文章的默认模板</td>\n</tr>\n<tr>\n<td><code>node_modules/</code></td>\n<td>每个blog的文件夹中安装的hexo插件</td>\n</tr>\n<tr>\n<td><code>source/</code></td>\n<td>撰写的博客文章要放在<code>source/_post</code>下，<code>source/</code>文件夹下的.md文件都会被生成为.html文件，其它类型的文件和文件夹则保持原样复制到 <code>public/</code>。可以在这里新建一个 <code>img/</code> 文件夹用于保存图片，文章中可以用<code>![图片说明](/img/image.png)</code>这样的代码来插入图片。</td>\n</tr>\n<tr>\n<td><code>themes/</code></td>\n<td>存放主题相关文件，各主题也有自己的<code>_config.yml。</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修改scaffold-post-md模板\"><a href=\"#修改scaffold-post-md模板\" class=\"headerlink\" title=\"修改scaffold/post.md模板\"></a>修改<code>scaffold/post.md</code>模板</h2><p>增加catagory，tags，及摘要和正文的分割线<code>&lt;!--more--&gt;</code>。</p>\n<blockquote>\n<p>注意，Markdown对空格和空行敏感。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: &#123;&#123; title &#125;&#125;</div><div class=\"line\">date: &#123;&#123; date &#125;&#125;</div><div class=\"line\">category: misc</div><div class=\"line\">tags: [tag1, tag2]</div><div class=\"line\">---</div><div class=\"line\">摘要部分</div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\">---</div><div class=\"line\">正文部分</div></pre></td></tr></table></figure>\n<h2 id=\"修改-hexo-server默认的4000端口号为80\"><a href=\"#修改-hexo-server默认的4000端口号为80\" class=\"headerlink\" title=\"修改 hexo-server默认的4000端口号为80\"></a>修改 hexo-server默认的4000端口号为80</h2><p>如果本机没有跑web服务器占用80端口的话，可以让hexo-server使用80端口而不是默认的4000端口，这样在浏览器直接输入机器名就可以预览blog了。<br>需修改<code>node_modules/hexo-server/index.js</code> 第8行 <code>port</code>。<br>比如我的机器名是z，在chrome地址栏直接输入 <code>z/</code> 即可，ie则需要输入 <a href=\"http://z/\" target=\"_blank\" rel=\"external\">http://z/</a></p>\n<h1 id=\"hexo-基本操作\"><a href=\"#hexo-基本操作\" class=\"headerlink\" title=\"hexo 基本操作\"></a>hexo 基本操作</h1><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo s     # server   本地预览，http://localhost:4000 。</div><div class=\"line\">hexo d     # deploy   部署整个网站到heroku</div><div class=\"line\">hexo g     # generate 生成静态html</div><div class=\"line\"></div><div class=\"line\">hexo s -g  # 本地预览，编辑了博客文章后，不必重新运行该命令，刷新页面即可，直到按 `Ctrl + C`会退出。</div><div class=\"line\">hexo d -g  # 依次执行生成和部署</div><div class=\"line\"></div><div class=\"line\">hexo clean # 删除 public/ 文件夹下所有内容</div></pre></td></tr></table></figure>\n<h2 id=\"撰写文章\"><a href=\"#撰写文章\" class=\"headerlink\" title=\"撰写文章\"></a>撰写文章</h2><p>执行下面的命令，在<code>source/_posts/</code>下生成名为 <code>New-Post.md</code> 的文件。<br>也可以通过常规的文件操作在<code>source/_posts/</code>下新建一个 <code>New-Post.md</code> 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo n &quot;New Post&quot;</div></pre></td></tr></table></figure>\n<p>更多详情可参考<a href=\"http://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">使用hexo写作</a>的文档。</p>\n<h2 id=\"发布静态html的博客网站到-Github\"><a href=\"#发布静态html的博客网站到-Github\" class=\"headerlink\" title=\"发布静态html的博客网站到 Github\"></a>发布静态html的博客网站到 Github</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">hexo d -g</div></pre></td></tr></table></figure>\n<h2 id=\"为整个blog建立repo\"><a href=\"#为整个blog建立repo\" class=\"headerlink\" title=\"为整个blog建立repo\"></a>为整个blog建立repo</h2><p>Hexo可以将生成的静态html博客网站发布到git仓库，但不会同步<code>source/</code>下源文件，<code>_config.yml</code>设置等。<br>如果需要在别的机器上写blog，还要重新设置，并拷贝这些文件。<br>为此，为已经设置好的博客建立一个新的git repo。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd blog/</div><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>编辑<code>.gitignore</code>如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">node_modules/</div><div class=\"line\">themes/</div><div class=\"line\">public/</div><div class=\"line\">.deploy_git/</div><div class=\"line\">.npmignore</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：把<code>node_modules/</code>和<code>themes/</code>排除，但把这两个文件夹分别压缩后，这里使用7zip压缩，生成<code>node_modules.7z</code> 和 <code>themes.7z</code> 会包括在git repo中。</p>\n</blockquote>\n<p>在Github创建一个名为<code>blog</code>的项目，<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;Init&quot;</div><div class=\"line\">git remote add github git@github.com:ying-zhang/blog.git</div><div class=\"line\">git push -u github master</div></pre></td></tr></table></figure></p>\n<h2 id=\"克隆已有的blog项目\"><a href=\"#克隆已有的blog项目\" class=\"headerlink\" title=\"克隆已有的blog项目\"></a>克隆已有的blog项目</h2><p>当然需要已经安装好git，nodejs和hexo。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:ying-zhang/blog.git</div><div class=\"line\">cd blog</div><div class=\"line\"></div><div class=\"line\">git remote rename origin github</div><div class=\"line\"></div><div class=\"line\">7z x node_modules.7z    # 不要忘了这一步</div><div class=\"line\">7z x themes.7z</div></pre></td></tr></table></figure></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p>Windows下编辑文本需要注意编码，应使用utf8无bom格式的编码，建议使用VS Code编辑器。</p>\n<h2 id=\"编辑数学公式\"><a href=\"#编辑数学公式\" class=\"headerlink\" title=\"编辑数学公式\"></a>编辑数学公式</h2><p>注意，需要<code>hexo-math</code>插件，但这个插件的作者已经停止维护了，不知有什么替代的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% math %&#125;</div><div class=\"line\">\\begin&#123;align*&#125;</div><div class=\"line\">-\\sum_i&#123;P_i\\log_2\\frac&#123;P_i&#125;&#123;Q_i&#125;&#125; =&amp; \\sum_i&#123;P_i\\log_2\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\\\</div><div class=\"line\">\\le&amp; \\log_2\\sum_i&#123;P_i\\frac&#123;Q_i&#125;&#123;P_i&#125;&#125; \\tag&#123;Jensen 不等式&#125; \\\\</div><div class=\"line\">=&amp; \\log_2\\sum_i&#123;Q_i&#125; \\\\</div><div class=\"line\">=&amp; 0</div><div class=\"line\">\\end&#123;align*&#125;</div><div class=\"line\">&#123;% endmath %&#125;</div></pre></td></tr></table></figure></p>\n<span>$$\\begin{align*}\n-\\sum_i{P_i\\log_2\\frac{P_i}{Q_i}} =&amp; \\sum_i{P_i\\log_2\\frac{Q_i}{P_i}} \\\\\n\\le&amp; \\log_2\\sum_i{P_i\\frac{Q_i}{P_i}} \\tag{Jensen 不等式} \\\\\n=&amp; \\log_2\\sum_i{Q_i} \\\\\n=&amp; 0\n\\end{align*}$$</span><!-- Has MathJax -->\n<h2 id=\"设置代码块不显示行号\"><a href=\"#设置代码块不显示行号\" class=\"headerlink\" title=\"设置代码块不显示行号\"></a>设置代码块不显示行号</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;% codeblock line_number:false%&#125;</div><div class=\"line\">echo &quot;Hello Hexo!&quot;</div><div class=\"line\">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p>飞鸟集 第128</p>\n<blockquote>\n<p>如果你不等待着要说出完全的真理，那末把话说出来是很容易的。</p>\n</blockquote>\n<p>所以，就随便写吧。</p>"},{"title":"使用Cobbler搭建PXE服务器","date":"2017-03-21T16:00:00.000Z","_content":"[PXE](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83) （Preboot eXecution Environment，预执行环境）是通过 **局域网** 来启动计算机（和安装操作系统）的技术。\n一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 **DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）**，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。\nCobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [测试环境](#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83)\n- [Cobbler设置步骤](#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4)\n    - [禁用SELinux](#%E7%A6%81%E7%94%A8selinux)\n    - [禁用防火墙](#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99)\n    - [安装软件](#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6)\n    - [设置为开机启动的服务](#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1)\n    - [生成加密的root密码](#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81)\n- [修改cobbler的配置](#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改xinetd tftp的配置](#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改dhcp配置](#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE)\n    - [使用 dnsmasq 提供 dhcp 服务](#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1)\n    - [启动相关服务](#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1)\n    - [执行 `cobbler check`](#%E6%89%A7%E8%A1%8C-cobbler-check)\n    - [导入CentOS系统的iso安装镜像](#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F)\n    - [修改Kickstarts文件](#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6)\n    - [更新设置，最后的检查](#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5)\n- [在其它机器使用PXE安装系统](#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [在docker容器中运行cobbler](#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler)\n    - [docker容器使用systemd](#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd)\n    - [使用容器的几个坑](#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91)\n- [真机上部署遇到的问题](#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [选择合适的网卡](#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1)\n    - [Dell iDRAC](#dell-idrac)\n- [参考](#%E5%8F%82%E8%80%83)\n\n<!-- /TOC -->\n\n# 测试环境\n虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。\n\n新建一个虚拟机，安装CentOS 7，使用的镜像是 **[CentOS-7-x86_64-Minimal-1611.iso](http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso)** 。因为是Minimal的，不必选择附加的软件包。\n安装后登录系统，查看IP地址`ip a`，可以通过ssh登录到VM。\n关闭VM，拍摄一个快照。\n+ IP ： 10.1.1.10\n+ 子网掩码：255.255.255.0\n+ 用户：root\n\n# Cobbler设置步骤\n\n> 因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。\n\n## 禁用SELinux\n```\nsed -i 's/SELINUX\\=enforcing/SELINUX\\=disabled/g' /etc/selinux/config\nsetenforce 0\n```\n\n## 禁用防火墙\n```\nsystemctl disable firewalld\nsystemctl stop firewalld\n```\n\n## 安装软件\n```\nyum -y install epel-release\nyum -y install cobbler dhcp httpd xinetd pykickstart fence-agents\n```\n\n## 设置为开机启动的服务\n```\nsystemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n> PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。\ncobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。\n\n## 生成加密的root密码\n```\nopenssl passwd -1 -salt \"centos\" \"centos\"\n# 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了\n$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\n```\n\n# 修改cobbler的配置\n```\nvi /etc/cobbler/settings\n# 改动 的内容如下\ndefault_password_crypted: \"$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\"\nmanage_dhcp: 1\nnext_server: 10.1.1.10\nserver: 10.1.1.10\n```\n> [修改后的完整 settings 文件 (删除了注释)](/doc/cobbler-setting.txt)\n\n## 修改xinetd tftp的配置\n```\nvi /etc/xinetd.d/tftp\n# 将 disable = yes 改为  disable = no\n```\n\n## 修改dhcp配置\n```\nvi /etc/cobbler/dhcp.template\n# 改动的内容包括 子网段，分配的IP区间，\n# 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）\n# $next-server 是指向 /etc/cobbler/settings 中的对应值\n#\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n     option routers             10.1.1.2;\n     option domain-name-servers 10.1.1.2;\n     option subnet-mask         255.255.255.0;\n     range dynamic-bootp        10.1.1.100 10.1.1.110;\n     default-lease-time         21700;\n     max-lease-time             43100;\n     next-server                $next_server;\n\n     class \"pxeclients\" {\n          match if substring (option vendor-class-identifier, 0, 9) = \"PXEClient\";\n          if option pxe-system-type = 00:02 {\n              filename \"ia64/elilo.efi\";\n          } else if option pxe-system-type = 00:06 {\n              filename \"grub/grub-x86.efi\";\n          } else if option pxe-system-type = 00:07 {\n              filename \"grub/grub-x86_64.efi\";\n          } else {\n              filename \"pxelinux.0\";\n          }\n     }\n}\n```\n\n> 如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。\n遇到这种情况，可以将 `/etc/cobbler/settings` 中的 `manage_dhcp: 1` 改为 `0`， 然后手动管理 dhcp：修改 `/etc/dhcp/dhcpd.conf`，格式如下。\n\n```\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n        option routers 10.1.1.2;\n        option domain-name-servers 10.1.1.2;\n        option subnet-mask 255.255.255.0;\n        default-lease-time 21600;\n        max-lease-time 43200;\n        range 10.1.1.100 10.1.1.110;\n        next-server 10.1.1.10;\n        filename \"pxelinux.0\";\n}\n```\n注意要把 `$next_server` 设置为 **具体的 IP地址**，这个配置项是 PXE 的关键。\n<!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。-->\n如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。\n如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。\n`/etc/cobbler/settings` 中 `next_server` 和 `server` 指定的IP地址要和DHCP的网段在 **同一个局域网段** 才能正常工作。\n\n## 使用 dnsmasq 提供 dhcp 服务\n\n参考[Managing DHCP - cobbler manual](http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html)，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： `yum install -y dnsmasq`。\n如果让cobbler来配置dnsmasq，需要设置`/etc/cobbler/settings` 中为 `manage_dhcp: 1`，\n然后修改 `/etc/cobbler/modules.conf`，将\n```\n[dhcp]\nmodule = manage_isc   # isc 即 dhcpd\n# 改为\n[dhcp]\nmodule = manage_dnsmasq\n```\n\n然后修改 `/etc/cobbler/dnsmasq.template`，dnsmasq的配置比较简单，只要修改IP区间即可\n```\ndhcp-range=10.1.1.100,10.1.1.110\n```\n\n> 注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。\n如果只是临时提供 dhcp 服务，可设置比较小的区间，**特别要避免与已有的重要服务器发生 IP地址 冲突**！\n\n## 启动相关服务\n> 注意： 重启服务器后，需要确认下面的几项服务是否正常启动。\n\n```\nsystemctl start cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n## 执行 `cobbler check`\n```\n# 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。\nThe following are potential configuration items that you may want to fix:\n1 : debmirror package is not installed, it will be required to manage debian deployments and repositories\nRestart cobblerd and then run 'cobbler sync' to apply changes.\n```\n\n+ 如果提示需下载额外的boot loader，可执行 `cobbler get-loaders` ，这 **不是必须的**，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，`/etc/cobbler/settings` 中可以在 `proxy_url_ext` 设置代理地址。\n+ 如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行`systemctl status httpd` 查看，还可以通过访问 http://10.1.1.10 （next_server的IP地址）来确认.可能是 `/etc/cobbler/settings` 中 `next_server` 或 `server` 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。\n\n再次执行 `cobbler check`，并检查相关的服务是否正常启动，然后继续执行下面的步骤。\n\n## 导入CentOS系统的iso安装镜像\n\n虚拟机中已经为Guest OS加载了iso文件到`/dev/cdrom`，需要再挂载到`/mnt`：`mount -t auto -o loop,ro /dev/cdrom /mnt`；\n也可以直接挂载iso文件：`mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt`。\n\n导入安装镜像：`cobbler import --name=centos --arch=x86_64 --path=/mnt`。\n等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 `/var/www/cobbler/ks_mirror/`\n\n查看导入的项目：`cobbler profile list`\n输出为 centos-x86_64，进一步查看，`cobbler profile report --name=centos-x86_64`。\n\n## 修改Kickstarts文件\n从上面的命令输出可知使用的Kickstart文件在 `/var/lib/cobbler/kickstarts/sample_end.ks`\n修改下面2项\n+ `firewall --enable`            改为 `firewall --disable`\n+ `timezone  America/New_York`   改为 `timezone  Asia/Shanghai`\n\n## 更新设置，最后的检查\n```\ncobbler sync\nsystemctl restart cobblerd\ncobbler check\n```\n\n# 在其它机器使用PXE安装系统\n新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -> 电源 -> 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 `F10` 键保存并重启虚拟机。\n![](/img/pxe-boot-config.png)\n\n稍等一下，DHCP配置完成后会显示启动项如下：\n![](/img/pxe-boot-menu.png)\n选择第二项 centos-x86_64，回车，就会开始自动安装。\n\n稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。\n从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。\n\n> 从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；\n此外还可以在[settings](/doc/cobbler-setting.txt)中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，\n在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。\n水平有限，就不深入这些功能了;-(\n\n-----\n# 在docker容器中运行cobbler\n\n## docker容器使用systemd\n通过 `docker pull centos:7` 直接pull下来的镜像 **不能使用** `systemd`， 因为这与 docker 的 **单容器单进程** 哲学不相容~~\n我们需要自己build一个支持systemd的镜像，参考 [Docker Hub 的 CentOS镜像](https://hub.docker.com/_/centos/) 或[Docker Store 的  CentOS](https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f)的页面中 **Systemd integration** 一节提供的 Dockerfile 即可。\n\n再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（**增加 which 和 curl**），启用相关服务项，其它设置进入容器的shell手工修改。\n\n假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用\n+ host 网络，`--network host`\n+ 特权模式，`--privileged`\n+ 挂载cgroup的fs，以使用systemd，`-v /sys/fs/cgroup:/sys/fs/cgroup:ro`\n+ 挂载`/mnt`，这是已经挂载到主机的CentOS安装文件iso镜像，`-v /mnt:/mnt:ro`\n\n```\ndocker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ \n--name cobbler cobbler:latest /usr/sbin/init\n```\n\n因为容器的`Entrypoint`是`/usr/sbin/init`，而且是`-d`，即detached，启动后不会进入shell。\n可以通过`docker exec`执行容器的shell，需要增加 `-ti`选项为shell分配一个终端，\n```\ndocker exec -ti cobbler bash\n```\n\n退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行`exit`。\n\n按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。\n\n## 使用容器的几个坑\n> Docker官方的CentOS镜像太精简了，\n+ 没有 `curl` 及 `wget`，还少了 `which`， 也需要装上；\n+ `/etc/httpd/logs`是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个`/etc/httpd/logs/`目录即可；\n+ 没有 `/var/log/cobbler/tasks` 目录，导致cobbler sync 失败，手动创建该目录。 \n\n\n# 真机上部署遇到的问题\n## 选择合适的网卡\n服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是`em1`，但有的机器需要修改BIOS选择`em2`网卡才行。\n\n## Dell iDRAC\n服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。\n在使用PXE之前，先要装好一台机器。\n装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。\niDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行`javacpl.exe`）中添加 `安全例外项`。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。\n> iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。\n\n通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-( \n安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。\n\n旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。\n\n\n# 参考\n+ [Cobbler Quick Start](http://cobbler.github.io/manuals/quickstart/)\n+ [Centos7.2安装Cobbler 并安装系统](http://readshlinux.blog.51cto.com/9322509/1812402)\n+ [How to Install and Configure Cobbler on CentOS 7.x](http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/)\n","source":"_posts/cobbler-pxe.md","raw":"title: 使用Cobbler搭建PXE服务器\ncategory: misc\ndate: 2017-3-22\ntags:\n\n---\n[PXE](https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83) （Preboot eXecution Environment，预执行环境）是通过 **局域网** 来启动计算机（和安装操作系统）的技术。\n一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 **DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）**，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。\nCobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [测试环境](#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83)\n- [Cobbler设置步骤](#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4)\n    - [禁用SELinux](#%E7%A6%81%E7%94%A8selinux)\n    - [禁用防火墙](#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99)\n    - [安装软件](#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6)\n    - [设置为开机启动的服务](#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1)\n    - [生成加密的root密码](#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81)\n- [修改cobbler的配置](#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改xinetd tftp的配置](#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE)\n    - [修改dhcp配置](#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE)\n    - [使用 dnsmasq 提供 dhcp 服务](#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1)\n    - [启动相关服务](#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1)\n    - [执行 `cobbler check`](#%E6%89%A7%E8%A1%8C-cobbler-check)\n    - [导入CentOS系统的iso安装镜像](#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F)\n    - [修改Kickstarts文件](#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6)\n    - [更新设置，最后的检查](#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5)\n- [在其它机器使用PXE安装系统](#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [在docker容器中运行cobbler](#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler)\n    - [docker容器使用systemd](#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd)\n    - [使用容器的几个坑](#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91)\n- [真机上部署遇到的问题](#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [选择合适的网卡](#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1)\n    - [Dell iDRAC](#dell-idrac)\n- [参考](#%E5%8F%82%E8%80%83)\n\n<!-- /TOC -->\n\n# 测试环境\n虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。\n\n新建一个虚拟机，安装CentOS 7，使用的镜像是 **[CentOS-7-x86_64-Minimal-1611.iso](http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso)** 。因为是Minimal的，不必选择附加的软件包。\n安装后登录系统，查看IP地址`ip a`，可以通过ssh登录到VM。\n关闭VM，拍摄一个快照。\n+ IP ： 10.1.1.10\n+ 子网掩码：255.255.255.0\n+ 用户：root\n\n# Cobbler设置步骤\n\n> 因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。\n\n## 禁用SELinux\n```\nsed -i 's/SELINUX\\=enforcing/SELINUX\\=disabled/g' /etc/selinux/config\nsetenforce 0\n```\n\n## 禁用防火墙\n```\nsystemctl disable firewalld\nsystemctl stop firewalld\n```\n\n## 安装软件\n```\nyum -y install epel-release\nyum -y install cobbler dhcp httpd xinetd pykickstart fence-agents\n```\n\n## 设置为开机启动的服务\n```\nsystemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n> PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。\ncobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。\n\n## 生成加密的root密码\n```\nopenssl passwd -1 -salt \"centos\" \"centos\"\n# 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了\n$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\n```\n\n# 修改cobbler的配置\n```\nvi /etc/cobbler/settings\n# 改动 的内容如下\ndefault_password_crypted: \"$1$centos$Uq6E6Wp5SDZYbs6MCmamP0\"\nmanage_dhcp: 1\nnext_server: 10.1.1.10\nserver: 10.1.1.10\n```\n> [修改后的完整 settings 文件 (删除了注释)](/doc/cobbler-setting.txt)\n\n## 修改xinetd tftp的配置\n```\nvi /etc/xinetd.d/tftp\n# 将 disable = yes 改为  disable = no\n```\n\n## 修改dhcp配置\n```\nvi /etc/cobbler/dhcp.template\n# 改动的内容包括 子网段，分配的IP区间，\n# 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）\n# $next-server 是指向 /etc/cobbler/settings 中的对应值\n#\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n     option routers             10.1.1.2;\n     option domain-name-servers 10.1.1.2;\n     option subnet-mask         255.255.255.0;\n     range dynamic-bootp        10.1.1.100 10.1.1.110;\n     default-lease-time         21700;\n     max-lease-time             43100;\n     next-server                $next_server;\n\n     class \"pxeclients\" {\n          match if substring (option vendor-class-identifier, 0, 9) = \"PXEClient\";\n          if option pxe-system-type = 00:02 {\n              filename \"ia64/elilo.efi\";\n          } else if option pxe-system-type = 00:06 {\n              filename \"grub/grub-x86.efi\";\n          } else if option pxe-system-type = 00:07 {\n              filename \"grub/grub-x86_64.efi\";\n          } else {\n              filename \"pxelinux.0\";\n          }\n     }\n}\n```\n\n> 如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。\n遇到这种情况，可以将 `/etc/cobbler/settings` 中的 `manage_dhcp: 1` 改为 `0`， 然后手动管理 dhcp：修改 `/etc/dhcp/dhcpd.conf`，格式如下。\n\n```\nsubnet 10.1.1.0 netmask 255.255.255.0 {\n        option routers 10.1.1.2;\n        option domain-name-servers 10.1.1.2;\n        option subnet-mask 255.255.255.0;\n        default-lease-time 21600;\n        max-lease-time 43200;\n        range 10.1.1.100 10.1.1.110;\n        next-server 10.1.1.10;\n        filename \"pxelinux.0\";\n}\n```\n注意要把 `$next_server` 设置为 **具体的 IP地址**，这个配置项是 PXE 的关键。\n<!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。-->\n如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。\n如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。\n`/etc/cobbler/settings` 中 `next_server` 和 `server` 指定的IP地址要和DHCP的网段在 **同一个局域网段** 才能正常工作。\n\n## 使用 dnsmasq 提供 dhcp 服务\n\n参考[Managing DHCP - cobbler manual](http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html)，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： `yum install -y dnsmasq`。\n如果让cobbler来配置dnsmasq，需要设置`/etc/cobbler/settings` 中为 `manage_dhcp: 1`，\n然后修改 `/etc/cobbler/modules.conf`，将\n```\n[dhcp]\nmodule = manage_isc   # isc 即 dhcpd\n# 改为\n[dhcp]\nmodule = manage_dnsmasq\n```\n\n然后修改 `/etc/cobbler/dnsmasq.template`，dnsmasq的配置比较简单，只要修改IP区间即可\n```\ndhcp-range=10.1.1.100,10.1.1.110\n```\n\n> 注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。\n如果只是临时提供 dhcp 服务，可设置比较小的区间，**特别要避免与已有的重要服务器发生 IP地址 冲突**！\n\n## 启动相关服务\n> 注意： 重启服务器后，需要确认下面的几项服务是否正常启动。\n\n```\nsystemctl start cobblerd dhcpd httpd rsyncd tftp xinetd\n```\n\n## 执行 `cobbler check`\n```\n# 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。\nThe following are potential configuration items that you may want to fix:\n1 : debmirror package is not installed, it will be required to manage debian deployments and repositories\nRestart cobblerd and then run 'cobbler sync' to apply changes.\n```\n\n+ 如果提示需下载额外的boot loader，可执行 `cobbler get-loaders` ，这 **不是必须的**，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，`/etc/cobbler/settings` 中可以在 `proxy_url_ext` 设置代理地址。\n+ 如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行`systemctl status httpd` 查看，还可以通过访问 http://10.1.1.10 （next_server的IP地址）来确认.可能是 `/etc/cobbler/settings` 中 `next_server` 或 `server` 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。\n\n再次执行 `cobbler check`，并检查相关的服务是否正常启动，然后继续执行下面的步骤。\n\n## 导入CentOS系统的iso安装镜像\n\n虚拟机中已经为Guest OS加载了iso文件到`/dev/cdrom`，需要再挂载到`/mnt`：`mount -t auto -o loop,ro /dev/cdrom /mnt`；\n也可以直接挂载iso文件：`mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt`。\n\n导入安装镜像：`cobbler import --name=centos --arch=x86_64 --path=/mnt`。\n等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 `/var/www/cobbler/ks_mirror/`\n\n查看导入的项目：`cobbler profile list`\n输出为 centos-x86_64，进一步查看，`cobbler profile report --name=centos-x86_64`。\n\n## 修改Kickstarts文件\n从上面的命令输出可知使用的Kickstart文件在 `/var/lib/cobbler/kickstarts/sample_end.ks`\n修改下面2项\n+ `firewall --enable`            改为 `firewall --disable`\n+ `timezone  America/New_York`   改为 `timezone  Asia/Shanghai`\n\n## 更新设置，最后的检查\n```\ncobbler sync\nsystemctl restart cobblerd\ncobbler check\n```\n\n# 在其它机器使用PXE安装系统\n新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -> 电源 -> 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 `F10` 键保存并重启虚拟机。\n![](/img/pxe-boot-config.png)\n\n稍等一下，DHCP配置完成后会显示启动项如下：\n![](/img/pxe-boot-menu.png)\n选择第二项 centos-x86_64，回车，就会开始自动安装。\n\n稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。\n从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。\n\n> 从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；\n此外还可以在[settings](/doc/cobbler-setting.txt)中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，\n在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。\n水平有限，就不深入这些功能了;-(\n\n-----\n# 在docker容器中运行cobbler\n\n## docker容器使用systemd\n通过 `docker pull centos:7` 直接pull下来的镜像 **不能使用** `systemd`， 因为这与 docker 的 **单容器单进程** 哲学不相容~~\n我们需要自己build一个支持systemd的镜像，参考 [Docker Hub 的 CentOS镜像](https://hub.docker.com/_/centos/) 或[Docker Store 的  CentOS](https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f)的页面中 **Systemd integration** 一节提供的 Dockerfile 即可。\n\n再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（**增加 which 和 curl**），启用相关服务项，其它设置进入容器的shell手工修改。\n\n假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用\n+ host 网络，`--network host`\n+ 特权模式，`--privileged`\n+ 挂载cgroup的fs，以使用systemd，`-v /sys/fs/cgroup:/sys/fs/cgroup:ro`\n+ 挂载`/mnt`，这是已经挂载到主机的CentOS安装文件iso镜像，`-v /mnt:/mnt:ro`\n\n```\ndocker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ \n--name cobbler cobbler:latest /usr/sbin/init\n```\n\n因为容器的`Entrypoint`是`/usr/sbin/init`，而且是`-d`，即detached，启动后不会进入shell。\n可以通过`docker exec`执行容器的shell，需要增加 `-ti`选项为shell分配一个终端，\n```\ndocker exec -ti cobbler bash\n```\n\n退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行`exit`。\n\n按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。\n\n## 使用容器的几个坑\n> Docker官方的CentOS镜像太精简了，\n+ 没有 `curl` 及 `wget`，还少了 `which`， 也需要装上；\n+ `/etc/httpd/logs`是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个`/etc/httpd/logs/`目录即可；\n+ 没有 `/var/log/cobbler/tasks` 目录，导致cobbler sync 失败，手动创建该目录。 \n\n\n# 真机上部署遇到的问题\n## 选择合适的网卡\n服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是`em1`，但有的机器需要修改BIOS选择`em2`网卡才行。\n\n## Dell iDRAC\n服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。\n在使用PXE之前，先要装好一台机器。\n装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。\niDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行`javacpl.exe`）中添加 `安全例外项`。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。\n> iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。\n\n通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-( \n安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。\n\n旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。\n\n\n# 参考\n+ [Cobbler Quick Start](http://cobbler.github.io/manuals/quickstart/)\n+ [Centos7.2安装Cobbler 并安装系统](http://readshlinux.blog.51cto.com/9322509/1812402)\n+ [How to Install and Configure Cobbler on CentOS 7.x](http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/)\n","slug":"cobbler-pxe","published":1,"updated":"2017-10-30T02:48:03.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgl00039s4ffs8admn7","content":"<p><a href=\"https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\" target=\"_blank\" rel=\"external\">PXE</a> （Preboot eXecution Environment，预执行环境）是通过 <strong>局域网</strong> 来启动计算机（和安装操作系统）的技术。<br>一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 <strong>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</strong>，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。<br>Cobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">测试环境</a></li>\n<li><a href=\"#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4\">Cobbler设置步骤</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8selinux\">禁用SELinux</a></li>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99\">禁用防火墙</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6\">安装软件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1\">设置为开机启动的服务</a></li>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81\">生成加密的root密码</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE\">修改cobbler的配置</a><ul>\n<li><a href=\"#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE\">修改xinetd tftp的配置</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE\">修改dhcp配置</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1\">使用 dnsmasq 提供 dhcp 服务</a></li>\n<li><a href=\"#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1\">启动相关服务</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C-cobbler-check\">执行 <code>cobbler check</code></a></li>\n<li><a href=\"#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F\">导入CentOS系统的iso安装镜像</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6\">修改Kickstarts文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5\">更新设置，最后的检查</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">在其它机器使用PXE安装系统</a></li>\n<li><a href=\"#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler\">在docker容器中运行cobbler</a><ul>\n<li><a href=\"#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd\">docker容器使用systemd</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91\">使用容器的几个坑</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">真机上部署遇到的问题</a><ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1\">选择合适的网卡</a></li>\n<li><a href=\"#dell-idrac\">Dell iDRAC</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。</p>\n<p>新建一个虚拟机，安装CentOS 7，使用的镜像是 <strong><a href=\"http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-Minimal-1611.iso</a></strong> 。因为是Minimal的，不必选择附加的软件包。<br>安装后登录系统，查看IP地址<code>ip a</code>，可以通过ssh登录到VM。<br>关闭VM，拍摄一个快照。</p>\n<ul>\n<li>IP ： 10.1.1.10</li>\n<li>子网掩码：255.255.255.0</li>\n<li>用户：root</li>\n</ul>\n<h1 id=\"Cobbler设置步骤\"><a href=\"#Cobbler设置步骤\" class=\"headerlink\" title=\"Cobbler设置步骤\"></a>Cobbler设置步骤</h1><blockquote>\n<p>因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。</p>\n</blockquote>\n<h2 id=\"禁用SELinux\"><a href=\"#禁用SELinux\" class=\"headerlink\" title=\"禁用SELinux\"></a>禁用SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &apos;s/SELINUX\\=enforcing/SELINUX\\=disabled/g&apos; /etc/selinux/config</div><div class=\"line\">setenforce 0</div></pre></td></tr></table></figure>\n<h2 id=\"禁用防火墙\"><a href=\"#禁用防火墙\" class=\"headerlink\" title=\"禁用防火墙\"></a>禁用防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div></pre></td></tr></table></figure>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install epel-release</div><div class=\"line\">yum -y install cobbler dhcp httpd xinetd pykickstart fence-agents</div></pre></td></tr></table></figure>\n<h2 id=\"设置为开机启动的服务\"><a href=\"#设置为开机启动的服务\" class=\"headerlink\" title=\"设置为开机启动的服务\"></a>设置为开机启动的服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<blockquote>\n<p>PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。<br>cobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。</p>\n</blockquote>\n<h2 id=\"生成加密的root密码\"><a href=\"#生成加密的root密码\" class=\"headerlink\" title=\"生成加密的root密码\"></a>生成加密的root密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">openssl passwd -1 -salt &quot;centos&quot; &quot;centos&quot;</div><div class=\"line\"># 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了</div><div class=\"line\">$1$centos$Uq6E6Wp5SDZYbs6MCmamP0</div></pre></td></tr></table></figure>\n<h1 id=\"修改cobbler的配置\"><a href=\"#修改cobbler的配置\" class=\"headerlink\" title=\"修改cobbler的配置\"></a>修改cobbler的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/settings</div><div class=\"line\"># 改动 的内容如下</div><div class=\"line\">default_password_crypted: &quot;$1$centos$Uq6E6Wp5SDZYbs6MCmamP0&quot;</div><div class=\"line\">manage_dhcp: 1</div><div class=\"line\">next_server: 10.1.1.10</div><div class=\"line\">server: 10.1.1.10</div></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"/doc/cobbler-setting.txt\">修改后的完整 settings 文件 (删除了注释)</a></p>\n</blockquote>\n<h2 id=\"修改xinetd-tftp的配置\"><a href=\"#修改xinetd-tftp的配置\" class=\"headerlink\" title=\"修改xinetd tftp的配置\"></a>修改xinetd tftp的配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/xinetd.d/tftp</div><div class=\"line\"># 将 disable = yes 改为  disable = no</div></pre></td></tr></table></figure>\n<h2 id=\"修改dhcp配置\"><a href=\"#修改dhcp配置\" class=\"headerlink\" title=\"修改dhcp配置\"></a>修改dhcp配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/dhcp.template</div><div class=\"line\"># 改动的内容包括 子网段，分配的IP区间，</div><div class=\"line\"># 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）</div><div class=\"line\"># $next-server 是指向 /etc/cobbler/settings 中的对应值</div><div class=\"line\">#</div><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">     option routers             10.1.1.2;</div><div class=\"line\">     option domain-name-servers 10.1.1.2;</div><div class=\"line\">     option subnet-mask         255.255.255.0;</div><div class=\"line\">     range dynamic-bootp        10.1.1.100 10.1.1.110;</div><div class=\"line\">     default-lease-time         21700;</div><div class=\"line\">     max-lease-time             43100;</div><div class=\"line\">     next-server                $next_server;</div><div class=\"line\"></div><div class=\"line\">     class &quot;pxeclients&quot; &#123;</div><div class=\"line\">          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;</div><div class=\"line\">          if option pxe-system-type = 00:02 &#123;</div><div class=\"line\">              filename &quot;ia64/elilo.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:06 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:07 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86_64.efi&quot;;</div><div class=\"line\">          &#125; else &#123;</div><div class=\"line\">              filename &quot;pxelinux.0&quot;;</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。<br>遇到这种情况，可以将 <code>/etc/cobbler/settings</code> 中的 <code>manage_dhcp: 1</code> 改为 <code>0</code>， 然后手动管理 dhcp：修改 <code>/etc/dhcp/dhcpd.conf</code>，格式如下。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">        option routers 10.1.1.2;</div><div class=\"line\">        option domain-name-servers 10.1.1.2;</div><div class=\"line\">        option subnet-mask 255.255.255.0;</div><div class=\"line\">        default-lease-time 21600;</div><div class=\"line\">        max-lease-time 43200;</div><div class=\"line\">        range 10.1.1.100 10.1.1.110;</div><div class=\"line\">        next-server 10.1.1.10;</div><div class=\"line\">        filename &quot;pxelinux.0&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意要把 <code>$next_server</code> 设置为 <strong>具体的 IP地址</strong>，这个配置项是 PXE 的关键。<br><!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。--><br>如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。<br>如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。<br><code>/etc/cobbler/settings</code> 中 <code>next_server</code> 和 <code>server</code> 指定的IP地址要和DHCP的网段在 <strong>同一个局域网段</strong> 才能正常工作。</p>\n<h2 id=\"使用-dnsmasq-提供-dhcp-服务\"><a href=\"#使用-dnsmasq-提供-dhcp-服务\" class=\"headerlink\" title=\"使用 dnsmasq 提供 dhcp 服务\"></a>使用 dnsmasq 提供 dhcp 服务</h2><p>参考<a href=\"http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html\" target=\"_blank\" rel=\"external\">Managing DHCP - cobbler manual</a>，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： <code>yum install -y dnsmasq</code>。<br>如果让cobbler来配置dnsmasq，需要设置<code>/etc/cobbler/settings</code> 中为 <code>manage_dhcp: 1</code>，<br>然后修改 <code>/etc/cobbler/modules.conf</code>，将<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_isc   # isc 即 dhcpd</div><div class=\"line\"># 改为</div><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_dnsmasq</div></pre></td></tr></table></figure></p>\n<p>然后修改 <code>/etc/cobbler/dnsmasq.template</code>，dnsmasq的配置比较简单，只要修改IP区间即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dhcp-range=10.1.1.100,10.1.1.110</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。<br>如果只是临时提供 dhcp 服务，可设置比较小的区间，<strong>特别要避免与已有的重要服务器发生 IP地址 冲突</strong>！</p>\n</blockquote>\n<h2 id=\"启动相关服务\"><a href=\"#启动相关服务\" class=\"headerlink\" title=\"启动相关服务\"></a>启动相关服务</h2><blockquote>\n<p>注意： 重启服务器后，需要确认下面的几项服务是否正常启动。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl start cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<h2 id=\"执行-cobbler-check\"><a href=\"#执行-cobbler-check\" class=\"headerlink\" title=\"执行 cobbler check\"></a>执行 <code>cobbler check</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。</div><div class=\"line\">The following are potential configuration items that you may want to fix:</div><div class=\"line\">1 : debmirror package is not installed, it will be required to manage debian deployments and repositories</div><div class=\"line\">Restart cobblerd and then run &apos;cobbler sync&apos; to apply changes.</div></pre></td></tr></table></figure>\n<ul>\n<li>如果提示需下载额外的boot loader，可执行 <code>cobbler get-loaders</code> ，这 <strong>不是必须的</strong>，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，<code>/etc/cobbler/settings</code> 中可以在 <code>proxy_url_ext</code> 设置代理地址。</li>\n<li>如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行<code>systemctl status httpd</code> 查看，还可以通过访问 <a href=\"http://10.1.1.10\" target=\"_blank\" rel=\"external\">http://10.1.1.10</a> （next_server的IP地址）来确认.可能是 <code>/etc/cobbler/settings</code> 中 <code>next_server</code> 或 <code>server</code> 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。</li>\n</ul>\n<p>再次执行 <code>cobbler check</code>，并检查相关的服务是否正常启动，然后继续执行下面的步骤。</p>\n<h2 id=\"导入CentOS系统的iso安装镜像\"><a href=\"#导入CentOS系统的iso安装镜像\" class=\"headerlink\" title=\"导入CentOS系统的iso安装镜像\"></a>导入CentOS系统的iso安装镜像</h2><p>虚拟机中已经为Guest OS加载了iso文件到<code>/dev/cdrom</code>，需要再挂载到<code>/mnt</code>：<code>mount -t auto -o loop,ro /dev/cdrom /mnt</code>；<br>也可以直接挂载iso文件：<code>mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt</code>。</p>\n<p>导入安装镜像：<code>cobbler import --name=centos --arch=x86_64 --path=/mnt</code>。<br>等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 <code>/var/www/cobbler/ks_mirror/</code></p>\n<p>查看导入的项目：<code>cobbler profile list</code><br>输出为 centos-x86_64，进一步查看，<code>cobbler profile report --name=centos-x86_64</code>。</p>\n<h2 id=\"修改Kickstarts文件\"><a href=\"#修改Kickstarts文件\" class=\"headerlink\" title=\"修改Kickstarts文件\"></a>修改Kickstarts文件</h2><p>从上面的命令输出可知使用的Kickstart文件在 <code>/var/lib/cobbler/kickstarts/sample_end.ks</code><br>修改下面2项</p>\n<ul>\n<li><code>firewall --enable</code>            改为 <code>firewall --disable</code></li>\n<li><code>timezone  America/New_York</code>   改为 <code>timezone  Asia/Shanghai</code></li>\n</ul>\n<h2 id=\"更新设置，最后的检查\"><a href=\"#更新设置，最后的检查\" class=\"headerlink\" title=\"更新设置，最后的检查\"></a>更新设置，最后的检查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cobbler sync</div><div class=\"line\">systemctl restart cobblerd</div><div class=\"line\">cobbler check</div></pre></td></tr></table></figure>\n<h1 id=\"在其它机器使用PXE安装系统\"><a href=\"#在其它机器使用PXE安装系统\" class=\"headerlink\" title=\"在其它机器使用PXE安装系统\"></a>在其它机器使用PXE安装系统</h1><p>新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -&gt; 电源 -&gt; 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 <code>F10</code> 键保存并重启虚拟机。<br><img src=\"/img/pxe-boot-config.png\" alt=\"\"></p>\n<p>稍等一下，DHCP配置完成后会显示启动项如下：<br><img src=\"/img/pxe-boot-menu.png\" alt=\"\"><br>选择第二项 centos-x86_64，回车，就会开始自动安装。</p>\n<p>稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。<br>从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。</p>\n<blockquote>\n<p>从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；<br>此外还可以在<a href=\"/doc/cobbler-setting.txt\">settings</a>中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，<br>在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。<br>水平有限，就不深入这些功能了;-(</p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中运行cobbler\"><a href=\"#在docker容器中运行cobbler\" class=\"headerlink\" title=\"在docker容器中运行cobbler\"></a>在docker容器中运行cobbler</h1><h2 id=\"docker容器使用systemd\"><a href=\"#docker容器使用systemd\" class=\"headerlink\" title=\"docker容器使用systemd\"></a>docker容器使用systemd</h2><p>通过 <code>docker pull centos:7</code> 直接pull下来的镜像 <strong>不能使用</strong> <code>systemd</code>， 因为这与 docker 的 <strong>单容器单进程</strong> 哲学不相容~~<br>我们需要自己build一个支持systemd的镜像，参考 <a href=\"https://hub.docker.com/_/centos/\" target=\"_blank\" rel=\"external\">Docker Hub 的 CentOS镜像</a> 或<a href=\"https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f\" target=\"_blank\" rel=\"external\">Docker Store 的  CentOS</a>的页面中 <strong>Systemd integration</strong> 一节提供的 Dockerfile 即可。</p>\n<p>再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（<strong>增加 which 和 curl</strong>），启用相关服务项，其它设置进入容器的shell手工修改。</p>\n<p>假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用</p>\n<ul>\n<li>host 网络，<code>--network host</code></li>\n<li>特权模式，<code>--privileged</code></li>\n<li>挂载cgroup的fs，以使用systemd，<code>-v /sys/fs/cgroup:/sys/fs/cgroup:ro</code></li>\n<li>挂载<code>/mnt</code>，这是已经挂载到主机的CentOS安装文件iso镜像，<code>-v /mnt:/mnt:ro</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ </div><div class=\"line\">--name cobbler cobbler:latest /usr/sbin/init</div></pre></td></tr></table></figure>\n<p>因为容器的<code>Entrypoint</code>是<code>/usr/sbin/init</code>，而且是<code>-d</code>，即detached，启动后不会进入shell。<br>可以通过<code>docker exec</code>执行容器的shell，需要增加 <code>-ti</code>选项为shell分配一个终端，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -ti cobbler bash</div></pre></td></tr></table></figure></p>\n<p>退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行<code>exit</code>。</p>\n<p>按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。</p>\n<h2 id=\"使用容器的几个坑\"><a href=\"#使用容器的几个坑\" class=\"headerlink\" title=\"使用容器的几个坑\"></a>使用容器的几个坑</h2><blockquote>\n<p>Docker官方的CentOS镜像太精简了，</p>\n<ul>\n<li>没有 <code>curl</code> 及 <code>wget</code>，还少了 <code>which</code>， 也需要装上；</li>\n<li><code>/etc/httpd/logs</code>是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个<code>/etc/httpd/logs/</code>目录即可；</li>\n<li>没有 <code>/var/log/cobbler/tasks</code> 目录，导致cobbler sync 失败，手动创建该目录。 </li>\n</ul>\n</blockquote>\n<h1 id=\"真机上部署遇到的问题\"><a href=\"#真机上部署遇到的问题\" class=\"headerlink\" title=\"真机上部署遇到的问题\"></a>真机上部署遇到的问题</h1><h2 id=\"选择合适的网卡\"><a href=\"#选择合适的网卡\" class=\"headerlink\" title=\"选择合适的网卡\"></a>选择合适的网卡</h2><p>服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是<code>em1</code>，但有的机器需要修改BIOS选择<code>em2</code>网卡才行。</p>\n<h2 id=\"Dell-iDRAC\"><a href=\"#Dell-iDRAC\" class=\"headerlink\" title=\"Dell iDRAC\"></a>Dell iDRAC</h2><p>服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。<br>在使用PXE之前，先要装好一台机器。<br>装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。<br>iDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行<code>javacpl.exe</code>）中添加 <code>安全例外项</code>。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。</p>\n<blockquote>\n<p>iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。</p>\n</blockquote>\n<p>通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-(<br>安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。</p>\n<p>旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://cobbler.github.io/manuals/quickstart/\" target=\"_blank\" rel=\"external\">Cobbler Quick Start</a></li>\n<li><a href=\"http://readshlinux.blog.51cto.com/9322509/1812402\" target=\"_blank\" rel=\"external\">Centos7.2安装Cobbler 并安装系统</a></li>\n<li><a href=\"http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/\" target=\"_blank\" rel=\"external\">How to Install and Configure Cobbler on CentOS 7.x</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83\" target=\"_blank\" rel=\"external\">PXE</a> （Preboot eXecution Environment，预执行环境）是通过 <strong>局域网</strong> 来启动计算机（和安装操作系统）的技术。<br>一般是通过刻录到光驱或U盘的Live CD这样的本地存储来安装系统的，要通过网络来安装系统，首先要知道安装文件存放的服务器（TFTP服务器，Trivial File Transfer Protocol，精简FTP），而系统启动时网卡的IP都还没有。所以PXE必须要有一个 <strong>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</strong>，不但负责为机器分配 IP地址，还会告知安装文件所在的服务器的 IP地址。<br>Cobbler简化了安装配置DHCP、TFTP、关联Kickstart应答文件等搭建PXE服务器的过程。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">测试环境</a></li>\n<li><a href=\"#cobbler%E8%AE%BE%E7%BD%AE%E6%AD%A5%E9%AA%A4\">Cobbler设置步骤</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8selinux\">禁用SELinux</a></li>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99\">禁用防火墙</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6\">安装软件</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1\">设置为开机启动的服务</a></li>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%8A%A0%E5%AF%86%E7%9A%84root%E5%AF%86%E7%A0%81\">生成加密的root密码</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9cobbler%E7%9A%84%E9%85%8D%E7%BD%AE\">修改cobbler的配置</a><ul>\n<li><a href=\"#%E4%BF%AE%E6%94%B9xinetd-tftp%E7%9A%84%E9%85%8D%E7%BD%AE\">修改xinetd tftp的配置</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9dhcp%E9%85%8D%E7%BD%AE\">修改dhcp配置</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-dnsmasq-%E6%8F%90%E4%BE%9B-dhcp-%E6%9C%8D%E5%8A%A1\">使用 dnsmasq 提供 dhcp 服务</a></li>\n<li><a href=\"#%E5%90%AF%E5%8A%A8%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1\">启动相关服务</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8C-cobbler-check\">执行 <code>cobbler check</code></a></li>\n<li><a href=\"#%E5%AF%BC%E5%85%A5centos%E7%B3%BB%E7%BB%9F%E7%9A%84iso%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F\">导入CentOS系统的iso安装镜像</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9kickstarts%E6%96%87%E4%BB%B6\">修改Kickstarts文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%A3%80%E6%9F%A5\">更新设置，最后的检查</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8pxe%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">在其它机器使用PXE安装系统</a></li>\n<li><a href=\"#%E5%9C%A8docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8Ccobbler\">在docker容器中运行cobbler</a><ul>\n<li><a href=\"#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8systemd\">docker容器使用systemd</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91\">使用容器的几个坑</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9C%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98\">真机上部署遇到的问题</a><ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%BD%91%E5%8D%A1\">选择合适的网卡</a></li>\n<li><a href=\"#dell-idrac\">Dell iDRAC</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>虚拟机使用NAT网络，IP段10.1.1.0，子网掩码：255.255.255.0，DNS/DHCP/Gateway：10.1.1.2。</p>\n<p>新建一个虚拟机，安装CentOS 7，使用的镜像是 <strong><a href=\"http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1611.iso\" target=\"_blank\" rel=\"external\">CentOS-7-x86_64-Minimal-1611.iso</a></strong> 。因为是Minimal的，不必选择附加的软件包。<br>安装后登录系统，查看IP地址<code>ip a</code>，可以通过ssh登录到VM。<br>关闭VM，拍摄一个快照。</p>\n<ul>\n<li>IP ： 10.1.1.10</li>\n<li>子网掩码：255.255.255.0</li>\n<li>用户：root</li>\n</ul>\n<h1 id=\"Cobbler设置步骤\"><a href=\"#Cobbler设置步骤\" class=\"headerlink\" title=\"Cobbler设置步骤\"></a>Cobbler设置步骤</h1><blockquote>\n<p>因为虚拟机已经加载了iso镜像，可以在Guest OS中直接挂载。对远程的服务器，可以配置的同时把iso镜像拷贝到远程机器上去，或者使用共享文件，节省一点拷贝文件的时间。</p>\n</blockquote>\n<h2 id=\"禁用SELinux\"><a href=\"#禁用SELinux\" class=\"headerlink\" title=\"禁用SELinux\"></a>禁用SELinux</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &apos;s/SELINUX\\=enforcing/SELINUX\\=disabled/g&apos; /etc/selinux/config</div><div class=\"line\">setenforce 0</div></pre></td></tr></table></figure>\n<h2 id=\"禁用防火墙\"><a href=\"#禁用防火墙\" class=\"headerlink\" title=\"禁用防火墙\"></a>禁用防火墙</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div></pre></td></tr></table></figure>\n<h2 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum -y install epel-release</div><div class=\"line\">yum -y install cobbler dhcp httpd xinetd pykickstart fence-agents</div></pre></td></tr></table></figure>\n<h2 id=\"设置为开机启动的服务\"><a href=\"#设置为开机启动的服务\" class=\"headerlink\" title=\"设置为开机启动的服务\"></a>设置为开机启动的服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl enable cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<blockquote>\n<p>PXE 需要从 dhcp服务器获取新的IP地址，以及TFTP，HTTP服务器的IP地址， TFTP服务器提供操作系统的安装文件，HTTP服务器提供Kickstart应答文件。<br>cobbler_web 是cobbler的设置界面，跟HTTP服务不是一回事，可不必安装。</p>\n</blockquote>\n<h2 id=\"生成加密的root密码\"><a href=\"#生成加密的root密码\" class=\"headerlink\" title=\"生成加密的root密码\"></a>生成加密的root密码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">openssl passwd -1 -salt &quot;centos&quot; &quot;centos&quot;</div><div class=\"line\"># 输出，由于salt和密码都是指定的，这段加密的字符串也就是确定的了</div><div class=\"line\">$1$centos$Uq6E6Wp5SDZYbs6MCmamP0</div></pre></td></tr></table></figure>\n<h1 id=\"修改cobbler的配置\"><a href=\"#修改cobbler的配置\" class=\"headerlink\" title=\"修改cobbler的配置\"></a>修改cobbler的配置</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/settings</div><div class=\"line\"># 改动 的内容如下</div><div class=\"line\">default_password_crypted: &quot;$1$centos$Uq6E6Wp5SDZYbs6MCmamP0&quot;</div><div class=\"line\">manage_dhcp: 1</div><div class=\"line\">next_server: 10.1.1.10</div><div class=\"line\">server: 10.1.1.10</div></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"/doc/cobbler-setting.txt\">修改后的完整 settings 文件 (删除了注释)</a></p>\n</blockquote>\n<h2 id=\"修改xinetd-tftp的配置\"><a href=\"#修改xinetd-tftp的配置\" class=\"headerlink\" title=\"修改xinetd tftp的配置\"></a>修改xinetd tftp的配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/xinetd.d/tftp</div><div class=\"line\"># 将 disable = yes 改为  disable = no</div></pre></td></tr></table></figure>\n<h2 id=\"修改dhcp配置\"><a href=\"#修改dhcp配置\" class=\"headerlink\" title=\"修改dhcp配置\"></a>修改dhcp配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/cobbler/dhcp.template</div><div class=\"line\"># 改动的内容包括 子网段，分配的IP区间，</div><div class=\"line\"># 以及 默认网关（路由器），DNS（默认网关和DNS的设置不影响PXE装机过程，只是新装的机器启动后可能无法访问外网）</div><div class=\"line\"># $next-server 是指向 /etc/cobbler/settings 中的对应值</div><div class=\"line\">#</div><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">     option routers             10.1.1.2;</div><div class=\"line\">     option domain-name-servers 10.1.1.2;</div><div class=\"line\">     option subnet-mask         255.255.255.0;</div><div class=\"line\">     range dynamic-bootp        10.1.1.100 10.1.1.110;</div><div class=\"line\">     default-lease-time         21700;</div><div class=\"line\">     max-lease-time             43100;</div><div class=\"line\">     next-server                $next_server;</div><div class=\"line\"></div><div class=\"line\">     class &quot;pxeclients&quot; &#123;</div><div class=\"line\">          match if substring (option vendor-class-identifier, 0, 9) = &quot;PXEClient&quot;;</div><div class=\"line\">          if option pxe-system-type = 00:02 &#123;</div><div class=\"line\">              filename &quot;ia64/elilo.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:06 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86.efi&quot;;</div><div class=\"line\">          &#125; else if option pxe-system-type = 00:07 &#123;</div><div class=\"line\">              filename &quot;grub/grub-x86_64.efi&quot;;</div><div class=\"line\">          &#125; else &#123;</div><div class=\"line\">              filename &quot;pxelinux.0&quot;;</div><div class=\"line\">          &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果遇到DHCP服务启动失败，可能是 dhcpd 先于 cobblerd 启动，导致 cobbler 来不及设置 dhcpd ，dhcpd.conf 配置文件还是空的。<br>遇到这种情况，可以将 <code>/etc/cobbler/settings</code> 中的 <code>manage_dhcp: 1</code> 改为 <code>0</code>， 然后手动管理 dhcp：修改 <code>/etc/dhcp/dhcpd.conf</code>，格式如下。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">subnet 10.1.1.0 netmask 255.255.255.0 &#123;</div><div class=\"line\">        option routers 10.1.1.2;</div><div class=\"line\">        option domain-name-servers 10.1.1.2;</div><div class=\"line\">        option subnet-mask 255.255.255.0;</div><div class=\"line\">        default-lease-time 21600;</div><div class=\"line\">        max-lease-time 43200;</div><div class=\"line\">        range 10.1.1.100 10.1.1.110;</div><div class=\"line\">        next-server 10.1.1.10;</div><div class=\"line\">        filename &quot;pxelinux.0&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意要把 <code>$next_server</code> 设置为 <strong>具体的 IP地址</strong>，这个配置项是 PXE 的关键。<br><!--这样的一个好处是可以设置 **多个** `subnet {...}` 段，以针对不同的网络环境，dhcpd会自动将 subnet段 与系统网卡的配置匹配，忽略不匹配的设置。\n很可惜 cobbler 的 next_server 只能指定一个 IP， 换了机器还要修改设置。--><br>如果dhcp服务器（也就是cobbler的服务器）有多个网卡，上面dhcp的配置项与哪个网卡的IP段匹配，就在这个网卡所在的局域网上提供 dhcp 服务。如果没有找到任何匹配的网卡， dhcpd 会报错退出。<br>如果所在的局域网已经有其它的dhcp服务器，那么会存在竞争，可以考虑使用 dnsmasq。<br><code>/etc/cobbler/settings</code> 中 <code>next_server</code> 和 <code>server</code> 指定的IP地址要和DHCP的网段在 <strong>同一个局域网段</strong> 才能正常工作。</p>\n<h2 id=\"使用-dnsmasq-提供-dhcp-服务\"><a href=\"#使用-dnsmasq-提供-dhcp-服务\" class=\"headerlink\" title=\"使用 dnsmasq 提供 dhcp 服务\"></a>使用 dnsmasq 提供 dhcp 服务</h2><p>参考<a href=\"http://cobbler.github.io/manuals/2.8.0/3/4/1_-_Managing_DHCP.html\" target=\"_blank\" rel=\"external\">Managing DHCP - cobbler manual</a>，如果 dhcpd 无法正确配置，可以使用 dnsmasq。首先需要安装： <code>yum install -y dnsmasq</code>。<br>如果让cobbler来配置dnsmasq，需要设置<code>/etc/cobbler/settings</code> 中为 <code>manage_dhcp: 1</code>，<br>然后修改 <code>/etc/cobbler/modules.conf</code>，将<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_isc   # isc 即 dhcpd</div><div class=\"line\"># 改为</div><div class=\"line\">[dhcp]</div><div class=\"line\">module = manage_dnsmasq</div></pre></td></tr></table></figure></p>\n<p>然后修改 <code>/etc/cobbler/dnsmasq.template</code>，dnsmasq的配置比较简单，只要修改IP区间即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">dhcp-range=10.1.1.100,10.1.1.110</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意 dhcpd 与 dnsmasq 的区间格式不同，配置文件的格式错误会导致服务无法启动。<br>如果只是临时提供 dhcp 服务，可设置比较小的区间，<strong>特别要避免与已有的重要服务器发生 IP地址 冲突</strong>！</p>\n</blockquote>\n<h2 id=\"启动相关服务\"><a href=\"#启动相关服务\" class=\"headerlink\" title=\"启动相关服务\"></a>启动相关服务</h2><blockquote>\n<p>注意： 重启服务器后，需要确认下面的几项服务是否正常启动。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">systemctl start cobblerd dhcpd httpd rsyncd tftp xinetd</div></pre></td></tr></table></figure>\n<h2 id=\"执行-cobbler-check\"><a href=\"#执行-cobbler-check\" class=\"headerlink\" title=\"执行 cobbler check\"></a>执行 <code>cobbler check</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 输出如下，可见只有一项问题，因为安装的是CentOS系统，可以忽略这一项。</div><div class=\"line\">The following are potential configuration items that you may want to fix:</div><div class=\"line\">1 : debmirror package is not installed, it will be required to manage debian deployments and repositories</div><div class=\"line\">Restart cobblerd and then run &apos;cobbler sync&apos; to apply changes.</div></pre></td></tr></table></figure>\n<ul>\n<li>如果提示需下载额外的boot loader，可执行 <code>cobbler get-loaders</code> ，这 <strong>不是必须的</strong>，因为已经自带了常用系统的loader。如果确实要下载，且要使用代理的话，<code>/etc/cobbler/settings</code> 中可以在 <code>proxy_url_ext</code> 设置代理地址。</li>\n<li>如果输出中说 httpd无法访问 或 SELinux 没有关闭，执行<code>systemctl status httpd</code> 查看，还可以通过访问 <a href=\"http://10.1.1.10\" target=\"_blank\" rel=\"external\">http://10.1.1.10</a> （next_server的IP地址）来确认.可能是 <code>/etc/cobbler/settings</code> 中 <code>next_server</code> 或 <code>server</code> 的 IP地址 设置错误，改正IP地址后尝试重启 httpd。</li>\n</ul>\n<p>再次执行 <code>cobbler check</code>，并检查相关的服务是否正常启动，然后继续执行下面的步骤。</p>\n<h2 id=\"导入CentOS系统的iso安装镜像\"><a href=\"#导入CentOS系统的iso安装镜像\" class=\"headerlink\" title=\"导入CentOS系统的iso安装镜像\"></a>导入CentOS系统的iso安装镜像</h2><p>虚拟机中已经为Guest OS加载了iso文件到<code>/dev/cdrom</code>，需要再挂载到<code>/mnt</code>：<code>mount -t auto -o loop,ro /dev/cdrom /mnt</code>；<br>也可以直接挂载iso文件：<code>mount -t iso9660 -o loop,ro /your/path/to/CentOS-7-x86_64-Minimal-1611.iso /mnt</code>。</p>\n<p>导入安装镜像：<code>cobbler import --name=centos --arch=x86_64 --path=/mnt</code>。<br>等几分钟才能执行完import，因为这一步把安装光盘拷贝到了 <code>/var/www/cobbler/ks_mirror/</code></p>\n<p>查看导入的项目：<code>cobbler profile list</code><br>输出为 centos-x86_64，进一步查看，<code>cobbler profile report --name=centos-x86_64</code>。</p>\n<h2 id=\"修改Kickstarts文件\"><a href=\"#修改Kickstarts文件\" class=\"headerlink\" title=\"修改Kickstarts文件\"></a>修改Kickstarts文件</h2><p>从上面的命令输出可知使用的Kickstart文件在 <code>/var/lib/cobbler/kickstarts/sample_end.ks</code><br>修改下面2项</p>\n<ul>\n<li><code>firewall --enable</code>            改为 <code>firewall --disable</code></li>\n<li><code>timezone  America/New_York</code>   改为 <code>timezone  Asia/Shanghai</code></li>\n</ul>\n<h2 id=\"更新设置，最后的检查\"><a href=\"#更新设置，最后的检查\" class=\"headerlink\" title=\"更新设置，最后的检查\"></a>更新设置，最后的检查</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cobbler sync</div><div class=\"line\">systemctl restart cobblerd</div><div class=\"line\">cobbler check</div></pre></td></tr></table></figure>\n<h1 id=\"在其它机器使用PXE安装系统\"><a href=\"#在其它机器使用PXE安装系统\" class=\"headerlink\" title=\"在其它机器使用PXE安装系统\"></a>在其它机器使用PXE安装系统</h1><p>新建一个虚拟机，不要直接启动，而是通过菜单选择“虚拟机 -&gt; 电源 -&gt; 打开电源时进入固件”，在虚拟机的BIOS中将网络启动设置为第一项，然后按 <code>F10</code> 键保存并重启虚拟机。<br><img src=\"/img/pxe-boot-config.png\" alt=\"\"></p>\n<p>稍等一下，DHCP配置完成后会显示启动项如下：<br><img src=\"/img/pxe-boot-menu.png\" alt=\"\"><br>选择第二项 centos-x86_64，回车，就会开始自动安装。</p>\n<p>稍等一会儿，安装完成后自动重启。可以按上面的步骤，在BIOS中修改默认启动项为本机硬盘。<br>从本机硬盘启动后，以root用户登录，密码就是之前使用openssl设置的密码，查看一下分配的IP地址，可以用ssh登录后继续系统管理操作。</p>\n<blockquote>\n<p>从Cobbler官网的手册来看，它支持profile和system命令，应该是支持多网卡和多种操作系统的Profile等复杂需求的；<br>此外还可以在<a href=\"/doc/cobbler-setting.txt\">settings</a>中设置加入LDAP domain，代理，安装软件包，配置用户ssh key等等功能，以及构建定制的系统iso镜像，<br>在Kickstart文件中也可以完成硬盘分区，安装软件包，配置用户等等功能。<br>水平有限，就不深入这些功能了;-(</p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中运行cobbler\"><a href=\"#在docker容器中运行cobbler\" class=\"headerlink\" title=\"在docker容器中运行cobbler\"></a>在docker容器中运行cobbler</h1><h2 id=\"docker容器使用systemd\"><a href=\"#docker容器使用systemd\" class=\"headerlink\" title=\"docker容器使用systemd\"></a>docker容器使用systemd</h2><p>通过 <code>docker pull centos:7</code> 直接pull下来的镜像 <strong>不能使用</strong> <code>systemd</code>， 因为这与 docker 的 <strong>单容器单进程</strong> 哲学不相容~~<br>我们需要自己build一个支持systemd的镜像，参考 <a href=\"https://hub.docker.com/_/centos/\" target=\"_blank\" rel=\"external\">Docker Hub 的 CentOS镜像</a> 或<a href=\"https://store.docker.com/images/d5052416-4069-4619-8597-ba61df35ba6f\" target=\"_blank\" rel=\"external\">Docker Store 的  CentOS</a>的页面中 <strong>Systemd integration</strong> 一节提供的 Dockerfile 即可。</p>\n<p>再此镜像之上再build一个cobbler的镜像，这里偷懒，cobbler的Dockerfile只是安装安装必要的软件（<strong>增加 which 和 curl</strong>），启用相关服务项，其它设置进入容器的shell手工修改。</p>\n<p>假设这个镜像的 tag 为 cobbler:default，启动一个容器，使用</p>\n<ul>\n<li>host 网络，<code>--network host</code></li>\n<li>特权模式，<code>--privileged</code></li>\n<li>挂载cgroup的fs，以使用systemd，<code>-v /sys/fs/cgroup:/sys/fs/cgroup:ro</code></li>\n<li>挂载<code>/mnt</code>，这是已经挂载到主机的CentOS安装文件iso镜像，<code>-v /mnt:/mnt:ro</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -d --privileged --network host -v /sys/fs/cgroup:/sys/fs/cgroup:ro -v /mnt:/mnt:ro \\ </div><div class=\"line\">--name cobbler cobbler:latest /usr/sbin/init</div></pre></td></tr></table></figure>\n<p>因为容器的<code>Entrypoint</code>是<code>/usr/sbin/init</code>，而且是<code>-d</code>，即detached，启动后不会进入shell。<br>可以通过<code>docker exec</code>执行容器的shell，需要增加 <code>-ti</code>选项为shell分配一个终端，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -ti cobbler bash</div></pre></td></tr></table></figure></p>\n<p>退出容器（不会停止容器运行）的快捷键是 Ctrl + P, Q，或在容器的shell中执行<code>exit</code>。</p>\n<p>按上述步骤启动容器，在容器的shell中执行上一节的操作，修改配置，导入iso镜像，检查各项服务是否正常启动。</p>\n<h2 id=\"使用容器的几个坑\"><a href=\"#使用容器的几个坑\" class=\"headerlink\" title=\"使用容器的几个坑\"></a>使用容器的几个坑</h2><blockquote>\n<p>Docker官方的CentOS镜像太精简了，</p>\n<ul>\n<li>没有 <code>curl</code> 及 <code>wget</code>，还少了 <code>which</code>， 也需要装上；</li>\n<li><code>/etc/httpd/logs</code>是一个链接，但应该是一个目录，结果导致 httpd 无法启动。把原来的链接删掉，新建一个<code>/etc/httpd/logs/</code>目录即可；</li>\n<li>没有 <code>/var/log/cobbler/tasks</code> 目录，导致cobbler sync 失败，手动创建该目录。 </li>\n</ul>\n</blockquote>\n<h1 id=\"真机上部署遇到的问题\"><a href=\"#真机上部署遇到的问题\" class=\"headerlink\" title=\"真机上部署遇到的问题\"></a>真机上部署遇到的问题</h1><h2 id=\"选择合适的网卡\"><a href=\"#选择合适的网卡\" class=\"headerlink\" title=\"选择合适的网卡\"></a>选择合适的网卡</h2><p>服务器有2个网卡，BIOS默认只有一个网卡能通过PXE启动机器。一般的机器都是<code>em1</code>，但有的机器需要修改BIOS选择<code>em2</code>网卡才行。</p>\n<h2 id=\"Dell-iDRAC\"><a href=\"#Dell-iDRAC\" class=\"headerlink\" title=\"Dell iDRAC\"></a>Dell iDRAC</h2><p>服务器是Dell的，有2种型号，分别通过iDRAC6 和 iDRAC8 web界面远程管理。它们都可以提供服务器的画面显示，鼠标和键盘控制，并且可以将本地的iso镜像/光驱挂载为远程服务器的虚拟光驱。<br>在使用PXE之前，先要装好一台机器。<br>装机之前，先把iDRAC的固件升级了一下，通过机器的服务标签可以搜索到对应的固件。<br>iDRAC6 的画面显示是通过 jnlp控件 显示的，要安装好 jre，并在控制面板的Java选项（或直接执行<code>javacpl.exe</code>）中添加 <code>安全例外项</code>。jnlp控件都是一次性的，每个会话都要重新下载，还要点击n个安全提示对话框。最好使用IE，使用Chrome出现过安装系统快结束时页面错误，功亏一篑。</p>\n<blockquote>\n<p>iDRAC6 的 jviewer jnlp控件对应的jar包证书比较旧了，如果使用较新的jre，会因为证书过期而无法执行jnlp控件，所以需要安装 java 7 版本的 jre。</p>\n</blockquote>\n<p>通过jnlp安装CentOS不管什么版本都是图形化的安装界面，太耗资源了，先要黑屏等着等传过去一堆文件之后才能显示出安装界面来，在安装界面虽然鼠标指针可以移动，但单击没有反应，键盘也没有反应;-(<br>安装Ubuntu Server版基于的文本安装界面，很快就可以显示出来，可以只用键盘操作。</p>\n<p>旧版iDRAC8 的jnlp同样是有显示但无法操作，好在升级后可以使用 html5 的新界面，而且支持多个会话。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"http://cobbler.github.io/manuals/quickstart/\" target=\"_blank\" rel=\"external\">Cobbler Quick Start</a></li>\n<li><a href=\"http://readshlinux.blog.51cto.com/9322509/1812402\" target=\"_blank\" rel=\"external\">Centos7.2安装Cobbler 并安装系统</a></li>\n<li><a href=\"http://www.linuxtechi.com/install-and-configure-cobbler-on-centos-7/\" target=\"_blank\" rel=\"external\">How to Install and Configure Cobbler on CentOS 7.x</a></li>\n</ul>"},{"title":"【译文】Docker镜像格式规范，v1.2","date":"2017-05-15T16:00:00.000Z","_content":"原文见 https://github.com/moby/moby/blob/master/image/spec/v1.2.md\nDocker已经迁移到Moby项目了。\n\n<!--more-->\n<!-- TOC -->\n\n    - [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n- [Docker镜像规范v1.2.0](#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120)\n    - [术语](#%E6%9C%AF%E8%AF%AD)\n        - [层（Layer）](#%E5%B1%82%EF%BC%88layer%EF%BC%89)\n        - [镜像的JSON描述文件](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6)\n        - [镜像文件变更集（changeset）](#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89)\n        - [层的DiffID](#%E5%B1%82%E7%9A%84diffid)\n        - [层的ChainID](#%E5%B1%82%E7%9A%84chainid)\n        - [镜像的ImageID](#%E9%95%9C%E5%83%8F%E7%9A%84imageid)\n        - [标签（Tag）](#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89)\n        - [镜像名（Repository）](#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89)\n    - [镜像的JSON描述文件示例](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B)\n    - [镜像的JSON描述文件说明](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E)\n        - [created](#created)\n        - [author](#author)\n        - [architecture](#architecture)\n        - [os](#os)\n        - [config](#config)\n            - [User](#user)\n            - [Memory](#memory)\n            - [MemorySwap](#memoryswap)\n            - [CpuShares](#cpushares)\n            - [ExposedPorts](#exposedports)\n            - [Env](#env)\n            - [Entrypoint](#entrypoint)\n            - [Cmd](#cmd)\n            - [Healthcheck](#healthcheck)\n                - [Test](#test)\n                - [Volumes](#volumes)\n                - [WorkingDir](#workingdir)\n                - [rootfs](#rootfs)\n        - [history](#history)\n    - [创建镜像文件变更集](#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86)\n    - [镜像的组合格式](#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F)\n- [TODO](#todo)\n- [补充](#%E8%A1%A5%E5%85%85)\n    - [alpine镜像的主机存储布局](#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80)\n\n<!-- /TOC -->\n\n# Docker镜像规范v1.2.0\n\n**镜像（Image）**是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。\n此版本的镜像规范自Docker 1.12开始采用。\n\n> 译注：本规范中的 **filesystem** 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 **文件集**。\n\n## 术语\n本规范使用以下术语:\n### 层（Layer）\n镜像由 **层** 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。\n\n### 镜像的JSON描述文件\n整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。\n该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。\n \n### 镜像文件变更集（changeset）\n每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。\n\n### 层的DiffID\n将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个`tar`包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用`tar-split`来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。\n\n>译注：关于层的打包和解包的可重复性，`tar`程序将一组文件打包的 **顺序** 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。\n参考：[tar打包的顺序](https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined)。\n\n### 层的ChainID\n为方便起见，可以给一串有序的层计算出一个ID，称为 **ChainID**。\n仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：\n\n$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ \" \\quad\" +DiffID(layerN))$$ \n\n### 镜像的ImageID\n每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。\n\n### 标签（Tag）\nTag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即`[a-zA-Z0-9_.-]`，首个字符不能是`.`或`-`。Tag不能超过127个字符。\n\n### 镜像名（Repository）\n这里的`Repository`是指镜像全名在冒号`:`之前的部分，冒号`:`之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为`my-app:3.1.4`的镜像，`my-app`就是镜像的 Repository 部分。\nRepository又可以用斜杠`/`分隔开，`/`之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 **不得** 包含下划线`_`字符，主机名可以有如`：8080`格式的端口号。\n镜像名可以包含小写字符，数字和分隔符。 分隔符是句点`.`，一个或两个下划线`_`，或一个或多个短横线`-`，镜像名 **不允许** 以分隔符开头或结尾。\n\n> 译注：\n+ 这里的 Repository 容易与git的 **代码仓库** 概念混淆。\n+ DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线`_`，参考[RFC 1123](https://tools.ietf.org/html/rfc1123)\n\n\n## 镜像的JSON描述文件示例\n下面是一个镜像的JSON描述文件示例：\n\n```\n{\n  \"architecture\": \"amd64\",\n  \"author\": \"Alyssa P. Hacker &ltalyspdev@example.com&gt\",\n  \"config\": {\n    \"Cmd\": [\n      \"--foreground\",\n      \"--config\",\n      \"/etc/my-app.d/default.cfg\"\n    ],\n    \"CpuShares\": 8,\n    \"Entrypoint\": [\n      \"/bin/my-app-binary\"\n    ],\n    \"Env\": [\n      \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n      \"FOO=docker_is_a_really\",\n      \"BAR=great_tool_you_know\"\n    ],\n    \"ExposedPorts\": {\n      \"8080/tcp\": {}\n    },\n    \"Memory\": 2048,\n    \"MemorySwap\": 4096,\n    \"User\": \"alice\",\n    \"Volumes\": {\n      \"/var/job-result-data\": {},\n      \"/var/log/my-app-logs\": {}\n    },\n    \"WorkingDir\": \"/home/alice\"\n  },\n  \"created\": \"2015-10-31T22:22:56.015925234Z\",\n  \"history\": [\n    {\n      \"created\": \"2015-10-31T22:22:54.690851953Z\",\n      \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n    },\n    {\n      \"created\": \"2015-10-31T22:22:55.613815829Z\",\n      \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n      \"empty_layer\": true\n    }\n  ],\n  \"os\": \"linux\",\n  \"rootfs\": {\n    \"diff_ids\": [\n      \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n      \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\"\n    ],\n    \"type\": \"layers\"\n  }\n}\n\n```\n\n注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。\n\n## 镜像的JSON描述文件说明\n\n### created\n`string`\n镜像创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)。\n\n### author\n`string`\n创建和负责维护改镜像的人员或组织名，或Email。\n### architecture\n`string`\n镜像中可执行文件的CPU架构，可以是 \n+ `386`\n+ `amd64`\n+ `arm`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。\n\n### os\n`string`\n镜像运行的操作系统名，可以是 \n+ `darwin`\n+ `freebsd`\n+ `linux`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。\n\n### config\n`struct`\n`config`结构是从镜像创建容器时，使用的基本执行参数。`config`可以是空值`null`，则创建容器时必须提供所有必要的执行参数。\n\n`config`结构的各字段说明\n#### User \n`string`\n容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：\n+ `user`\n+ `uid`\n+ `user:group`\n+ `uid:gid`\n+ `uid:group`\n+ `user:gid`\n\n如果没有给出组名 `group`/`gid`，默认的组使用容器中`/etc/passwd`文件对应的`user`/`uid`项。\n\n#### Memory \n`integer`\n内存限值（以 **字节** 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### MemorySwap \n`integer`\n总的内存使用量（内存 + swap），设置为`-1`则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### CpuShares \n`integer`\nCPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### ExposedPorts \n`struct`\n基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"8080\": {},\n    \"53/udp\": {},\n    \"2356/tcp\": {}\n}\n```\n其中的键可以是下面的格式：\n+ `\"port/tcp\"`\n+ `\"port/udp\"`\n+ `\"port\"`\n如果没有给出协议，默认使用`tcp`协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。\n\n#### Env \n`array of strings`\nEnv的每项都是 `VARNAME=\"var value\"` 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。\n\n#### Entrypoint \n`array of strings`\n容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。\n\n#### Cmd \n`array of strings`\n容器启动时执行的命令参数列表（附加在`Entrypoint`之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出`Entrypoint`，那么`Cmd`列表的第一项将被认为是可执行的程序名。\n\n#### Healthcheck \n`struct`\n用以检查容器是否正常的测试命令，如下面的例子所示：\n```\n{\n  \"Test\": [\n      \"CMD-SHELL\",\n      \"/usr/bin/check-health localhost\"\n  ],\n  \"Interval\": 30000000000,\n  \"Timeout\":  10000000000,\n  \"Retries\":  3\n}\n```\n\n此结构有如下字段，\n\n##### Test \n`array of strings`\n用以检查容器是否正常的测试命令，可以是\n+ `[]` : 继承父镜像的健康检查命令；\n+ `[\"NONE\"]` : 禁用健康检查；\n+ `[\"CMD\", arg1, arg2, ...]` : 直接执行命令和参数；\n+ `[\"CMD-SHELL\", command]` : 使用系统默认shell执行命令；\n\n如果容器状态正常，测试命令退出后应返回 `0`，否则返回 `1`。\n+ Interval `integer`：相邻两次尝试的间隔，单位为纳秒；\n+ Timeout `integer`：认为异常的超时间隔，单位为纳秒；\n+ Retries `integer`：认为异常的重试次数。\n\n任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。\n\n##### Volumes \n`struct`\n创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"/var/my-app-data/\": {},\n    \"/etc/some-config.d/\": {},\n}\n```\n\n##### WorkingDir \n`string`\n容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。\n\n##### rootfs \n`struct`\nrootfs结构是镜像各层的`DiffID`列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:\n+ `type`，其值一般为 `layers`.\n+ `diff_ids` 各层散列（`DiffID`）的数组，顺序为从最底层到最顶层。\n\n下面是 rootfs 的一个例子：\n\n```\n\"rootfs\": {\n  \"diff_ids\": [\n    \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n    \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\",\n    \"sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49\"\n  ],\n  \"type\": \"layers\"\n}\n```\n\n### history \n`struct`\n`history`结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。\n+ `created`: 创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)；\n+ `author`: 创建的作者；\n+ `created_by`: 创建该层的命令；\n+ `comment`: 创建该层的注释；\n+ `empty_layer`: 标识此项历史记录是否会创建一个文件变更集。如果值为`true`，则此项历史不会对应一个实际的文件集（如`ENV`命令就对层的文件没有影响）。\n下面是 history 结构的一个例子：\n```\n\"history\": [\n  {\n    \"created\": \"2015-10-31T22:22:54.690851953Z\",\n    \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n  },\n  {\n    \"created\": \"2015-10-31T22:22:55.613815829Z\",\n    \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n    \"empty_layer\": true\n  }\n]\n```\n\n镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。\n\n## 创建镜像文件变更集\n创建镜像文件变更集的例子如下：\n首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名`c3167915dc9d`（层的DiffID是基于目录内的文件内容生成的）。\n\n然后在其中创建文件和目录:\n```\nc3167915dc9d/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n将目录`c3167915dc9d`提交为一个 `tar` 包（无压缩），其中包含如下的文件：\n\n```\netc/my-app-config\nbin/my-app-binary\nbin/my-app-tools\n```\n\n如果要在此基础上更改文件，则创建一个新的目录，假如为`f60c56784b83`，将其初始化为父镜像的快照，即与目录`c3167915dc9d`的内容相同。\n>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。\n\n```\nf60c56784b83/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n然后添加一个配置目录`/etc/my-app.d`，其中包含默认的配置文件。可执行程序`my-app-tools`也更新了，以便处理新的配置文件路径。\n修改后的目录`f60c56784b83`如下所示：\n```\nf60c56784b83/\n    etc/\n        my-app.d/\n            default.cfg\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n其中移除了`/etc/my-app-config`，然后创建了新的目录和文件`/etc/my-app.d/default.cfg`。`/bin/my-app-tools`也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照`f60c56784b83`比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：\n```\n增加：  /etc/my-app.d/default.cfg\n修改：  /bin/my-app-tools\n删除：  /etc/my-app-config\n```\n\n创建一个 **仅包含** 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加`.wh.`前缀（表示已删除）。\n> 注意：无法直接创建以名称`.wh.`开头的文件或目录。\n\n目录`f60c56784b83`生成的`tar` 包中有如下的文件：\n\n```\n/etc/my-app.d/default.cfg\n/bin/my-app-tools\n/etc/.wh.my-app-config\n```\n\n任何镜像都是由若干类似的文件变更集的tar包组成的。\n\n## 镜像的组合格式\n包含镜像完整内容的单一tar包格式如下：\n- 镜像名：tag\n- 镜像的 JSON 配置文件\n- 各层的tar包\n\n如镜像`library/busybox`的组合tar包内容如下（使用`tree`命令输出）：\n\n```\n.\n├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\n├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── manifest.json\n└── repositories\n```\n\n镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。\n> 注意：该目录名 **不必** 是层的`DiffID`或`ChainID`。\n\n每个目录包含3个文件：\n+ `VERSION` - `json`文件模式的版本号；\n+ `json` - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。\n+ `layer.tar` - 该层的tar包。\n\n注意：这个目录结构仅用于向后兼容。当前的实现使用`manifest.json`文件中列出的目录。\n\n`VERSION`文件只是JSON元数据模式的版本号：`1.0`。\n\n`repositories`也是一个JSON文件，包含镜像名和tag列表：\n```\n{  \n    \"busybox\":{  \n        \"latest\":\"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\"\n    }\n}\n```\n\n其中有镜像的`repository`和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用`manifest.json`文件。\n\n`manifest.json`文件是顶层镜像的JSON配置。\n该文件包含以下元数据：\n```\n[\n  {\n    \"Config\": \"47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\",\n    \"RepoTags\": [\"busybox:latest\"],\n    \"Layers\": [\n      \"a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar\",\n      \"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar\"\n    ]\n  }\n]\n```\n\n上面这个JSON数组中，每项都对应着一个镜像。\n+ `Config` 指向该镜像的JSON文件；\n+ `RepoTags` 是该镜像的名称；\n+ `Layers` 指向镜像各层的 tar 包；\n+ `Parent` 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 `manifest.json` 文件中存在。\n\n\n不要把 `manifest.json` 与用来push和pull镜像的分发清单（distribution manifest）相混淆。\n一般来说，支持v1.2版本镜像规范的实现将使用`manifest.json`文件，早期的实现仍使用 `*/json`和`repositories`文件。\n\n# TODO\n其它相关文档：\n+ [Open Containers Initiative Image Spec](https://github.com/opencontainers/image-spec)\n+ [Image Manifest Version 2, Schema 2](https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md)\n+ [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/master/docs/spec/api.md)\n+ [Supporting Container Images in Mesos Containerizer](https://github.com/apache/mesos/blob/master/docs/container-image.md)\n\n# 补充\n>注意：不要把上面的 **镜像格式** 与镜像的 **主机存储布局** 搞混了。\n+ 镜像格式是执行`docker save <镜像名或ID>`之后得到的对应镜像`tar`包的格式。\n+ 镜像在主机的存储布局，以及镜像push和pull都 **不会** 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。\n\n>镜像的各层存在顺序依赖，而镜像也有父子继承关系。\n最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。\n\n## alpine镜像的主机存储布局\nalpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。\n+ ./aufs是解开layer.tar后的文件内容；\n+ ./aufs/mnt是容器文件系统的挂载点；\n+ ./containers是创建的容器的读写层；\n+ ./image/aufs/distribution中两个文件夹相当于正反查找的指针；\n+ ./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；\n\n```\n# tree /var/lib/docker\n/var/lib/docker\n├── aufs\n│   ├── diff\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   │       ├── bin\n│   │       │   ├── ash -> /bin/busybox\n│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）\n│   ├── layers\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   └── mnt\n│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n├── containers\n├── image\n│   └── aufs\n│       ├── distribution\n│       │   ├── diffid-by-digest\n│       │   │   └── sha256\n│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299\n│       │   └── v2metadata-by-diffid\n│       │       └── sha256\n│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       ├── imagedb\n│       │   ├── content\n│       │   │   └── sha256\n│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9\n│       │   └── metadata\n│       │       └── sha256\n│       ├── layerdb\n│       │   ├── sha256\n│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       │   │       ├── cache-id \n│       │   │       ├── diff\n│       │   │       ├── size\n│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件\n│       │   └── tmp\n│       └── repositories.json\n├── network\n│   └── files\n│       └── local-kv.db\n├── plugins\n│   ├── storage\n│   │   └── blobs\n│   │       └── tmp\n│   └── tmp\n├── swarm\n├── tmp\n├── trust\n└── volumes\n    └── metadata.db\n\n```","source":"_posts/docker-image-spec-v1.2.md","raw":"title: 【译文】Docker镜像格式规范，v1.2\ncategory: [cloud]\ntags:\ndate: 2017-05-16\n---\n原文见 https://github.com/moby/moby/blob/master/image/spec/v1.2.md\nDocker已经迁移到Moby项目了。\n\n<!--more-->\n<!-- TOC -->\n\n    - [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n- [Docker镜像规范v1.2.0](#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120)\n    - [术语](#%E6%9C%AF%E8%AF%AD)\n        - [层（Layer）](#%E5%B1%82%EF%BC%88layer%EF%BC%89)\n        - [镜像的JSON描述文件](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6)\n        - [镜像文件变更集（changeset）](#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89)\n        - [层的DiffID](#%E5%B1%82%E7%9A%84diffid)\n        - [层的ChainID](#%E5%B1%82%E7%9A%84chainid)\n        - [镜像的ImageID](#%E9%95%9C%E5%83%8F%E7%9A%84imageid)\n        - [标签（Tag）](#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89)\n        - [镜像名（Repository）](#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89)\n    - [镜像的JSON描述文件示例](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B)\n    - [镜像的JSON描述文件说明](#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E)\n        - [created](#created)\n        - [author](#author)\n        - [architecture](#architecture)\n        - [os](#os)\n        - [config](#config)\n            - [User](#user)\n            - [Memory](#memory)\n            - [MemorySwap](#memoryswap)\n            - [CpuShares](#cpushares)\n            - [ExposedPorts](#exposedports)\n            - [Env](#env)\n            - [Entrypoint](#entrypoint)\n            - [Cmd](#cmd)\n            - [Healthcheck](#healthcheck)\n                - [Test](#test)\n                - [Volumes](#volumes)\n                - [WorkingDir](#workingdir)\n                - [rootfs](#rootfs)\n        - [history](#history)\n    - [创建镜像文件变更集](#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86)\n    - [镜像的组合格式](#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F)\n- [TODO](#todo)\n- [补充](#%E8%A1%A5%E5%85%85)\n    - [alpine镜像的主机存储布局](#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80)\n\n<!-- /TOC -->\n\n# Docker镜像规范v1.2.0\n\n**镜像（Image）**是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。\n此版本的镜像规范自Docker 1.12开始采用。\n\n> 译注：本规范中的 **filesystem** 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 **文件集**。\n\n## 术语\n本规范使用以下术语:\n### 层（Layer）\n镜像由 **层** 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。\n\n### 镜像的JSON描述文件\n整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。\n该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。\n \n### 镜像文件变更集（changeset）\n每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。\n\n### 层的DiffID\n将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个`tar`包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用`tar-split`来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。\n\n>译注：关于层的打包和解包的可重复性，`tar`程序将一组文件打包的 **顺序** 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。\n参考：[tar打包的顺序](https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined)。\n\n### 层的ChainID\n为方便起见，可以给一串有序的层计算出一个ID，称为 **ChainID**。\n仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：\n\n$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ \" \\quad\" +DiffID(layerN))$$ \n\n### 镜像的ImageID\n每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，\n如`sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9`。\n由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。\n\n### 标签（Tag）\nTag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即`[a-zA-Z0-9_.-]`，首个字符不能是`.`或`-`。Tag不能超过127个字符。\n\n### 镜像名（Repository）\n这里的`Repository`是指镜像全名在冒号`:`之前的部分，冒号`:`之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为`my-app:3.1.4`的镜像，`my-app`就是镜像的 Repository 部分。\nRepository又可以用斜杠`/`分隔开，`/`之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 **不得** 包含下划线`_`字符，主机名可以有如`：8080`格式的端口号。\n镜像名可以包含小写字符，数字和分隔符。 分隔符是句点`.`，一个或两个下划线`_`，或一个或多个短横线`-`，镜像名 **不允许** 以分隔符开头或结尾。\n\n> 译注：\n+ 这里的 Repository 容易与git的 **代码仓库** 概念混淆。\n+ DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线`_`，参考[RFC 1123](https://tools.ietf.org/html/rfc1123)\n\n\n## 镜像的JSON描述文件示例\n下面是一个镜像的JSON描述文件示例：\n\n```\n{\n  \"architecture\": \"amd64\",\n  \"author\": \"Alyssa P. Hacker &ltalyspdev@example.com&gt\",\n  \"config\": {\n    \"Cmd\": [\n      \"--foreground\",\n      \"--config\",\n      \"/etc/my-app.d/default.cfg\"\n    ],\n    \"CpuShares\": 8,\n    \"Entrypoint\": [\n      \"/bin/my-app-binary\"\n    ],\n    \"Env\": [\n      \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n      \"FOO=docker_is_a_really\",\n      \"BAR=great_tool_you_know\"\n    ],\n    \"ExposedPorts\": {\n      \"8080/tcp\": {}\n    },\n    \"Memory\": 2048,\n    \"MemorySwap\": 4096,\n    \"User\": \"alice\",\n    \"Volumes\": {\n      \"/var/job-result-data\": {},\n      \"/var/log/my-app-logs\": {}\n    },\n    \"WorkingDir\": \"/home/alice\"\n  },\n  \"created\": \"2015-10-31T22:22:56.015925234Z\",\n  \"history\": [\n    {\n      \"created\": \"2015-10-31T22:22:54.690851953Z\",\n      \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n    },\n    {\n      \"created\": \"2015-10-31T22:22:55.613815829Z\",\n      \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n      \"empty_layer\": true\n    }\n  ],\n  \"os\": \"linux\",\n  \"rootfs\": {\n    \"diff_ids\": [\n      \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n      \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\"\n    ],\n    \"type\": \"layers\"\n  }\n}\n\n```\n\n注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。\n\n## 镜像的JSON描述文件说明\n\n### created\n`string`\n镜像创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)。\n\n### author\n`string`\n创建和负责维护改镜像的人员或组织名，或Email。\n### architecture\n`string`\n镜像中可执行文件的CPU架构，可以是 \n+ `386`\n+ `amd64`\n+ `arm`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。\n\n### os\n`string`\n镜像运行的操作系统名，可以是 \n+ `darwin`\n+ `freebsd`\n+ `linux`\n未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。\n\n### config\n`struct`\n`config`结构是从镜像创建容器时，使用的基本执行参数。`config`可以是空值`null`，则创建容器时必须提供所有必要的执行参数。\n\n`config`结构的各字段说明\n#### User \n`string`\n容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：\n+ `user`\n+ `uid`\n+ `user:group`\n+ `uid:gid`\n+ `uid:group`\n+ `user:gid`\n\n如果没有给出组名 `group`/`gid`，默认的组使用容器中`/etc/passwd`文件对应的`user`/`uid`项。\n\n#### Memory \n`integer`\n内存限值（以 **字节** 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### MemorySwap \n`integer`\n总的内存使用量（内存 + swap），设置为`-1`则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### CpuShares \n`integer`\nCPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。\n\n#### ExposedPorts \n`struct`\n基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"8080\": {},\n    \"53/udp\": {},\n    \"2356/tcp\": {}\n}\n```\n其中的键可以是下面的格式：\n+ `\"port/tcp\"`\n+ `\"port/udp\"`\n+ `\"port\"`\n如果没有给出协议，默认使用`tcp`协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。\n\n#### Env \n`array of strings`\nEnv的每项都是 `VARNAME=\"var value\"` 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。\n\n#### Entrypoint \n`array of strings`\n容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。\n\n#### Cmd \n`array of strings`\n容器启动时执行的命令参数列表（附加在`Entrypoint`之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出`Entrypoint`，那么`Cmd`列表的第一项将被认为是可执行的程序名。\n\n#### Healthcheck \n`struct`\n用以检查容器是否正常的测试命令，如下面的例子所示：\n```\n{\n  \"Test\": [\n      \"CMD-SHELL\",\n      \"/usr/bin/check-health localhost\"\n  ],\n  \"Interval\": 30000000000,\n  \"Timeout\":  10000000000,\n  \"Retries\":  3\n}\n```\n\n此结构有如下字段，\n\n##### Test \n`array of strings`\n用以检查容器是否正常的测试命令，可以是\n+ `[]` : 继承父镜像的健康检查命令；\n+ `[\"NONE\"]` : 禁用健康检查；\n+ `[\"CMD\", arg1, arg2, ...]` : 直接执行命令和参数；\n+ `[\"CMD-SHELL\", command]` : 使用系统默认shell执行命令；\n\n如果容器状态正常，测试命令退出后应返回 `0`，否则返回 `1`。\n+ Interval `integer`：相邻两次尝试的间隔，单位为纳秒；\n+ Timeout `integer`：认为异常的超时间隔，单位为纳秒；\n+ Retries `integer`：认为异常的重试次数。\n\n任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。\n\n##### Volumes \n`struct`\n创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的`map[string]struct{}`结构直接序列化为JSON格式的，形式为每个键对应着 **值为空对象{}** 的JSON对象。如下面的例子所示：\n```\n{\n    \"/var/my-app-data/\": {},\n    \"/etc/some-config.d/\": {},\n}\n```\n\n##### WorkingDir \n`string`\n容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。\n\n##### rootfs \n`struct`\nrootfs结构是镜像各层的`DiffID`列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:\n+ `type`，其值一般为 `layers`.\n+ `diff_ids` 各层散列（`DiffID`）的数组，顺序为从最底层到最顶层。\n\n下面是 rootfs 的一个例子：\n\n```\n\"rootfs\": {\n  \"diff_ids\": [\n    \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\",\n    \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\",\n    \"sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49\"\n  ],\n  \"type\": \"layers\"\n}\n```\n\n### history \n`struct`\n`history`结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。\n+ `created`: 创建的日期和时间，[ISO-8601格式](https://zh.wikipedia.org/wiki/ISO_8601)；\n+ `author`: 创建的作者；\n+ `created_by`: 创建该层的命令；\n+ `comment`: 创建该层的注释；\n+ `empty_layer`: 标识此项历史记录是否会创建一个文件变更集。如果值为`true`，则此项历史不会对应一个实际的文件集（如`ENV`命令就对层的文件没有影响）。\n下面是 history 结构的一个例子：\n```\n\"history\": [\n  {\n    \"created\": \"2015-10-31T22:22:54.690851953Z\",\n    \"created_by\": \"/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /\"\n  },\n  {\n    \"created\": \"2015-10-31T22:22:55.613815829Z\",\n    \"created_by\": \"/bin/sh -c #(nop) CMD [\\\"sh\\\"]\",\n    \"empty_layer\": true\n  }\n]\n```\n\n镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。\n\n## 创建镜像文件变更集\n创建镜像文件变更集的例子如下：\n首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名`c3167915dc9d`（层的DiffID是基于目录内的文件内容生成的）。\n\n然后在其中创建文件和目录:\n```\nc3167915dc9d/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n将目录`c3167915dc9d`提交为一个 `tar` 包（无压缩），其中包含如下的文件：\n\n```\netc/my-app-config\nbin/my-app-binary\nbin/my-app-tools\n```\n\n如果要在此基础上更改文件，则创建一个新的目录，假如为`f60c56784b83`，将其初始化为父镜像的快照，即与目录`c3167915dc9d`的内容相同。\n>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。\n\n```\nf60c56784b83/\n    etc/\n        my-app-config\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n然后添加一个配置目录`/etc/my-app.d`，其中包含默认的配置文件。可执行程序`my-app-tools`也更新了，以便处理新的配置文件路径。\n修改后的目录`f60c56784b83`如下所示：\n```\nf60c56784b83/\n    etc/\n        my-app.d/\n            default.cfg\n    bin/\n        my-app-binary\n        my-app-tools\n```\n\n其中移除了`/etc/my-app-config`，然后创建了新的目录和文件`/etc/my-app.d/default.cfg`。`/bin/my-app-tools`也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照`f60c56784b83`比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：\n```\n增加：  /etc/my-app.d/default.cfg\n修改：  /bin/my-app-tools\n删除：  /etc/my-app-config\n```\n\n创建一个 **仅包含** 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加`.wh.`前缀（表示已删除）。\n> 注意：无法直接创建以名称`.wh.`开头的文件或目录。\n\n目录`f60c56784b83`生成的`tar` 包中有如下的文件：\n\n```\n/etc/my-app.d/default.cfg\n/bin/my-app-tools\n/etc/.wh.my-app-config\n```\n\n任何镜像都是由若干类似的文件变更集的tar包组成的。\n\n## 镜像的组合格式\n包含镜像完整内容的单一tar包格式如下：\n- 镜像名：tag\n- 镜像的 JSON 配置文件\n- 各层的tar包\n\n如镜像`library/busybox`的组合tar包内容如下（使用`tree`命令输出）：\n\n```\n.\n├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\n├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198\n│   ├── VERSION\n│   ├── json\n│   └── layer.tar\n├── manifest.json\n└── repositories\n```\n\n镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。\n> 注意：该目录名 **不必** 是层的`DiffID`或`ChainID`。\n\n每个目录包含3个文件：\n+ `VERSION` - `json`文件模式的版本号；\n+ `json` - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。\n+ `layer.tar` - 该层的tar包。\n\n注意：这个目录结构仅用于向后兼容。当前的实现使用`manifest.json`文件中列出的目录。\n\n`VERSION`文件只是JSON元数据模式的版本号：`1.0`。\n\n`repositories`也是一个JSON文件，包含镜像名和tag列表：\n```\n{  \n    \"busybox\":{  \n        \"latest\":\"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a\"\n    }\n}\n```\n\n其中有镜像的`repository`和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用`manifest.json`文件。\n\n`manifest.json`文件是顶层镜像的JSON配置。\n该文件包含以下元数据：\n```\n[\n  {\n    \"Config\": \"47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json\",\n    \"RepoTags\": [\"busybox:latest\"],\n    \"Layers\": [\n      \"a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar\",\n      \"5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar\"\n    ]\n  }\n]\n```\n\n上面这个JSON数组中，每项都对应着一个镜像。\n+ `Config` 指向该镜像的JSON文件；\n+ `RepoTags` 是该镜像的名称；\n+ `Layers` 指向镜像各层的 tar 包；\n+ `Parent` 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 `manifest.json` 文件中存在。\n\n\n不要把 `manifest.json` 与用来push和pull镜像的分发清单（distribution manifest）相混淆。\n一般来说，支持v1.2版本镜像规范的实现将使用`manifest.json`文件，早期的实现仍使用 `*/json`和`repositories`文件。\n\n# TODO\n其它相关文档：\n+ [Open Containers Initiative Image Spec](https://github.com/opencontainers/image-spec)\n+ [Image Manifest Version 2, Schema 2](https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md)\n+ [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/master/docs/spec/api.md)\n+ [Supporting Container Images in Mesos Containerizer](https://github.com/apache/mesos/blob/master/docs/container-image.md)\n\n# 补充\n>注意：不要把上面的 **镜像格式** 与镜像的 **主机存储布局** 搞混了。\n+ 镜像格式是执行`docker save <镜像名或ID>`之后得到的对应镜像`tar`包的格式。\n+ 镜像在主机的存储布局，以及镜像push和pull都 **不会** 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。\n\n>镜像的各层存在顺序依赖，而镜像也有父子继承关系。\n最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。\n\n## alpine镜像的主机存储布局\nalpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。\n+ ./aufs是解开layer.tar后的文件内容；\n+ ./aufs/mnt是容器文件系统的挂载点；\n+ ./containers是创建的容器的读写层；\n+ ./image/aufs/distribution中两个文件夹相当于正反查找的指针；\n+ ./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；\n\n```\n# tree /var/lib/docker\n/var/lib/docker\n├── aufs\n│   ├── diff\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   │       ├── bin\n│   │       │   ├── ash -> /bin/busybox\n│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）\n│   ├── layers\n│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n│   └── mnt\n│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951\n├── containers\n├── image\n│   └── aufs\n│       ├── distribution\n│       │   ├── diffid-by-digest\n│       │   │   └── sha256\n│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299\n│       │   └── v2metadata-by-diffid\n│       │       └── sha256\n│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       ├── imagedb\n│       │   ├── content\n│       │   │   └── sha256\n│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9\n│       │   └── metadata\n│       │       └── sha256\n│       ├── layerdb\n│       │   ├── sha256\n│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860\n│       │   │       ├── cache-id \n│       │   │       ├── diff\n│       │   │       ├── size\n│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件\n│       │   └── tmp\n│       └── repositories.json\n├── network\n│   └── files\n│       └── local-kv.db\n├── plugins\n│   ├── storage\n│   │   └── blobs\n│   │       └── tmp\n│   └── tmp\n├── swarm\n├── tmp\n├── trust\n└── volumes\n    └── metadata.db\n\n```","slug":"docker-image-spec-v1.2","published":1,"updated":"2017-10-30T03:41:07.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgm00049s4fw85z86x7","content":"<p>原文见 <a href=\"https://github.com/moby/moby/blob/master/image/spec/v1.2.md\" target=\"_blank\" rel=\"external\">https://github.com/moby/moby/blob/master/image/spec/v1.2.md</a><br>Docker已经迁移到Moby项目了。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<pre><code>- [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n</code></pre><ul>\n<li><a href=\"#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120\">Docker镜像规范v1.2.0</a><ul>\n<li><a href=\"#%E6%9C%AF%E8%AF%AD\">术语</a><ul>\n<li><a href=\"#%E5%B1%82%EF%BC%88layer%EF%BC%89\">层（Layer）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6\">镜像的JSON描述文件</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89\">镜像文件变更集（changeset）</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84diffid\">层的DiffID</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84chainid\">层的ChainID</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84imageid\">镜像的ImageID</a></li>\n<li><a href=\"#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89\">标签（Tag）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89\">镜像名（Repository）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B\">镜像的JSON描述文件示例</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E\">镜像的JSON描述文件说明</a><ul>\n<li><a href=\"#created\">created</a></li>\n<li><a href=\"#author\">author</a></li>\n<li><a href=\"#architecture\">architecture</a></li>\n<li><a href=\"#os\">os</a></li>\n<li><a href=\"#config\">config</a><ul>\n<li><a href=\"#user\">User</a></li>\n<li><a href=\"#memory\">Memory</a></li>\n<li><a href=\"#memoryswap\">MemorySwap</a></li>\n<li><a href=\"#cpushares\">CpuShares</a></li>\n<li><a href=\"#exposedports\">ExposedPorts</a></li>\n<li><a href=\"#env\">Env</a></li>\n<li><a href=\"#entrypoint\">Entrypoint</a></li>\n<li><a href=\"#cmd\">Cmd</a></li>\n<li><a href=\"#healthcheck\">Healthcheck</a><ul>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#volumes\">Volumes</a></li>\n<li><a href=\"#workingdir\">WorkingDir</a></li>\n<li><a href=\"#rootfs\">rootfs</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#history\">history</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86\">创建镜像文件变更集</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F\">镜像的组合格式</a></li>\n</ul>\n</li>\n<li><a href=\"#todo\">TODO</a></li>\n<li><a href=\"#%E8%A1%A5%E5%85%85\">补充</a><ul>\n<li><a href=\"#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80\">alpine镜像的主机存储布局</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"Docker镜像规范v1-2-0\"><a href=\"#Docker镜像规范v1-2-0\" class=\"headerlink\" title=\"Docker镜像规范v1.2.0\"></a>Docker镜像规范v1.2.0</h1><p><strong>镜像（Image）</strong>是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。<br>此版本的镜像规范自Docker 1.12开始采用。</p>\n<blockquote>\n<p>译注：本规范中的 <strong>filesystem</strong> 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 <strong>文件集</strong>。</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>本规范使用以下术语:</p>\n<h3 id=\"层（Layer）\"><a href=\"#层（Layer）\" class=\"headerlink\" title=\"层（Layer）\"></a>层（Layer）</h3><p>镜像由 <strong>层</strong> 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。</p>\n<h3 id=\"镜像的JSON描述文件\"><a href=\"#镜像的JSON描述文件\" class=\"headerlink\" title=\"镜像的JSON描述文件\"></a>镜像的JSON描述文件</h3><p>整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。<br>该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。</p>\n<h3 id=\"镜像文件变更集（changeset）\"><a href=\"#镜像文件变更集（changeset）\" class=\"headerlink\" title=\"镜像文件变更集（changeset）\"></a>镜像文件变更集（changeset）</h3><p>每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。</p>\n<h3 id=\"层的DiffID\"><a href=\"#层的DiffID\" class=\"headerlink\" title=\"层的DiffID\"></a>层的DiffID</h3><p>将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个<code>tar</code>包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用<code>tar-split</code>来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。</p>\n<blockquote>\n<p>译注：关于层的打包和解包的可重复性，<code>tar</code>程序将一组文件打包的 <strong>顺序</strong> 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。<br>参考：<a href=\"https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined\" target=\"_blank\" rel=\"external\">tar打包的顺序</a>。</p>\n</blockquote>\n<h3 id=\"层的ChainID\"><a href=\"#层的ChainID\" class=\"headerlink\" title=\"层的ChainID\"></a>层的ChainID</h3><p>为方便起见，可以给一串有序的层计算出一个ID，称为 <strong>ChainID</strong>。<br>仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：</p>\n<p>$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ “ \\quad” +DiffID(layerN))$$ </p>\n<h3 id=\"镜像的ImageID\"><a href=\"#镜像的ImageID\" class=\"headerlink\" title=\"镜像的ImageID\"></a>镜像的ImageID</h3><p>每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。</p>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>Tag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即<code>[a-zA-Z0-9_.-]</code>，首个字符不能是<code>.</code>或<code>-</code>。Tag不能超过127个字符。</p>\n<h3 id=\"镜像名（Repository）\"><a href=\"#镜像名（Repository）\" class=\"headerlink\" title=\"镜像名（Repository）\"></a>镜像名（Repository）</h3><p>这里的<code>Repository</code>是指镜像全名在冒号<code>:</code>之前的部分，冒号<code>:</code>之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为<code>my-app:3.1.4</code>的镜像，<code>my-app</code>就是镜像的 Repository 部分。<br>Repository又可以用斜杠<code>/</code>分隔开，<code>/</code>之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 <strong>不得</strong> 包含下划线<code>_</code>字符，主机名可以有如<code>：8080</code>格式的端口号。<br>镜像名可以包含小写字符，数字和分隔符。 分隔符是句点<code>.</code>，一个或两个下划线<code>_</code>，或一个或多个短横线<code>-</code>，镜像名 <strong>不允许</strong> 以分隔符开头或结尾。</p>\n<blockquote>\n<p>译注：</p>\n<ul>\n<li>这里的 Repository 容易与git的 <strong>代码仓库</strong> 概念混淆。</li>\n<li>DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线<code>_</code>，参考<a href=\"https://tools.ietf.org/html/rfc1123\" target=\"_blank\" rel=\"external\">RFC 1123</a></li>\n</ul>\n</blockquote>\n<h2 id=\"镜像的JSON描述文件示例\"><a href=\"#镜像的JSON描述文件示例\" class=\"headerlink\" title=\"镜像的JSON描述文件示例\"></a>镜像的JSON描述文件示例</h2><p>下面是一个镜像的JSON描述文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;architecture&quot;: &quot;amd64&quot;,</div><div class=\"line\">  &quot;author&quot;: &quot;Alyssa P. Hacker &amp;ltalyspdev@example.com&amp;gt&quot;,</div><div class=\"line\">  &quot;config&quot;: &#123;</div><div class=\"line\">    &quot;Cmd&quot;: [</div><div class=\"line\">      &quot;--foreground&quot;,</div><div class=\"line\">      &quot;--config&quot;,</div><div class=\"line\">      &quot;/etc/my-app.d/default.cfg&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;CpuShares&quot;: 8,</div><div class=\"line\">    &quot;Entrypoint&quot;: [</div><div class=\"line\">      &quot;/bin/my-app-binary&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;Env&quot;: [</div><div class=\"line\">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</div><div class=\"line\">      &quot;FOO=docker_is_a_really&quot;,</div><div class=\"line\">      &quot;BAR=great_tool_you_know&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;ExposedPorts&quot;: &#123;</div><div class=\"line\">      &quot;8080/tcp&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;Memory&quot;: 2048,</div><div class=\"line\">    &quot;MemorySwap&quot;: 4096,</div><div class=\"line\">    &quot;User&quot;: &quot;alice&quot;,</div><div class=\"line\">    &quot;Volumes&quot;: &#123;</div><div class=\"line\">      &quot;/var/job-result-data&quot;: &#123;&#125;,</div><div class=\"line\">      &quot;/var/log/my-app-logs&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;WorkingDir&quot;: &quot;/home/alice&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;created&quot;: &quot;2015-10-31T22:22:56.015925234Z&quot;,</div><div class=\"line\">  &quot;history&quot;: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">      &quot;empty_layer&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;os&quot;: &quot;linux&quot;,</div><div class=\"line\">  &quot;rootfs&quot;: &#123;</div><div class=\"line\">    &quot;diff_ids&quot;: [</div><div class=\"line\">      &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">      &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。</p>\n<h2 id=\"镜像的JSON描述文件说明\"><a href=\"#镜像的JSON描述文件说明\" class=\"headerlink\" title=\"镜像的JSON描述文件说明\"></a>镜像的JSON描述文件说明</h2><h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p><code>string</code><br>镜像创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>。</p>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><p><code>string</code><br>创建和负责维护改镜像的人员或组织名，或Email。</p>\n<h3 id=\"architecture\"><a href=\"#architecture\" class=\"headerlink\" title=\"architecture\"></a>architecture</h3><p><code>string</code><br>镜像中可执行文件的CPU架构，可以是 </p>\n<ul>\n<li><code>386</code></li>\n<li><code>amd64</code></li>\n<li><code>arm</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。</li>\n</ul>\n<h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><p><code>string</code><br>镜像运行的操作系统名，可以是 </p>\n<ul>\n<li><code>darwin</code></li>\n<li><code>freebsd</code></li>\n<li><code>linux</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。</li>\n</ul>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p><code>struct</code><br><code>config</code>结构是从镜像创建容器时，使用的基本执行参数。<code>config</code>可以是空值<code>null</code>，则创建容器时必须提供所有必要的执行参数。</p>\n<p><code>config</code>结构的各字段说明</p>\n<h4 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h4><p><code>string</code><br>容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：</p>\n<ul>\n<li><code>user</code></li>\n<li><code>uid</code></li>\n<li><code>user:group</code></li>\n<li><code>uid:gid</code></li>\n<li><code>uid:group</code></li>\n<li><code>user:gid</code></li>\n</ul>\n<p>如果没有给出组名 <code>group</code>/<code>gid</code>，默认的组使用容器中<code>/etc/passwd</code>文件对应的<code>user</code>/<code>uid</code>项。</p>\n<h4 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h4><p><code>integer</code><br>内存限值（以 <strong>字节</strong> 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"MemorySwap\"><a href=\"#MemorySwap\" class=\"headerlink\" title=\"MemorySwap\"></a>MemorySwap</h4><p><code>integer</code><br>总的内存使用量（内存 + swap），设置为<code>-1</code>则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"CpuShares\"><a href=\"#CpuShares\" class=\"headerlink\" title=\"CpuShares\"></a>CpuShares</h4><p><code>integer</code><br>CPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"ExposedPorts\"><a href=\"#ExposedPorts\" class=\"headerlink\" title=\"ExposedPorts\"></a>ExposedPorts</h4><p><code>struct</code><br>基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;8080&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;53/udp&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;2356/tcp&quot;: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的键可以是下面的格式：</p>\n<ul>\n<li><code>&quot;port/tcp&quot;</code></li>\n<li><code>&quot;port/udp&quot;</code></li>\n<li><code>&quot;port&quot;</code><br>如果没有给出协议，默认使用<code>tcp</code>协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。</li>\n</ul>\n<h4 id=\"Env\"><a href=\"#Env\" class=\"headerlink\" title=\"Env\"></a>Env</h4><p><code>array of strings</code><br>Env的每项都是 <code>VARNAME=&quot;var value&quot;</code> 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。</p>\n<h4 id=\"Entrypoint\"><a href=\"#Entrypoint\" class=\"headerlink\" title=\"Entrypoint\"></a>Entrypoint</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。</p>\n<h4 id=\"Cmd\"><a href=\"#Cmd\" class=\"headerlink\" title=\"Cmd\"></a>Cmd</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表（附加在<code>Entrypoint</code>之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出<code>Entrypoint</code>，那么<code>Cmd</code>列表的第一项将被认为是可执行的程序名。</p>\n<h4 id=\"Healthcheck\"><a href=\"#Healthcheck\" class=\"headerlink\" title=\"Healthcheck\"></a>Healthcheck</h4><p><code>struct</code><br>用以检查容器是否正常的测试命令，如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;Test&quot;: [</div><div class=\"line\">      &quot;CMD-SHELL&quot;,</div><div class=\"line\">      &quot;/usr/bin/check-health localhost&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;Interval&quot;: 30000000000,</div><div class=\"line\">  &quot;Timeout&quot;:  10000000000,</div><div class=\"line\">  &quot;Retries&quot;:  3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此结构有如下字段，</p>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h5><p><code>array of strings</code><br>用以检查容器是否正常的测试命令，可以是</p>\n<ul>\n<li><code>[]</code> : 继承父镜像的健康检查命令；</li>\n<li><code>[&quot;NONE&quot;]</code> : 禁用健康检查；</li>\n<li><code>[&quot;CMD&quot;, arg1, arg2, ...]</code> : 直接执行命令和参数；</li>\n<li><code>[&quot;CMD-SHELL&quot;, command]</code> : 使用系统默认shell执行命令；</li>\n</ul>\n<p>如果容器状态正常，测试命令退出后应返回 <code>0</code>，否则返回 <code>1</code>。</p>\n<ul>\n<li>Interval <code>integer</code>：相邻两次尝试的间隔，单位为纳秒；</li>\n<li>Timeout <code>integer</code>：认为异常的超时间隔，单位为纳秒；</li>\n<li>Retries <code>integer</code>：认为异常的重试次数。</li>\n</ul>\n<p>任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。</p>\n<h5 id=\"Volumes\"><a href=\"#Volumes\" class=\"headerlink\" title=\"Volumes\"></a>Volumes</h5><p><code>struct</code><br>创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;/var/my-app-data/&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;/etc/some-config.d/&quot;: &#123;&#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"WorkingDir\"><a href=\"#WorkingDir\" class=\"headerlink\" title=\"WorkingDir\"></a>WorkingDir</h5><p><code>string</code><br>容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。</p>\n<h5 id=\"rootfs\"><a href=\"#rootfs\" class=\"headerlink\" title=\"rootfs\"></a>rootfs</h5><p><code>struct</code><br>rootfs结构是镜像各层的<code>DiffID</code>列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:</p>\n<ul>\n<li><code>type</code>，其值一般为 <code>layers</code>.</li>\n<li><code>diff_ids</code> 各层散列（<code>DiffID</code>）的数组，顺序为从最底层到最顶层。</li>\n</ul>\n<p>下面是 rootfs 的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;rootfs&quot;: &#123;</div><div class=\"line\">  &quot;diff_ids&quot;: [</div><div class=\"line\">    &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">    &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</div><div class=\"line\">    &quot;sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>struct</code><br><code>history</code>结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。</p>\n<ul>\n<li><code>created</code>: 创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>；</li>\n<li><code>author</code>: 创建的作者；</li>\n<li><code>created_by</code>: 创建该层的命令；</li>\n<li><code>comment</code>: 创建该层的注释；</li>\n<li><code>empty_layer</code>: 标识此项历史记录是否会创建一个文件变更集。如果值为<code>true</code>，则此项历史不会对应一个实际的文件集（如<code>ENV</code>命令就对层的文件没有影响）。<br>下面是 history 结构的一个例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;history&quot;: [</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">    &quot;empty_layer&quot;: true</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。</p>\n<h2 id=\"创建镜像文件变更集\"><a href=\"#创建镜像文件变更集\" class=\"headerlink\" title=\"创建镜像文件变更集\"></a>创建镜像文件变更集</h2><p>创建镜像文件变更集的例子如下：<br>首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名<code>c3167915dc9d</code>（层的DiffID是基于目录内的文件内容生成的）。</p>\n<p>然后在其中创建文件和目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">c3167915dc9d/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>将目录<code>c3167915dc9d</code>提交为一个 <code>tar</code> 包（无压缩），其中包含如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">etc/my-app-config</div><div class=\"line\">bin/my-app-binary</div><div class=\"line\">bin/my-app-tools</div></pre></td></tr></table></figure>\n<p>如果要在此基础上更改文件，则创建一个新的目录，假如为<code>f60c56784b83</code>，将其初始化为父镜像的快照，即与目录<code>c3167915dc9d</code>的内容相同。</p>\n<blockquote>\n<p>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure>\n<p>然后添加一个配置目录<code>/etc/my-app.d</code>，其中包含默认的配置文件。可执行程序<code>my-app-tools</code>也更新了，以便处理新的配置文件路径。<br>修改后的目录<code>f60c56784b83</code>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app.d/</div><div class=\"line\">            default.cfg</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>其中移除了<code>/etc/my-app-config</code>，然后创建了新的目录和文件<code>/etc/my-app.d/default.cfg</code>。<code>/bin/my-app-tools</code>也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照<code>f60c56784b83</code>比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加：  /etc/my-app.d/default.cfg</div><div class=\"line\">修改：  /bin/my-app-tools</div><div class=\"line\">删除：  /etc/my-app-config</div></pre></td></tr></table></figure></p>\n<p>创建一个 <strong>仅包含</strong> 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加<code>.wh.</code>前缀（表示已删除）。</p>\n<blockquote>\n<p>注意：无法直接创建以名称<code>.wh.</code>开头的文件或目录。</p>\n</blockquote>\n<p>目录<code>f60c56784b83</code>生成的<code>tar</code> 包中有如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my-app.d/default.cfg</div><div class=\"line\">/bin/my-app-tools</div><div class=\"line\">/etc/.wh.my-app-config</div></pre></td></tr></table></figure>\n<p>任何镜像都是由若干类似的文件变更集的tar包组成的。</p>\n<h2 id=\"镜像的组合格式\"><a href=\"#镜像的组合格式\" class=\"headerlink\" title=\"镜像的组合格式\"></a>镜像的组合格式</h2><p>包含镜像完整内容的单一tar包格式如下：</p>\n<ul>\n<li>镜像名：tag</li>\n<li>镜像的 JSON 配置文件</li>\n<li>各层的tar包</li>\n</ul>\n<p>如镜像<code>library/busybox</code>的组合tar包内容如下（使用<code>tree</code>命令输出）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json</div><div class=\"line\">├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── manifest.json</div><div class=\"line\">└── repositories</div></pre></td></tr></table></figure>\n<p>镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。</p>\n<blockquote>\n<p>注意：该目录名 <strong>不必</strong> 是层的<code>DiffID</code>或<code>ChainID</code>。</p>\n</blockquote>\n<p>每个目录包含3个文件：</p>\n<ul>\n<li><code>VERSION</code> - <code>json</code>文件模式的版本号；</li>\n<li><code>json</code> - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。</li>\n<li><code>layer.tar</code> - 该层的tar包。</li>\n</ul>\n<p>注意：这个目录结构仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件中列出的目录。</p>\n<p><code>VERSION</code>文件只是JSON元数据模式的版本号：<code>1.0</code>。</p>\n<p><code>repositories</code>也是一个JSON文件，包含镜像名和tag列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  </div><div class=\"line\">    &quot;busybox&quot;:&#123;  </div><div class=\"line\">        &quot;latest&quot;:&quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有镜像的<code>repository</code>和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件。</p>\n<p><code>manifest.json</code>文件是顶层镜像的JSON配置。<br>该文件包含以下元数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;Config&quot;: &quot;47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json&quot;,</div><div class=\"line\">    &quot;RepoTags&quot;: [&quot;busybox:latest&quot;],</div><div class=\"line\">    &quot;Layers&quot;: [</div><div class=\"line\">      &quot;a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar&quot;,</div><div class=\"line\">      &quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar&quot;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>上面这个JSON数组中，每项都对应着一个镜像。</p>\n<ul>\n<li><code>Config</code> 指向该镜像的JSON文件；</li>\n<li><code>RepoTags</code> 是该镜像的名称；</li>\n<li><code>Layers</code> 指向镜像各层的 tar 包；</li>\n<li><code>Parent</code> 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 <code>manifest.json</code> 文件中存在。</li>\n</ul>\n<p>不要把 <code>manifest.json</code> 与用来push和pull镜像的分发清单（distribution manifest）相混淆。<br>一般来说，支持v1.2版本镜像规范的实现将使用<code>manifest.json</code>文件，早期的实现仍使用 <code>*/json</code>和<code>repositories</code>文件。</p>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><p>其它相关文档：</p>\n<ul>\n<li><a href=\"https://github.com/opencontainers/image-spec\" target=\"_blank\" rel=\"external\">Open Containers Initiative Image Spec</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md\" target=\"_blank\" rel=\"external\">Image Manifest Version 2, Schema 2</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/api.md\" target=\"_blank\" rel=\"external\">Docker Registry HTTP API V2</a></li>\n<li><a href=\"https://github.com/apache/mesos/blob/master/docs/container-image.md\" target=\"_blank\" rel=\"external\">Supporting Container Images in Mesos Containerizer</a></li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<p>注意：不要把上面的 <strong>镜像格式</strong> 与镜像的 <strong>主机存储布局</strong> 搞混了。</p>\n<ul>\n<li>镜像格式是执行<code>docker save &lt;镜像名或ID&gt;</code>之后得到的对应镜像<code>tar</code>包的格式。</li>\n<li>镜像在主机的存储布局，以及镜像push和pull都 <strong>不会</strong> 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。</li>\n</ul>\n<p>镜像的各层存在顺序依赖，而镜像也有父子继承关系。<br>最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。</p>\n</blockquote>\n<h2 id=\"alpine镜像的主机存储布局\"><a href=\"#alpine镜像的主机存储布局\" class=\"headerlink\" title=\"alpine镜像的主机存储布局\"></a>alpine镜像的主机存储布局</h2><p>alpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。</p>\n<ul>\n<li>./aufs是解开layer.tar后的文件内容；</li>\n<li>./aufs/mnt是容器文件系统的挂载点；</li>\n<li>./containers是创建的容器的读写层；</li>\n<li>./image/aufs/distribution中两个文件夹相当于正反查找的指针；</li>\n<li>./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"># tree /var/lib/docker</div><div class=\"line\">/var/lib/docker</div><div class=\"line\">├── aufs</div><div class=\"line\">│   ├── diff</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   │       ├── bin</div><div class=\"line\">│   │       │   ├── ash -&gt; /bin/busybox</div><div class=\"line\">│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）</div><div class=\"line\">│   ├── layers</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   └── mnt</div><div class=\"line\">│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">├── containers</div><div class=\"line\">├── image</div><div class=\"line\">│   └── aufs</div><div class=\"line\">│       ├── distribution</div><div class=\"line\">│       │   ├── diffid-by-digest</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299</div><div class=\"line\">│       │   └── v2metadata-by-diffid</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       ├── imagedb</div><div class=\"line\">│       │   ├── content</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9</div><div class=\"line\">│       │   └── metadata</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       ├── layerdb</div><div class=\"line\">│       │   ├── sha256</div><div class=\"line\">│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       │   │       ├── cache-id </div><div class=\"line\">│       │   │       ├── diff</div><div class=\"line\">│       │   │       ├── size</div><div class=\"line\">│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件</div><div class=\"line\">│       │   └── tmp</div><div class=\"line\">│       └── repositories.json</div><div class=\"line\">├── network</div><div class=\"line\">│   └── files</div><div class=\"line\">│       └── local-kv.db</div><div class=\"line\">├── plugins</div><div class=\"line\">│   ├── storage</div><div class=\"line\">│   │   └── blobs</div><div class=\"line\">│   │       └── tmp</div><div class=\"line\">│   └── tmp</div><div class=\"line\">├── swarm</div><div class=\"line\">├── tmp</div><div class=\"line\">├── trust</div><div class=\"line\">└── volumes</div><div class=\"line\">    └── metadata.db</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>原文见 <a href=\"https://github.com/moby/moby/blob/master/image/spec/v1.2.md\" target=\"_blank\" rel=\"external\">https://github.com/moby/moby/blob/master/image/spec/v1.2.md</a><br>Docker已经迁移到Moby项目了。</p>","more":"<!-- TOC -->\n<pre><code>- [title: 【译文】Docker镜像格式规范，v1.2](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91docker%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83%EF%BC%8Cv12)\n</code></pre><ul>\n<li><a href=\"#docker%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83v120\">Docker镜像规范v1.2.0</a><ul>\n<li><a href=\"#%E6%9C%AF%E8%AF%AD\">术语</a><ul>\n<li><a href=\"#%E5%B1%82%EF%BC%88layer%EF%BC%89\">层（Layer）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6\">镜像的JSON描述文件</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86%EF%BC%88changeset%EF%BC%89\">镜像文件变更集（changeset）</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84diffid\">层的DiffID</a></li>\n<li><a href=\"#%E5%B1%82%E7%9A%84chainid\">层的ChainID</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84imageid\">镜像的ImageID</a></li>\n<li><a href=\"#%E6%A0%87%E7%AD%BE%EF%BC%88tag%EF%BC%89\">标签（Tag）</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E5%90%8D%EF%BC%88repository%EF%BC%89\">镜像名（Repository）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B\">镜像的JSON描述文件示例</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84json%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E\">镜像的JSON描述文件说明</a><ul>\n<li><a href=\"#created\">created</a></li>\n<li><a href=\"#author\">author</a></li>\n<li><a href=\"#architecture\">architecture</a></li>\n<li><a href=\"#os\">os</a></li>\n<li><a href=\"#config\">config</a><ul>\n<li><a href=\"#user\">User</a></li>\n<li><a href=\"#memory\">Memory</a></li>\n<li><a href=\"#memoryswap\">MemorySwap</a></li>\n<li><a href=\"#cpushares\">CpuShares</a></li>\n<li><a href=\"#exposedports\">ExposedPorts</a></li>\n<li><a href=\"#env\">Env</a></li>\n<li><a href=\"#entrypoint\">Entrypoint</a></li>\n<li><a href=\"#cmd\">Cmd</a></li>\n<li><a href=\"#healthcheck\">Healthcheck</a><ul>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#volumes\">Volumes</a></li>\n<li><a href=\"#workingdir\">WorkingDir</a></li>\n<li><a href=\"#rootfs\">rootfs</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#history\">history</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E9%9B%86\">创建镜像文件变更集</a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A0%BC%E5%BC%8F\">镜像的组合格式</a></li>\n</ul>\n</li>\n<li><a href=\"#todo\">TODO</a></li>\n<li><a href=\"#%E8%A1%A5%E5%85%85\">补充</a><ul>\n<li><a href=\"#alpine%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80\">alpine镜像的主机存储布局</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"Docker镜像规范v1-2-0\"><a href=\"#Docker镜像规范v1-2-0\" class=\"headerlink\" title=\"Docker镜像规范v1.2.0\"></a>Docker镜像规范v1.2.0</h1><p><strong>镜像（Image）</strong>是在基础文件集（root filesystem）之上依次变更的集合，及在容器运行的默认执行参数。本规范概述这些文件变更及执行参数的格式，创建和使用它们的方法。<br>此版本的镜像规范自Docker 1.12开始采用。</p>\n<blockquote>\n<p>译注：本规范中的 <strong>filesystem</strong> 并非通常意义的文件系统，实际上只是一组文件及文件夹的集合，故译为 <strong>文件集</strong>。</p>\n</blockquote>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>本规范使用以下术语:</p>\n<h3 id=\"层（Layer）\"><a href=\"#层（Layer）\" class=\"headerlink\" title=\"层（Layer）\"></a>层（Layer）</h3><p>镜像由 <strong>层</strong> 组成。 每一层都是若干文件的变更集合。层不包含环境变量或默认参数等元数据。这些元数据是镜像整体的属性，而不是特定层的。</p>\n<h3 id=\"镜像的JSON描述文件\"><a href=\"#镜像的JSON描述文件\" class=\"headerlink\" title=\"镜像的JSON描述文件\"></a>镜像的JSON描述文件</h3><p>整个镜像有一个JSON描述文件，它包含镜像的基本信息，如创建的日期、作者、父镜像的ID、以及启动/运行的配置（如入口命令、默认参数、CPU / 内存份额、网络和数据卷等）。JSON文件还列出了组成镜像的每个层的加密散列及其命令历史。<br>该JSON文件是不可变的，更改它会导致重新计算整个镜像的ImageID（译注：见下面ImageID的计算方法小节），这意味着派生出一个新的镜像，而不是改变现有的镜像。</p>\n<h3 id=\"镜像文件变更集（changeset）\"><a href=\"#镜像文件变更集（changeset）\" class=\"headerlink\" title=\"镜像文件变更集（changeset）\"></a>镜像文件变更集（changeset）</h3><p>每个层都是一组在其父层之上增加、修改或删除文件的归档。使用分层或联合文件系统（如AUFS），或通过从文件系统快照计算差异（Diff），可以将一系列的层（即文件变更集）合并成一个虚拟的单层文件集合（one cohesive filesystem）。</p>\n<h3 id=\"层的DiffID\"><a href=\"#层的DiffID\" class=\"headerlink\" title=\"层的DiffID\"></a>层的DiffID</h3><p>将一个层的所有文件内容序列化后，计算出一个加密散列来作为该层的标识。具体是将层打包为一个<code>tar</code>包，然后计算其SHA256摘要，用十六进制编码表示长度为256比特的串（共64个字符），<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>层的打包和解包必须是可重复的，以免更改层的ID，例如，应使用<code>tar-split</code>来保存tar包的header。注意，层的ID是基于未压缩的tar包计算的。</p>\n<blockquote>\n<p>译注：关于层的打包和解包的可重复性，<code>tar</code>程序将一组文件打包的 <strong>顺序</strong> 是与文件系统相关的，此处没有详细说明可重复性的实现方式，可参考Docker源码深入了解。<br>参考：<a href=\"https://unix.stackexchange.com/questions/120143/how-is-the-order-in-which-tar-works-on-files-determined\" target=\"_blank\" rel=\"external\">tar打包的顺序</a>。</p>\n</blockquote>\n<h3 id=\"层的ChainID\"><a href=\"#层的ChainID\" class=\"headerlink\" title=\"层的ChainID\"></a>层的ChainID</h3><p>为方便起见，可以给一串有序的层计算出一个ID，称为 <strong>ChainID</strong>。<br>仅有一个层时，其ChainID与该层的DiffID相同。多个层时，其ChainID由下面的递归公式给出：</p>\n<p>$$ChainID(layerN)=SHA256hex(ChainID(layer(N-1))+ “ \\quad” +DiffID(layerN))$$ </p>\n<h3 id=\"镜像的ImageID\"><a href=\"#镜像的ImageID\" class=\"headerlink\" title=\"镜像的ImageID\"></a>镜像的ImageID</h3><p>每个镜像的ID是其JSON描述文件的SHA256散列值，用十六进制编码表示，<br>如<code>sha256:a9561eb1b190625c9adb5a9513e72c4dedafc1cb2d4c5236c9a6957ec7dfd5a9</code>。<br>由于JSON文件包含镜像所有层的散列ID，据此计算出的ImageID，使得可以对镜像的即各层按内容寻址（Content Addressable，地址即各层的DiffID）。</p>\n<h3 id=\"标签（Tag）\"><a href=\"#标签（Tag）\" class=\"headerlink\" title=\"标签（Tag）\"></a>标签（Tag）</h3><p>Tag是用户为ImageID指定的说明文字。Tag中的字符只能是大小写英文字母、数字、短线、下划线和点，即<code>[a-zA-Z0-9_.-]</code>，首个字符不能是<code>.</code>或<code>-</code>。Tag不能超过127个字符。</p>\n<h3 id=\"镜像名（Repository）\"><a href=\"#镜像名（Repository）\" class=\"headerlink\" title=\"镜像名（Repository）\"></a>镜像名（Repository）</h3><p>这里的<code>Repository</code>是指镜像全名在冒号<code>:</code>之前的部分，冒号<code>:</code>之后的部分是镜像的标签（tag），用来区分镜像的版本。 如名为<code>my-app:3.1.4</code>的镜像，<code>my-app</code>就是镜像的 Repository 部分。<br>Repository又可以用斜杠<code>/</code>分隔开，<code>/</code>之前的部分是可选的DNS格式的主机名。主机名必须符合DNS规则，但 <strong>不得</strong> 包含下划线<code>_</code>字符，主机名可以有如<code>：8080</code>格式的端口号。<br>镜像名可以包含小写字符，数字和分隔符。 分隔符是句点<code>.</code>，一个或两个下划线<code>_</code>，或一个或多个短横线<code>-</code>，镜像名 <strong>不允许</strong> 以分隔符开头或结尾。</p>\n<blockquote>\n<p>译注：</p>\n<ul>\n<li>这里的 Repository 容易与git的 <strong>代码仓库</strong> 概念混淆。</li>\n<li>DNS名和主机名的格式稍有不同，一般来说，主机名不允许使用下划线<code>_</code>，参考<a href=\"https://tools.ietf.org/html/rfc1123\" target=\"_blank\" rel=\"external\">RFC 1123</a></li>\n</ul>\n</blockquote>\n<h2 id=\"镜像的JSON描述文件示例\"><a href=\"#镜像的JSON描述文件示例\" class=\"headerlink\" title=\"镜像的JSON描述文件示例\"></a>镜像的JSON描述文件示例</h2><p>下面是一个镜像的JSON描述文件示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;architecture&quot;: &quot;amd64&quot;,</div><div class=\"line\">  &quot;author&quot;: &quot;Alyssa P. Hacker &amp;ltalyspdev@example.com&amp;gt&quot;,</div><div class=\"line\">  &quot;config&quot;: &#123;</div><div class=\"line\">    &quot;Cmd&quot;: [</div><div class=\"line\">      &quot;--foreground&quot;,</div><div class=\"line\">      &quot;--config&quot;,</div><div class=\"line\">      &quot;/etc/my-app.d/default.cfg&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;CpuShares&quot;: 8,</div><div class=\"line\">    &quot;Entrypoint&quot;: [</div><div class=\"line\">      &quot;/bin/my-app-binary&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;Env&quot;: [</div><div class=\"line\">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</div><div class=\"line\">      &quot;FOO=docker_is_a_really&quot;,</div><div class=\"line\">      &quot;BAR=great_tool_you_know&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;ExposedPorts&quot;: &#123;</div><div class=\"line\">      &quot;8080/tcp&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;Memory&quot;: 2048,</div><div class=\"line\">    &quot;MemorySwap&quot;: 4096,</div><div class=\"line\">    &quot;User&quot;: &quot;alice&quot;,</div><div class=\"line\">    &quot;Volumes&quot;: &#123;</div><div class=\"line\">      &quot;/var/job-result-data&quot;: &#123;&#125;,</div><div class=\"line\">      &quot;/var/log/my-app-logs&quot;: &#123;&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;WorkingDir&quot;: &quot;/home/alice&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &quot;created&quot;: &quot;2015-10-31T22:22:56.015925234Z&quot;,</div><div class=\"line\">  &quot;history&quot;: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">      &quot;empty_layer&quot;: true</div><div class=\"line\">    &#125;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;os&quot;: &quot;linux&quot;,</div><div class=\"line\">  &quot;rootfs&quot;: &#123;</div><div class=\"line\">    &quot;diff_ids&quot;: [</div><div class=\"line\">      &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">      &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</div><div class=\"line\">    ],</div><div class=\"line\">    &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，Docker生成的镜像JSON描述文件不包含为了格式化而插入的空格，这里是为了方便阅读。</p>\n<h2 id=\"镜像的JSON描述文件说明\"><a href=\"#镜像的JSON描述文件说明\" class=\"headerlink\" title=\"镜像的JSON描述文件说明\"></a>镜像的JSON描述文件说明</h2><h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p><code>string</code><br>镜像创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>。</p>\n<h3 id=\"author\"><a href=\"#author\" class=\"headerlink\" title=\"author\"></a>author</h3><p><code>string</code><br>创建和负责维护改镜像的人员或组织名，或Email。</p>\n<h3 id=\"architecture\"><a href=\"#architecture\" class=\"headerlink\" title=\"architecture\"></a>architecture</h3><p><code>string</code><br>镜像中可执行文件的CPU架构，可以是 </p>\n<ul>\n<li><code>386</code></li>\n<li><code>amd64</code></li>\n<li><code>arm</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些架构。</li>\n</ul>\n<h3 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h3><p><code>string</code><br>镜像运行的操作系统名，可以是 </p>\n<ul>\n<li><code>darwin</code></li>\n<li><code>freebsd</code></li>\n<li><code>linux</code><br>未来可能会支持更多的架构，有的容器引擎可能不支持某些操作系统。</li>\n</ul>\n<h3 id=\"config\"><a href=\"#config\" class=\"headerlink\" title=\"config\"></a>config</h3><p><code>struct</code><br><code>config</code>结构是从镜像创建容器时，使用的基本执行参数。<code>config</code>可以是空值<code>null</code>，则创建容器时必须提供所有必要的执行参数。</p>\n<p><code>config</code>结构的各字段说明</p>\n<h4 id=\"User\"><a href=\"#User\" class=\"headerlink\" title=\"User\"></a>User</h4><p><code>string</code><br>容器中进程执行使用的用户名或UID。如果创建容器时没有在命令行给出，将使用此配置项的值。下面的格式都是有效的：</p>\n<ul>\n<li><code>user</code></li>\n<li><code>uid</code></li>\n<li><code>user:group</code></li>\n<li><code>uid:gid</code></li>\n<li><code>uid:group</code></li>\n<li><code>user:gid</code></li>\n</ul>\n<p>如果没有给出组名 <code>group</code>/<code>gid</code>，默认的组使用容器中<code>/etc/passwd</code>文件对应的<code>user</code>/<code>uid</code>项。</p>\n<h4 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h4><p><code>integer</code><br>内存限值（以 <strong>字节</strong> 为单位）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"MemorySwap\"><a href=\"#MemorySwap\" class=\"headerlink\" title=\"MemorySwap\"></a>MemorySwap</h4><p><code>integer</code><br>总的内存使用量（内存 + swap），设置为<code>-1</code>则禁用 swap。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"CpuShares\"><a href=\"#CpuShares\" class=\"headerlink\" title=\"CpuShares\"></a>CpuShares</h4><p><code>integer</code><br>CPU份额（相对其它容器的权重）。如果创建容器时没有在命令行给出，则使用此配置项的值。</p>\n<h4 id=\"ExposedPorts\"><a href=\"#ExposedPorts\" class=\"headerlink\" title=\"ExposedPorts\"></a>ExposedPorts</h4><p><code>struct</code><br>基于此镜像创建的容器公开的端口列表。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;8080&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;53/udp&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;2356/tcp&quot;: &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中的键可以是下面的格式：</p>\n<ul>\n<li><code>&quot;port/tcp&quot;</code></li>\n<li><code>&quot;port/udp&quot;</code></li>\n<li><code>&quot;port&quot;</code><br>如果没有给出协议，默认使用<code>tcp</code>协议。这是创建容器使用的默认值，可以与命令行提供的端口列表合并。</li>\n</ul>\n<h4 id=\"Env\"><a href=\"#Env\" class=\"headerlink\" title=\"Env\"></a>Env</h4><p><code>array of strings</code><br>Env的每项都是 <code>VARNAME=&quot;var value&quot;</code> 的格式。这是创建容器使用的默认值，可以与命令行提供的环境变量列表合并。</p>\n<h4 id=\"Entrypoint\"><a href=\"#Entrypoint\" class=\"headerlink\" title=\"Entrypoint\"></a>Entrypoint</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。</p>\n<h4 id=\"Cmd\"><a href=\"#Cmd\" class=\"headerlink\" title=\"Cmd\"></a>Cmd</h4><p><code>array of strings</code><br>容器启动时执行的命令参数列表（附加在<code>Entrypoint</code>之后）。这是创建容器使用的默认值，可以被命令行提供的入口命令替换。如果没有给出<code>Entrypoint</code>，那么<code>Cmd</code>列表的第一项将被认为是可执行的程序名。</p>\n<h4 id=\"Healthcheck\"><a href=\"#Healthcheck\" class=\"headerlink\" title=\"Healthcheck\"></a>Healthcheck</h4><p><code>struct</code><br>用以检查容器是否正常的测试命令，如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;Test&quot;: [</div><div class=\"line\">      &quot;CMD-SHELL&quot;,</div><div class=\"line\">      &quot;/usr/bin/check-health localhost&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;Interval&quot;: 30000000000,</div><div class=\"line\">  &quot;Timeout&quot;:  10000000000,</div><div class=\"line\">  &quot;Retries&quot;:  3</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此结构有如下字段，</p>\n<h5 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h5><p><code>array of strings</code><br>用以检查容器是否正常的测试命令，可以是</p>\n<ul>\n<li><code>[]</code> : 继承父镜像的健康检查命令；</li>\n<li><code>[&quot;NONE&quot;]</code> : 禁用健康检查；</li>\n<li><code>[&quot;CMD&quot;, arg1, arg2, ...]</code> : 直接执行命令和参数；</li>\n<li><code>[&quot;CMD-SHELL&quot;, command]</code> : 使用系统默认shell执行命令；</li>\n</ul>\n<p>如果容器状态正常，测试命令退出后应返回 <code>0</code>，否则返回 <code>1</code>。</p>\n<ul>\n<li>Interval <code>integer</code>：相邻两次尝试的间隔，单位为纳秒；</li>\n<li>Timeout <code>integer</code>：认为异常的超时间隔，单位为纳秒；</li>\n<li>Retries <code>integer</code>：认为异常的重试次数。</li>\n</ul>\n<p>任何缺失的值都会从基础镜像继承。这是创建容器使用的默认值，可以与命令行提供的值合并（替代？）。</p>\n<h5 id=\"Volumes\"><a href=\"#Volumes\" class=\"headerlink\" title=\"Volumes\"></a>Volumes</h5><p><code>struct</code><br>创建容器时作为数据卷的一组目录。此JSON结构的特殊之处在于它是由Go语言的<code>map[string]struct{}</code>结构直接序列化为JSON格式的，形式为每个键对应着 <strong>值为空对象{}</strong> 的JSON对象。如下面的例子所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    &quot;/var/my-app-data/&quot;: &#123;&#125;,</div><div class=\"line\">    &quot;/etc/some-config.d/&quot;: &#123;&#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"WorkingDir\"><a href=\"#WorkingDir\" class=\"headerlink\" title=\"WorkingDir\"></a>WorkingDir</h5><p><code>string</code><br>容器入口程序的工作目录，这是创建容器使用的默认值，可以被命令行提供的值替代。</p>\n<h5 id=\"rootfs\"><a href=\"#rootfs\" class=\"headerlink\" title=\"rootfs\"></a>rootfs</h5><p><code>struct</code><br>rootfs结构是镜像各层的<code>DiffID</code>列表，此结构使镜像的描述文件的散列与各层的散列（及内容）相对应。rootfs有两个字段:</p>\n<ul>\n<li><code>type</code>，其值一般为 <code>layers</code>.</li>\n<li><code>diff_ids</code> 各层散列（<code>DiffID</code>）的数组，顺序为从最底层到最顶层。</li>\n</ul>\n<p>下面是 rootfs 的一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;rootfs&quot;: &#123;</div><div class=\"line\">  &quot;diff_ids&quot;: [</div><div class=\"line\">    &quot;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&quot;,</div><div class=\"line\">    &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</div><div class=\"line\">    &quot;sha256:13f53e08df5a220ab6d13c58b2bf83a59cbdc2e04d0a3f041ddf4b0ba4112d49&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;type&quot;: &quot;layers&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h3><p><code>struct</code><br><code>history</code>结构是描述每层历史的一组对象，顺序为从最底层到最顶层。每个对象有以下字段。</p>\n<ul>\n<li><code>created</code>: 创建的日期和时间，<a href=\"https://zh.wikipedia.org/wiki/ISO_8601\" target=\"_blank\" rel=\"external\">ISO-8601格式</a>；</li>\n<li><code>author</code>: 创建的作者；</li>\n<li><code>created_by</code>: 创建该层的命令；</li>\n<li><code>comment</code>: 创建该层的注释；</li>\n<li><code>empty_layer</code>: 标识此项历史记录是否会创建一个文件变更集。如果值为<code>true</code>，则此项历史不会对应一个实际的文件集（如<code>ENV</code>命令就对层的文件没有影响）。<br>下面是 history 结构的一个例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;history&quot;: [</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:54.690851953Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:a3bc1e842b69636f9df5256c49c5374fb4eef1e281fe3f282c65fb853ee171c5 in /&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;created&quot;: &quot;2015-10-31T22:22:55.613815829Z&quot;,</div><div class=\"line\">    &quot;created_by&quot;: &quot;/bin/sh -c #(nop) CMD [\\&quot;sh\\&quot;]&quot;,</div><div class=\"line\">    &quot;empty_layer&quot;: true</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>镜像的JSON文件中任何额外的字段应被认为是特定于实现的，如果无法处理，应该将其忽略。</p>\n<h2 id=\"创建镜像文件变更集\"><a href=\"#创建镜像文件变更集\" class=\"headerlink\" title=\"创建镜像文件变更集\"></a>创建镜像文件变更集</h2><p>创建镜像文件变更集的例子如下：<br>首先，镜像的基础文件是一个空的目录，使用了随机生成的目录名<code>c3167915dc9d</code>（层的DiffID是基于目录内的文件内容生成的）。</p>\n<p>然后在其中创建文件和目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">c3167915dc9d/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>将目录<code>c3167915dc9d</code>提交为一个 <code>tar</code> 包（无压缩），其中包含如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">etc/my-app-config</div><div class=\"line\">bin/my-app-binary</div><div class=\"line\">bin/my-app-tools</div></pre></td></tr></table></figure>\n<p>如果要在此基础上更改文件，则创建一个新的目录，假如为<code>f60c56784b83</code>，将其初始化为父镜像的快照，即与目录<code>c3167915dc9d</code>的内容相同。</p>\n<blockquote>\n<p>注意：支持 Copy-on-Write 或联合机制的文件系统创建快照很高效。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app-config</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure>\n<p>然后添加一个配置目录<code>/etc/my-app.d</code>，其中包含默认的配置文件。可执行程序<code>my-app-tools</code>也更新了，以便处理新的配置文件路径。<br>修改后的目录<code>f60c56784b83</code>如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">f60c56784b83/</div><div class=\"line\">    etc/</div><div class=\"line\">        my-app.d/</div><div class=\"line\">            default.cfg</div><div class=\"line\">    bin/</div><div class=\"line\">        my-app-binary</div><div class=\"line\">        my-app-tools</div></pre></td></tr></table></figure></p>\n<p>其中移除了<code>/etc/my-app-config</code>，然后创建了新的目录和文件<code>/etc/my-app.d/default.cfg</code>。<code>/bin/my-app-tools</code>也替换成新的版本。在将此目录提交为变更集之前，首先需要与其父镜像的快照<code>f60c56784b83</code>比较，找出增加、修改及删除的文件和目录。本例中找到如下的变更集：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">增加：  /etc/my-app.d/default.cfg</div><div class=\"line\">修改：  /bin/my-app-tools</div><div class=\"line\">删除：  /etc/my-app-config</div></pre></td></tr></table></figure></p>\n<p>创建一个 <strong>仅包含</strong> 此变更集的tar包：增加和修改的文件内容及目录被完整地包含在tar包中；而删除的项则对应为相同路径的空文件，其文件名或目录名增加<code>.wh.</code>前缀（表示已删除）。</p>\n<blockquote>\n<p>注意：无法直接创建以名称<code>.wh.</code>开头的文件或目录。</p>\n</blockquote>\n<p>目录<code>f60c56784b83</code>生成的<code>tar</code> 包中有如下的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my-app.d/default.cfg</div><div class=\"line\">/bin/my-app-tools</div><div class=\"line\">/etc/.wh.my-app-config</div></pre></td></tr></table></figure>\n<p>任何镜像都是由若干类似的文件变更集的tar包组成的。</p>\n<h2 id=\"镜像的组合格式\"><a href=\"#镜像的组合格式\" class=\"headerlink\" title=\"镜像的组合格式\"></a>镜像的组合格式</h2><p>包含镜像完整内容的单一tar包格式如下：</p>\n<ul>\n<li>镜像名：tag</li>\n<li>镜像的 JSON 配置文件</li>\n<li>各层的tar包</li>\n</ul>\n<p>如镜像<code>library/busybox</code>的组合tar包内容如下（使用<code>tree</code>命令输出）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── 47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json</div><div class=\"line\">├── 5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198</div><div class=\"line\">│   ├── VERSION</div><div class=\"line\">│   ├── json</div><div class=\"line\">│   └── layer.tar</div><div class=\"line\">├── manifest.json</div><div class=\"line\">└── repositories</div></pre></td></tr></table></figure>\n<p>镜像的每层都对应一个目录，其名称是64个十六进制的字符，是根据该层的文件内容确定性地生成的。</p>\n<blockquote>\n<p>注意：该目录名 <strong>不必</strong> 是层的<code>DiffID</code>或<code>ChainID</code>。</p>\n</blockquote>\n<p>每个目录包含3个文件：</p>\n<ul>\n<li><code>VERSION</code> - <code>json</code>文件模式的版本号；</li>\n<li><code>json</code> - 旧的JSON格式镜像层元数据。v1.2版的镜像规范中，各层没有JSON元数据，但在v1版中是存在的。此文件是为了向后兼容v1版格式。</li>\n<li><code>layer.tar</code> - 该层的tar包。</li>\n</ul>\n<p>注意：这个目录结构仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件中列出的目录。</p>\n<p><code>VERSION</code>文件只是JSON元数据模式的版本号：<code>1.0</code>。</p>\n<p><code>repositories</code>也是一个JSON文件，包含镜像名和tag列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  </div><div class=\"line\">    &quot;busybox&quot;:&#123;  </div><div class=\"line\">        &quot;latest&quot;:&quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有镜像的<code>repository</code>和一组tag列表。每个tag关联着镜像的 ID。该文件仅用于向后兼容。当前的实现使用<code>manifest.json</code>文件。</p>\n<p><code>manifest.json</code>文件是顶层镜像的JSON配置。<br>该文件包含以下元数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123;</div><div class=\"line\">    &quot;Config&quot;: &quot;47bcc53f74dc94b1920f0b34f6036096526296767650f223433fe65c35f149eb.json&quot;,</div><div class=\"line\">    &quot;RepoTags&quot;: [&quot;busybox:latest&quot;],</div><div class=\"line\">    &quot;Layers&quot;: [</div><div class=\"line\">      &quot;a65da33792c5187473faa80fa3e1b975acba06712852d1dea860692ccddf3198/layer.tar&quot;,</div><div class=\"line\">      &quot;5f29f704785248ddb9d06b90a11b5ea36c534865e9035e4022bb2e71d4ecbb9a/layer.tar&quot;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>上面这个JSON数组中，每项都对应着一个镜像。</p>\n<ul>\n<li><code>Config</code> 指向该镜像的JSON文件；</li>\n<li><code>RepoTags</code> 是该镜像的名称；</li>\n<li><code>Layers</code> 指向镜像各层的 tar 包；</li>\n<li><code>Parent</code> 可选，指向其父镜像的 imageID，父镜像的ID必须在同一个 <code>manifest.json</code> 文件中存在。</li>\n</ul>\n<p>不要把 <code>manifest.json</code> 与用来push和pull镜像的分发清单（distribution manifest）相混淆。<br>一般来说，支持v1.2版本镜像规范的实现将使用<code>manifest.json</code>文件，早期的实现仍使用 <code>*/json</code>和<code>repositories</code>文件。</p>\n<h1 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h1><p>其它相关文档：</p>\n<ul>\n<li><a href=\"https://github.com/opencontainers/image-spec\" target=\"_blank\" rel=\"external\">Open Containers Initiative Image Spec</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md\" target=\"_blank\" rel=\"external\">Image Manifest Version 2, Schema 2</a></li>\n<li><a href=\"https://github.com/docker/distribution/blob/master/docs/spec/api.md\" target=\"_blank\" rel=\"external\">Docker Registry HTTP API V2</a></li>\n<li><a href=\"https://github.com/apache/mesos/blob/master/docs/container-image.md\" target=\"_blank\" rel=\"external\">Supporting Container Images in Mesos Containerizer</a></li>\n</ul>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><blockquote>\n<p>注意：不要把上面的 <strong>镜像格式</strong> 与镜像的 <strong>主机存储布局</strong> 搞混了。</p>\n<ul>\n<li>镜像格式是执行<code>docker save &lt;镜像名或ID&gt;</code>之后得到的对应镜像<code>tar</code>包的格式。</li>\n<li>镜像在主机的存储布局，以及镜像push和pull都 <strong>不会</strong> 用到打包成一个文件的镜像，因为这样不利于多个层并行加速下载和利用本地缓存的层。</li>\n</ul>\n<p>镜像的各层存在顺序依赖，而镜像也有父子继承关系。<br>最初Docker只支持AUFS存储驱动，但AUFS没有合并到Linux内核，虽然Ubuntu内置了AUFS，但RHEL/CentOS则需要添加对应的内核模块。目前Docker在RHEL/CentOS默认使用OverlayFS作为存储驱动。OverlayFS只支持上下两层，所以其主机存储布局与AUFS不同，但镜像格式不受影响。</p>\n</blockquote>\n<h2 id=\"alpine镜像的主机存储布局\"><a href=\"#alpine镜像的主机存储布局\" class=\"headerlink\" title=\"alpine镜像的主机存储布局\"></a>alpine镜像的主机存储布局</h2><p>alpine镜像仅有一个层，比较简单。Ubuntu使用AUFS存储驱动的文件布局如下。layer.tar包 已经被解开了。</p>\n<ul>\n<li>./aufs是解开layer.tar后的文件内容；</li>\n<li>./aufs/mnt是容器文件系统的挂载点；</li>\n<li>./containers是创建的容器的读写层；</li>\n<li>./image/aufs/distribution中两个文件夹相当于正反查找的指针；</li>\n<li>./image/aufs/imagedb/content/sha256/[id] 接近镜像的JSON描述文件，但与上面的v1.2规范不完全一致；</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"># tree /var/lib/docker</div><div class=\"line\">/var/lib/docker</div><div class=\"line\">├── aufs</div><div class=\"line\">│   ├── diff</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   │       ├── bin</div><div class=\"line\">│   │       │   ├── ash -&gt; /bin/busybox</div><div class=\"line\">│   │       │  # ... alpine镜像中的文件列表（大部分是指向/bin/busybox的软链接）</div><div class=\"line\">│   ├── layers</div><div class=\"line\">│   │   └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">│   └── mnt</div><div class=\"line\">│       └── 0b9c9a223af5f795049b86fc4f3dace61a44ced8a08a3cc8ccad0699eecec951</div><div class=\"line\">├── containers</div><div class=\"line\">├── image</div><div class=\"line\">│   └── aufs</div><div class=\"line\">│       ├── distribution</div><div class=\"line\">│       │   ├── diffid-by-digest</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── cfc728c1c5584d8e0ae69368fc9c34d54d72651355573ba42554c2469a0a6299</div><div class=\"line\">│       │   └── v2metadata-by-diffid</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       │           └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       ├── imagedb</div><div class=\"line\">│       │   ├── content</div><div class=\"line\">│       │   │   └── sha256</div><div class=\"line\">│       │   │       └── 02674b9cb179d57c68b526733adf38b458bd31ba0abff0c2bf5ceca5bad72cd9</div><div class=\"line\">│       │   └── metadata</div><div class=\"line\">│       │       └── sha256</div><div class=\"line\">│       ├── layerdb</div><div class=\"line\">│       │   ├── sha256</div><div class=\"line\">│       │   │   └── e154057080f406372ebecadc0bfb5ff8a7982a0d13823bab1be5b86926c6f860</div><div class=\"line\">│       │   │       ├── cache-id </div><div class=\"line\">│       │   │       ├── diff</div><div class=\"line\">│       │   │       ├── size</div><div class=\"line\">│       │   │       └── tar-split.json.gz # 如果是中间层，此处会有 parent 文件</div><div class=\"line\">│       │   └── tmp</div><div class=\"line\">│       └── repositories.json</div><div class=\"line\">├── network</div><div class=\"line\">│   └── files</div><div class=\"line\">│       └── local-kv.db</div><div class=\"line\">├── plugins</div><div class=\"line\">│   ├── storage</div><div class=\"line\">│   │   └── blobs</div><div class=\"line\">│   │       └── tmp</div><div class=\"line\">│   └── tmp</div><div class=\"line\">├── swarm</div><div class=\"line\">├── tmp</div><div class=\"line\">├── trust</div><div class=\"line\">└── volumes</div><div class=\"line\">    └── metadata.db</div></pre></td></tr></table></figure>"},{"title":"CCF目录单页版","date":"2017-02-24T16:00:00.000Z","_content":"CCF目录有[网页版](http://history.ccf.org.cn/sites/ccf/paiming.jsp)和[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)。\n前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。\nMarkdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 **[CCF目录完整列表2017-02-25](/doc/ccf-all-in-one-2017-02-25.html)** 。\n此外还有 **[Excel格式](/doc/ccf_all_in_one_2017-02-25.xlsx)**。\n\nCCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是[CCF目录](http://webtest.ccf.org.cn/xspj/gyml/) ，HTML版不太完整，而且没有提供PDF文件。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n- [CCF目录中存在的问题](#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [同一刊物同时被列入不同方向](#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91)\n    - [同一方向中的重复会议](#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE)\n\n<!-- /TOC -->\n\n# 说明\n表格中的类别简写分别是:\n+ AI：人工智能\n+ 系统：计算机体系结构/并行与分布计算/存储系统\n+ 软工：软件工程/系统软件/程序设计语言\n+ 数据库：数据库/数据检索/内容检索\n+ 安全：网络与信息安全\n+ 多媒体：计算机图形学与多媒体\n+ 网络：计算机网络\n+ 理论：计算机科学理论\n+ 其它：交叉/综合/新兴\n+ 交互：人机交互与普适计算\n\n表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。\n\n# CCF目录中存在的问题\n\n## 同一刊物同时被列入不同方向\n多个研究方向经常出现交叉，所以这种情况也是可以接受的。\n\n+ B类刊物 `DKE: Data and Knowledge Engineering` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IJIS: International Journal of Intelligent Systems` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IPL: Information Processing Letters` 分别被列入了 理论 和 数据库 方向\n+ B类刊物 `TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications` 分别被列入了 网络 和 多媒体 方向\n\n## 同一方向中的重复会议\n+ 安全方向的 C类会议 `ASIACCS`和 A类会议 `CCS`给出的链接都是 [http://dblp.org/db/conf/ccs/] ，这个不是错误，因为dblp上确实是在同一页面显示了 `ASIACCS` 和 `CCS`，不过列表中 `ASIACCS`的全称不太恰当\n+ 交互方向的 C类会议 `DIS: ACM Conference on Designing Interactive  Systems` 在第2条和第11条重复出现了两次\n\n<img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\">\n","source":"_posts/ccf-all-in-one.md","raw":"title: CCF目录单页版\ncategory: [misc]\ntags:\ndate: 2017-02-25\n\n---\nCCF目录有[网页版](http://history.ccf.org.cn/sites/ccf/paiming.jsp)和[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)。\n前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。\nMarkdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 **[CCF目录完整列表2017-02-25](/doc/ccf-all-in-one-2017-02-25.html)** 。\n此外还有 **[Excel格式](/doc/ccf_all_in_one_2017-02-25.xlsx)**。\n\nCCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是[CCF目录](http://webtest.ccf.org.cn/xspj/gyml/) ，HTML版不太完整，而且没有提供PDF文件。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n- [CCF目录中存在的问题](#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [同一刊物同时被列入不同方向](#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91)\n    - [同一方向中的重复会议](#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE)\n\n<!-- /TOC -->\n\n# 说明\n表格中的类别简写分别是:\n+ AI：人工智能\n+ 系统：计算机体系结构/并行与分布计算/存储系统\n+ 软工：软件工程/系统软件/程序设计语言\n+ 数据库：数据库/数据检索/内容检索\n+ 安全：网络与信息安全\n+ 多媒体：计算机图形学与多媒体\n+ 网络：计算机网络\n+ 理论：计算机科学理论\n+ 其它：交叉/综合/新兴\n+ 交互：人机交互与普适计算\n\n表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。\n\n# CCF目录中存在的问题\n\n## 同一刊物同时被列入不同方向\n多个研究方向经常出现交叉，所以这种情况也是可以接受的。\n\n+ B类刊物 `DKE: Data and Knowledge Engineering` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IJIS: International Journal of Intelligent Systems` 分别被列入了 AI 和 数据库 方向\n+ C类刊物 `IPL: Information Processing Letters` 分别被列入了 理论 和 数据库 方向\n+ B类刊物 `TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications` 分别被列入了 网络 和 多媒体 方向\n\n## 同一方向中的重复会议\n+ 安全方向的 C类会议 `ASIACCS`和 A类会议 `CCS`给出的链接都是 [http://dblp.org/db/conf/ccs/] ，这个不是错误，因为dblp上确实是在同一页面显示了 `ASIACCS` 和 `CCS`，不过列表中 `ASIACCS`的全称不太恰当\n+ 交互方向的 C类会议 `DIS: ACM Conference on Designing Interactive  Systems` 在第2条和第11条重复出现了两次\n\n<img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\">\n","slug":"ccf-all-in-one","published":1,"updated":"2017-10-30T02:48:06.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgq00059s4f3yzvt8hk","content":"<p>CCF目录有<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">网页版</a>和<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>。<br>前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。<br>Markdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 <strong><a href=\"/doc/ccf-all-in-one-2017-02-25.html\">CCF目录完整列表2017-02-25</a></strong> 。<br>此外还有 <strong><a href=\"/doc/ccf_all_in_one_2017-02-25.xlsx\">Excel格式</a></strong>。</p>\n<p>CCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是<a href=\"http://webtest.ccf.org.cn/xspj/gyml/\" target=\"_blank\" rel=\"external\">CCF目录</a> ，HTML版不太完整，而且没有提供PDF文件。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a></li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\">CCF目录中存在的问题</a><ul>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91\">同一刊物同时被列入不同方向</a></li>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE\">同一方向中的重复会议</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>表格中的类别简写分别是:</p>\n<ul>\n<li>AI：人工智能</li>\n<li>系统：计算机体系结构/并行与分布计算/存储系统</li>\n<li>软工：软件工程/系统软件/程序设计语言</li>\n<li>数据库：数据库/数据检索/内容检索</li>\n<li>安全：网络与信息安全</li>\n<li>多媒体：计算机图形学与多媒体</li>\n<li>网络：计算机网络</li>\n<li>理论：计算机科学理论</li>\n<li>其它：交叉/综合/新兴</li>\n<li>交互：人机交互与普适计算</li>\n</ul>\n<p>表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。</p>\n<h1 id=\"CCF目录中存在的问题\"><a href=\"#CCF目录中存在的问题\" class=\"headerlink\" title=\"CCF目录中存在的问题\"></a>CCF目录中存在的问题</h1><h2 id=\"同一刊物同时被列入不同方向\"><a href=\"#同一刊物同时被列入不同方向\" class=\"headerlink\" title=\"同一刊物同时被列入不同方向\"></a>同一刊物同时被列入不同方向</h2><p>多个研究方向经常出现交叉，所以这种情况也是可以接受的。</p>\n<ul>\n<li>B类刊物 <code>DKE: Data and Knowledge Engineering</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IJIS: International Journal of Intelligent Systems</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IPL: Information Processing Letters</code> 分别被列入了 理论 和 数据库 方向</li>\n<li>B类刊物 <code>TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications</code> 分别被列入了 网络 和 多媒体 方向</li>\n</ul>\n<h2 id=\"同一方向中的重复会议\"><a href=\"#同一方向中的重复会议\" class=\"headerlink\" title=\"同一方向中的重复会议\"></a>同一方向中的重复会议</h2><ul>\n<li>安全方向的 C类会议 <code>ASIACCS</code>和 A类会议 <code>CCS</code>给出的链接都是 [<a href=\"http://dblp.org/db/conf/ccs/\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/ccs/</a>] ，这个不是错误，因为dblp上确实是在同一页面显示了 <code>ASIACCS</code> 和 <code>CCS</code>，不过列表中 <code>ASIACCS</code>的全称不太恰当</li>\n<li>交互方向的 C类会议 <code>DIS: ACM Conference on Designing Interactive  Systems</code> 在第2条和第11条重复出现了两次</li>\n</ul>\n<p><img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\"></p>\n","site":{"data":{}},"excerpt":"<p>CCF目录有<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">网页版</a>和<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>。<br>前一段时间整理论文列表，感觉分成多页的目录用起来不太方便。于是就粘贴复制，把它们合并到一起。<br>Markdown排版比较麻烦，于是把表格单独放在一个html文件里了，链接是 <strong><a href=\"/doc/ccf-all-in-one-2017-02-25.html\">CCF目录完整列表2017-02-25</a></strong> 。<br>此外还有 <strong><a href=\"/doc/ccf_all_in_one_2017-02-25.xlsx\">Excel格式</a></strong>。</p>\n<p>CCF网站最近改版了，原来的链接发生了变化(2017-02-25访问，上面的链接已经更新过了)。新版的链接是<a href=\"http://webtest.ccf.org.cn/xspj/gyml/\" target=\"_blank\" rel=\"external\">CCF目录</a> ，HTML版不太完整，而且没有提供PDF文件。</p>","more":"<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a></li>\n<li><a href=\"#ccf%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\">CCF目录中存在的问题</a><ul>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E5%88%8A%E7%89%A9%E5%90%8C%E6%97%B6%E8%A2%AB%E5%88%97%E5%85%A5%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91\">同一刊物同时被列入不同方向</a></li>\n<li><a href=\"#%E5%90%8C%E4%B8%80%E6%96%B9%E5%90%91%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BC%9A%E8%AE%AE\">同一方向中的重复会议</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>表格中的类别简写分别是:</p>\n<ul>\n<li>AI：人工智能</li>\n<li>系统：计算机体系结构/并行与分布计算/存储系统</li>\n<li>软工：软件工程/系统软件/程序设计语言</li>\n<li>数据库：数据库/数据检索/内容检索</li>\n<li>安全：网络与信息安全</li>\n<li>多媒体：计算机图形学与多媒体</li>\n<li>网络：计算机网络</li>\n<li>理论：计算机科学理论</li>\n<li>其它：交叉/综合/新兴</li>\n<li>交互：人机交互与普适计算</li>\n</ul>\n<p>表格中是按拼音排序的，排序字段依次是：方向，类型（会议/刊物），级别（A/B/C）。</p>\n<h1 id=\"CCF目录中存在的问题\"><a href=\"#CCF目录中存在的问题\" class=\"headerlink\" title=\"CCF目录中存在的问题\"></a>CCF目录中存在的问题</h1><h2 id=\"同一刊物同时被列入不同方向\"><a href=\"#同一刊物同时被列入不同方向\" class=\"headerlink\" title=\"同一刊物同时被列入不同方向\"></a>同一刊物同时被列入不同方向</h2><p>多个研究方向经常出现交叉，所以这种情况也是可以接受的。</p>\n<ul>\n<li>B类刊物 <code>DKE: Data and Knowledge Engineering</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IJIS: International Journal of Intelligent Systems</code> 分别被列入了 AI 和 数据库 方向</li>\n<li>C类刊物 <code>IPL: Information Processing Letters</code> 分别被列入了 理论 和 数据库 方向</li>\n<li>B类刊物 <code>TOMCCAP: ACM Transactions on Multimedia Computing, Communications and Applications</code> 分别被列入了 网络 和 多媒体 方向</li>\n</ul>\n<h2 id=\"同一方向中的重复会议\"><a href=\"#同一方向中的重复会议\" class=\"headerlink\" title=\"同一方向中的重复会议\"></a>同一方向中的重复会议</h2><ul>\n<li>安全方向的 C类会议 <code>ASIACCS</code>和 A类会议 <code>CCS</code>给出的链接都是 [<a href=\"http://dblp.org/db/conf/ccs/\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/ccs/</a>] ，这个不是错误，因为dblp上确实是在同一页面显示了 <code>ASIACCS</code> 和 <code>CCS</code>，不过列表中 <code>ASIACCS</code>的全称不太恰当</li>\n<li>交互方向的 C类会议 <code>DIS: ACM Conference on Designing Interactive  Systems</code> 在第2条和第11条重复出现了两次</li>\n</ul>\n<p><img src=\"/img/ccf_sum.png\" alt=\"刊物分方向汇总\"></p>"},{"title":"安装Ubuntu Server 16.04 lts","date":"2016-09-15T16:00:00.000Z","_content":"记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n    - [为什么是16.04](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604)\n    - [为什么是Server版](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88)\n    - [为什么使用 VM](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm)\n- [在虚拟中安装Ubuntu](#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu)\n    - [Virtualbox的全局设定](#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A)\n    - [安装Ubuntu](#%E5%AE%89%E8%A3%85ubuntu)\n- [基本配置](#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)\n    - [设置网络](#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C)\n    - [系统更新和升级](#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7)\n    - [[可选] 切换为root用户](#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7)\n    - [[可选] 设置sudo免密码](#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81)\n    - [杂项设置](#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE)\n    - [Tips](#tips)\n        - [PATH环境变量](#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n        - [`which`命令](#which%E5%91%BD%E4%BB%A4)\n        - [查看系统版本](#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC)\n\n<!-- /TOC -->\n\n# 说明\n\n## 为什么是16.04\n\n+ 16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。\n+ 16.04的软件源更新比较快，而且可以用更简洁的`apt`命令代替`apt-get`来安装程序。\n+ 另一个原因是[systemd](https://zh.wikipedia.org/wiki/Systemd)。`systemd`参考了Mac OS X的`launchd`，是一个替代`init`程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了`systemd`。Ubuntu 14.04 lts采用的是`upstart`，直到15.04版才转用`systemd`。在运行一些 **dokcer**，**etcd** 等服务程序的示例时，经常会看到用`systemd`的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。\n\n## 为什么是Server版\n因为在Ubuntu下只是在 **敲命令**，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 **Ubuntu桌面版默认强制** 安装一堆充满bug的办公软件，多媒体软件等。\n\n## 为什么使用 VM\n如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。\n如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(`headless`)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。\n\n> 如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机\n\"C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" startvm <虚拟机名> --type headless\n其中`C:\\Program Files\\Oracle\\VirtualBox\\`是vbox的安装路径，可以把它添加到`PATH`环境变量中。\n![](/img/vbox-headless.png)\n\n使用VM比物理机器更好的地方，\n+ 一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；\n+ 另一点是可以利用VM的 **快照功能** 方便地进行全系统的备份和恢复。\n\nVM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。\n即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。\n不建议在物理机器上安装双系统。\n\n# 在虚拟中安装Ubuntu\n\n## Virtualbox的全局设定\n安装好Virtualbox后，可以在`管理->全局设定`中修改`默认虚拟电脑位置`；另外在`网络`中添加`Nat网络`，并修改IP网段；修改已经默认添加的`仅主机(Host-Only)网络`的IP网段。\n如下图，设置Nat网络的IP网段为`10.0.1.0/24`，设置Host-Only网络的`主机虚拟网络界面`(即vbox的虚拟网卡)的IP为`10.1.1.1`，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 `192.168.56.0`网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。\n![添加Nat网络，并修改IP网段](/img/vboxconf-NatNetwork.png)\n\n![修改默认Host-Only网络的IP网段](/img/vboxconf-hostonly.png)\n\n## 安装Ubuntu\n从Ubuntu官网下载[Server 16.04.2 的.iso镜像](http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso)。\n在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。\n![](/img/vboxsetting-store.png)\n\n+ **[可选]** 安装系统前先 **不接入网络**，即在VM设置中不勾选`启用网络连接`，以免安装过程中联网更新耗时较长。\n+ **[强烈建议]** 安装时语言选择为 **英文**：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但`Location`要选择实际的区域，以匹配正确的时区。\n\n在最后的步骤中选中`Samba File Server`，`Standard System Utility`和`OpenSSH Server`（`空格键`选择或取消选择，`回车键`确认并继续下一步）。\n\n>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。\n\n![](/img/vboxsetting-net.png)\n\nServer没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是`ying`），回车，输入密码（没有任何显示），回车，进入系统的`shell`。\n![](/img/vm-tty.png)\n\n# 基本配置\n\n## 设置网络\n如果安装时没有接入网络，添加网卡后需要在`/etc/network/interfaces`中设置一下。\nUbuntu 16.04的网卡命名不是以前的类似`eth0`，`eth1`，而是`enp0s?`这样。`?`代表一个数字，\n执行`ip a`，如上图，输出的`2: enp0s3...`和`3: enp0s8...`就是已经识别出的网卡名。\n\n设置网卡：执行`sudo nano /etc/network/interfaces`，使用`nano`编辑`/etc/network/interfaces`，**增加** 下面的内容\n{% codeblock line_number:false%}\nauto  enp0s3       # NAT网络，用于连接外网\niface enp0s3 inet dhcp\n\nauto  enp0s8       # Host-Only网卡，设置静态IP，内网\niface enp0s8 inet static\naddress 10.1.1.5\nnetmask 255.255.255.0\n{% endcodeblock %}\n\n按 `Ctrl+X` 快捷键，再按 `Y` 键，回车，保存并退出`nano`。\n\n>`nano` 是一个简单的命令行文本编辑器，功能比较弱，但比`vim`直观一些。\n\n启动网卡：执行`sudo ifup enp0s3 enp0s8`，再次执行`ip a`，可以看到这两个网卡已经获取了IP地址。\n\n确认网卡工作正常：\n+ Nat网络连接外网：执行`curl ip.cn`，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）\n+ Host-only连接内网（主机）：执行`ping 10.1.1.1 -c 5`，应该能ping通。\n\n> 网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。\n\n## 系统更新和升级\n{% codeblock line_number:false%}\nsudo apt update   # 更新apt\nsudo apt upgrade  # 升级系统，可能耗时较长。\n{% endcodeblock %}\n\n如果网络速度较慢，可将apt源更换为[国内163](http://mirrors.163.com/.help/ubuntu.html)的，或者[http://mirrors.nju.edu.cn]，其中Ubuntu 16.04的代号是`xenial`。\n\n\n## [可选] 切换为root用户\n安装系统时设置的的用户有`sudo`权限。直接使用`root` **不是** 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的`sudo` 。\n执行`sudo passwd`，先输入当前用户的密码以授权`sudo`，然后输入两次`root`的登录密码。执行`exit`注销当前用户，以`root`和刚才设置的密码登录。\n\nssh默认禁止`root`用密码登录。可以修改`/etc/ssh/sshd_config`允许`root`使用密码登录，或为`root`设置使用密钥登录。\n\n## [可选] 设置sudo免密码\n如果不想直接使用`root`用户，还可以设置执行`sudo`时 **免输密码**。执行`sudo visudo`(实际上是`nano`编辑器)，找到 `%sudo\tALL=(ALL:ALL) ALL`这一行，改为`%sudo\tALL=(ALL:ALL) NOPASSWD: ALL` 。\n\n## 杂项设置\n\n{% codeblock line_number:false%}\n; 安装常用软件\nsudo apt install git zsh tree\n\n; 设置Git的全局用户名和Email\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\n\n; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF\n; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n\n; 设置zsh和oh-my-zsh\nsudo chsh ying -s /usr/bin/zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n; 使用短网址  \nwget https://git.io/SM81Wg -O - | sh\n\n; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。\n\n; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改\n; 禁用oh-my-zsh的自动更新，取消下面一行的注释\nDISABLE_AUTO_UPDATE=\"true\"\n\n; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH\n\n; 增加alias\nalias cls=\"clear\"\nalias dir=\"ls -alF\"\nalias ipconfig=\"ifconfig\"\nalias ping=\"ping -c 3\"\n\nalias ll=\"ls -alF\"\nalias ps=\"ps -af\"\nalias netstat=\"netstat -nap\"\nalias json=\"python -m json.tool\"\n{% endcodeblock %}\n\n## Tips\n### PATH环境变量\nLinux下的绝大多数命令，其实是对应着一个可执行程序的 **文件名**。这些可执行文件分散在 `PATH` 环境变量设置的目录列表中，比如\n{% codeblock line_number:false%}\necho $PATH\n; 输出为\n; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\n{% endcodeblock %}\n\n可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在`/usr/bin`，可以通过`ls /usr/bin`来确认。\n如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 *无法找到命令* 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到`PATH`。\n当前目录（`.`）默认没有加入到`PATH`中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要`./foo.sh`这样。\n\n### `which`命令\n{% codeblock line_number:false%}\n$ which which\nwhich: shell built-in command\n\n$ which echo\necho: shell built-in command\n\n$ which python\n/usr/bin/python\n{% endcodeblock %}\n\n### 查看系统版本\n查看发行版本和代号，执行`cat /etc/os-release`\n查看内核版本，执行`uname -a`\n\n-----\n\n设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。\n![](/img/vbox-snapshot.png)\n","source":"_posts/install-ubuntu.md","raw":"title: 安装Ubuntu Server 16.04 lts\ndate: 2016-09-16\ncategory: [misc]\ntags:\n\n---\n记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [说明](#%E8%AF%B4%E6%98%8E)\n    - [为什么是16.04](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604)\n    - [为什么是Server版](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88)\n    - [为什么使用 VM](#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm)\n- [在虚拟中安装Ubuntu](#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu)\n    - [Virtualbox的全局设定](#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A)\n    - [安装Ubuntu](#%E5%AE%89%E8%A3%85ubuntu)\n- [基本配置](#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)\n    - [设置网络](#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C)\n    - [系统更新和升级](#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7)\n    - [[可选] 切换为root用户](#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7)\n    - [[可选] 设置sudo免密码](#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81)\n    - [杂项设置](#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE)\n    - [Tips](#tips)\n        - [PATH环境变量](#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n        - [`which`命令](#which%E5%91%BD%E4%BB%A4)\n        - [查看系统版本](#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC)\n\n<!-- /TOC -->\n\n# 说明\n\n## 为什么是16.04\n\n+ 16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。\n+ 16.04的软件源更新比较快，而且可以用更简洁的`apt`命令代替`apt-get`来安装程序。\n+ 另一个原因是[systemd](https://zh.wikipedia.org/wiki/Systemd)。`systemd`参考了Mac OS X的`launchd`，是一个替代`init`程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了`systemd`。Ubuntu 14.04 lts采用的是`upstart`，直到15.04版才转用`systemd`。在运行一些 **dokcer**，**etcd** 等服务程序的示例时，经常会看到用`systemd`的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。\n\n## 为什么是Server版\n因为在Ubuntu下只是在 **敲命令**，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 **Ubuntu桌面版默认强制** 安装一堆充满bug的办公软件，多媒体软件等。\n\n## 为什么使用 VM\n如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。\n如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(`headless`)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。\n\n> 如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机\n\"C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe\" startvm <虚拟机名> --type headless\n其中`C:\\Program Files\\Oracle\\VirtualBox\\`是vbox的安装路径，可以把它添加到`PATH`环境变量中。\n![](/img/vbox-headless.png)\n\n使用VM比物理机器更好的地方，\n+ 一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；\n+ 另一点是可以利用VM的 **快照功能** 方便地进行全系统的备份和恢复。\n\nVM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。\n即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。\n不建议在物理机器上安装双系统。\n\n# 在虚拟中安装Ubuntu\n\n## Virtualbox的全局设定\n安装好Virtualbox后，可以在`管理->全局设定`中修改`默认虚拟电脑位置`；另外在`网络`中添加`Nat网络`，并修改IP网段；修改已经默认添加的`仅主机(Host-Only)网络`的IP网段。\n如下图，设置Nat网络的IP网段为`10.0.1.0/24`，设置Host-Only网络的`主机虚拟网络界面`(即vbox的虚拟网卡)的IP为`10.1.1.1`，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 `192.168.56.0`网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。\n![添加Nat网络，并修改IP网段](/img/vboxconf-NatNetwork.png)\n\n![修改默认Host-Only网络的IP网段](/img/vboxconf-hostonly.png)\n\n## 安装Ubuntu\n从Ubuntu官网下载[Server 16.04.2 的.iso镜像](http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso)。\n在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。\n![](/img/vboxsetting-store.png)\n\n+ **[可选]** 安装系统前先 **不接入网络**，即在VM设置中不勾选`启用网络连接`，以免安装过程中联网更新耗时较长。\n+ **[强烈建议]** 安装时语言选择为 **英文**：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但`Location`要选择实际的区域，以匹配正确的时区。\n\n在最后的步骤中选中`Samba File Server`，`Standard System Utility`和`OpenSSH Server`（`空格键`选择或取消选择，`回车键`确认并继续下一步）。\n\n>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。\n\n![](/img/vboxsetting-net.png)\n\nServer没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是`ying`），回车，输入密码（没有任何显示），回车，进入系统的`shell`。\n![](/img/vm-tty.png)\n\n# 基本配置\n\n## 设置网络\n如果安装时没有接入网络，添加网卡后需要在`/etc/network/interfaces`中设置一下。\nUbuntu 16.04的网卡命名不是以前的类似`eth0`，`eth1`，而是`enp0s?`这样。`?`代表一个数字，\n执行`ip a`，如上图，输出的`2: enp0s3...`和`3: enp0s8...`就是已经识别出的网卡名。\n\n设置网卡：执行`sudo nano /etc/network/interfaces`，使用`nano`编辑`/etc/network/interfaces`，**增加** 下面的内容\n{% codeblock line_number:false%}\nauto  enp0s3       # NAT网络，用于连接外网\niface enp0s3 inet dhcp\n\nauto  enp0s8       # Host-Only网卡，设置静态IP，内网\niface enp0s8 inet static\naddress 10.1.1.5\nnetmask 255.255.255.0\n{% endcodeblock %}\n\n按 `Ctrl+X` 快捷键，再按 `Y` 键，回车，保存并退出`nano`。\n\n>`nano` 是一个简单的命令行文本编辑器，功能比较弱，但比`vim`直观一些。\n\n启动网卡：执行`sudo ifup enp0s3 enp0s8`，再次执行`ip a`，可以看到这两个网卡已经获取了IP地址。\n\n确认网卡工作正常：\n+ Nat网络连接外网：执行`curl ip.cn`，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）\n+ Host-only连接内网（主机）：执行`ping 10.1.1.1 -c 5`，应该能ping通。\n\n> 网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。\n\n## 系统更新和升级\n{% codeblock line_number:false%}\nsudo apt update   # 更新apt\nsudo apt upgrade  # 升级系统，可能耗时较长。\n{% endcodeblock %}\n\n如果网络速度较慢，可将apt源更换为[国内163](http://mirrors.163.com/.help/ubuntu.html)的，或者[http://mirrors.nju.edu.cn]，其中Ubuntu 16.04的代号是`xenial`。\n\n\n## [可选] 切换为root用户\n安装系统时设置的的用户有`sudo`权限。直接使用`root` **不是** 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的`sudo` 。\n执行`sudo passwd`，先输入当前用户的密码以授权`sudo`，然后输入两次`root`的登录密码。执行`exit`注销当前用户，以`root`和刚才设置的密码登录。\n\nssh默认禁止`root`用密码登录。可以修改`/etc/ssh/sshd_config`允许`root`使用密码登录，或为`root`设置使用密钥登录。\n\n## [可选] 设置sudo免密码\n如果不想直接使用`root`用户，还可以设置执行`sudo`时 **免输密码**。执行`sudo visudo`(实际上是`nano`编辑器)，找到 `%sudo\tALL=(ALL:ALL) ALL`这一行，改为`%sudo\tALL=(ALL:ALL) NOPASSWD: ALL` 。\n\n## 杂项设置\n\n{% codeblock line_number:false%}\n; 安装常用软件\nsudo apt install git zsh tree\n\n; 设置Git的全局用户名和Email\ngit config --global user.name  \"ZHANG Ying\"\ngit config --global user.email \"your@email.com\"\n\n; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF\n; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration\ngit config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理\n\n; 设置zsh和oh-my-zsh\nsudo chsh ying -s /usr/bin/zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n; 使用短网址  \nwget https://git.io/SM81Wg -O - | sh\n\n; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。\n\n; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改\n; 禁用oh-my-zsh的自动更新，取消下面一行的注释\nDISABLE_AUTO_UPDATE=\"true\"\n\n; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH\n\n; 增加alias\nalias cls=\"clear\"\nalias dir=\"ls -alF\"\nalias ipconfig=\"ifconfig\"\nalias ping=\"ping -c 3\"\n\nalias ll=\"ls -alF\"\nalias ps=\"ps -af\"\nalias netstat=\"netstat -nap\"\nalias json=\"python -m json.tool\"\n{% endcodeblock %}\n\n## Tips\n### PATH环境变量\nLinux下的绝大多数命令，其实是对应着一个可执行程序的 **文件名**。这些可执行文件分散在 `PATH` 环境变量设置的目录列表中，比如\n{% codeblock line_number:false%}\necho $PATH\n; 输出为\n; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\n{% endcodeblock %}\n\n可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在`/usr/bin`，可以通过`ls /usr/bin`来确认。\n如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 *无法找到命令* 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到`PATH`。\n当前目录（`.`）默认没有加入到`PATH`中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要`./foo.sh`这样。\n\n### `which`命令\n{% codeblock line_number:false%}\n$ which which\nwhich: shell built-in command\n\n$ which echo\necho: shell built-in command\n\n$ which python\n/usr/bin/python\n{% endcodeblock %}\n\n### 查看系统版本\n查看发行版本和代号，执行`cat /etc/os-release`\n查看内核版本，执行`uname -a`\n\n-----\n\n设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。\n![](/img/vbox-snapshot.png)\n","slug":"install-ubuntu","published":1,"updated":"2017-10-30T02:47:52.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgt00079s4f0n9fj7bz","content":"<p>记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604\">为什么是16.04</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88\">为什么是Server版</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm\">为什么使用 VM</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu\">在虚拟中安装Ubuntu</a><ul>\n<li><a href=\"#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A\">Virtualbox的全局设定</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85ubuntu\">安装Ubuntu</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\">基本配置</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C\">设置网络</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7\">系统更新和升级</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7\">[可选] 切换为root用户</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81\">[可选] 设置sudo免密码</a></li>\n<li><a href=\"#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE\">杂项设置</a></li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">PATH环境变量</a></li>\n<li><a href=\"#which%E5%91%BD%E4%BB%A4\"><code>which</code>命令</a></li>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC\">查看系统版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><h2 id=\"为什么是16-04\"><a href=\"#为什么是16-04\" class=\"headerlink\" title=\"为什么是16.04\"></a>为什么是16.04</h2><ul>\n<li>16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。</li>\n<li>16.04的软件源更新比较快，而且可以用更简洁的<code>apt</code>命令代替<code>apt-get</code>来安装程序。</li>\n<li>另一个原因是<a href=\"https://zh.wikipedia.org/wiki/Systemd\" target=\"_blank\" rel=\"external\">systemd</a>。<code>systemd</code>参考了Mac OS X的<code>launchd</code>，是一个替代<code>init</code>程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了<code>systemd</code>。Ubuntu 14.04 lts采用的是<code>upstart</code>，直到15.04版才转用<code>systemd</code>。在运行一些 <strong>dokcer</strong>，<strong>etcd</strong> 等服务程序的示例时，经常会看到用<code>systemd</code>的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。</li>\n</ul>\n<h2 id=\"为什么是Server版\"><a href=\"#为什么是Server版\" class=\"headerlink\" title=\"为什么是Server版\"></a>为什么是Server版</h2><p>因为在Ubuntu下只是在 <strong>敲命令</strong>，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 <strong>Ubuntu桌面版默认强制</strong> 安装一堆充满bug的办公软件，多媒体软件等。</p>\n<h2 id=\"为什么使用-VM\"><a href=\"#为什么使用-VM\" class=\"headerlink\" title=\"为什么使用 VM\"></a>为什么使用 VM</h2><p>如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。<br>如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(<code>headless</code>)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。</p>\n<blockquote>\n<p>如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机<br>“C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe” startvm &lt;虚拟机名&gt; –type headless<br>其中<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>是vbox的安装路径，可以把它添加到<code>PATH</code>环境变量中。<br><img src=\"/img/vbox-headless.png\" alt=\"\"></p>\n</blockquote>\n<p>使用VM比物理机器更好的地方，</p>\n<ul>\n<li>一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；</li>\n<li>另一点是可以利用VM的 <strong>快照功能</strong> 方便地进行全系统的备份和恢复。</li>\n</ul>\n<p>VM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。<br>即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。<br>不建议在物理机器上安装双系统。</p>\n<h1 id=\"在虚拟中安装Ubuntu\"><a href=\"#在虚拟中安装Ubuntu\" class=\"headerlink\" title=\"在虚拟中安装Ubuntu\"></a>在虚拟中安装Ubuntu</h1><h2 id=\"Virtualbox的全局设定\"><a href=\"#Virtualbox的全局设定\" class=\"headerlink\" title=\"Virtualbox的全局设定\"></a>Virtualbox的全局设定</h2><p>安装好Virtualbox后，可以在<code>管理-&gt;全局设定</code>中修改<code>默认虚拟电脑位置</code>；另外在<code>网络</code>中添加<code>Nat网络</code>，并修改IP网段；修改已经默认添加的<code>仅主机(Host-Only)网络</code>的IP网段。<br>如下图，设置Nat网络的IP网段为<code>10.0.1.0/24</code>，设置Host-Only网络的<code>主机虚拟网络界面</code>(即vbox的虚拟网卡)的IP为<code>10.1.1.1</code>，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 <code>192.168.56.0</code>网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。<br><img src=\"/img/vboxconf-NatNetwork.png\" alt=\"添加Nat网络，并修改IP网段\"></p>\n<p><img src=\"/img/vboxconf-hostonly.png\" alt=\"修改默认Host-Only网络的IP网段\"></p>\n<h2 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h2><p>从Ubuntu官网下载<a href=\"http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso\" target=\"_blank\" rel=\"external\">Server 16.04.2 的.iso镜像</a>。<br>在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。<br><img src=\"/img/vboxsetting-store.png\" alt=\"\"></p>\n<ul>\n<li><strong>[可选]</strong> 安装系统前先 <strong>不接入网络</strong>，即在VM设置中不勾选<code>启用网络连接</code>，以免安装过程中联网更新耗时较长。</li>\n<li><strong>[强烈建议]</strong> 安装时语言选择为 <strong>英文</strong>：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但<code>Location</code>要选择实际的区域，以匹配正确的时区。</li>\n</ul>\n<p>在最后的步骤中选中<code>Samba File Server</code>，<code>Standard System Utility</code>和<code>OpenSSH Server</code>（<code>空格键</code>选择或取消选择，<code>回车键</code>确认并继续下一步）。</p>\n<blockquote>\n<p>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。</p>\n</blockquote>\n<p><img src=\"/img/vboxsetting-net.png\" alt=\"\"></p>\n<p>Server没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是<code>ying</code>），回车，输入密码（没有任何显示），回车，进入系统的<code>shell</code>。<br><img src=\"/img/vm-tty.png\" alt=\"\"></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><h2 id=\"设置网络\"><a href=\"#设置网络\" class=\"headerlink\" title=\"设置网络\"></a>设置网络</h2><p>如果安装时没有接入网络，添加网卡后需要在<code>/etc/network/interfaces</code>中设置一下。<br>Ubuntu 16.04的网卡命名不是以前的类似<code>eth0</code>，<code>eth1</code>，而是<code>enp0s?</code>这样。<code>?</code>代表一个数字，<br>执行<code>ip a</code>，如上图，输出的<code>2: enp0s3...</code>和<code>3: enp0s8...</code>就是已经识别出的网卡名。</p>\n<p>设置网卡：执行<code>sudo nano /etc/network/interfaces</code>，使用<code>nano</code>编辑<code>/etc/network/interfaces</code>，<strong>增加</strong> 下面的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">auto  enp0s3       # NAT网络，用于连接外网</div><div class=\"line\">iface enp0s3 inet dhcp</div><div class=\"line\"></div><div class=\"line\">auto  enp0s8       # Host-Only网卡，设置静态IP，内网</div><div class=\"line\">iface enp0s8 inet static</div><div class=\"line\">address 10.1.1.5</div><div class=\"line\">netmask 255.255.255.0</div></pre></td></tr></table></figure></p>\n<p>按 <code>Ctrl+X</code> 快捷键，再按 <code>Y</code> 键，回车，保存并退出<code>nano</code>。</p>\n<blockquote>\n<p><code>nano</code> 是一个简单的命令行文本编辑器，功能比较弱，但比<code>vim</code>直观一些。</p>\n</blockquote>\n<p>启动网卡：执行<code>sudo ifup enp0s3 enp0s8</code>，再次执行<code>ip a</code>，可以看到这两个网卡已经获取了IP地址。</p>\n<p>确认网卡工作正常：</p>\n<ul>\n<li>Nat网络连接外网：执行<code>curl ip.cn</code>，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）</li>\n<li>Host-only连接内网（主机）：执行<code>ping 10.1.1.1 -c 5</code>，应该能ping通。</li>\n</ul>\n<blockquote>\n<p>网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。</p>\n</blockquote>\n<h2 id=\"系统更新和升级\"><a href=\"#系统更新和升级\" class=\"headerlink\" title=\"系统更新和升级\"></a>系统更新和升级</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo apt update   # 更新apt</div><div class=\"line\">sudo apt upgrade  # 升级系统，可能耗时较长。</div></pre></td></tr></table></figure>\n<p>如果网络速度较慢，可将apt源更换为<a href=\"http://mirrors.163.com/.help/ubuntu.html\" target=\"_blank\" rel=\"external\">国内163</a>的，或者[<a href=\"http://mirrors.nju.edu.cn]，其中Ubuntu\" target=\"_blank\" rel=\"external\">http://mirrors.nju.edu.cn]，其中Ubuntu</a> 16.04的代号是<code>xenial</code>。</p>\n<h2 id=\"可选-切换为root用户\"><a href=\"#可选-切换为root用户\" class=\"headerlink\" title=\"[可选] 切换为root用户\"></a>[可选] 切换为root用户</h2><p>安装系统时设置的的用户有<code>sudo</code>权限。直接使用<code>root</code> <strong>不是</strong> 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的<code>sudo</code> 。<br>执行<code>sudo passwd</code>，先输入当前用户的密码以授权<code>sudo</code>，然后输入两次<code>root</code>的登录密码。执行<code>exit</code>注销当前用户，以<code>root</code>和刚才设置的密码登录。</p>\n<p>ssh默认禁止<code>root</code>用密码登录。可以修改<code>/etc/ssh/sshd_config</code>允许<code>root</code>使用密码登录，或为<code>root</code>设置使用密钥登录。</p>\n<h2 id=\"可选-设置sudo免密码\"><a href=\"#可选-设置sudo免密码\" class=\"headerlink\" title=\"[可选] 设置sudo免密码\"></a>[可选] 设置sudo免密码</h2><p>如果不想直接使用<code>root</code>用户，还可以设置执行<code>sudo</code>时 <strong>免输密码</strong>。执行<code>sudo visudo</code>(实际上是<code>nano</code>编辑器)，找到 <code>%sudo    ALL=(ALL:ALL) ALL</code>这一行，改为<code>%sudo    ALL=(ALL:ALL) NOPASSWD: ALL</code> 。</p>\n<h2 id=\"杂项设置\"><a href=\"#杂项设置\" class=\"headerlink\" title=\"杂项设置\"></a>杂项设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">; 安装常用软件</div><div class=\"line\">sudo apt install git zsh tree</div><div class=\"line\"></div><div class=\"line\">; 设置Git的全局用户名和Email</div><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\"></div><div class=\"line\">; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF</div><div class=\"line\">; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div><div class=\"line\"></div><div class=\"line\">; 设置zsh和oh-my-zsh</div><div class=\"line\">sudo chsh ying -s /usr/bin/zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</div><div class=\"line\">; 使用短网址  </div><div class=\"line\">wget https://git.io/SM81Wg -O - | sh</div><div class=\"line\"></div><div class=\"line\">; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。</div><div class=\"line\"></div><div class=\"line\">; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改</div><div class=\"line\">; 禁用oh-my-zsh的自动更新，取消下面一行的注释</div><div class=\"line\">DISABLE_AUTO_UPDATE=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH</div><div class=\"line\"></div><div class=\"line\">; 增加alias</div><div class=\"line\">alias cls=&quot;clear&quot;</div><div class=\"line\">alias dir=&quot;ls -alF&quot;</div><div class=\"line\">alias ipconfig=&quot;ifconfig&quot;</div><div class=\"line\">alias ping=&quot;ping -c 3&quot;</div><div class=\"line\"></div><div class=\"line\">alias ll=&quot;ls -alF&quot;</div><div class=\"line\">alias ps=&quot;ps -af&quot;</div><div class=\"line\">alias netstat=&quot;netstat -nap&quot;</div><div class=\"line\">alias json=&quot;python -m json.tool&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><h3 id=\"PATH环境变量\"><a href=\"#PATH环境变量\" class=\"headerlink\" title=\"PATH环境变量\"></a>PATH环境变量</h3><p>Linux下的绝大多数命令，其实是对应着一个可执行程序的 <strong>文件名</strong>。这些可执行文件分散在 <code>PATH</code> 环境变量设置的目录列表中，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">echo $PATH</div><div class=\"line\">; 输出为</div><div class=\"line\">; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</div></pre></td></tr></table></figure></p>\n<p>可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在<code>/usr/bin</code>，可以通过<code>ls /usr/bin</code>来确认。<br>如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 <em>无法找到命令</em> 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到<code>PATH</code>。<br>当前目录（<code>.</code>）默认没有加入到<code>PATH</code>中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要<code>./foo.sh</code>这样。</p>\n<h3 id=\"which命令\"><a href=\"#which命令\" class=\"headerlink\" title=\"which命令\"></a><code>which</code>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ which which</div><div class=\"line\">which: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which echo</div><div class=\"line\">echo: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which python</div><div class=\"line\">/usr/bin/python</div></pre></td></tr></table></figure>\n<h3 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h3><p>查看发行版本和代号，执行<code>cat /etc/os-release</code><br>查看内核版本，执行<code>uname -a</code></p>\n<hr>\n<p>设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。<br><img src=\"/img/vbox-snapshot.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>记录一下安装Ubuntu Server 16.04 lts 及 基本设置作为备忘。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E8%AF%B4%E6%98%8E\">说明</a><ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1604\">为什么是16.04</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFserver%E7%89%88\">为什么是Server版</a></li>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-vm\">为什么使用 VM</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9C%A8%E8%99%9A%E6%8B%9F%E4%B8%AD%E5%AE%89%E8%A3%85ubuntu\">在虚拟中安装Ubuntu</a><ul>\n<li><a href=\"#virtualbox%E7%9A%84%E5%85%A8%E5%B1%80%E8%AE%BE%E5%AE%9A\">Virtualbox的全局设定</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85ubuntu\">安装Ubuntu</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\">基本配置</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C\">设置网络</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%92%8C%E5%8D%87%E7%BA%A7\">系统更新和升级</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E5%88%87%E6%8D%A2%E4%B8%BAroot%E7%94%A8%E6%88%B7\">[可选] 切换为root用户</a></li>\n<li><a href=\"#%E5%8F%AF%E9%80%89-%E8%AE%BE%E7%BD%AEsudo%E5%85%8D%E5%AF%86%E7%A0%81\">[可选] 设置sudo免密码</a></li>\n<li><a href=\"#%E6%9D%82%E9%A1%B9%E8%AE%BE%E7%BD%AE\">杂项设置</a></li>\n<li><a href=\"#tips\">Tips</a><ul>\n<li><a href=\"#path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">PATH环境变量</a></li>\n<li><a href=\"#which%E5%91%BD%E4%BB%A4\"><code>which</code>命令</a></li>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC\">查看系统版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><h2 id=\"为什么是16-04\"><a href=\"#为什么是16-04\" class=\"headerlink\" title=\"为什么是16.04\"></a>为什么是16.04</h2><ul>\n<li>16.04是lts版，相比非lts要稳定一些(不会瞎折腾)；虽然14.04也是lts版，但毕竟2014年都已经过去很久了。</li>\n<li>16.04的软件源更新比较快，而且可以用更简洁的<code>apt</code>命令代替<code>apt-get</code>来安装程序。</li>\n<li>另一个原因是<a href=\"https://zh.wikipedia.org/wiki/Systemd\" target=\"_blank\" rel=\"external\">systemd</a>。<code>systemd</code>参考了Mac OS X的<code>launchd</code>，是一个替代<code>init</code>程序的系统服务管理组件。其它发行版，如RHEL/CentOS，CoreOS都已经采用了<code>systemd</code>。Ubuntu 14.04 lts采用的是<code>upstart</code>，直到15.04版才转用<code>systemd</code>。在运行一些 <strong>dokcer</strong>，<strong>etcd</strong> 等服务程序的示例时，经常会看到用<code>systemd</code>的unit文件定义的系统服务(service)，不能直接拿来用在Ubuntu 14.04 lts。当然在15.04版及以后的版本就可以了，由于一些默认路径不同，不同发行版的unit文件可能还是需要适当修改。</li>\n</ul>\n<h2 id=\"为什么是Server版\"><a href=\"#为什么是Server版\" class=\"headerlink\" title=\"为什么是Server版\"></a>为什么是Server版</h2><p>因为在Ubuntu下只是在 <strong>敲命令</strong>，极少有非使用图形界面不可的情况，又何必忍受Ubuntu臃肿的GUI呢。ssh远程登录到系统上，所有操作都通过命令行搞定，不必费心某个软件没有Linux版，或者QQ、输入法的功能弱，也不用被 <strong>Ubuntu桌面版默认强制</strong> 安装一堆充满bug的办公软件，多媒体软件等。</p>\n<h2 id=\"为什么使用-VM\"><a href=\"#为什么使用-VM\" class=\"headerlink\" title=\"为什么使用 VM\"></a>为什么使用 VM</h2><p>如果有两台机器，一个装Ubuntu Server，连上网络然后扔在一边（只是一个机箱，都不需要显示器、键盘鼠标），另一个装Windows，远程访问即可。<br>如果只有一台机器，那么用Virtulbox创建虚拟机，安装一个Server版，平时可以选择“无界面启动”(<code>headless</code>)，没有多余的窗口，然后就跟使用物理服务器一样ssh远程登录到系统上。</p>\n<blockquote>\n<p>如果通过ssh远程执行命令，就不必使用vbox的虚拟机窗口了。启动虚拟机时，可以选择“无界面启动”，也可以在Windows命令行启动虚拟机<br>“C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe” startvm &lt;虚拟机名&gt; –type headless<br>其中<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>是vbox的安装路径，可以把它添加到<code>PATH</code>环境变量中。<br><img src=\"/img/vbox-headless.png\" alt=\"\"></p>\n</blockquote>\n<p>使用VM比物理机器更好的地方，</p>\n<ul>\n<li>一是可以使用主机的网络，对学校网络这种外网帐号只能在一处使用的场景很方便；</li>\n<li>另一点是可以利用VM的 <strong>快照功能</strong> 方便地进行全系统的备份和恢复。</li>\n</ul>\n<p>VM相比物理机器的性能损失，或者较少的CPU、内存资源其实影响并不大，毕竟云计算中都在普遍使用VM嘛。<br>即便是Mac OS X这样的Unix环境，也建议使用VM安装Ubuntu，除了上面两个优点，还可以防止误操作弄乱系统，另外可以避免Mac OS X内置命令与Linux不兼容的困扰。<br>不建议在物理机器上安装双系统。</p>\n<h1 id=\"在虚拟中安装Ubuntu\"><a href=\"#在虚拟中安装Ubuntu\" class=\"headerlink\" title=\"在虚拟中安装Ubuntu\"></a>在虚拟中安装Ubuntu</h1><h2 id=\"Virtualbox的全局设定\"><a href=\"#Virtualbox的全局设定\" class=\"headerlink\" title=\"Virtualbox的全局设定\"></a>Virtualbox的全局设定</h2><p>安装好Virtualbox后，可以在<code>管理-&gt;全局设定</code>中修改<code>默认虚拟电脑位置</code>；另外在<code>网络</code>中添加<code>Nat网络</code>，并修改IP网段；修改已经默认添加的<code>仅主机(Host-Only)网络</code>的IP网段。<br>如下图，设置Nat网络的IP网段为<code>10.0.1.0/24</code>，设置Host-Only网络的<code>主机虚拟网络界面</code>(即vbox的虚拟网卡)的IP为<code>10.1.1.1</code>，并启用DHCP服务器，设置其IP网段。当然使用Host-Only虚拟网卡默认的 <code>192.168.56.0</code>网段也是可以的。这里是为了说明如何设置任意的（私网）IP网段，二是为了以后敲命令时IP较简短。<br><img src=\"/img/vboxconf-NatNetwork.png\" alt=\"添加Nat网络，并修改IP网段\"></p>\n<p><img src=\"/img/vboxconf-hostonly.png\" alt=\"修改默认Host-Only网络的IP网段\"></p>\n<h2 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h2><p>从Ubuntu官网下载<a href=\"http://releases.ubuntu.com/16.04/ubuntu-16.04.2-server-amd64.iso\" target=\"_blank\" rel=\"external\">Server 16.04.2 的.iso镜像</a>。<br>在vbox中新建Linux类型虚拟机，选择Ubuntu 64位，虚拟磁盘使用vhd格式，动态扩展，将下载的.iso镜像挂载到虚拟机，启动虚拟机后开始安装。<br><img src=\"/img/vboxsetting-store.png\" alt=\"\"></p>\n<ul>\n<li><strong>[可选]</strong> 安装系统前先 <strong>不接入网络</strong>，即在VM设置中不勾选<code>启用网络连接</code>，以免安装过程中联网更新耗时较长。</li>\n<li><strong>[强烈建议]</strong> 安装时语言选择为 <strong>英文</strong>：如果选择默认语言为中文，安装后一些命令会显示中文的帮助信息，结果因为终端不能显示中文而变成乱码，造成不便。英文系统也是使用UTF8编码，可以在ssh客户端正常显示中文。但<code>Location</code>要选择实际的区域，以匹配正确的时区。</li>\n</ul>\n<p>在最后的步骤中选中<code>Samba File Server</code>，<code>Standard System Utility</code>和<code>OpenSSH Server</code>（<code>空格键</code>选择或取消选择，<code>回车键</code>确认并继续下一步）。</p>\n<blockquote>\n<p>如果安装前没有接入网络，则安装后关闭虚拟机，添加“NAT网络”和“仅主机(Host-Only)网卡”两个网卡。</p>\n</blockquote>\n<p><img src=\"/img/vboxsetting-net.png\" alt=\"\"></p>\n<p>Server没有图形界面，启动系统，进入的是下面这样一个黑乎乎的界面。输入安装时设置的用户名（这里是<code>ying</code>），回车，输入密码（没有任何显示），回车，进入系统的<code>shell</code>。<br><img src=\"/img/vm-tty.png\" alt=\"\"></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><h2 id=\"设置网络\"><a href=\"#设置网络\" class=\"headerlink\" title=\"设置网络\"></a>设置网络</h2><p>如果安装时没有接入网络，添加网卡后需要在<code>/etc/network/interfaces</code>中设置一下。<br>Ubuntu 16.04的网卡命名不是以前的类似<code>eth0</code>，<code>eth1</code>，而是<code>enp0s?</code>这样。<code>?</code>代表一个数字，<br>执行<code>ip a</code>，如上图，输出的<code>2: enp0s3...</code>和<code>3: enp0s8...</code>就是已经识别出的网卡名。</p>\n<p>设置网卡：执行<code>sudo nano /etc/network/interfaces</code>，使用<code>nano</code>编辑<code>/etc/network/interfaces</code>，<strong>增加</strong> 下面的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">auto  enp0s3       # NAT网络，用于连接外网</div><div class=\"line\">iface enp0s3 inet dhcp</div><div class=\"line\"></div><div class=\"line\">auto  enp0s8       # Host-Only网卡，设置静态IP，内网</div><div class=\"line\">iface enp0s8 inet static</div><div class=\"line\">address 10.1.1.5</div><div class=\"line\">netmask 255.255.255.0</div></pre></td></tr></table></figure></p>\n<p>按 <code>Ctrl+X</code> 快捷键，再按 <code>Y</code> 键，回车，保存并退出<code>nano</code>。</p>\n<blockquote>\n<p><code>nano</code> 是一个简单的命令行文本编辑器，功能比较弱，但比<code>vim</code>直观一些。</p>\n</blockquote>\n<p>启动网卡：执行<code>sudo ifup enp0s3 enp0s8</code>，再次执行<code>ip a</code>，可以看到这两个网卡已经获取了IP地址。</p>\n<p>确认网卡工作正常：</p>\n<ul>\n<li>Nat网络连接外网：执行<code>curl ip.cn</code>，应返回一个IP地址和乱码（乱码是IP地址对应的中文的地理位置）</li>\n<li>Host-only连接内网（主机）：执行<code>ping 10.1.1.1 -c 5</code>，应该能ping通。</li>\n</ul>\n<blockquote>\n<p>网络工作正常后，就可以通过ssh登录到虚拟机来执行命令了。</p>\n</blockquote>\n<h2 id=\"系统更新和升级\"><a href=\"#系统更新和升级\" class=\"headerlink\" title=\"系统更新和升级\"></a>系统更新和升级</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo apt update   # 更新apt</div><div class=\"line\">sudo apt upgrade  # 升级系统，可能耗时较长。</div></pre></td></tr></table></figure>\n<p>如果网络速度较慢，可将apt源更换为<a href=\"http://mirrors.163.com/.help/ubuntu.html\" target=\"_blank\" rel=\"external\">国内163</a>的，或者[<a href=\"http://mirrors.nju.edu.cn]，其中Ubuntu\" target=\"_blank\" rel=\"external\">http://mirrors.nju.edu.cn]，其中Ubuntu</a> 16.04的代号是<code>xenial</code>。</p>\n<h2 id=\"可选-切换为root用户\"><a href=\"#可选-切换为root用户\" class=\"headerlink\" title=\"[可选] 切换为root用户\"></a>[可选] 切换为root用户</h2><p>安装系统时设置的的用户有<code>sudo</code>权限。直接使用<code>root</code> <strong>不是</strong> 一种好的做法，不过可以省去很多权限相关的问题和很多命令前面的<code>sudo</code> 。<br>执行<code>sudo passwd</code>，先输入当前用户的密码以授权<code>sudo</code>，然后输入两次<code>root</code>的登录密码。执行<code>exit</code>注销当前用户，以<code>root</code>和刚才设置的密码登录。</p>\n<p>ssh默认禁止<code>root</code>用密码登录。可以修改<code>/etc/ssh/sshd_config</code>允许<code>root</code>使用密码登录，或为<code>root</code>设置使用密钥登录。</p>\n<h2 id=\"可选-设置sudo免密码\"><a href=\"#可选-设置sudo免密码\" class=\"headerlink\" title=\"[可选] 设置sudo免密码\"></a>[可选] 设置sudo免密码</h2><p>如果不想直接使用<code>root</code>用户，还可以设置执行<code>sudo</code>时 <strong>免输密码</strong>。执行<code>sudo visudo</code>(实际上是<code>nano</code>编辑器)，找到 <code>%sudo    ALL=(ALL:ALL) ALL</code>这一行，改为<code>%sudo    ALL=(ALL:ALL) NOPASSWD: ALL</code> 。</p>\n<h2 id=\"杂项设置\"><a href=\"#杂项设置\" class=\"headerlink\" title=\"杂项设置\"></a>杂项设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">; 安装常用软件</div><div class=\"line\">sudo apt install git zsh tree</div><div class=\"line\"></div><div class=\"line\">; 设置Git的全局用户名和Email</div><div class=\"line\">git config --global user.name  &quot;ZHANG Ying&quot;</div><div class=\"line\">git config --global user.email &quot;your@email.com&quot;</div><div class=\"line\"></div><div class=\"line\">; 设置Git换行符转换规则，input选项会把Windows下的CRLF换行符转换成Linux下的LF</div><div class=\"line\">; 参考https://git-scm.com/book/be/v2/Customizing-Git-Git-Configuration</div><div class=\"line\">git config --global core.autocrlf input  # true会将LF转换为CRLF，false则不做任何处理</div><div class=\"line\"></div><div class=\"line\">; 设置zsh和oh-my-zsh</div><div class=\"line\">sudo chsh ying -s /usr/bin/zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</div><div class=\"line\">; 使用短网址  </div><div class=\"line\">wget https://git.io/SM81Wg -O - | sh</div><div class=\"line\"></div><div class=\"line\">; 注销后重新登录，默认的shell已经从bash（dash）切换到了zsh。</div><div class=\"line\"></div><div class=\"line\">; 以下修改~/.zshrc，执行 source ~/.zshrc 应用更改</div><div class=\"line\">; 禁用oh-my-zsh的自动更新，取消下面一行的注释</div><div class=\"line\">DISABLE_AUTO_UPDATE=&quot;true&quot;</div><div class=\"line\"></div><div class=\"line\">; 默认已禁用oh-my-zsh的PATH，可在/etc/enviroment改PATH</div><div class=\"line\"></div><div class=\"line\">; 增加alias</div><div class=\"line\">alias cls=&quot;clear&quot;</div><div class=\"line\">alias dir=&quot;ls -alF&quot;</div><div class=\"line\">alias ipconfig=&quot;ifconfig&quot;</div><div class=\"line\">alias ping=&quot;ping -c 3&quot;</div><div class=\"line\"></div><div class=\"line\">alias ll=&quot;ls -alF&quot;</div><div class=\"line\">alias ps=&quot;ps -af&quot;</div><div class=\"line\">alias netstat=&quot;netstat -nap&quot;</div><div class=\"line\">alias json=&quot;python -m json.tool&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><h3 id=\"PATH环境变量\"><a href=\"#PATH环境变量\" class=\"headerlink\" title=\"PATH环境变量\"></a>PATH环境变量</h3><p>Linux下的绝大多数命令，其实是对应着一个可执行程序的 <strong>文件名</strong>。这些可执行文件分散在 <code>PATH</code> 环境变量设置的目录列表中，比如<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">echo $PATH</div><div class=\"line\">; 输出为</div><div class=\"line\">; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</div></pre></td></tr></table></figure></p>\n<p>可以查看这些目录中都有哪些可执行程序，也就是系统支持的命令了。比如Ubuntu系统安装后已经内置了Python2，Python3，Ruby，Perl，它们的可执行程序都在<code>/usr/bin</code>，可以通过<code>ls /usr/bin</code>来确认。<br>如果在上面的目录中都找不到要执行的程序文件名，那么就会得到 <em>无法找到命令</em> 的错误。如果不是敲错了命令，那么就需要完整的程序路径，或者将程序所在目录加到<code>PATH</code>。<br>当前目录（<code>.</code>）默认没有加入到<code>PATH</code>中去，这是出于安全考虑。要执行当前目录下的程序或脚本，需要<code>./foo.sh</code>这样。</p>\n<h3 id=\"which命令\"><a href=\"#which命令\" class=\"headerlink\" title=\"which命令\"></a><code>which</code>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ which which</div><div class=\"line\">which: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which echo</div><div class=\"line\">echo: shell built-in command</div><div class=\"line\"></div><div class=\"line\">$ which python</div><div class=\"line\">/usr/bin/python</div></pre></td></tr></table></figure>\n<h3 id=\"查看系统版本\"><a href=\"#查看系统版本\" class=\"headerlink\" title=\"查看系统版本\"></a>查看系统版本</h3><p>查看发行版本和代号，执行<code>cat /etc/os-release</code><br>查看内核版本，执行<code>uname -a</code></p>\n<hr>\n<p>设置完成后，关闭VM，在vbox中创建一个快照，另外可以再将虚拟磁盘压缩备份。<br><img src=\"/img/vbox-snapshot.png\" alt=\"\"></p>"},{"title":"安装和设置Windows 10","date":"2016-09-16T16:00:00.000Z","_content":"记录一下安装Windows 10 LTSB 及 基本设置作为备忘。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [为什么是 LTSB](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb)\n- [创建USB安装盘，安装系统](#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [硬盘分区规划](#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92)\n- [常用快捷键](#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE)\n- [系统设置](#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE)\n- [安装Linux常用工具](#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7)\n- [Windows Server 2016 的设置](#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE)\n- [Reg文件](#reg%E6%96%87%E4%BB%B6)\n- [其它](#%E5%85%B6%E5%AE%83)\n    - [开启虚拟wifi](#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi)\n\n<!-- /TOC -->\n\n# 为什么是 LTSB\n1、Win10 LTSB企业版没有Edge浏览器\n2、无应用商店\n3、无任何系统自带磁贴程序\n4、无Cortana\n5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。\n总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。\n此外，还可以使用有学校后缀的Email在微软的[https://imagine.microsoft.com/zh-cn] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。\n\n# 创建USB安装盘，安装系统\n搜索`cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso` 或在[http://msdn.itellyou.cn] 找到下载的ED2K链接，下载后用[Rufus](http://rufus.akeo.ie/) 制作USB启动安装盘，注意要 **取消** `高级选项` 中的 `使用Rufus MBR配合 BIOS ID...`。\n然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。\n\n# 硬盘分区规划\n买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。\n\n# 常用快捷键\n+ Win + D : 切换显示桌面\n+ Win + E : 打开`文件资源管理器`\n+ Win + R : 打开`运行`对话框\n+ Win + X : 打开`开始`按钮的右键快捷菜单，*基本* 对应于`C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX`目录的快捷方式\n  + F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 `F` 键，或写成`Win+X, F`，这些键都在每个菜单项后面标出来了）\n  + P : 控制面板\n  + Y : 系统属性\n  + C/A : 命令窗口\n  + G : 计算机管理\n  + U, I : 注销\n  + U, R : 重启\n  + U, U : 关机\n\n> [向Win+X添加快捷方式](http://blog.sina.com.cn/s/blog_a0c06a350102y239.html)。为了方便使用git附带的minGW，创建了一个指向`git-bash.exe`的快捷方式。可以在`C:\\Users\\Ying\\.bash_profile`增加一个`cd /E/Code`的命令来修改`git-bash`的默认启动目录。\n\n# 系统设置\n\n0. 安装系统更新（会自动安装大部分驱动）\n1. 在`系统属性`对话框中\n  + 更改计算机名\n  + 调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量\n  + 禁用系统保护\n  + 禁用远程协助，开启远程桌面\n2. 关闭休眠：Win+X, A，然后再命令行输入 `powercfg /h off`\n3. 在每个分区，打开`分区属性`对话框，取消`除了文件属性外，还允许索引此驱动器上的文件内容`；磁盘清理，删除`Windows.old`\n4. 安装字体，如`Microsoft Yahei Mono`，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体\n5. 更改IE主页为`about:tabs`，删除内置的加速器\n6. 在`文件夹选项`\n + 设置`打开文件资源管理器时打开`此电脑\n + 取消隐私相关选项\n + `查看`中将大图标文件夹视图`应用到文件夹`\n + 取消`使用共享向导`\n + 取消`始终显示图标，从不显示缩略图`\n + 取消`隐藏受保护的操作系统文件`，选择`显示隐藏的文件、文件夹或驱动器`\n + 取消`隐藏已知文件类型的扩展名`\n7. 在`个性化->主题->桌面图标设置`中选中显示`计算机`桌面图标\n8. 任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标\n9. 禁用防火墙，取消`安全性与维护`中的所有消息\n10. 禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender\n11. 禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索\n12. 安装`百度输入法`，设置使用双拼；安装`7zip`，`迅雷精简版`，`Everything`\n13. 移动系统默认文件夹\n  + 在D盘新建`D:\\桌面`，`D:\\下载`，`D:\\App`，`D:\\文档\\音乐`，`D:文档\\图片`，`D:\\文档\\视频`，`D:文档\\收藏夹`\n  + 在`C:\\Users\\Ying\\`各系统默认文件夹的属性对话框的`位置`选项卡中，将其移动到对应的D盘新位置\n  + `D:\\App`存放一些绿色免安装的程序\n  + **不要** 使用以前的更改注册表的方法来移动默认文件夹\n14. 删除/合并开始菜单项\n  + `C:\\ProgramData\\Microsoft\\Windows\\Start Menu`\n  + `C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu`\n15. 禁用某些服务\n16. 安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用`cleanmaster.exe`清理磁盘和隐私项，使用`winmaster.exe`清理右键菜单\n\nGhost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。\n\n# 安装Linux常用工具\n安装git（不是Github，当然也可以），其中自带`MinGW`，其中有`bash`、`curl`、`vim`、`ssh`等工具。\n在`PATH`环境变量中添上其路径（`D:\\App\\git\\mingw64\\bin`，`D:\\App\\Git\\usr\\bin`和`D:\\App\\Git\\bin`）即可。\n还可以安装 [Linux Subsystem on Windows（WSL）](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) 和 ‎Bash on Ubuntu on Windows。\n\n# Windows Server 2016 的设置\n\n+ 安装系统更新，鲁大师安装不能识别的设备驱动\n+ 设置Windows audio服务为自动启动\n+ 卸载Defender\n+ 组策略-> 计算机配置\n  + Windows设置-> 安全设置-> 帐户策略-> 密码策略-> 密码必须符合复杂性要求\n  + Windows设置-> 安全设置-> 本地策略-> 安全选项-> 交互式登录：无须按Ctrl+Alt+Del\n  + 管理模板-> 系统-> 显示“关闭事件跟踪程序”\n\n# Reg文件\n\n[直接下载Win10.reg](/doc/win10.reg)\n\n```\nWindows Registry Editor Version 5.00\n\n;更改命令行窗口字体\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]\n\"0\"=\"Lucida Console\"\n\"936\"=\"*Microsoft YaHei Mono\"\n\"00\"=\"Consolas\"\n\n;开启的分区共享(C$, D$...)\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]\n\"LocalAccountTokenFilterPolicy\"=dword:00000001\n\n;清除通知区域图标，需重启文件资源管理器\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]\n\n;删除“此电脑”下的6个文件夹\n;视频\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}]\n;文档\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{d3162b92-9365-467a-956b-92703aca08af}]\n;桌面\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}]\n;音乐\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}]\n;下载\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{088e3905-0323-4b02-9826-5d99428e115f}]\n;图片\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]\n\n;删除文件资源管理器左侧的OneDrive\n[HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}\\ShellFolder]\n\"FolderValueFlags\"=dword:00000028\n\"Attributes\"=dword:f090004d\n\n;使用“照片查看器”打开图片\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.gif]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.png]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n\n```\n\n# 其它\n## 开启虚拟wifi\n设置\n```\nnetsh wlan set hostednetwork mode=allow ssid=Ying key=12345678\n```\n\n开启\n```\nnetsh wlan start hostednetwork\n```\n\n连接外网\n有线网卡 的属性中选择`共享`\n","source":"_posts/install-win-10.md","raw":"title: 安装和设置Windows 10\ndate: 2016-09-17\ncategory: [misc]\ntags:\n\n---\n记录一下安装Windows 10 LTSB 及 基本设置作为备忘。\n\n<!--more-->\n\n<!-- TOC -->\n\n- [为什么是 LTSB](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb)\n- [创建USB安装盘，安装系统](#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F)\n- [硬盘分区规划](#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92)\n- [常用快捷键](#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE)\n- [系统设置](#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE)\n- [安装Linux常用工具](#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7)\n- [Windows Server 2016 的设置](#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE)\n- [Reg文件](#reg%E6%96%87%E4%BB%B6)\n- [其它](#%E5%85%B6%E5%AE%83)\n    - [开启虚拟wifi](#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi)\n\n<!-- /TOC -->\n\n# 为什么是 LTSB\n1、Win10 LTSB企业版没有Edge浏览器\n2、无应用商店\n3、无任何系统自带磁贴程序\n4、无Cortana\n5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。\n总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。\n此外，还可以使用有学校后缀的Email在微软的[https://imagine.microsoft.com/zh-cn] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。\n\n# 创建USB安装盘，安装系统\n搜索`cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso` 或在[http://msdn.itellyou.cn] 找到下载的ED2K链接，下载后用[Rufus](http://rufus.akeo.ie/) 制作USB启动安装盘，注意要 **取消** `高级选项` 中的 `使用Rufus MBR配合 BIOS ID...`。\n然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。\n\n# 硬盘分区规划\n买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。\n\n# 常用快捷键\n+ Win + D : 切换显示桌面\n+ Win + E : 打开`文件资源管理器`\n+ Win + R : 打开`运行`对话框\n+ Win + X : 打开`开始`按钮的右键快捷菜单，*基本* 对应于`C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX`目录的快捷方式\n  + F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 `F` 键，或写成`Win+X, F`，这些键都在每个菜单项后面标出来了）\n  + P : 控制面板\n  + Y : 系统属性\n  + C/A : 命令窗口\n  + G : 计算机管理\n  + U, I : 注销\n  + U, R : 重启\n  + U, U : 关机\n\n> [向Win+X添加快捷方式](http://blog.sina.com.cn/s/blog_a0c06a350102y239.html)。为了方便使用git附带的minGW，创建了一个指向`git-bash.exe`的快捷方式。可以在`C:\\Users\\Ying\\.bash_profile`增加一个`cd /E/Code`的命令来修改`git-bash`的默认启动目录。\n\n# 系统设置\n\n0. 安装系统更新（会自动安装大部分驱动）\n1. 在`系统属性`对话框中\n  + 更改计算机名\n  + 调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量\n  + 禁用系统保护\n  + 禁用远程协助，开启远程桌面\n2. 关闭休眠：Win+X, A，然后再命令行输入 `powercfg /h off`\n3. 在每个分区，打开`分区属性`对话框，取消`除了文件属性外，还允许索引此驱动器上的文件内容`；磁盘清理，删除`Windows.old`\n4. 安装字体，如`Microsoft Yahei Mono`，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体\n5. 更改IE主页为`about:tabs`，删除内置的加速器\n6. 在`文件夹选项`\n + 设置`打开文件资源管理器时打开`此电脑\n + 取消隐私相关选项\n + `查看`中将大图标文件夹视图`应用到文件夹`\n + 取消`使用共享向导`\n + 取消`始终显示图标，从不显示缩略图`\n + 取消`隐藏受保护的操作系统文件`，选择`显示隐藏的文件、文件夹或驱动器`\n + 取消`隐藏已知文件类型的扩展名`\n7. 在`个性化->主题->桌面图标设置`中选中显示`计算机`桌面图标\n8. 任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标\n9. 禁用防火墙，取消`安全性与维护`中的所有消息\n10. 禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender\n11. 禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索\n12. 安装`百度输入法`，设置使用双拼；安装`7zip`，`迅雷精简版`，`Everything`\n13. 移动系统默认文件夹\n  + 在D盘新建`D:\\桌面`，`D:\\下载`，`D:\\App`，`D:\\文档\\音乐`，`D:文档\\图片`，`D:\\文档\\视频`，`D:文档\\收藏夹`\n  + 在`C:\\Users\\Ying\\`各系统默认文件夹的属性对话框的`位置`选项卡中，将其移动到对应的D盘新位置\n  + `D:\\App`存放一些绿色免安装的程序\n  + **不要** 使用以前的更改注册表的方法来移动默认文件夹\n14. 删除/合并开始菜单项\n  + `C:\\ProgramData\\Microsoft\\Windows\\Start Menu`\n  + `C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu`\n15. 禁用某些服务\n16. 安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用`cleanmaster.exe`清理磁盘和隐私项，使用`winmaster.exe`清理右键菜单\n\nGhost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。\n\n# 安装Linux常用工具\n安装git（不是Github，当然也可以），其中自带`MinGW`，其中有`bash`、`curl`、`vim`、`ssh`等工具。\n在`PATH`环境变量中添上其路径（`D:\\App\\git\\mingw64\\bin`，`D:\\App\\Git\\usr\\bin`和`D:\\App\\Git\\bin`）即可。\n还可以安装 [Linux Subsystem on Windows（WSL）](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) 和 ‎Bash on Ubuntu on Windows。\n\n# Windows Server 2016 的设置\n\n+ 安装系统更新，鲁大师安装不能识别的设备驱动\n+ 设置Windows audio服务为自动启动\n+ 卸载Defender\n+ 组策略-> 计算机配置\n  + Windows设置-> 安全设置-> 帐户策略-> 密码策略-> 密码必须符合复杂性要求\n  + Windows设置-> 安全设置-> 本地策略-> 安全选项-> 交互式登录：无须按Ctrl+Alt+Del\n  + 管理模板-> 系统-> 显示“关闭事件跟踪程序”\n\n# Reg文件\n\n[直接下载Win10.reg](/doc/win10.reg)\n\n```\nWindows Registry Editor Version 5.00\n\n;更改命令行窗口字体\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]\n\"0\"=\"Lucida Console\"\n\"936\"=\"*Microsoft YaHei Mono\"\n\"00\"=\"Consolas\"\n\n;开启的分区共享(C$, D$...)\n[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]\n\"LocalAccountTokenFilterPolicy\"=dword:00000001\n\n;清除通知区域图标，需重启文件资源管理器\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]\n[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]\n\n;删除“此电脑”下的6个文件夹\n;视频\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a}]\n;文档\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{d3162b92-9365-467a-956b-92703aca08af}]\n;桌面\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}]\n;音乐\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{3dfdf296-dbec-4fb4-81d1-6a3438bcf4de}]\n;下载\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{088e3905-0323-4b02-9826-5d99428e115f}]\n;图片\n[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{24ad3ad4-a569-4530-98e1-ab02f9417aa8}]\n\n;删除文件资源管理器左侧的OneDrive\n[HKEY_CLASSES_ROOT\\CLSID\\{018D5C66-4533-4307-9B53-224DE2ED1FE6}\\ShellFolder]\n\"FolderValueFlags\"=dword:00000028\n\"Attributes\"=dword:f090004d\n\n;使用“照片查看器”打开图片\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.gif]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.png]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]\n@=\"PhotoViewer.FileAssoc.Tiff\"\n\n```\n\n# 其它\n## 开启虚拟wifi\n设置\n```\nnetsh wlan set hostednetwork mode=allow ssid=Ying key=12345678\n```\n\n开启\n```\nnetsh wlan start hostednetwork\n```\n\n连接外网\n有线网卡 的属性中选择`共享`\n","slug":"install-win-10","published":1,"updated":"2017-10-30T03:42:23.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgv00089s4fjohqs8ll","content":"<p>记录一下安装Windows 10 LTSB 及 基本设置作为备忘。</p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb\">为什么是 LTSB</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">创建USB安装盘，安装系统</a></li>\n<li><a href=\"#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92\">硬盘分区规划</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE\">常用快捷键</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE\">系统设置</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7\">安装Linux常用工具</a></li>\n<li><a href=\"#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE\">Windows Server 2016 的设置</a></li>\n<li><a href=\"#reg%E6%96%87%E4%BB%B6\">Reg文件</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a><ul>\n<li><a href=\"#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi\">开启虚拟wifi</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"为什么是-LTSB\"><a href=\"#为什么是-LTSB\" class=\"headerlink\" title=\"为什么是 LTSB\"></a>为什么是 LTSB</h1><p>1、Win10 LTSB企业版没有Edge浏览器<br>2、无应用商店<br>3、无任何系统自带磁贴程序<br>4、无Cortana<br>5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。<br>总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。<br>此外，还可以使用有学校后缀的Email在微软的[<a href=\"https://imagine.microsoft.com/zh-cn\" target=\"_blank\" rel=\"external\">https://imagine.microsoft.com/zh-cn</a>] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。</p>\n<h1 id=\"创建USB安装盘，安装系统\"><a href=\"#创建USB安装盘，安装系统\" class=\"headerlink\" title=\"创建USB安装盘，安装系统\"></a>创建USB安装盘，安装系统</h1><p>搜索<code>cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso</code> 或在[<a href=\"http://msdn.itellyou.cn\" target=\"_blank\" rel=\"external\">http://msdn.itellyou.cn</a>] 找到下载的ED2K链接，下载后用<a href=\"http://rufus.akeo.ie/\" target=\"_blank\" rel=\"external\">Rufus</a> 制作USB启动安装盘，注意要 <strong>取消</strong> <code>高级选项</code> 中的 <code>使用Rufus MBR配合 BIOS ID...</code>。<br>然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。</p>\n<h1 id=\"硬盘分区规划\"><a href=\"#硬盘分区规划\" class=\"headerlink\" title=\"硬盘分区规划\"></a>硬盘分区规划</h1><p>买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。</p>\n<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ul>\n<li>Win + D : 切换显示桌面</li>\n<li>Win + E : 打开<code>文件资源管理器</code></li>\n<li>Win + R : 打开<code>运行</code>对话框</li>\n<li>Win + X : 打开<code>开始</code>按钮的右键快捷菜单，<em>基本</em> 对应于<code>C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX</code>目录的快捷方式<ul>\n<li>F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 <code>F</code> 键，或写成<code>Win+X, F</code>，这些键都在每个菜单项后面标出来了）</li>\n<li>P : 控制面板</li>\n<li>Y : 系统属性</li>\n<li>C/A : 命令窗口</li>\n<li>G : 计算机管理</li>\n<li>U, I : 注销</li>\n<li>U, R : 重启</li>\n<li>U, U : 关机</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"http://blog.sina.com.cn/s/blog_a0c06a350102y239.html\" target=\"_blank\" rel=\"external\">向Win+X添加快捷方式</a>。为了方便使用git附带的minGW，创建了一个指向<code>git-bash.exe</code>的快捷方式。可以在<code>C:\\Users\\Ying\\.bash_profile</code>增加一个<code>cd /E/Code</code>的命令来修改<code>git-bash</code>的默认启动目录。</p>\n</blockquote>\n<h1 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h1><ol>\n<li>安装系统更新（会自动安装大部分驱动）</li>\n<li>在<code>系统属性</code>对话框中<ul>\n<li>更改计算机名</li>\n<li>调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量</li>\n<li>禁用系统保护</li>\n<li>禁用远程协助，开启远程桌面</li>\n</ul>\n</li>\n<li>关闭休眠：Win+X, A，然后再命令行输入 <code>powercfg /h off</code></li>\n<li>在每个分区，打开<code>分区属性</code>对话框，取消<code>除了文件属性外，还允许索引此驱动器上的文件内容</code>；磁盘清理，删除<code>Windows.old</code></li>\n<li>安装字体，如<code>Microsoft Yahei Mono</code>，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体</li>\n<li>更改IE主页为<code>about:tabs</code>，删除内置的加速器</li>\n<li>在<code>文件夹选项</code><ul>\n<li>设置<code>打开文件资源管理器时打开</code>此电脑</li>\n<li>取消隐私相关选项</li>\n<li><code>查看</code>中将大图标文件夹视图<code>应用到文件夹</code></li>\n<li>取消<code>使用共享向导</code></li>\n<li>取消<code>始终显示图标，从不显示缩略图</code></li>\n<li>取消<code>隐藏受保护的操作系统文件</code>，选择<code>显示隐藏的文件、文件夹或驱动器</code></li>\n<li>取消<code>隐藏已知文件类型的扩展名</code></li>\n</ul>\n</li>\n<li>在<code>个性化-&gt;主题-&gt;桌面图标设置</code>中选中显示<code>计算机</code>桌面图标</li>\n<li>任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标</li>\n<li>禁用防火墙，取消<code>安全性与维护</code>中的所有消息</li>\n<li>禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender</li>\n<li>禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索</li>\n<li>安装<code>百度输入法</code>，设置使用双拼；安装<code>7zip</code>，<code>迅雷精简版</code>，<code>Everything</code></li>\n<li>移动系统默认文件夹<ul>\n<li>在D盘新建<code>D:\\桌面</code>，<code>D:\\下载</code>，<code>D:\\App</code>，<code>D:\\文档\\音乐</code>，<code>D:文档\\图片</code>，<code>D:\\文档\\视频</code>，<code>D:文档\\收藏夹</code></li>\n<li>在<code>C:\\Users\\Ying\\</code>各系统默认文件夹的属性对话框的<code>位置</code>选项卡中，将其移动到对应的D盘新位置</li>\n<li><code>D:\\App</code>存放一些绿色免安装的程序</li>\n<li><strong>不要</strong> 使用以前的更改注册表的方法来移动默认文件夹</li>\n</ul>\n</li>\n<li>删除/合并开始菜单项<ul>\n<li><code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu</code></li>\n<li><code>C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu</code></li>\n</ul>\n</li>\n<li>禁用某些服务</li>\n<li>安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用<code>cleanmaster.exe</code>清理磁盘和隐私项，使用<code>winmaster.exe</code>清理右键菜单</li>\n</ol>\n<p>Ghost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。</p>\n<h1 id=\"安装Linux常用工具\"><a href=\"#安装Linux常用工具\" class=\"headerlink\" title=\"安装Linux常用工具\"></a>安装Linux常用工具</h1><p>安装git（不是Github，当然也可以），其中自带<code>MinGW</code>，其中有<code>bash</code>、<code>curl</code>、<code>vim</code>、<code>ssh</code>等工具。<br>在<code>PATH</code>环境变量中添上其路径（<code>D:\\App\\git\\mingw64\\bin</code>，<code>D:\\App\\Git\\usr\\bin</code>和<code>D:\\App\\Git\\bin</code>）即可。<br>还可以安装 <a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/install_guide\" target=\"_blank\" rel=\"external\">Linux Subsystem on Windows（WSL）</a> 和 ‎Bash on Ubuntu on Windows。</p>\n<h1 id=\"Windows-Server-2016-的设置\"><a href=\"#Windows-Server-2016-的设置\" class=\"headerlink\" title=\"Windows Server 2016 的设置\"></a>Windows Server 2016 的设置</h1><ul>\n<li>安装系统更新，鲁大师安装不能识别的设备驱动</li>\n<li>设置Windows audio服务为自动启动</li>\n<li>卸载Defender</li>\n<li>组策略-&gt; 计算机配置<ul>\n<li>Windows设置-&gt; 安全设置-&gt; 帐户策略-&gt; 密码策略-&gt; 密码必须符合复杂性要求</li>\n<li>Windows设置-&gt; 安全设置-&gt; 本地策略-&gt; 安全选项-&gt; 交互式登录：无须按Ctrl+Alt+Del</li>\n<li>管理模板-&gt; 系统-&gt; 显示“关闭事件跟踪程序”</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Reg文件\"><a href=\"#Reg文件\" class=\"headerlink\" title=\"Reg文件\"></a>Reg文件</h1><p><a href=\"/doc/win10.reg\">直接下载Win10.reg</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">Windows Registry Editor Version 5.00</div><div class=\"line\"></div><div class=\"line\">;更改命令行窗口字体</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]</div><div class=\"line\">&quot;0&quot;=&quot;Lucida Console&quot;</div><div class=\"line\">&quot;936&quot;=&quot;*Microsoft YaHei Mono&quot;</div><div class=\"line\">&quot;00&quot;=&quot;Consolas&quot;</div><div class=\"line\"></div><div class=\"line\">;开启的分区共享(C$, D$...)</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]</div><div class=\"line\">&quot;LocalAccountTokenFilterPolicy&quot;=dword:00000001</div><div class=\"line\"></div><div class=\"line\">;清除通知区域图标，需重启文件资源管理器</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]</div><div class=\"line\"></div><div class=\"line\">;删除“此电脑”下的6个文件夹</div><div class=\"line\">;视频</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a&#125;]</div><div class=\"line\">;文档</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;d3162b92-9365-467a-956b-92703aca08af&#125;]</div><div class=\"line\">;桌面</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;B4BFCC3A-DB2C-424C-B029-7FE99A87C641&#125;]</div><div class=\"line\">;音乐</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;3dfdf296-dbec-4fb4-81d1-6a3438bcf4de&#125;]</div><div class=\"line\">;下载</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;088e3905-0323-4b02-9826-5d99428e115f&#125;]</div><div class=\"line\">;图片</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;24ad3ad4-a569-4530-98e1-ab02f9417aa8&#125;]</div><div class=\"line\"></div><div class=\"line\">;删除文件资源管理器左侧的OneDrive</div><div class=\"line\">[HKEY_CLASSES_ROOT\\CLSID\\&#123;018D5C66-4533-4307-9B53-224DE2ED1FE6&#125;\\ShellFolder]</div><div class=\"line\">&quot;FolderValueFlags&quot;=dword:00000028</div><div class=\"line\">&quot;Attributes&quot;=dword:f090004d</div><div class=\"line\"></div><div class=\"line\">;使用“照片查看器”打开图片</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.gif]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.png]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div></pre></td></tr></table></figure>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"开启虚拟wifi\"><a href=\"#开启虚拟wifi\" class=\"headerlink\" title=\"开启虚拟wifi\"></a>开启虚拟wifi</h2><p>设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan set hostednetwork mode=allow ssid=Ying key=12345678</div></pre></td></tr></table></figure></p>\n<p>开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan start hostednetwork</div></pre></td></tr></table></figure></p>\n<p>连接外网<br>有线网卡 的属性中选择<code>共享</code></p>\n","site":{"data":{}},"excerpt":"<p>记录一下安装Windows 10 LTSB 及 基本设置作为备忘。</p>","more":"<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-ltsb\">为什么是 LTSB</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAusb%E5%AE%89%E8%A3%85%E7%9B%98%EF%BC%8C%E5%AE%89%E8%A3%85%E7%B3%BB%E7%BB%9F\">创建USB安装盘，安装系统</a></li>\n<li><a href=\"#%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92\">硬盘分区规划</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE\">常用快捷键</a></li>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE\">系统设置</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7\">安装Linux常用工具</a></li>\n<li><a href=\"#windows-server-2016-%E7%9A%84%E8%AE%BE%E7%BD%AE\">Windows Server 2016 的设置</a></li>\n<li><a href=\"#reg%E6%96%87%E4%BB%B6\">Reg文件</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a><ul>\n<li><a href=\"#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9Fwifi\">开启虚拟wifi</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"为什么是-LTSB\"><a href=\"#为什么是-LTSB\" class=\"headerlink\" title=\"为什么是 LTSB\"></a>为什么是 LTSB</h1><p>1、Win10 LTSB企业版没有Edge浏览器<br>2、无应用商店<br>3、无任何系统自带磁贴程序<br>4、无Cortana<br>5、在系统更新方面，用户能完全手动控制更新，选择和决定自己要的更新和驱动，更新内容和更新时间可以随意控制，但不能无限期推迟。<br>总结起来就是微软官方精简版啊。而且学校的KMS可以正常激活2015版的LTSB。<br>此外，还可以使用有学校后缀的Email在微软的[<a href=\"https://imagine.microsoft.com/zh-cn\" target=\"_blank\" rel=\"external\">https://imagine.microsoft.com/zh-cn</a>] 认证一个学生帐号，即可免费获得一个Windows Server 2016版的密钥。Win Server也是精简的，还可以彻底卸载Defender。</p>\n<h1 id=\"创建USB安装盘，安装系统\"><a href=\"#创建USB安装盘，安装系统\" class=\"headerlink\" title=\"创建USB安装盘，安装系统\"></a>创建USB安装盘，安装系统</h1><p>搜索<code>cn_windows_10_enterprise_2016_ltsb_x64_dvd_9060409.iso</code> 或在[<a href=\"http://msdn.itellyou.cn\" target=\"_blank\" rel=\"external\">http://msdn.itellyou.cn</a>] 找到下载的ED2K链接，下载后用<a href=\"http://rufus.akeo.ie/\" target=\"_blank\" rel=\"external\">Rufus</a> 制作USB启动安装盘，注意要 <strong>取消</strong> <code>高级选项</code> 中的 <code>使用Rufus MBR配合 BIOS ID...</code>。<br>然后重启机器，选择从U盘启动，按界面一步步安装系统即可。新建的用户一定要设置密码，方便后面远程操作。</p>\n<h1 id=\"硬盘分区规划\"><a href=\"#硬盘分区规划\" class=\"headerlink\" title=\"硬盘分区规划\"></a>硬盘分区规划</h1><p>买一个SSD，只分一个区，即C盘，系统装在上面，以后的应用程序一般也按默认路径装在C盘。机器自带的机械硬盘，也只分一个区，保存个人数据。如果只有一块硬盘，也只要分一个系统分区和一个数据分区即可。多分无用，平添麻烦。如果需要Linux，装在虚拟机里，不要搞双系统。</p>\n<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ul>\n<li>Win + D : 切换显示桌面</li>\n<li>Win + E : 打开<code>文件资源管理器</code></li>\n<li>Win + R : 打开<code>运行</code>对话框</li>\n<li>Win + X : 打开<code>开始</code>按钮的右键快捷菜单，<em>基本</em> 对应于<code>C:\\Users\\Ying\\AppData\\Local\\Microsoft\\Windows\\WinX</code>目录的快捷方式<ul>\n<li>F : 程序和功能（即弹出上面的菜单后，松开手，再按小写的 <code>F</code> 键，或写成<code>Win+X, F</code>，这些键都在每个菜单项后面标出来了）</li>\n<li>P : 控制面板</li>\n<li>Y : 系统属性</li>\n<li>C/A : 命令窗口</li>\n<li>G : 计算机管理</li>\n<li>U, I : 注销</li>\n<li>U, R : 重启</li>\n<li>U, U : 关机</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><a href=\"http://blog.sina.com.cn/s/blog_a0c06a350102y239.html\" target=\"_blank\" rel=\"external\">向Win+X添加快捷方式</a>。为了方便使用git附带的minGW，创建了一个指向<code>git-bash.exe</code>的快捷方式。可以在<code>C:\\Users\\Ying\\.bash_profile</code>增加一个<code>cd /E/Code</code>的命令来修改<code>git-bash</code>的默认启动目录。</p>\n</blockquote>\n<h1 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h1><ol>\n<li>安装系统更新（会自动安装大部分驱动）</li>\n<li>在<code>系统属性</code>对话框中<ul>\n<li>更改计算机名</li>\n<li>调整视觉效果，禁用虚拟内存，修改默认启动项和等待时间，修改环境变量</li>\n<li>禁用系统保护</li>\n<li>禁用远程协助，开启远程桌面</li>\n</ul>\n</li>\n<li>关闭休眠：Win+X, A，然后再命令行输入 <code>powercfg /h off</code></li>\n<li>在每个分区，打开<code>分区属性</code>对话框，取消<code>除了文件属性外，还允许索引此驱动器上的文件内容</code>；磁盘清理，删除<code>Windows.old</code></li>\n<li>安装字体，如<code>Microsoft Yahei Mono</code>，更改命令行窗口的默认字体（使用Microsoft Yahei Mono，见下面的注册表项）、颜色和半透明效果；更改记事本的字体</li>\n<li>更改IE主页为<code>about:tabs</code>，删除内置的加速器</li>\n<li>在<code>文件夹选项</code><ul>\n<li>设置<code>打开文件资源管理器时打开</code>此电脑</li>\n<li>取消隐私相关选项</li>\n<li><code>查看</code>中将大图标文件夹视图<code>应用到文件夹</code></li>\n<li>取消<code>使用共享向导</code></li>\n<li>取消<code>始终显示图标，从不显示缩略图</code></li>\n<li>取消<code>隐藏受保护的操作系统文件</code>，选择<code>显示隐藏的文件、文件夹或驱动器</code></li>\n<li>取消<code>隐藏已知文件类型的扩展名</code></li>\n</ul>\n</li>\n<li>在<code>个性化-&gt;主题-&gt;桌面图标设置</code>中选中显示<code>计算机</code>桌面图标</li>\n<li>任务栏上不显示搜索和任务视图按钮，使用小图标，显示所有托盘图标</li>\n<li>禁用防火墙，取消<code>安全性与维护</code>中的所有消息</li>\n<li>禁用Defender，：组策略，计算机配置，管理模板，Windows组件，Windows Defender</li>\n<li>禁用contana：组策略，计算机配置，管理模板，Windows组件，搜索</li>\n<li>安装<code>百度输入法</code>，设置使用双拼；安装<code>7zip</code>，<code>迅雷精简版</code>，<code>Everything</code></li>\n<li>移动系统默认文件夹<ul>\n<li>在D盘新建<code>D:\\桌面</code>，<code>D:\\下载</code>，<code>D:\\App</code>，<code>D:\\文档\\音乐</code>，<code>D:文档\\图片</code>，<code>D:\\文档\\视频</code>，<code>D:文档\\收藏夹</code></li>\n<li>在<code>C:\\Users\\Ying\\</code>各系统默认文件夹的属性对话框的<code>位置</code>选项卡中，将其移动到对应的D盘新位置</li>\n<li><code>D:\\App</code>存放一些绿色免安装的程序</li>\n<li><strong>不要</strong> 使用以前的更改注册表的方法来移动默认文件夹</li>\n</ul>\n</li>\n<li>删除/合并开始菜单项<ul>\n<li><code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu</code></li>\n<li><code>C:\\Users\\Ying\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu</code></li>\n</ul>\n</li>\n<li>禁用某些服务</li>\n<li>安装360，检查/清理系统，优化设置，然后卸掉；下载魔方PC Master绿色版，删掉自动更新等无关程序，使用<code>cleanmaster.exe</code>清理磁盘和隐私项，使用<code>winmaster.exe</code>清理右键菜单</li>\n</ol>\n<p>Ghost制作系统备份。之后安装Office，Acrobat，QQ影音，Paint.net，xshell，Chrome，QQ，微信，百度云，Visual Studio Code，VMWare，MikTex，TexStudio，Jetbrains全家桶，打印机驱动等。</p>\n<h1 id=\"安装Linux常用工具\"><a href=\"#安装Linux常用工具\" class=\"headerlink\" title=\"安装Linux常用工具\"></a>安装Linux常用工具</h1><p>安装git（不是Github，当然也可以），其中自带<code>MinGW</code>，其中有<code>bash</code>、<code>curl</code>、<code>vim</code>、<code>ssh</code>等工具。<br>在<code>PATH</code>环境变量中添上其路径（<code>D:\\App\\git\\mingw64\\bin</code>，<code>D:\\App\\Git\\usr\\bin</code>和<code>D:\\App\\Git\\bin</code>）即可。<br>还可以安装 <a href=\"https://msdn.microsoft.com/en-us/commandline/wsl/install_guide\" target=\"_blank\" rel=\"external\">Linux Subsystem on Windows（WSL）</a> 和 ‎Bash on Ubuntu on Windows。</p>\n<h1 id=\"Windows-Server-2016-的设置\"><a href=\"#Windows-Server-2016-的设置\" class=\"headerlink\" title=\"Windows Server 2016 的设置\"></a>Windows Server 2016 的设置</h1><ul>\n<li>安装系统更新，鲁大师安装不能识别的设备驱动</li>\n<li>设置Windows audio服务为自动启动</li>\n<li>卸载Defender</li>\n<li>组策略-&gt; 计算机配置<ul>\n<li>Windows设置-&gt; 安全设置-&gt; 帐户策略-&gt; 密码策略-&gt; 密码必须符合复杂性要求</li>\n<li>Windows设置-&gt; 安全设置-&gt; 本地策略-&gt; 安全选项-&gt; 交互式登录：无须按Ctrl+Alt+Del</li>\n<li>管理模板-&gt; 系统-&gt; 显示“关闭事件跟踪程序”</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Reg文件\"><a href=\"#Reg文件\" class=\"headerlink\" title=\"Reg文件\"></a>Reg文件</h1><p><a href=\"/doc/win10.reg\">直接下载Win10.reg</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">Windows Registry Editor Version 5.00</div><div class=\"line\"></div><div class=\"line\">;更改命令行窗口字体</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont]</div><div class=\"line\">&quot;0&quot;=&quot;Lucida Console&quot;</div><div class=\"line\">&quot;936&quot;=&quot;*Microsoft YaHei Mono&quot;</div><div class=\"line\">&quot;00&quot;=&quot;Consolas&quot;</div><div class=\"line\"></div><div class=\"line\">;开启的分区共享(C$, D$...)</div><div class=\"line\">[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System]</div><div class=\"line\">&quot;LocalAccountTokenFilterPolicy&quot;=dword:00000001</div><div class=\"line\"></div><div class=\"line\">;清除通知区域图标，需重启文件资源管理器</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\PastIconsStream]</div><div class=\"line\">[-HKEY_CURRENT_USER\\Software\\Classes\\LocalSettings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify\\IconStreams]</div><div class=\"line\"></div><div class=\"line\">;删除“此电脑”下的6个文件夹</div><div class=\"line\">;视频</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;f86fa3ab-70d2-4fc7-9c99-fcbf05467f3a&#125;]</div><div class=\"line\">;文档</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;d3162b92-9365-467a-956b-92703aca08af&#125;]</div><div class=\"line\">;桌面</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;B4BFCC3A-DB2C-424C-B029-7FE99A87C641&#125;]</div><div class=\"line\">;音乐</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;3dfdf296-dbec-4fb4-81d1-6a3438bcf4de&#125;]</div><div class=\"line\">;下载</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;088e3905-0323-4b02-9826-5d99428e115f&#125;]</div><div class=\"line\">;图片</div><div class=\"line\">[-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\&#123;24ad3ad4-a569-4530-98e1-ab02f9417aa8&#125;]</div><div class=\"line\"></div><div class=\"line\">;删除文件资源管理器左侧的OneDrive</div><div class=\"line\">[HKEY_CLASSES_ROOT\\CLSID\\&#123;018D5C66-4533-4307-9B53-224DE2ED1FE6&#125;\\ShellFolder]</div><div class=\"line\">&quot;FolderValueFlags&quot;=dword:00000028</div><div class=\"line\">&quot;Attributes&quot;=dword:f090004d</div><div class=\"line\"></div><div class=\"line\">;使用“照片查看器”打开图片</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.jpeg]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.gif]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.png]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.bmp]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div><div class=\"line\">[HKEY_CURRENT_USER\\Software\\Classes\\.tiff]</div><div class=\"line\">@=&quot;PhotoViewer.FileAssoc.Tiff&quot;</div></pre></td></tr></table></figure>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><h2 id=\"开启虚拟wifi\"><a href=\"#开启虚拟wifi\" class=\"headerlink\" title=\"开启虚拟wifi\"></a>开启虚拟wifi</h2><p>设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan set hostednetwork mode=allow ssid=Ying key=12345678</div></pre></td></tr></table></figure></p>\n<p>开启<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">netsh wlan start hostednetwork</div></pre></td></tr></table></figure></p>\n<p>连接外网<br>有线网卡 的属性中选择<code>共享</code></p>"},{"title":"在MPI集群执行Linpack测试","date":"2017-04-11T16:00:00.000Z","_content":"使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。\n尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。\n后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(\n<!--more-->\n\n<!-- TOC -->\n\n- [安装和设置mpich，blas（atlas），hpl](#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl)\n    - [设置mpich](#%E8%AE%BE%E7%BD%AEmpich)\n    - [BLAS, LINPACK/LAPACK, HPL](#blas-linpacklapack-hpl)\n    - [单机上执行 HPL](#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl)\n- [使用Intel MKL Benchmarks](#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks)\n- [Todo: 集群中测试mpi xhpl](#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl)\n\n<!-- /TOC -->\n\n# 安装和设置mpich，blas（atlas），hpl\n编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。\n\n## 设置mpich\n参考 [MPI安装手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf) 和 [MPI用户手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf)\n```\n# 安装编译器\nyum install -y gcc gcc-gfortran gcc-c++ bzip2 wget\n\n# yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译\nwget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz\ntar axf mpich-3.2.tar.gz\ncd ~/mpich-3.2\n./configure prefix=/opt/mpich\nmake -j 8 && make install  # make只会编译lib，make install才会编译lib和bin\n\ncp -r examples/ /opt/mpich/\n\n# 把编译结果打包\ncd ~\ntar zcf mpich-3.2-build.tar.gz /opt/mpich/\n# 可以将其保存到主机上\n\necho 'export PATH=$PATH:/opt/mpich/bin'                         >> /etc/profile\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib'   >> /etc/profile\nsource /etc/profile\n\n# 在本机测试一下\nmpiexec -n 3 /opt/mpich/examples/cpi\n```\n\nmpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。\nmpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。\n如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。\n要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。\n\n## BLAS, LINPACK/LAPACK, HPL\n[BLAS（Basic Linear Algebra Subprograms）- wiki](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) 或 [BLAS基础线性代数程序集 - wiki](https://zh.wikipedia.org/wiki/BLAS) 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。\n```\nwget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2\ntar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2\ncd ATLAS\nmkdir build; cd build\n../configure\nmake -j 8 && make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include\n# 同样将编译的结果也打包保存\nmkdir atlas\nmv bin/ lib/ include/ atlas/\ntar zcf atlas-build.tar.gz atlas/\n```\n\n[LINPACK](https://en.wikipedia.org/wiki/LINPACK)是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继[LAPACK](https://en.wikipedia.org/wiki/LAPACK)。[HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）](http://www.netlib.org/benchmark/hpl/)是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。\n\n参考 http://blog.chinaunix.net/uid-20104120-id-4071017.html 。\n```\nwget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz\ntar axf hpl-2.2.tar.gz\ncd hpl-2.2\ncp setup/Make.Linux_PII_CBLAS_gm Make.x86_64\n\n# 编辑 Make.x86_64，修改的内容如下。\n# 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。\n# 注意各值结尾不要有 空格。\n# 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录\nARCH         = x86_64\n\nTOPdir       = $(HOME)/hpl-2.2\nINCdir       = $(TOPdir)/include\nBINdir       = $(TOPdir)/bin\nLIBdir       = $(TOPdir)/lib\n\nMPdir        =\nMPinc        =\nMPlib        =\n\nLAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录\nLAinc        = -I$(LAdir)/include\nLAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a\n\n# 开始编译\nmake arch=x86_64 -j 8\n\n# 也将编译的结果也打包保存\nmv hpl hpl.bk.d; mkdir hpl\nmv bin/ lib/ include/ hpl/\nrmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/\ntar zcf hpl-build.tar.gz hpl/\n```\n\n## 单机上执行 HPL\n```\ncd /root/hpl-2.2/hpl/bin/\nmpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS\n# 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响\n```\n\n# 使用Intel MKL Benchmarks\n参考 https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite 。\n\n```\nwget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz\ntar axf l_mklb_p_2017.2.015.tgz\ncd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack\n./runme_xeon64\n```\n测试的结果约 150GFLOPS。\n还有一个Windows版的，在主机上测试也是接近的结果。\n\n# Todo: 集群中测试mpi xhpl\n直接运行 `l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack` 中的 `runme_intel64_static` 会报不识别 perhost 参数的错误。\n执行 `mpiexec -f hosts -n 12 ./xhpl_intel64_static`（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过`top`监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？\n参考\n+ [Intel® MPI Library - Documentation](https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation)\n+ [Intel® Optimized MP LINPACK Benchmark for Clusters](https://software.intel.com/en-us/node/528457)\n+ [HPL application note](https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note)\n+ [HPC LINPACK benchmark](http://khmel.org/?p=527)\n+ [如何做LINPACK测试及性能优化](http://blog.sciencenet.cn/blog-935970-892936.html)\n","source":"_posts/install-linpack-xhpl.md","raw":"title: 在MPI集群执行Linpack测试\ndate: 2017-04-12\ncategory: [misc]\ntags:\n\n---\n使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。\n尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。\n后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(\n<!--more-->\n\n<!-- TOC -->\n\n- [安装和设置mpich，blas（atlas），hpl](#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl)\n    - [设置mpich](#%E8%AE%BE%E7%BD%AEmpich)\n    - [BLAS, LINPACK/LAPACK, HPL](#blas-linpacklapack-hpl)\n    - [单机上执行 HPL](#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl)\n- [使用Intel MKL Benchmarks](#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks)\n- [Todo: 集群中测试mpi xhpl](#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl)\n\n<!-- /TOC -->\n\n# 安装和设置mpich，blas（atlas），hpl\n编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。\n\n## 设置mpich\n参考 [MPI安装手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf) 和 [MPI用户手册](http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf)\n```\n# 安装编译器\nyum install -y gcc gcc-gfortran gcc-c++ bzip2 wget\n\n# yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译\nwget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz\ntar axf mpich-3.2.tar.gz\ncd ~/mpich-3.2\n./configure prefix=/opt/mpich\nmake -j 8 && make install  # make只会编译lib，make install才会编译lib和bin\n\ncp -r examples/ /opt/mpich/\n\n# 把编译结果打包\ncd ~\ntar zcf mpich-3.2-build.tar.gz /opt/mpich/\n# 可以将其保存到主机上\n\necho 'export PATH=$PATH:/opt/mpich/bin'                         >> /etc/profile\necho 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib'   >> /etc/profile\nsource /etc/profile\n\n# 在本机测试一下\nmpiexec -n 3 /opt/mpich/examples/cpi\n```\n\nmpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。\nmpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。\n如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。\n要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。\n\n## BLAS, LINPACK/LAPACK, HPL\n[BLAS（Basic Linear Algebra Subprograms）- wiki](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms) 或 [BLAS基础线性代数程序集 - wiki](https://zh.wikipedia.org/wiki/BLAS) 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。\n```\nwget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2\ntar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2\ncd ATLAS\nmkdir build; cd build\n../configure\nmake -j 8 && make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include\n# 同样将编译的结果也打包保存\nmkdir atlas\nmv bin/ lib/ include/ atlas/\ntar zcf atlas-build.tar.gz atlas/\n```\n\n[LINPACK](https://en.wikipedia.org/wiki/LINPACK)是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继[LAPACK](https://en.wikipedia.org/wiki/LAPACK)。[HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）](http://www.netlib.org/benchmark/hpl/)是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。\n\n参考 http://blog.chinaunix.net/uid-20104120-id-4071017.html 。\n```\nwget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz\ntar axf hpl-2.2.tar.gz\ncd hpl-2.2\ncp setup/Make.Linux_PII_CBLAS_gm Make.x86_64\n\n# 编辑 Make.x86_64，修改的内容如下。\n# 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。\n# 注意各值结尾不要有 空格。\n# 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录\nARCH         = x86_64\n\nTOPdir       = $(HOME)/hpl-2.2\nINCdir       = $(TOPdir)/include\nBINdir       = $(TOPdir)/bin\nLIBdir       = $(TOPdir)/lib\n\nMPdir        =\nMPinc        =\nMPlib        =\n\nLAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录\nLAinc        = -I$(LAdir)/include\nLAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a\n\n# 开始编译\nmake arch=x86_64 -j 8\n\n# 也将编译的结果也打包保存\nmv hpl hpl.bk.d; mkdir hpl\nmv bin/ lib/ include/ hpl/\nrmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/\ntar zcf hpl-build.tar.gz hpl/\n```\n\n## 单机上执行 HPL\n```\ncd /root/hpl-2.2/hpl/bin/\nmpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS\n# 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响\n```\n\n# 使用Intel MKL Benchmarks\n参考 https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite 。\n\n```\nwget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz\ntar axf l_mklb_p_2017.2.015.tgz\ncd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack\n./runme_xeon64\n```\n测试的结果约 150GFLOPS。\n还有一个Windows版的，在主机上测试也是接近的结果。\n\n# Todo: 集群中测试mpi xhpl\n直接运行 `l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack` 中的 `runme_intel64_static` 会报不识别 perhost 参数的错误。\n执行 `mpiexec -f hosts -n 12 ./xhpl_intel64_static`（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过`top`监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？\n参考\n+ [Intel® MPI Library - Documentation](https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation)\n+ [Intel® Optimized MP LINPACK Benchmark for Clusters](https://software.intel.com/en-us/node/528457)\n+ [HPL application note](https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note)\n+ [HPC LINPACK benchmark](http://khmel.org/?p=527)\n+ [如何做LINPACK测试及性能优化](http://blog.sciencenet.cn/blog-935970-892936.html)\n","slug":"install-linpack-xhpl","published":1,"updated":"2017-10-30T03:41:18.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgy000b9s4firh86gus","content":"<p>使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。<br>尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。<br>后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl\">安装和设置mpich，blas（atlas），hpl</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEmpich\">设置mpich</a></li>\n<li><a href=\"#blas-linpacklapack-hpl\">BLAS, LINPACK/LAPACK, HPL</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl\">单机上执行 HPL</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks\">使用Intel MKL Benchmarks</a></li>\n<li><a href=\"#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl\">Todo: 集群中测试mpi xhpl</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"安装和设置mpich，blas（atlas），hpl\"><a href=\"#安装和设置mpich，blas（atlas），hpl\" class=\"headerlink\" title=\"安装和设置mpich，blas（atlas），hpl\"></a>安装和设置mpich，blas（atlas），hpl</h1><p>编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。</p>\n<h2 id=\"设置mpich\"><a href=\"#设置mpich\" class=\"headerlink\" title=\"设置mpich\"></a>设置mpich</h2><p>参考 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf\" target=\"_blank\" rel=\"external\">MPI安装手册</a> 和 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf\" target=\"_blank\" rel=\"external\">MPI用户手册</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 安装编译器</div><div class=\"line\">yum install -y gcc gcc-gfortran gcc-c++ bzip2 wget</div><div class=\"line\"></div><div class=\"line\"># yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译</div><div class=\"line\">wget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz</div><div class=\"line\">tar axf mpich-3.2.tar.gz</div><div class=\"line\">cd ~/mpich-3.2</div><div class=\"line\">./configure prefix=/opt/mpich</div><div class=\"line\">make -j 8 &amp;&amp; make install  # make只会编译lib，make install才会编译lib和bin</div><div class=\"line\"></div><div class=\"line\">cp -r examples/ /opt/mpich/</div><div class=\"line\"></div><div class=\"line\"># 把编译结果打包</div><div class=\"line\">cd ~</div><div class=\"line\">tar zcf mpich-3.2-build.tar.gz /opt/mpich/</div><div class=\"line\"># 可以将其保存到主机上</div><div class=\"line\"></div><div class=\"line\">echo &apos;export PATH=$PATH:/opt/mpich/bin&apos;                         &gt;&gt; /etc/profile</div><div class=\"line\">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib&apos;   &gt;&gt; /etc/profile</div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\"># 在本机测试一下</div><div class=\"line\">mpiexec -n 3 /opt/mpich/examples/cpi</div></pre></td></tr></table></figure></p>\n<p>mpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。<br>mpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。<br>如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。<br>要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。</p>\n<h2 id=\"BLAS-LINPACK-LAPACK-HPL\"><a href=\"#BLAS-LINPACK-LAPACK-HPL\" class=\"headerlink\" title=\"BLAS, LINPACK/LAPACK, HPL\"></a>BLAS, LINPACK/LAPACK, HPL</h2><p><a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\" target=\"_blank\" rel=\"external\">BLAS（Basic Linear Algebra Subprograms）- wiki</a> 或 <a href=\"https://zh.wikipedia.org/wiki/BLAS\" target=\"_blank\" rel=\"external\">BLAS基础线性代数程序集 - wiki</a> 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2</div><div class=\"line\">tar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2</div><div class=\"line\">cd ATLAS</div><div class=\"line\">mkdir build; cd build</div><div class=\"line\">../configure</div><div class=\"line\">make -j 8 &amp;&amp; make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include</div><div class=\"line\"># 同样将编译的结果也打包保存</div><div class=\"line\">mkdir atlas</div><div class=\"line\">mv bin/ lib/ include/ atlas/</div><div class=\"line\">tar zcf atlas-build.tar.gz atlas/</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://en.wikipedia.org/wiki/LINPACK\" target=\"_blank\" rel=\"external\">LINPACK</a>是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继<a href=\"https://en.wikipedia.org/wiki/LAPACK\" target=\"_blank\" rel=\"external\">LAPACK</a>。<a href=\"http://www.netlib.org/benchmark/hpl/\" target=\"_blank\" rel=\"external\">HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）</a>是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。</p>\n<p>参考 <a href=\"http://blog.chinaunix.net/uid-20104120-id-4071017.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-20104120-id-4071017.html</a> 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz</div><div class=\"line\">tar axf hpl-2.2.tar.gz</div><div class=\"line\">cd hpl-2.2</div><div class=\"line\">cp setup/Make.Linux_PII_CBLAS_gm Make.x86_64</div><div class=\"line\"></div><div class=\"line\"># 编辑 Make.x86_64，修改的内容如下。</div><div class=\"line\"># 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。</div><div class=\"line\"># 注意各值结尾不要有 空格。</div><div class=\"line\"># 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录</div><div class=\"line\">ARCH         = x86_64</div><div class=\"line\"></div><div class=\"line\">TOPdir       = $(HOME)/hpl-2.2</div><div class=\"line\">INCdir       = $(TOPdir)/include</div><div class=\"line\">BINdir       = $(TOPdir)/bin</div><div class=\"line\">LIBdir       = $(TOPdir)/lib</div><div class=\"line\"></div><div class=\"line\">MPdir        =</div><div class=\"line\">MPinc        =</div><div class=\"line\">MPlib        =</div><div class=\"line\"></div><div class=\"line\">LAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录</div><div class=\"line\">LAinc        = -I$(LAdir)/include</div><div class=\"line\">LAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a</div><div class=\"line\"></div><div class=\"line\"># 开始编译</div><div class=\"line\">make arch=x86_64 -j 8</div><div class=\"line\"></div><div class=\"line\"># 也将编译的结果也打包保存</div><div class=\"line\">mv hpl hpl.bk.d; mkdir hpl</div><div class=\"line\">mv bin/ lib/ include/ hpl/</div><div class=\"line\">rmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/</div><div class=\"line\">tar zcf hpl-build.tar.gz hpl/</div></pre></td></tr></table></figure></p>\n<h2 id=\"单机上执行-HPL\"><a href=\"#单机上执行-HPL\" class=\"headerlink\" title=\"单机上执行 HPL\"></a>单机上执行 HPL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/hpl-2.2/hpl/bin/</div><div class=\"line\">mpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS</div><div class=\"line\"># 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响</div></pre></td></tr></table></figure>\n<h1 id=\"使用Intel-MKL-Benchmarks\"><a href=\"#使用Intel-MKL-Benchmarks\" class=\"headerlink\" title=\"使用Intel MKL Benchmarks\"></a>使用Intel MKL Benchmarks</h1><p>参考 <a href=\"https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite\" target=\"_blank\" rel=\"external\">https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz</div><div class=\"line\">tar axf l_mklb_p_2017.2.015.tgz</div><div class=\"line\">cd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack</div><div class=\"line\">./runme_xeon64</div></pre></td></tr></table></figure>\n<p>测试的结果约 150GFLOPS。<br>还有一个Windows版的，在主机上测试也是接近的结果。</p>\n<h1 id=\"Todo-集群中测试mpi-xhpl\"><a href=\"#Todo-集群中测试mpi-xhpl\" class=\"headerlink\" title=\"Todo: 集群中测试mpi xhpl\"></a>Todo: 集群中测试mpi xhpl</h1><p>直接运行 <code>l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack</code> 中的 <code>runme_intel64_static</code> 会报不识别 perhost 参数的错误。<br>执行 <code>mpiexec -f hosts -n 12 ./xhpl_intel64_static</code>（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过<code>top</code>监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？<br>参考</p>\n<ul>\n<li><a href=\"https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation\" target=\"_blank\" rel=\"external\">Intel® MPI Library - Documentation</a></li>\n<li><a href=\"https://software.intel.com/en-us/node/528457\" target=\"_blank\" rel=\"external\">Intel® Optimized MP LINPACK Benchmark for Clusters</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note\" target=\"_blank\" rel=\"external\">HPL application note</a></li>\n<li><a href=\"http://khmel.org/?p=527\" target=\"_blank\" rel=\"external\">HPC LINPACK benchmark</a></li>\n<li><a href=\"http://blog.sciencenet.cn/blog-935970-892936.html\" target=\"_blank\" rel=\"external\">如何做LINPACK测试及性能优化</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>使用虚拟机搭建一个3台VM的CentOS 7集群，安装mpi，blas和hpl，执行linpack测试集群的计算性能。<br>尝试编译netlib hpl 2.2时遇到一个错误，导致不能使用mpi。<br>后来发现可以直接使用Intel编译好的xhpl。由于不理解mpi和xhpl的选项，集群的性能比单机还明显低得多，还没找到原因;-(<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEmpich%EF%BC%8Cblas%EF%BC%88atlas%EF%BC%89%EF%BC%8Chpl\">安装和设置mpich，blas（atlas），hpl</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEmpich\">设置mpich</a></li>\n<li><a href=\"#blas-linpacklapack-hpl\">BLAS, LINPACK/LAPACK, HPL</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E4%B8%8A%E6%89%A7%E8%A1%8C-hpl\">单机上执行 HPL</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8intel-mkl-benchmarks\">使用Intel MKL Benchmarks</a></li>\n<li><a href=\"#todo-%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%B5%8B%E8%AF%95mpi-xhpl\">Todo: 集群中测试mpi xhpl</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"安装和设置mpich，blas（atlas），hpl\"><a href=\"#安装和设置mpich，blas（atlas），hpl\" class=\"headerlink\" title=\"安装和设置mpich，blas（atlas），hpl\"></a>安装和设置mpich，blas（atlas），hpl</h1><p>编译可只在一台VM上进行，然后将编译的结果拷贝到其它VM。</p>\n<h2 id=\"设置mpich\"><a href=\"#设置mpich\" class=\"headerlink\" title=\"设置mpich\"></a>设置mpich</h2><p>参考 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-installguide.pdf\" target=\"_blank\" rel=\"external\">MPI安装手册</a> 和 <a href=\"http://www.mpich.org/static/downloads/3.2/mpich-3.2-userguide.pdf\" target=\"_blank\" rel=\"external\">MPI用户手册</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 安装编译器</div><div class=\"line\">yum install -y gcc gcc-gfortran gcc-c++ bzip2 wget</div><div class=\"line\"></div><div class=\"line\"># yum 可以安装mpich-3.2.x86_64，但只有lib，没有bin，所以这里从src编译</div><div class=\"line\">wget http://www.mpich.org/static/downloads/3.2/mpich-3.2.tar.gz</div><div class=\"line\">tar axf mpich-3.2.tar.gz</div><div class=\"line\">cd ~/mpich-3.2</div><div class=\"line\">./configure prefix=/opt/mpich</div><div class=\"line\">make -j 8 &amp;&amp; make install  # make只会编译lib，make install才会编译lib和bin</div><div class=\"line\"></div><div class=\"line\">cp -r examples/ /opt/mpich/</div><div class=\"line\"></div><div class=\"line\"># 把编译结果打包</div><div class=\"line\">cd ~</div><div class=\"line\">tar zcf mpich-3.2-build.tar.gz /opt/mpich/</div><div class=\"line\"># 可以将其保存到主机上</div><div class=\"line\"></div><div class=\"line\">echo &apos;export PATH=$PATH:/opt/mpich/bin&apos;                         &gt;&gt; /etc/profile</div><div class=\"line\">echo &apos;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mpich/lib&apos;   &gt;&gt; /etc/profile</div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\"># 在本机测试一下</div><div class=\"line\">mpiexec -n 3 /opt/mpich/examples/cpi</div></pre></td></tr></table></figure></p>\n<p>mpiexec会在单个主机创建N个进程（通过 -n 指定）执行后面的命令（程序），如果通过 -f host_list_file 指定集群节点列表，会把进程分布在这些节点上分布执行。<br>mpiexec执行的可以是普通的命令，这时只是重复地执行N次，但这些命令之间并没有什么联系。<br>如果执行的是一个使用了mpi库的程序，那么程序执行中会彼此通信，协调计算进度，从而充分利用集群的计算资源。<br>要在集群上运行mpi程序，需要所有的节点上都有这个程序的可执行文件，以及需要的数据，配置文件，环境变量等。当然可以将这些文件等拷贝到各节点，但一般会创建一个共享目录，集群中的节点都将共享目录挂载到相同的路径，并将mpi程序及相关文件放到共享目录下。</p>\n<h2 id=\"BLAS-LINPACK-LAPACK-HPL\"><a href=\"#BLAS-LINPACK-LAPACK-HPL\" class=\"headerlink\" title=\"BLAS, LINPACK/LAPACK, HPL\"></a>BLAS, LINPACK/LAPACK, HPL</h2><p><a href=\"https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms\" target=\"_blank\" rel=\"external\">BLAS（Basic Linear Algebra Subprograms）- wiki</a> 或 <a href=\"https://zh.wikipedia.org/wiki/BLAS\" target=\"_blank\" rel=\"external\">BLAS基础线性代数程序集 - wiki</a> 是一个API标准，有多个开源实现，如Netlib BLAS（Fortran实现），Netlib ATLAS，Intel MKL和ACML等。这里使用ATLAS。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://downloads.sourceforge.net/project/math-atlas/Stable/3.10.3/atlas3.10.3.tar.bz2</div><div class=\"line\">tar axf atlas3.10.3.tar.bz2   # 需要已安装bzip2</div><div class=\"line\">cd ATLAS</div><div class=\"line\">mkdir build; cd build</div><div class=\"line\">../configure</div><div class=\"line\">make -j 8 &amp;&amp; make install # 编译完成后安装到/usr/local/atlas，包括 lib 和 include</div><div class=\"line\"># 同样将编译的结果也打包保存</div><div class=\"line\">mkdir atlas</div><div class=\"line\">mv bin/ lib/ include/ atlas/</div><div class=\"line\">tar zcf atlas-build.tar.gz atlas/</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://en.wikipedia.org/wiki/LINPACK\" target=\"_blank\" rel=\"external\">LINPACK</a>是一个线性代数数值计算库，其中用到了BLAS。不过目前多是使用它的后继<a href=\"https://en.wikipedia.org/wiki/LAPACK\" target=\"_blank\" rel=\"external\">LAPACK</a>。<a href=\"http://www.netlib.org/benchmark/hpl/\" target=\"_blank\" rel=\"external\">HPLinpack（Highly Parallel Computing benchmark，HP不是指惠普公司）</a>是一个使用LINPACK测试集群浮点计算性能的测试基准程序，测试的结果是多少GFPLOPS。</p>\n<p>参考 <a href=\"http://blog.chinaunix.net/uid-20104120-id-4071017.html\" target=\"_blank\" rel=\"external\">http://blog.chinaunix.net/uid-20104120-id-4071017.html</a> 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://www.netlib.org/benchmark/hpl/hpl-2.2.tar.gz</div><div class=\"line\">tar axf hpl-2.2.tar.gz</div><div class=\"line\">cd hpl-2.2</div><div class=\"line\">cp setup/Make.Linux_PII_CBLAS_gm Make.x86_64</div><div class=\"line\"></div><div class=\"line\"># 编辑 Make.x86_64，修改的内容如下。</div><div class=\"line\"># 因为设置MPdir后有编译错误，所以没有设置。这样编译出来的是单机版的。</div><div class=\"line\"># 注意各值结尾不要有 空格。</div><div class=\"line\"># 虽然在 INCdir、BINdir和LIBdir删掉了$(ARCH)，但最终还创建了x86_64的空目录</div><div class=\"line\">ARCH         = x86_64</div><div class=\"line\"></div><div class=\"line\">TOPdir       = $(HOME)/hpl-2.2</div><div class=\"line\">INCdir       = $(TOPdir)/include</div><div class=\"line\">BINdir       = $(TOPdir)/bin</div><div class=\"line\">LIBdir       = $(TOPdir)/lib</div><div class=\"line\"></div><div class=\"line\">MPdir        =</div><div class=\"line\">MPinc        =</div><div class=\"line\">MPlib        =</div><div class=\"line\"></div><div class=\"line\">LAdir        = /usr/local/atlas  # atlas 执行了make install之后的安装目录</div><div class=\"line\">LAinc        = -I$(LAdir)/include</div><div class=\"line\">LAlib        = $(LAdir)/lib/libcblas.a $(LAdir)/lib/libatlas.a</div><div class=\"line\"></div><div class=\"line\"># 开始编译</div><div class=\"line\">make arch=x86_64 -j 8</div><div class=\"line\"></div><div class=\"line\"># 也将编译的结果也打包保存</div><div class=\"line\">mv hpl hpl.bk.d; mkdir hpl</div><div class=\"line\">mv bin/ lib/ include/ hpl/</div><div class=\"line\">rmdir hpl/bin/x86_64/ hpl/include/x86_64/ hpl/lib/x86_64/</div><div class=\"line\">tar zcf hpl-build.tar.gz hpl/</div></pre></td></tr></table></figure></p>\n<h2 id=\"单机上执行-HPL\"><a href=\"#单机上执行-HPL\" class=\"headerlink\" title=\"单机上执行 HPL\"></a>单机上执行 HPL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/hpl-2.2/hpl/bin/</div><div class=\"line\">mpiexec -n 4 ./xhpl  # 得到的结果比较差，只有约0.4GFLOPS</div><div class=\"line\"># 因为需要配置HPL.dat，选择合适的参数，另外编译中一些选项也会有影响</div></pre></td></tr></table></figure>\n<h1 id=\"使用Intel-MKL-Benchmarks\"><a href=\"#使用Intel-MKL-Benchmarks\" class=\"headerlink\" title=\"使用Intel MKL Benchmarks\"></a>使用Intel MKL Benchmarks</h1><p>参考 <a href=\"https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite\" target=\"_blank\" rel=\"external\">https://software.intel.com/en-us/articles/intel-mkl-benchmarks-suite</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://registrationcenter-download.intel.com/akdlm/irc_nas/9752/l_mklb_p_2017.2.015.tgz</div><div class=\"line\">tar axf l_mklb_p_2017.2.015.tgz</div><div class=\"line\">cd l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/linpack</div><div class=\"line\">./runme_xeon64</div></pre></td></tr></table></figure>\n<p>测试的结果约 150GFLOPS。<br>还有一个Windows版的，在主机上测试也是接近的结果。</p>\n<h1 id=\"Todo-集群中测试mpi-xhpl\"><a href=\"#Todo-集群中测试mpi-xhpl\" class=\"headerlink\" title=\"Todo: 集群中测试mpi xhpl\"></a>Todo: 集群中测试mpi xhpl</h1><p>直接运行 <code>l_mklb_p_2017.2.015/benchmarks_2017/linux/mkl/benchmarks/mp_linpack</code> 中的 <code>runme_intel64_static</code> 会报不识别 perhost 参数的错误。<br>执行 <code>mpiexec -f hosts -n 12 ./xhpl_intel64_static</code>（xhpl_intel64_static和HPL.dat拷贝到了/root，hosts是节点列表），在其它节点通过<code>top</code>监视，确实执行了xhpl_intel64_static，但输出只有当前机器的，而且只有约4GFLOPS（单机执行xhpl_intel64_static也是这么多，按理应接近4×集群节点数啊），不知道问题具体出在哪里，看来还是需要仔细看文档了。或许MPI，BLAS等全部使用Intel的版本？<br>参考</p>\n<ul>\n<li><a href=\"https://software.intel.com/zh-cn/articles/intel-mpi-library-documentation\" target=\"_blank\" rel=\"external\">Intel® MPI Library - Documentation</a></li>\n<li><a href=\"https://software.intel.com/en-us/node/528457\" target=\"_blank\" rel=\"external\">Intel® Optimized MP LINPACK Benchmark for Clusters</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/performance-tools-for-software-developers-hpl-application-note\" target=\"_blank\" rel=\"external\">HPL application note</a></li>\n<li><a href=\"http://khmel.org/?p=527\" target=\"_blank\" rel=\"external\">HPC LINPACK benchmark</a></li>\n<li><a href=\"http://blog.sciencenet.cn/blog-935970-892936.html\" target=\"_blank\" rel=\"external\">如何做LINPACK测试及性能优化</a></li>\n</ul>"},{"title":"局域网内的远程操作","date":"2016-09-17T16:00:00.000Z","_content":"一些基础的远程操作，包括ssh，共享文件，远程桌面。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [Linux远程执行命令（ssh）](#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89)\n    - [Linux下设置和使用ssh](#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh)\n    - [Windows安装和设置xshell，使用密码ssh登录](#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95)\n    - [scp](#scp)\n    - [sftp](#sftp)\n    - [设置ssh使用密钥登录](#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95)\n        - [生成密钥对](#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9)\n        - [分发密钥对](#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9)\n            - [ssh-copy-id](#ssh-copy-id)\n            - [复制密钥文本](#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC)\n        - [ssh config设置](#ssh-config%E8%AE%BE%E7%BD%AE)\n        - [踢出ssh会话](#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D)\n- [远程共享文件（SMB/CIFS）](#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89)\n    - [Samba访问Windows提供的共享文件](#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [Windows访问Samba的共享文件](#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [更改Samba的默认端口号](#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7)\n- [远程桌面](#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2)\n    - [mstsc](#mstsc)\n    - [vnc](#vnc)\n    - [其它](#%E5%85%B6%E5%AE%83)\n\n<!-- /TOC -->\n\n这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（`ssh`），共享文件（`Samba`）和远程桌面（`mstsc`和`vnc`）。\n远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。\n\n为了方便配置，**建议关闭系统的防火墙**。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是`10.1.1.5`，用户名`ying`；Windows的IP是`10.1.1.1`，用户名也是`ying`。\n\n# Linux远程执行命令（ssh）\nssh（[Secure Shell](https://en.wikipedia.org/wiki/Secure_Shell)）通过加密的网络通道在客户端和服务器之间传递命令及其输出。\n在ssh之前，远程执行命令是通过`telnet`或`rsh`等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。\n可以在ssh提供的加密通道上完成其它网络通信：如`scp`是在ssh加密通道上实现的远程拷贝（`rcp`）；`sftp`是在ssh加密通道上实现的`ftp`；`git`也有使用ssh加密通道传输文件的模式。\n对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。\n\n## Linux下设置和使用ssh\nLinux系统的ssh服务程序是`OpenSSH Server`，执行命令`sudo apt install openssh-server`。\n安装过程中会将ssh服务程序（`sshd`）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。\n\n> 查看SSH Server状态，执行`systemctl status sshd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart sshd`\n\n一般Linux系统都内置了ssh客户端，执行\n`ssh 用户名@主机名或IP`\n登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。\n登录到本机的命令是`ssh localhost`\n第一次登录某个主机会提示是否 **信任** 该主机，需要输入`yes`，之后才会提示输入远程主机的登录密码。\n\n>修改`/etc/ssh/ssh_config`，将其中`#   StrictHostKeyChecking ask` 改为 `StrictHostKeyChecking no`，这样在第一次登录时就不会询问是否要信任该主机了。\n\n如果登录到远程主机只是执行一两条命令，可执行\n`ssh 用户名@主机名或IP 命令`\n当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。\n\n## Windows安装和设置xshell，使用密码ssh登录\nWindows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。\n\n> Windows版的`git`包含一个简化版`MinGW`，将`<git安装目录>\\usr\\bin`这个路径添加到Windows的`Path`环境变量，就可以在Windows的命令窗口执行`ssh`，`scp`及其它很多Linux命令了。\n> `MinGW` 中也包含SSH Server程序`sshd`，不过估计很少会登录到Windows执行命令行操作吧。\n\n从官网下载并安装 [xshell](http://www.netsarang.com/download/down_xsh.html) （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 **普通下载**。\n\n启动xshell后，可以直接执行`ssh ying@10.1.1.5`，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。\n![](/img/xshell-ui.png)\n\n> 工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行`open <会话名>`。\n> 工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。\n> 每个会话即`<用户文档>\\NetSarang\\Xshell\\Sessions`下的一个配置文件，会话也可以复制后修改。\n\n为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 **“会话属性”** 对话框中\n+ 在“连接” 输入主机 `10.1.1.5`，在用户身份验证中选择方法为Password，输入用户名 `ying` 和 密码；\n+ 在“终端” 修改“编码”为UTF-8；\n+ 在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。\n\n![](/img/xshell-prop.png)\n\n> 注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”`Ctrl+C`对应的是中断当前命令。\n> xshell中默认“复制”、“粘贴”的快捷键是`Ctrl+Ins`，`Shift+Ins`，而不是`Ctrl+C`，`Ctrl+V`。\n可以打开 “工具”->“选项”，“键盘和鼠标”选项卡，“按键对应”->“编辑”，将其修改为`Ctrl+C`，`Ctrl+V`，而原来Linux终端的快捷键需要加`Shift`，如中断当前命令的`Ctrl+C`变成了`Ctrl+Shift+C`。\n\n## scp\n通过ssh加密的通道传输文件。文件路径格式为`用户名@主机名或IP:主机上的路径`。注意，Windows文件路径中的盘符`C:\\`变成了`/c/`。\n{% codeblock line_number:false%}\nscp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/\n{% endcodeblock %}\n\n## sftp\n`OpenSSH Server`内置了一个`sftp`服务器，会随`sshd`服务自动启动。我们还需要一个`sftp`的客户端即可传送文件。\n这里使用图形界面的，跨平台的，免费的，开源的[Filezilla](https://filezilla-project.org/download.php?type=client)。下载并安装后，在“快速连接”工具栏输入主机`sftp://10.1.1.5`，及用户名 `ying` 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。\n![](/img/sftp.png)\n\nAndroid上的`ES文件浏览器`也支持`sftp`（还支持下面介绍的smb局域网文件共享）。\n\n## 设置ssh使用密钥登录\n更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用`rsa`算法，公钥和私钥分别保存在两个 **文本** 文件`id_rsa.pub`和`id_rsa`中。\n+ 公钥`id_rsa.pub`保存在要登录的目标机器上（服务器，Github等），\n+ 私钥`id_rsa`保存在 **发起** 登录的机器上（客户端），私钥要妥善保管，防止泄露。\n\nLinux主机的密钥对默认保存在`~/.ssh/`目录。\nWindows是`C:\\Users\\<Win用户名>\\.ssh\\`目录。在图形界面的文件管理器中不能创建以`.`开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（`Win键+X，C`），执行命令`mkdir C:\\Users\\<Win用户名>\\.ssh`。\n\n### 生成密钥对\n因为加密算法是公开的，有多种工具可以生成密钥。\n对Linux或MinGW，执行`ssh-keygen -t rsa -P \"\"` ，会在`~/.ssh/`生成密钥对`id_rsa.pub`和`id_rsa`。\n\nxshell也可以生成密钥对：\n+ 打开 “工具”-> “新建用户密钥生成向导” 或 “工具”-> “用户密钥管理者” -> “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；\n+ 选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；\n+ 选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。\n\n![](/img/xshell-key.png)\n\n### 分发密钥对\n要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的`.ssh/authorized_keys`文件中。\n分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的`scp`和`sftp`，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行`wget`或`curl`命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。\n\n#### ssh-copy-id\n执行命令`ssh-copy-id -i 公钥文件 用户名@主机名或IP`，将公钥拷贝到远程Linux主机的`/home/<用户名>/.ssh/authorized_keys`文件中。当然，这个命令需要用密码访问远程主机。\n\n#### 复制密钥文本\n如将Linux主机上生成的私钥`id_rsa`拷贝到Windows上：\n+ 使用xshell用密码登录到Linux，执行`cat ~/.ssh/id_rsa`，输出私钥的内容，复制输出的文字。\n+ 在Windows文件管理器中打开路径`C:\\Users\\<Win用户名>\\.ssh`，在其中创建一个名为`id_rsa.txt`的文本文件，将上一步复制的文字粘贴进去，然后把文件名的`.txt`扩展名去掉，即改为`id_rsa`。\n\n可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行`git`、`ssh`等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。\n\n### ssh config设置\n在`~/.ssh/config`文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。\n{% codeblock line_number:false%}\nHost   别名\n    HostName 主机名或IP\n    Port     端口\n    User     用户名\n    IdentityFile   私钥文件\n\nHost u\n    Hostname  10.1.1.5\n    Port      22\n    User      ying\n\nHost          10.1.1.6\nPort          2222\n\n{% endcodeblock %}\n\n这样就可以直接执行`ssh 别名`登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在`scp`的路径中。\n\n### 踢出ssh会话\n查看在线用户：`w` 或 `who`，两者输出格式有所不同。\n查看自己的连接信息：`who am i`。\n踢出其它会话：`pkill -9 -t pts/1 `，其中`pts/1`是被踢会话的终端。\n\n# 远程共享文件（SMB/CIFS）\n“共享文件”（[Server Message Block，SMB](https://en.wikipedia.org/wiki/Server_Message_Block) )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。\nSamba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。\nLinux上与SMB/CIFS功能是类似的是“网络文件系统”（[Network File System，NFS](https://en.wikipedia.org/wiki/Network_File_System) ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过`控制面板→程序和功能→启用或关闭Windows功能`来添加NFS客户端和服务端软件。\n\n> 注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。\n> 共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。\n\nLinux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行`sudo apt install cifs-utils`来安装。\n\n## Samba访问Windows提供的共享文件\nWindows上启用共享文件夹只要在文件夹的`属性对话框→共享选项卡→高级共享`中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加`$`，就表示是隐藏的，必须通过输入完整路径才能打开。\n![Windows上启用共享文件夹](/img/win-share.png)\n\n创建挂载点`mkdir ~/z`，并在`/etc/fstab`中添加\n{% codeblock line_number:false%}\n//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0\n{% endcodeblock %}\n\n执行`sudo mount -a`，挂载`/etc/fstab`中新增的设置。\n执行`ls ~/z`，应列出共享文件夹中的内容，确认挂载成功。\n\n> 上面的命令将共享文件夹`文档`挂载到Ubuntu的`/home/ying/z`，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。\n> 其中uid是Ubuntu中用户`ying`的，具体的值可执行命令`id`，或在`/etc/passwd`中查看。\n\n## Windows访问Samba的共享文件\n先要安装`Samba File Server`，执行`sudo apt install samba samba-common`。\n> 查看Samba Server的运行状态，执行`systemctl status smbd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart smbd`\n\n添加共享文件夹：执行 `sudo nano /etc/samba/smb.conf`，在末尾添加如下内容，添加了只读的根目录`/`和可读写的`/home/ying`目录，但显示为`all`和`ying`。\n{% codeblock line_number:false%}\n[all]\n    comment = fs root directory\n    path = /\n;   writeable = no\n;   browseable = yes\n    valid users = ying\n\n[ying]\n    comment = ying's home\n    path = /home/ying\n    writeable = yes\n    create mask = 0664\n    directory mask = 0775\n;   browseable = yes\n    valid users = ying\n{% endcodeblock %}\n\n将`ying`添加为smb的共享用户：`sudo smbpasswd -a ying`， 按提示设置`ying`的smb密码，**可以与系统密码不同**。\n重启smbd，使设置生效：`sudo systemctl restart smbd`。\n\n> Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。\n\n从Windows的文件管理器的地址栏访问 `\\\\10.1.1.5` ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 **“映射网络驱动器”** 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为`\\\\u` 。\n\n从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是`smb://10.1.1.5`或`smb://u`。macOS会自动把共享文件挂载到`/Volumes`下。\n\n> Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的`WINS`名字服务。\n> 另一种方法是在`hosts`文件中为IP地址指定名字。\n\n![](/img/smb.png)\n\n> Samba共享文件与`sftp`的区别在于，`sftp`不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。\n> PS, `testparm`命令可以用来检查`smb.conf`的配置是否正确。\n\n> 参考\n+ [Setting up Samba as a Standalone Server - samba wiki](https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server)\n+ [在CentOS 7中Samba服务安装和配置](http://lybing.blog.51cto.com/3286625/1676515)\n\n## 更改Samba的默认端口号\n2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。\n估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是`smb://10.1.1.5:4455/home/`，其中4455是修改后的端口号。\n\n修改Samba的端口号只需在`/etc/samba/smb.conf`中增加\n{% codeblock line_number:false%}\n[global]\n   smb ports = 4455 445  # 可以同时监听多个端口号\n...\n{% endcodeblock %}\n\n# 远程桌面\n## mstsc\nWindows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议[Remote Desktop Protocol，RDP](https://en.wikipedia.org/wiki/Remote_Desktop_Protocol)。\n\n+ 客户端在`所有程序→Windows附件→远程桌面连接`，或直接执行命令`mstsc`。\n+ 服务程序：依次打开`控制面板→所有控制面板项→系统`，或`Win+X，Y`，然后单击左侧的`高级系统设置`，打开`系统属性`对话框，在`远程`选项卡中的`远程桌面`部分选中`允许远程连接到此计算机`，并选择某个用户。\n![Windows上的远程桌面客户端](/img/win-mstsc.png)\n![Windows上启用远程桌面](/img/win-mstsc-svr.png)\n\nUbuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。\n如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。\n\nWindows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。\n\n## vnc\nVNC（[Virtual Network Computing](https://en.wikipedia.org/wiki/Virtual_Network_Computing)）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了`远程共享`程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。\nVNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。\n\n可以参考教程[https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。\n\nWindows上没有内置的VNC客户端，有一些免费的`VNC-Viewer`程序。\n\n> 注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，\n> 默认的 `Tab` 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-> Window Manager -> Keyboard”中清除 `Switch Window from same application` 关联的快捷键\n> 还可以在 “Settings-> Keyboard -> application shortcut” 中设置打开终端的快捷键 `exo-open --launch TerminalEmulator ~ Ctrl+Alt+T`\n\n## 其它\n在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 **[TeamViewer](https://www.teamviewer.com)**，[向日葵](http://sunlogin.oray.com/zh_CN/)等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。\n","source":"_posts/remote.md","raw":"title: 局域网内的远程操作\ndate: 2016-09-18\ncategory: [misc]\ntags:\n\n---\n一些基础的远程操作，包括ssh，共享文件，远程桌面。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n- [Linux远程执行命令（ssh）](#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89)\n    - [Linux下设置和使用ssh](#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh)\n    - [Windows安装和设置xshell，使用密码ssh登录](#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95)\n    - [scp](#scp)\n    - [sftp](#sftp)\n    - [设置ssh使用密钥登录](#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95)\n        - [生成密钥对](#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9)\n        - [分发密钥对](#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9)\n            - [ssh-copy-id](#ssh-copy-id)\n            - [复制密钥文本](#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC)\n        - [ssh config设置](#ssh-config%E8%AE%BE%E7%BD%AE)\n        - [踢出ssh会话](#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D)\n- [远程共享文件（SMB/CIFS）](#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89)\n    - [Samba访问Windows提供的共享文件](#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [Windows访问Samba的共享文件](#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6)\n    - [更改Samba的默认端口号](#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7)\n- [远程桌面](#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2)\n    - [mstsc](#mstsc)\n    - [vnc](#vnc)\n    - [其它](#%E5%85%B6%E5%AE%83)\n\n<!-- /TOC -->\n\n这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（`ssh`），共享文件（`Samba`）和远程桌面（`mstsc`和`vnc`）。\n远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。\n\n为了方便配置，**建议关闭系统的防火墙**。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是`10.1.1.5`，用户名`ying`；Windows的IP是`10.1.1.1`，用户名也是`ying`。\n\n# Linux远程执行命令（ssh）\nssh（[Secure Shell](https://en.wikipedia.org/wiki/Secure_Shell)）通过加密的网络通道在客户端和服务器之间传递命令及其输出。\n在ssh之前，远程执行命令是通过`telnet`或`rsh`等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。\n可以在ssh提供的加密通道上完成其它网络通信：如`scp`是在ssh加密通道上实现的远程拷贝（`rcp`）；`sftp`是在ssh加密通道上实现的`ftp`；`git`也有使用ssh加密通道传输文件的模式。\n对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。\n\n## Linux下设置和使用ssh\nLinux系统的ssh服务程序是`OpenSSH Server`，执行命令`sudo apt install openssh-server`。\n安装过程中会将ssh服务程序（`sshd`）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。\n\n> 查看SSH Server状态，执行`systemctl status sshd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart sshd`\n\n一般Linux系统都内置了ssh客户端，执行\n`ssh 用户名@主机名或IP`\n登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。\n登录到本机的命令是`ssh localhost`\n第一次登录某个主机会提示是否 **信任** 该主机，需要输入`yes`，之后才会提示输入远程主机的登录密码。\n\n>修改`/etc/ssh/ssh_config`，将其中`#   StrictHostKeyChecking ask` 改为 `StrictHostKeyChecking no`，这样在第一次登录时就不会询问是否要信任该主机了。\n\n如果登录到远程主机只是执行一两条命令，可执行\n`ssh 用户名@主机名或IP 命令`\n当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。\n\n## Windows安装和设置xshell，使用密码ssh登录\nWindows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。\n\n> Windows版的`git`包含一个简化版`MinGW`，将`<git安装目录>\\usr\\bin`这个路径添加到Windows的`Path`环境变量，就可以在Windows的命令窗口执行`ssh`，`scp`及其它很多Linux命令了。\n> `MinGW` 中也包含SSH Server程序`sshd`，不过估计很少会登录到Windows执行命令行操作吧。\n\n从官网下载并安装 [xshell](http://www.netsarang.com/download/down_xsh.html) （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 **普通下载**。\n\n启动xshell后，可以直接执行`ssh ying@10.1.1.5`，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。\n![](/img/xshell-ui.png)\n\n> 工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行`open <会话名>`。\n> 工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。\n> 每个会话即`<用户文档>\\NetSarang\\Xshell\\Sessions`下的一个配置文件，会话也可以复制后修改。\n\n为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 **“会话属性”** 对话框中\n+ 在“连接” 输入主机 `10.1.1.5`，在用户身份验证中选择方法为Password，输入用户名 `ying` 和 密码；\n+ 在“终端” 修改“编码”为UTF-8；\n+ 在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。\n\n![](/img/xshell-prop.png)\n\n> 注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”`Ctrl+C`对应的是中断当前命令。\n> xshell中默认“复制”、“粘贴”的快捷键是`Ctrl+Ins`，`Shift+Ins`，而不是`Ctrl+C`，`Ctrl+V`。\n可以打开 “工具”->“选项”，“键盘和鼠标”选项卡，“按键对应”->“编辑”，将其修改为`Ctrl+C`，`Ctrl+V`，而原来Linux终端的快捷键需要加`Shift`，如中断当前命令的`Ctrl+C`变成了`Ctrl+Shift+C`。\n\n## scp\n通过ssh加密的通道传输文件。文件路径格式为`用户名@主机名或IP:主机上的路径`。注意，Windows文件路径中的盘符`C:\\`变成了`/c/`。\n{% codeblock line_number:false%}\nscp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/\n{% endcodeblock %}\n\n## sftp\n`OpenSSH Server`内置了一个`sftp`服务器，会随`sshd`服务自动启动。我们还需要一个`sftp`的客户端即可传送文件。\n这里使用图形界面的，跨平台的，免费的，开源的[Filezilla](https://filezilla-project.org/download.php?type=client)。下载并安装后，在“快速连接”工具栏输入主机`sftp://10.1.1.5`，及用户名 `ying` 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。\n![](/img/sftp.png)\n\nAndroid上的`ES文件浏览器`也支持`sftp`（还支持下面介绍的smb局域网文件共享）。\n\n## 设置ssh使用密钥登录\n更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用`rsa`算法，公钥和私钥分别保存在两个 **文本** 文件`id_rsa.pub`和`id_rsa`中。\n+ 公钥`id_rsa.pub`保存在要登录的目标机器上（服务器，Github等），\n+ 私钥`id_rsa`保存在 **发起** 登录的机器上（客户端），私钥要妥善保管，防止泄露。\n\nLinux主机的密钥对默认保存在`~/.ssh/`目录。\nWindows是`C:\\Users\\<Win用户名>\\.ssh\\`目录。在图形界面的文件管理器中不能创建以`.`开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（`Win键+X，C`），执行命令`mkdir C:\\Users\\<Win用户名>\\.ssh`。\n\n### 生成密钥对\n因为加密算法是公开的，有多种工具可以生成密钥。\n对Linux或MinGW，执行`ssh-keygen -t rsa -P \"\"` ，会在`~/.ssh/`生成密钥对`id_rsa.pub`和`id_rsa`。\n\nxshell也可以生成密钥对：\n+ 打开 “工具”-> “新建用户密钥生成向导” 或 “工具”-> “用户密钥管理者” -> “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；\n+ 选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；\n+ 选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。\n\n![](/img/xshell-key.png)\n\n### 分发密钥对\n要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的`.ssh/authorized_keys`文件中。\n分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的`scp`和`sftp`，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行`wget`或`curl`命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。\n\n#### ssh-copy-id\n执行命令`ssh-copy-id -i 公钥文件 用户名@主机名或IP`，将公钥拷贝到远程Linux主机的`/home/<用户名>/.ssh/authorized_keys`文件中。当然，这个命令需要用密码访问远程主机。\n\n#### 复制密钥文本\n如将Linux主机上生成的私钥`id_rsa`拷贝到Windows上：\n+ 使用xshell用密码登录到Linux，执行`cat ~/.ssh/id_rsa`，输出私钥的内容，复制输出的文字。\n+ 在Windows文件管理器中打开路径`C:\\Users\\<Win用户名>\\.ssh`，在其中创建一个名为`id_rsa.txt`的文本文件，将上一步复制的文字粘贴进去，然后把文件名的`.txt`扩展名去掉，即改为`id_rsa`。\n\n可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行`git`、`ssh`等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。\n\n### ssh config设置\n在`~/.ssh/config`文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。\n{% codeblock line_number:false%}\nHost   别名\n    HostName 主机名或IP\n    Port     端口\n    User     用户名\n    IdentityFile   私钥文件\n\nHost u\n    Hostname  10.1.1.5\n    Port      22\n    User      ying\n\nHost          10.1.1.6\nPort          2222\n\n{% endcodeblock %}\n\n这样就可以直接执行`ssh 别名`登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在`scp`的路径中。\n\n### 踢出ssh会话\n查看在线用户：`w` 或 `who`，两者输出格式有所不同。\n查看自己的连接信息：`who am i`。\n踢出其它会话：`pkill -9 -t pts/1 `，其中`pts/1`是被踢会话的终端。\n\n# 远程共享文件（SMB/CIFS）\n“共享文件”（[Server Message Block，SMB](https://en.wikipedia.org/wiki/Server_Message_Block) )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。\nSamba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。\nLinux上与SMB/CIFS功能是类似的是“网络文件系统”（[Network File System，NFS](https://en.wikipedia.org/wiki/Network_File_System) ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过`控制面板→程序和功能→启用或关闭Windows功能`来添加NFS客户端和服务端软件。\n\n> 注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。\n> 共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。\n\nLinux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行`sudo apt install cifs-utils`来安装。\n\n## Samba访问Windows提供的共享文件\nWindows上启用共享文件夹只要在文件夹的`属性对话框→共享选项卡→高级共享`中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加`$`，就表示是隐藏的，必须通过输入完整路径才能打开。\n![Windows上启用共享文件夹](/img/win-share.png)\n\n创建挂载点`mkdir ~/z`，并在`/etc/fstab`中添加\n{% codeblock line_number:false%}\n//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0\n{% endcodeblock %}\n\n执行`sudo mount -a`，挂载`/etc/fstab`中新增的设置。\n执行`ls ~/z`，应列出共享文件夹中的内容，确认挂载成功。\n\n> 上面的命令将共享文件夹`文档`挂载到Ubuntu的`/home/ying/z`，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。\n> 其中uid是Ubuntu中用户`ying`的，具体的值可执行命令`id`，或在`/etc/passwd`中查看。\n\n## Windows访问Samba的共享文件\n先要安装`Samba File Server`，执行`sudo apt install samba samba-common`。\n> 查看Samba Server的运行状态，执行`systemctl status smbd`\n> 启动，停止或重启服务，执行`sudo systemctl start/stop/restart smbd`\n\n添加共享文件夹：执行 `sudo nano /etc/samba/smb.conf`，在末尾添加如下内容，添加了只读的根目录`/`和可读写的`/home/ying`目录，但显示为`all`和`ying`。\n{% codeblock line_number:false%}\n[all]\n    comment = fs root directory\n    path = /\n;   writeable = no\n;   browseable = yes\n    valid users = ying\n\n[ying]\n    comment = ying's home\n    path = /home/ying\n    writeable = yes\n    create mask = 0664\n    directory mask = 0775\n;   browseable = yes\n    valid users = ying\n{% endcodeblock %}\n\n将`ying`添加为smb的共享用户：`sudo smbpasswd -a ying`， 按提示设置`ying`的smb密码，**可以与系统密码不同**。\n重启smbd，使设置生效：`sudo systemctl restart smbd`。\n\n> Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。\n\n从Windows的文件管理器的地址栏访问 `\\\\10.1.1.5` ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 **“映射网络驱动器”** 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为`\\\\u` 。\n\n从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是`smb://10.1.1.5`或`smb://u`。macOS会自动把共享文件挂载到`/Volumes`下。\n\n> Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的`WINS`名字服务。\n> 另一种方法是在`hosts`文件中为IP地址指定名字。\n\n![](/img/smb.png)\n\n> Samba共享文件与`sftp`的区别在于，`sftp`不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。\n> PS, `testparm`命令可以用来检查`smb.conf`的配置是否正确。\n\n> 参考\n+ [Setting up Samba as a Standalone Server - samba wiki](https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server)\n+ [在CentOS 7中Samba服务安装和配置](http://lybing.blog.51cto.com/3286625/1676515)\n\n## 更改Samba的默认端口号\n2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。\n估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是`smb://10.1.1.5:4455/home/`，其中4455是修改后的端口号。\n\n修改Samba的端口号只需在`/etc/samba/smb.conf`中增加\n{% codeblock line_number:false%}\n[global]\n   smb ports = 4455 445  # 可以同时监听多个端口号\n...\n{% endcodeblock %}\n\n# 远程桌面\n## mstsc\nWindows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议[Remote Desktop Protocol，RDP](https://en.wikipedia.org/wiki/Remote_Desktop_Protocol)。\n\n+ 客户端在`所有程序→Windows附件→远程桌面连接`，或直接执行命令`mstsc`。\n+ 服务程序：依次打开`控制面板→所有控制面板项→系统`，或`Win+X，Y`，然后单击左侧的`高级系统设置`，打开`系统属性`对话框，在`远程`选项卡中的`远程桌面`部分选中`允许远程连接到此计算机`，并选择某个用户。\n![Windows上的远程桌面客户端](/img/win-mstsc.png)\n![Windows上启用远程桌面](/img/win-mstsc-svr.png)\n\nUbuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。\n如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。\n\nWindows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。\n\n## vnc\nVNC（[Virtual Network Computing](https://en.wikipedia.org/wiki/Virtual_Network_Computing)）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了`远程共享`程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。\nVNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。\n\n可以参考教程[https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。\n\nWindows上没有内置的VNC客户端，有一些免费的`VNC-Viewer`程序。\n\n> 注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，\n> 默认的 `Tab` 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-> Window Manager -> Keyboard”中清除 `Switch Window from same application` 关联的快捷键\n> 还可以在 “Settings-> Keyboard -> application shortcut” 中设置打开终端的快捷键 `exo-open --launch TerminalEmulator ~ Ctrl+Alt+T`\n\n## 其它\n在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 **[TeamViewer](https://www.teamviewer.com)**，[向日葵](http://sunlogin.oray.com/zh_CN/)等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。\n","slug":"remote","published":1,"updated":"2017-10-30T02:47:45.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmgz000d9s4fbpnq3yyr","content":"<p>一些基础的远程操作，包括ssh，共享文件，远程桌面。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89\">Linux远程执行命令（ssh）</a><ul>\n<li><a href=\"#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh\">Linux下设置和使用ssh</a></li>\n<li><a href=\"#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95\">Windows安装和设置xshell，使用密码ssh登录</a></li>\n<li><a href=\"#scp\">scp</a></li>\n<li><a href=\"#sftp\">sftp</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95\">设置ssh使用密钥登录</a><ul>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9\">生成密钥对</a></li>\n<li><a href=\"#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9\">分发密钥对</a><ul>\n<li><a href=\"#ssh-copy-id\">ssh-copy-id</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC\">复制密钥文本</a></li>\n</ul>\n</li>\n<li><a href=\"#ssh-config%E8%AE%BE%E7%BD%AE\">ssh config设置</a></li>\n<li><a href=\"#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D\">踢出ssh会话</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89\">远程共享文件（SMB/CIFS）</a><ul>\n<li><a href=\"#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Samba访问Windows提供的共享文件</a></li>\n<li><a href=\"#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Windows访问Samba的共享文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7\">更改Samba的默认端口号</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2\">远程桌面</a><ul>\n<li><a href=\"#mstsc\">mstsc</a></li>\n<li><a href=\"#vnc\">vnc</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（<code>ssh</code>），共享文件（<code>Samba</code>）和远程桌面（<code>mstsc</code>和<code>vnc</code>）。<br>远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。</p>\n<p>为了方便配置，<strong>建议关闭系统的防火墙</strong>。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是<code>10.1.1.5</code>，用户名<code>ying</code>；Windows的IP是<code>10.1.1.1</code>，用户名也是<code>ying</code>。</p>\n<h1 id=\"Linux远程执行命令（ssh）\"><a href=\"#Linux远程执行命令（ssh）\" class=\"headerlink\" title=\"Linux远程执行命令（ssh）\"></a>Linux远程执行命令（ssh）</h1><p>ssh（<a href=\"https://en.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">Secure Shell</a>）通过加密的网络通道在客户端和服务器之间传递命令及其输出。<br>在ssh之前，远程执行命令是通过<code>telnet</code>或<code>rsh</code>等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。<br>可以在ssh提供的加密通道上完成其它网络通信：如<code>scp</code>是在ssh加密通道上实现的远程拷贝（<code>rcp</code>）；<code>sftp</code>是在ssh加密通道上实现的<code>ftp</code>；<code>git</code>也有使用ssh加密通道传输文件的模式。<br>对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。</p>\n<h2 id=\"Linux下设置和使用ssh\"><a href=\"#Linux下设置和使用ssh\" class=\"headerlink\" title=\"Linux下设置和使用ssh\"></a>Linux下设置和使用ssh</h2><p>Linux系统的ssh服务程序是<code>OpenSSH Server</code>，执行命令<code>sudo apt install openssh-server</code>。<br>安装过程中会将ssh服务程序（<code>sshd</code>）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。</p>\n<blockquote>\n<p>查看SSH Server状态，执行<code>systemctl status sshd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart sshd</code></p>\n</blockquote>\n<p>一般Linux系统都内置了ssh客户端，执行<br><code>ssh 用户名@主机名或IP</code><br>登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。<br>登录到本机的命令是<code>ssh localhost</code><br>第一次登录某个主机会提示是否 <strong>信任</strong> 该主机，需要输入<code>yes</code>，之后才会提示输入远程主机的登录密码。</p>\n<blockquote>\n<p>修改<code>/etc/ssh/ssh_config</code>，将其中<code>#   StrictHostKeyChecking ask</code> 改为 <code>StrictHostKeyChecking no</code>，这样在第一次登录时就不会询问是否要信任该主机了。</p>\n</blockquote>\n<p>如果登录到远程主机只是执行一两条命令，可执行<br><code>ssh 用户名@主机名或IP 命令</code><br>当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。</p>\n<h2 id=\"Windows安装和设置xshell，使用密码ssh登录\"><a href=\"#Windows安装和设置xshell，使用密码ssh登录\" class=\"headerlink\" title=\"Windows安装和设置xshell，使用密码ssh登录\"></a>Windows安装和设置xshell，使用密码ssh登录</h2><p>Windows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。</p>\n<blockquote>\n<p>Windows版的<code>git</code>包含一个简化版<code>MinGW</code>，将<code>&lt;git安装目录&gt;\\usr\\bin</code>这个路径添加到Windows的<code>Path</code>环境变量，就可以在Windows的命令窗口执行<code>ssh</code>，<code>scp</code>及其它很多Linux命令了。<br><code>MinGW</code> 中也包含SSH Server程序<code>sshd</code>，不过估计很少会登录到Windows执行命令行操作吧。</p>\n</blockquote>\n<p>从官网下载并安装 <a href=\"http://www.netsarang.com/download/down_xsh.html\" target=\"_blank\" rel=\"external\">xshell</a> （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 <strong>普通下载</strong>。</p>\n<p>启动xshell后，可以直接执行<code>ssh ying@10.1.1.5</code>，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。<br><img src=\"/img/xshell-ui.png\" alt=\"\"></p>\n<blockquote>\n<p>工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行<code>open &lt;会话名&gt;</code>。<br>工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。<br>每个会话即<code>&lt;用户文档&gt;\\NetSarang\\Xshell\\Sessions</code>下的一个配置文件，会话也可以复制后修改。</p>\n</blockquote>\n<p>为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 <strong>“会话属性”</strong> 对话框中</p>\n<ul>\n<li>在“连接” 输入主机 <code>10.1.1.5</code>，在用户身份验证中选择方法为Password，输入用户名 <code>ying</code> 和 密码；</li>\n<li>在“终端” 修改“编码”为UTF-8；</li>\n<li>在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。</li>\n</ul>\n<p><img src=\"/img/xshell-prop.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”<code>Ctrl+C</code>对应的是中断当前命令。<br>xshell中默认“复制”、“粘贴”的快捷键是<code>Ctrl+Ins</code>，<code>Shift+Ins</code>，而不是<code>Ctrl+C</code>，<code>Ctrl+V</code>。<br>可以打开 “工具”-&gt;“选项”，“键盘和鼠标”选项卡，“按键对应”-&gt;“编辑”，将其修改为<code>Ctrl+C</code>，<code>Ctrl+V</code>，而原来Linux终端的快捷键需要加<code>Shift</code>，如中断当前命令的<code>Ctrl+C</code>变成了<code>Ctrl+Shift+C</code>。</p>\n</blockquote>\n<h2 id=\"scp\"><a href=\"#scp\" class=\"headerlink\" title=\"scp\"></a>scp</h2><p>通过ssh加密的通道传输文件。文件路径格式为<code>用户名@主机名或IP:主机上的路径</code>。注意，Windows文件路径中的盘符<code>C:\\</code>变成了<code>/c/</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">scp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/</div></pre></td></tr></table></figure></p>\n<h2 id=\"sftp\"><a href=\"#sftp\" class=\"headerlink\" title=\"sftp\"></a>sftp</h2><p><code>OpenSSH Server</code>内置了一个<code>sftp</code>服务器，会随<code>sshd</code>服务自动启动。我们还需要一个<code>sftp</code>的客户端即可传送文件。<br>这里使用图形界面的，跨平台的，免费的，开源的<a href=\"https://filezilla-project.org/download.php?type=client\" target=\"_blank\" rel=\"external\">Filezilla</a>。下载并安装后，在“快速连接”工具栏输入主机<code>sftp://10.1.1.5</code>，及用户名 <code>ying</code> 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。<br><img src=\"/img/sftp.png\" alt=\"\"></p>\n<p>Android上的<code>ES文件浏览器</code>也支持<code>sftp</code>（还支持下面介绍的smb局域网文件共享）。</p>\n<h2 id=\"设置ssh使用密钥登录\"><a href=\"#设置ssh使用密钥登录\" class=\"headerlink\" title=\"设置ssh使用密钥登录\"></a>设置ssh使用密钥登录</h2><p>更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用<code>rsa</code>算法，公钥和私钥分别保存在两个 <strong>文本</strong> 文件<code>id_rsa.pub</code>和<code>id_rsa</code>中。</p>\n<ul>\n<li>公钥<code>id_rsa.pub</code>保存在要登录的目标机器上（服务器，Github等），</li>\n<li>私钥<code>id_rsa</code>保存在 <strong>发起</strong> 登录的机器上（客户端），私钥要妥善保管，防止泄露。</li>\n</ul>\n<p>Linux主机的密钥对默认保存在<code>~/.ssh/</code>目录。<br>Windows是<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh\\</code>目录。在图形界面的文件管理器中不能创建以<code>.</code>开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（<code>Win键+X，C</code>），执行命令<code>mkdir C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>。</p>\n<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3><p>因为加密算法是公开的，有多种工具可以生成密钥。<br>对Linux或MinGW，执行<code>ssh-keygen -t rsa -P &quot;&quot;</code> ，会在<code>~/.ssh/</code>生成密钥对<code>id_rsa.pub</code>和<code>id_rsa</code>。</p>\n<p>xshell也可以生成密钥对：</p>\n<ul>\n<li>打开 “工具”-&gt; “新建用户密钥生成向导” 或 “工具”-&gt; “用户密钥管理者” -&gt; “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；</li>\n<li>选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；</li>\n<li>选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。</li>\n</ul>\n<p><img src=\"/img/xshell-key.png\" alt=\"\"></p>\n<h3 id=\"分发密钥对\"><a href=\"#分发密钥对\" class=\"headerlink\" title=\"分发密钥对\"></a>分发密钥对</h3><p>要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的<code>.ssh/authorized_keys</code>文件中。<br>分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的<code>scp</code>和<code>sftp</code>，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行<code>wget</code>或<code>curl</code>命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。</p>\n<h4 id=\"ssh-copy-id\"><a href=\"#ssh-copy-id\" class=\"headerlink\" title=\"ssh-copy-id\"></a>ssh-copy-id</h4><p>执行命令<code>ssh-copy-id -i 公钥文件 用户名@主机名或IP</code>，将公钥拷贝到远程Linux主机的<code>/home/&lt;用户名&gt;/.ssh/authorized_keys</code>文件中。当然，这个命令需要用密码访问远程主机。</p>\n<h4 id=\"复制密钥文本\"><a href=\"#复制密钥文本\" class=\"headerlink\" title=\"复制密钥文本\"></a>复制密钥文本</h4><p>如将Linux主机上生成的私钥<code>id_rsa</code>拷贝到Windows上：</p>\n<ul>\n<li>使用xshell用密码登录到Linux，执行<code>cat ~/.ssh/id_rsa</code>，输出私钥的内容，复制输出的文字。</li>\n<li>在Windows文件管理器中打开路径<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>，在其中创建一个名为<code>id_rsa.txt</code>的文本文件，将上一步复制的文字粘贴进去，然后把文件名的<code>.txt</code>扩展名去掉，即改为<code>id_rsa</code>。</li>\n</ul>\n<p>可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行<code>git</code>、<code>ssh</code>等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。</p>\n<h3 id=\"ssh-config设置\"><a href=\"#ssh-config设置\" class=\"headerlink\" title=\"ssh config设置\"></a>ssh config设置</h3><p>在<code>~/.ssh/config</code>文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Host   别名</div><div class=\"line\">    HostName 主机名或IP</div><div class=\"line\">    Port     端口</div><div class=\"line\">    User     用户名</div><div class=\"line\">    IdentityFile   私钥文件</div><div class=\"line\"></div><div class=\"line\">Host u</div><div class=\"line\">    Hostname  10.1.1.5</div><div class=\"line\">    Port      22</div><div class=\"line\">    User      ying</div><div class=\"line\"></div><div class=\"line\">Host          10.1.1.6</div><div class=\"line\">Port          2222</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>这样就可以直接执行<code>ssh 别名</code>登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在<code>scp</code>的路径中。</p>\n<h3 id=\"踢出ssh会话\"><a href=\"#踢出ssh会话\" class=\"headerlink\" title=\"踢出ssh会话\"></a>踢出ssh会话</h3><p>查看在线用户：<code>w</code> 或 <code>who</code>，两者输出格式有所不同。<br>查看自己的连接信息：<code>who am i</code>。<br>踢出其它会话：<code>pkill -9 -t pts/1</code>，其中<code>pts/1</code>是被踢会话的终端。</p>\n<h1 id=\"远程共享文件（SMB-CIFS）\"><a href=\"#远程共享文件（SMB-CIFS）\" class=\"headerlink\" title=\"远程共享文件（SMB/CIFS）\"></a>远程共享文件（SMB/CIFS）</h1><p>“共享文件”（<a href=\"https://en.wikipedia.org/wiki/Server_Message_Block\" target=\"_blank\" rel=\"external\">Server Message Block，SMB</a> )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。<br>Samba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。<br>Linux上与SMB/CIFS功能是类似的是“网络文件系统”（<a href=\"https://en.wikipedia.org/wiki/Network_File_System\" target=\"_blank\" rel=\"external\">Network File System，NFS</a> ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过<code>控制面板→程序和功能→启用或关闭Windows功能</code>来添加NFS客户端和服务端软件。</p>\n<blockquote>\n<p>注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。<br>共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。</p>\n</blockquote>\n<p>Linux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行<code>sudo apt install cifs-utils</code>来安装。</p>\n<h2 id=\"Samba访问Windows提供的共享文件\"><a href=\"#Samba访问Windows提供的共享文件\" class=\"headerlink\" title=\"Samba访问Windows提供的共享文件\"></a>Samba访问Windows提供的共享文件</h2><p>Windows上启用共享文件夹只要在文件夹的<code>属性对话框→共享选项卡→高级共享</code>中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加<code>$</code>，就表示是隐藏的，必须通过输入完整路径才能打开。<br><img src=\"/img/win-share.png\" alt=\"Windows上启用共享文件夹\"></p>\n<p>创建挂载点<code>mkdir ~/z</code>，并在<code>/etc/fstab</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0</div></pre></td></tr></table></figure></p>\n<p>执行<code>sudo mount -a</code>，挂载<code>/etc/fstab</code>中新增的设置。<br>执行<code>ls ~/z</code>，应列出共享文件夹中的内容，确认挂载成功。</p>\n<blockquote>\n<p>上面的命令将共享文件夹<code>文档</code>挂载到Ubuntu的<code>/home/ying/z</code>，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。<br>其中uid是Ubuntu中用户<code>ying</code>的，具体的值可执行命令<code>id</code>，或在<code>/etc/passwd</code>中查看。</p>\n</blockquote>\n<h2 id=\"Windows访问Samba的共享文件\"><a href=\"#Windows访问Samba的共享文件\" class=\"headerlink\" title=\"Windows访问Samba的共享文件\"></a>Windows访问Samba的共享文件</h2><p>先要安装<code>Samba File Server</code>，执行<code>sudo apt install samba samba-common</code>。</p>\n<blockquote>\n<p>查看Samba Server的运行状态，执行<code>systemctl status smbd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart smbd</code></p>\n</blockquote>\n<p>添加共享文件夹：执行 <code>sudo nano /etc/samba/smb.conf</code>，在末尾添加如下内容，添加了只读的根目录<code>/</code>和可读写的<code>/home/ying</code>目录，但显示为<code>all</code>和<code>ying</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[all]</div><div class=\"line\">    comment = fs root directory</div><div class=\"line\">    path = /</div><div class=\"line\">;   writeable = no</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div><div class=\"line\"></div><div class=\"line\">[ying]</div><div class=\"line\">    comment = ying&apos;s home</div><div class=\"line\">    path = /home/ying</div><div class=\"line\">    writeable = yes</div><div class=\"line\">    create mask = 0664</div><div class=\"line\">    directory mask = 0775</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div></pre></td></tr></table></figure></p>\n<p>将<code>ying</code>添加为smb的共享用户：<code>sudo smbpasswd -a ying</code>， 按提示设置<code>ying</code>的smb密码，<strong>可以与系统密码不同</strong>。<br>重启smbd，使设置生效：<code>sudo systemctl restart smbd</code>。</p>\n<blockquote>\n<p>Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。</p>\n</blockquote>\n<p>从Windows的文件管理器的地址栏访问 <code>\\\\10.1.1.5</code> ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 <strong>“映射网络驱动器”</strong> 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为<code>\\\\u</code> 。</p>\n<p>从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是<code>smb://10.1.1.5</code>或<code>smb://u</code>。macOS会自动把共享文件挂载到<code>/Volumes</code>下。</p>\n<blockquote>\n<p>Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的<code>WINS</code>名字服务。<br>另一种方法是在<code>hosts</code>文件中为IP地址指定名字。</p>\n</blockquote>\n<p><img src=\"/img/smb.png\" alt=\"\"></p>\n<blockquote>\n<p>Samba共享文件与<code>sftp</code>的区别在于，<code>sftp</code>不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。<br>PS, <code>testparm</code>命令可以用来检查<code>smb.conf</code>的配置是否正确。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server\" target=\"_blank\" rel=\"external\">Setting up Samba as a Standalone Server - samba wiki</a></li>\n<li><a href=\"http://lybing.blog.51cto.com/3286625/1676515\" target=\"_blank\" rel=\"external\">在CentOS 7中Samba服务安装和配置</a></li>\n</ul>\n</blockquote>\n<h2 id=\"更改Samba的默认端口号\"><a href=\"#更改Samba的默认端口号\" class=\"headerlink\" title=\"更改Samba的默认端口号\"></a>更改Samba的默认端口号</h2><p>2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。<br>估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是<code>smb://10.1.1.5:4455/home/</code>，其中4455是修改后的端口号。</p>\n<p>修改Samba的端口号只需在<code>/etc/samba/smb.conf</code>中增加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">   smb ports = 4455 445  # 可以同时监听多个端口号</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h1><h2 id=\"mstsc\"><a href=\"#mstsc\" class=\"headerlink\" title=\"mstsc\"></a>mstsc</h2><p>Windows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议<a href=\"https://en.wikipedia.org/wiki/Remote_Desktop_Protocol\" target=\"_blank\" rel=\"external\">Remote Desktop Protocol，RDP</a>。</p>\n<ul>\n<li>客户端在<code>所有程序→Windows附件→远程桌面连接</code>，或直接执行命令<code>mstsc</code>。</li>\n<li>服务程序：依次打开<code>控制面板→所有控制面板项→系统</code>，或<code>Win+X，Y</code>，然后单击左侧的<code>高级系统设置</code>，打开<code>系统属性</code>对话框，在<code>远程</code>选项卡中的<code>远程桌面</code>部分选中<code>允许远程连接到此计算机</code>，并选择某个用户。<br><img src=\"/img/win-mstsc.png\" alt=\"Windows上的远程桌面客户端\"><br><img src=\"/img/win-mstsc-svr.png\" alt=\"Windows上启用远程桌面\"></li>\n</ul>\n<p>Ubuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。<br>如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。</p>\n<p>Windows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。</p>\n<h2 id=\"vnc\"><a href=\"#vnc\" class=\"headerlink\" title=\"vnc\"></a>vnc</h2><p>VNC（<a href=\"https://en.wikipedia.org/wiki/Virtual_Network_Computing\" target=\"_blank\" rel=\"external\">Virtual Network Computing</a>）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了<code>远程共享</code>程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。<br>VNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。</p>\n<p>可以参考教程[<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04\" target=\"_blank\" rel=\"external\">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04</a>] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。</p>\n<p>Windows上没有内置的VNC客户端，有一些免费的<code>VNC-Viewer</code>程序。</p>\n<blockquote>\n<p>注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，<br>默认的 <code>Tab</code> 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-&gt; Window Manager -&gt; Keyboard”中清除 <code>Switch Window from same application</code> 关联的快捷键<br>还可以在 “Settings-&gt; Keyboard -&gt; application shortcut” 中设置打开终端的快捷键 <code>exo-open --launch TerminalEmulator ~ Ctrl+Alt+T</code></p>\n</blockquote>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 <strong><a href=\"https://www.teamviewer.com\" target=\"_blank\" rel=\"external\">TeamViewer</a></strong>，<a href=\"http://sunlogin.oray.com/zh_CN/\" target=\"_blank\" rel=\"external\">向日葵</a>等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。</p>\n","site":{"data":{}},"excerpt":"<p>一些基础的远程操作，包括ssh，共享文件，远程桌面。</p>","more":"<hr>\n<!-- TOC -->\n<ul>\n<li><a href=\"#linux%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%88ssh%EF%BC%89\">Linux远程执行命令（ssh）</a><ul>\n<li><a href=\"#linux%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8ssh\">Linux下设置和使用ssh</a></li>\n<li><a href=\"#windows%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AExshell%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95\">Windows安装和设置xshell，使用密码ssh登录</a></li>\n<li><a href=\"#scp\">scp</a></li>\n<li><a href=\"#sftp\">sftp</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEssh%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95\">设置ssh使用密钥登录</a><ul>\n<li><a href=\"#%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9\">生成密钥对</a></li>\n<li><a href=\"#%E5%88%86%E5%8F%91%E5%AF%86%E9%92%A5%E5%AF%B9\">分发密钥对</a><ul>\n<li><a href=\"#ssh-copy-id\">ssh-copy-id</a></li>\n<li><a href=\"#%E5%A4%8D%E5%88%B6%E5%AF%86%E9%92%A5%E6%96%87%E6%9C%AC\">复制密钥文本</a></li>\n</ul>\n</li>\n<li><a href=\"#ssh-config%E8%AE%BE%E7%BD%AE\">ssh config设置</a></li>\n<li><a href=\"#%E8%B8%A2%E5%87%BAssh%E4%BC%9A%E8%AF%9D\">踢出ssh会话</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%88smbcifs%EF%BC%89\">远程共享文件（SMB/CIFS）</a><ul>\n<li><a href=\"#samba%E8%AE%BF%E9%97%AEwindows%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Samba访问Windows提供的共享文件</a></li>\n<li><a href=\"#windows%E8%AE%BF%E9%97%AEsamba%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6\">Windows访问Samba的共享文件</a></li>\n<li><a href=\"#%E6%9B%B4%E6%94%B9samba%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7\">更改Samba的默认端口号</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2\">远程桌面</a><ul>\n<li><a href=\"#mstsc\">mstsc</a></li>\n<li><a href=\"#vnc\">vnc</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>这里简单介绍局域网中Windows与Linux系统之间的一些基本远程操作，包括远程执行命令（<code>ssh</code>），共享文件（<code>Samba</code>）和远程桌面（<code>mstsc</code>和<code>vnc</code>）。<br>远程操作一般是“服务器-客户端”模式，有的服务程序或客户端是操作系统内置的，开箱即用，有的程序则需要手动安装。</p>\n<p>为了方便配置，<strong>建议关闭系统的防火墙</strong>。下面例子使用的远程Linux主机是Ubuntu 16.04，IP是<code>10.1.1.5</code>，用户名<code>ying</code>；Windows的IP是<code>10.1.1.1</code>，用户名也是<code>ying</code>。</p>\n<h1 id=\"Linux远程执行命令（ssh）\"><a href=\"#Linux远程执行命令（ssh）\" class=\"headerlink\" title=\"Linux远程执行命令（ssh）\"></a>Linux远程执行命令（ssh）</h1><p>ssh（<a href=\"https://en.wikipedia.org/wiki/Secure_Shell\" target=\"_blank\" rel=\"external\">Secure Shell</a>）通过加密的网络通道在客户端和服务器之间传递命令及其输出。<br>在ssh之前，远程执行命令是通过<code>telnet</code>或<code>rsh</code>等程序实现的，数据是明文传输的，缺乏安全性。ssh提供了一个在网络上认证用户和加密数据的通道，执行命令是直接使用的系统内置的shell。<br>可以在ssh提供的加密通道上完成其它网络通信：如<code>scp</code>是在ssh加密通道上实现的远程拷贝（<code>rcp</code>）；<code>sftp</code>是在ssh加密通道上实现的<code>ftp</code>；<code>git</code>也有使用ssh加密通道传输文件的模式。<br>对于Linux这种主要通过shell命令行交互的系统来说，使用ssh远程登录到服务器上，就跟直接在机器上敲命令就没什么区别了。</p>\n<h2 id=\"Linux下设置和使用ssh\"><a href=\"#Linux下设置和使用ssh\" class=\"headerlink\" title=\"Linux下设置和使用ssh\"></a>Linux下设置和使用ssh</h2><p>Linux系统的ssh服务程序是<code>OpenSSH Server</code>，执行命令<code>sudo apt install openssh-server</code>。<br>安装过程中会将ssh服务程序（<code>sshd</code>）添加为开机启动的系统服务，默认设置允许当前用户通过密码登录ssh。</p>\n<blockquote>\n<p>查看SSH Server状态，执行<code>systemctl status sshd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart sshd</code></p>\n</blockquote>\n<p>一般Linux系统都内置了ssh客户端，执行<br><code>ssh 用户名@主机名或IP</code><br>登录到远程主机（如果用户名与当前登录的用户名相同，可以省略）。<br>登录到本机的命令是<code>ssh localhost</code><br>第一次登录某个主机会提示是否 <strong>信任</strong> 该主机，需要输入<code>yes</code>，之后才会提示输入远程主机的登录密码。</p>\n<blockquote>\n<p>修改<code>/etc/ssh/ssh_config</code>，将其中<code>#   StrictHostKeyChecking ask</code> 改为 <code>StrictHostKeyChecking no</code>，这样在第一次登录时就不会询问是否要信任该主机了。</p>\n</blockquote>\n<p>如果登录到远程主机只是执行一两条命令，可执行<br><code>ssh 用户名@主机名或IP 命令</code><br>当然，每次还是需要输入密码，参考下面的设置密钥登录后就方便多了。</p>\n<h2 id=\"Windows安装和设置xshell，使用密码ssh登录\"><a href=\"#Windows安装和设置xshell，使用密码ssh登录\" class=\"headerlink\" title=\"Windows安装和设置xshell，使用密码ssh登录\"></a>Windows安装和设置xshell，使用密码ssh登录</h2><p>Windows目前没有内置的ssh客户端，可以安装Putty、SecureCRT、xshell等ssh客户端软件，或者使用Cygwin/MinGW，git（包含MinGW），Bash on Windows等附带的ssh命令。</p>\n<blockquote>\n<p>Windows版的<code>git</code>包含一个简化版<code>MinGW</code>，将<code>&lt;git安装目录&gt;\\usr\\bin</code>这个路径添加到Windows的<code>Path</code>环境变量，就可以在Windows的命令窗口执行<code>ssh</code>，<code>scp</code>及其它很多Linux命令了。<br><code>MinGW</code> 中也包含SSH Server程序<code>sshd</code>，不过估计很少会登录到Windows执行命令行操作吧。</p>\n</blockquote>\n<p>从官网下载并安装 <a href=\"http://www.netsarang.com/download/down_xsh.html\" target=\"_blank\" rel=\"external\">xshell</a> （需要注册一个免费的账号，选择免费的Home/School许可），也可以在百度搜索“xshell”，第一条结果即是，注意要选择 <strong>普通下载</strong>。</p>\n<p>启动xshell后，可以直接执行<code>ssh ying@10.1.1.5</code>，会提示输入密码，首次连接也会提示“未知的主机密钥”，选择保存即可。<br><img src=\"/img/xshell-ui.png\" alt=\"\"></p>\n<blockquote>\n<p>工具栏的打开会话按钮，可以从其中选择某个会话，也可以直接在xshell中执行<code>open &lt;会话名&gt;</code>。<br>工具栏的那个带小齿轮的按钮是“默认会话属性”，修改其中的设置会影响新建的会话。<br>每个会话即<code>&lt;用户文档&gt;\\NetSarang\\Xshell\\Sessions</code>下的一个配置文件，会话也可以复制后修改。</p>\n</blockquote>\n<p>为方便后续使用，可以为这个虚拟机创建一个会话。单击工具栏的“新建”按钮，在打开的 <strong>“会话属性”</strong> 对话框中</p>\n<ul>\n<li>在“连接” 输入主机 <code>10.1.1.5</code>，在用户身份验证中选择方法为Password，输入用户名 <code>ying</code> 和 密码；</li>\n<li>在“终端” 修改“编码”为UTF-8；</li>\n<li>在“外观” 修改终端字体和配色方案，我比较习惯黑底绿字的配色，使用Consolas字体，使用闪烁的光标。</li>\n</ul>\n<p><img src=\"/img/xshell-prop.png\" alt=\"\"></p>\n<blockquote>\n<p>注意：Windows的快捷键与Linux终端的快捷键存在冲突，如“复制”<code>Ctrl+C</code>对应的是中断当前命令。<br>xshell中默认“复制”、“粘贴”的快捷键是<code>Ctrl+Ins</code>，<code>Shift+Ins</code>，而不是<code>Ctrl+C</code>，<code>Ctrl+V</code>。<br>可以打开 “工具”-&gt;“选项”，“键盘和鼠标”选项卡，“按键对应”-&gt;“编辑”，将其修改为<code>Ctrl+C</code>，<code>Ctrl+V</code>，而原来Linux终端的快捷键需要加<code>Shift</code>，如中断当前命令的<code>Ctrl+C</code>变成了<code>Ctrl+Shift+C</code>。</p>\n</blockquote>\n<h2 id=\"scp\"><a href=\"#scp\" class=\"headerlink\" title=\"scp\"></a>scp</h2><p>通过ssh加密的通道传输文件。文件路径格式为<code>用户名@主机名或IP:主机上的路径</code>。注意，Windows文件路径中的盘符<code>C:\\</code>变成了<code>/c/</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">scp ying@10.1.1.5:/home/ying/.ssh/id_rsa.pub /c/users/ying/.ssh/</div></pre></td></tr></table></figure></p>\n<h2 id=\"sftp\"><a href=\"#sftp\" class=\"headerlink\" title=\"sftp\"></a>sftp</h2><p><code>OpenSSH Server</code>内置了一个<code>sftp</code>服务器，会随<code>sshd</code>服务自动启动。我们还需要一个<code>sftp</code>的客户端即可传送文件。<br>这里使用图形界面的，跨平台的，免费的，开源的<a href=\"https://filezilla-project.org/download.php?type=client\" target=\"_blank\" rel=\"external\">Filezilla</a>。下载并安装后，在“快速连接”工具栏输入主机<code>sftp://10.1.1.5</code>，及用户名 <code>ying</code> 和密码，端口为22，单击“快速连接”，然后就可以进行文件传输和管理了。<br><img src=\"/img/sftp.png\" alt=\"\"></p>\n<p>Android上的<code>ES文件浏览器</code>也支持<code>sftp</code>（还支持下面介绍的smb局域网文件共享）。</p>\n<h2 id=\"设置ssh使用密钥登录\"><a href=\"#设置ssh使用密钥登录\" class=\"headerlink\" title=\"设置ssh使用密钥登录\"></a>设置ssh使用密钥登录</h2><p>更安全而且方便的ssh登录方式是使用密钥对(key)。密钥对包含公钥和私钥，其实是两个很长的整数（被编码为字符串）。比如采用<code>rsa</code>算法，公钥和私钥分别保存在两个 <strong>文本</strong> 文件<code>id_rsa.pub</code>和<code>id_rsa</code>中。</p>\n<ul>\n<li>公钥<code>id_rsa.pub</code>保存在要登录的目标机器上（服务器，Github等），</li>\n<li>私钥<code>id_rsa</code>保存在 <strong>发起</strong> 登录的机器上（客户端），私钥要妥善保管，防止泄露。</li>\n</ul>\n<p>Linux主机的密钥对默认保存在<code>~/.ssh/</code>目录。<br>Windows是<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh\\</code>目录。在图形界面的文件管理器中不能创建以<code>.</code>开头的文件夹，需要在命令窗口操作：打开Windows的命令窗口（<code>Win键+X，C</code>），执行命令<code>mkdir C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>。</p>\n<h3 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h3><p>因为加密算法是公开的，有多种工具可以生成密钥。<br>对Linux或MinGW，执行<code>ssh-keygen -t rsa -P &quot;&quot;</code> ，会在<code>~/.ssh/</code>生成密钥对<code>id_rsa.pub</code>和<code>id_rsa</code>。</p>\n<p>xshell也可以生成密钥对：</p>\n<ul>\n<li>打开 “工具”-&gt; “新建用户密钥生成向导” 或 “工具”-&gt; “用户密钥管理者” -&gt; “生成” 生成一个密钥类型为RSA的密钥，向导的最后一步会显示公钥，可以将其保存起来；</li>\n<li>选择刚创建的密钥，单击“导出”按钮，保存私钥，默认的格式与OpenSSH相同；</li>\n<li>选择刚创建的密钥，单击“属性”按钮，在“公钥”选项卡中保存公钥。</li>\n</ul>\n<p><img src=\"/img/xshell-key.png\" alt=\"\"></p>\n<h3 id=\"分发密钥对\"><a href=\"#分发密钥对\" class=\"headerlink\" title=\"分发密钥对\"></a>分发密钥对</h3><p>要启用密钥，需清除其它用户访问私钥的权限（600），并公钥拷贝到远程目标Linux主机的<code>.ssh/authorized_keys</code>文件中。<br>分发密钥对其实就是在在Windows和Linux之间传送文件，可以使用上面提到的<code>scp</code>和<code>sftp</code>，也可以参考后面要介绍的smb文件共享；或者更复杂一些，搭建一个Web服务器，把文件放到上面，在Linux执行<code>wget</code>或<code>curl</code>命令下载，Windows可以通过浏览器下载。下面还有另外两种方法。</p>\n<h4 id=\"ssh-copy-id\"><a href=\"#ssh-copy-id\" class=\"headerlink\" title=\"ssh-copy-id\"></a>ssh-copy-id</h4><p>执行命令<code>ssh-copy-id -i 公钥文件 用户名@主机名或IP</code>，将公钥拷贝到远程Linux主机的<code>/home/&lt;用户名&gt;/.ssh/authorized_keys</code>文件中。当然，这个命令需要用密码访问远程主机。</p>\n<h4 id=\"复制密钥文本\"><a href=\"#复制密钥文本\" class=\"headerlink\" title=\"复制密钥文本\"></a>复制密钥文本</h4><p>如将Linux主机上生成的私钥<code>id_rsa</code>拷贝到Windows上：</p>\n<ul>\n<li>使用xshell用密码登录到Linux，执行<code>cat ~/.ssh/id_rsa</code>，输出私钥的内容，复制输出的文字。</li>\n<li>在Windows文件管理器中打开路径<code>C:\\Users\\&lt;Win用户名&gt;\\.ssh</code>，在其中创建一个名为<code>id_rsa.txt</code>的文本文件，将上一步复制的文字粘贴进去，然后把文件名的<code>.txt</code>扩展名去掉，即改为<code>id_rsa</code>。</li>\n</ul>\n<p>可以参考上面的方式将Windows上生成的公钥拷贝到远程Linux主机上。因为还要从远程Linux主机上执行<code>git</code>、<code>ssh</code>等命令，所以也要把私钥放拷过去。当然，也可以使用不同的密钥对。</p>\n<h3 id=\"ssh-config设置\"><a href=\"#ssh-config设置\" class=\"headerlink\" title=\"ssh config设置\"></a>ssh config设置</h3><p>在<code>~/.ssh/config</code>文件中可以设置多个远程主机的别名，地址，端口，用户名和密钥，简化ssh命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Host   别名</div><div class=\"line\">    HostName 主机名或IP</div><div class=\"line\">    Port     端口</div><div class=\"line\">    User     用户名</div><div class=\"line\">    IdentityFile   私钥文件</div><div class=\"line\"></div><div class=\"line\">Host u</div><div class=\"line\">    Hostname  10.1.1.5</div><div class=\"line\">    Port      22</div><div class=\"line\">    User      ying</div><div class=\"line\"></div><div class=\"line\">Host          10.1.1.6</div><div class=\"line\">Port          2222</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p>这样就可以直接执行<code>ssh 别名</code>登录指定的主机，而且不同的主机可以使用不同的端口，用户，密钥配置。别名还可以用在<code>scp</code>的路径中。</p>\n<h3 id=\"踢出ssh会话\"><a href=\"#踢出ssh会话\" class=\"headerlink\" title=\"踢出ssh会话\"></a>踢出ssh会话</h3><p>查看在线用户：<code>w</code> 或 <code>who</code>，两者输出格式有所不同。<br>查看自己的连接信息：<code>who am i</code>。<br>踢出其它会话：<code>pkill -9 -t pts/1</code>，其中<code>pts/1</code>是被踢会话的终端。</p>\n<h1 id=\"远程共享文件（SMB-CIFS）\"><a href=\"#远程共享文件（SMB-CIFS）\" class=\"headerlink\" title=\"远程共享文件（SMB/CIFS）\"></a>远程共享文件（SMB/CIFS）</h1><p>“共享文件”（<a href=\"https://en.wikipedia.org/wiki/Server_Message_Block\" target=\"_blank\" rel=\"external\">Server Message Block，SMB</a> )，改进的版本称为Common Internet File System，CIFS），是Windows上为局域网用户提供的远程访问文件的功能。Windows内置了smb的服务程序和客户端。<br>Samba是Linux上实现SMB/CIFS协议的开源服务程序及客户端。<br>Linux上与SMB/CIFS功能是类似的是“网络文件系统”（<a href=\"https://en.wikipedia.org/wiki/Network_File_System\" target=\"_blank\" rel=\"external\">Network File System，NFS</a> ）。SMB和NFS功能相似，都是文件级别（相比于块级别iSCSI等方式）的远程存储服务。Windows默认没有安装NFS功能，但可以通过<code>控制面板→程序和功能→启用或关闭Windows功能</code>来添加NFS客户端和服务端软件。</p>\n<blockquote>\n<p>注意：只能共享某个文件夹，不能单独共享某个文件。Windows会限制能链接的共享用户数量，如果需要提供共享文件服务，Samba是更好的选择。<br>共享配合文件系统的权限设置，可以实现精细的权限控制，比如 “只能上传，不能下载，不能删除” 这样的需求（上传作业的文件服务器）。</p>\n</blockquote>\n<p>Linux一般内置了smb的客户端（mount.cifs模块）。如果没有，可以执行<code>sudo apt install cifs-utils</code>来安装。</p>\n<h2 id=\"Samba访问Windows提供的共享文件\"><a href=\"#Samba访问Windows提供的共享文件\" class=\"headerlink\" title=\"Samba访问Windows提供的共享文件\"></a>Samba访问Windows提供的共享文件</h2><p>Windows上启用共享文件夹只要在文件夹的<code>属性对话框→共享选项卡→高级共享</code>中设置即可，在这个对话框中还可以指定用户和读写权限。共享名和实际的文件夹名可以不同。如果在共享文件名后添加<code>$</code>，就表示是隐藏的，必须通过输入完整路径才能打开。<br><img src=\"/img/win-share.png\" alt=\"Windows上启用共享文件夹\"></p>\n<p>创建挂载点<code>mkdir ~/z</code>，并在<code>/etc/fstab</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//10.1.1.1/文档 /home/ying/z cifs username=Win用户名,password=Win密码,uid=1000,rw,iocharset=utf8,sec=ntlm 0 0</div></pre></td></tr></table></figure></p>\n<p>执行<code>sudo mount -a</code>，挂载<code>/etc/fstab</code>中新增的设置。<br>执行<code>ls ~/z</code>，应列出共享文件夹中的内容，确认挂载成功。</p>\n<blockquote>\n<p>上面的命令将共享文件夹<code>文档</code>挂载到Ubuntu的<code>/home/ying/z</code>，有读写权限。因为设置了终端编码为UTF-8，中文的文件名也能正常显示。<br>其中uid是Ubuntu中用户<code>ying</code>的，具体的值可执行命令<code>id</code>，或在<code>/etc/passwd</code>中查看。</p>\n</blockquote>\n<h2 id=\"Windows访问Samba的共享文件\"><a href=\"#Windows访问Samba的共享文件\" class=\"headerlink\" title=\"Windows访问Samba的共享文件\"></a>Windows访问Samba的共享文件</h2><p>先要安装<code>Samba File Server</code>，执行<code>sudo apt install samba samba-common</code>。</p>\n<blockquote>\n<p>查看Samba Server的运行状态，执行<code>systemctl status smbd</code><br>启动，停止或重启服务，执行<code>sudo systemctl start/stop/restart smbd</code></p>\n</blockquote>\n<p>添加共享文件夹：执行 <code>sudo nano /etc/samba/smb.conf</code>，在末尾添加如下内容，添加了只读的根目录<code>/</code>和可读写的<code>/home/ying</code>目录，但显示为<code>all</code>和<code>ying</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[all]</div><div class=\"line\">    comment = fs root directory</div><div class=\"line\">    path = /</div><div class=\"line\">;   writeable = no</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div><div class=\"line\"></div><div class=\"line\">[ying]</div><div class=\"line\">    comment = ying&apos;s home</div><div class=\"line\">    path = /home/ying</div><div class=\"line\">    writeable = yes</div><div class=\"line\">    create mask = 0664</div><div class=\"line\">    directory mask = 0775</div><div class=\"line\">;   browseable = yes</div><div class=\"line\">    valid users = ying</div></pre></td></tr></table></figure></p>\n<p>将<code>ying</code>添加为smb的共享用户：<code>sudo smbpasswd -a ying</code>， 按提示设置<code>ying</code>的smb密码，<strong>可以与系统密码不同</strong>。<br>重启smbd，使设置生效：<code>sudo systemctl restart smbd</code>。</p>\n<blockquote>\n<p>Samba的权限问题：Samba中的用户需要是Ubuntu已有的用户，还要给Samba的用户设置相关文件和目录的读写权限。</p>\n</blockquote>\n<p>从Windows的文件管理器的地址栏访问 <code>\\\\10.1.1.5</code> ，会看到刚添加的两个共享文件夹。可以在文件夹上右击，快捷菜单中有 <strong>“映射网络驱动器”</strong> 的选项，也可以像普通文件夹一样创建快捷方式。除了IP地址，还可以通过Ubuntu的机器名来访问，若机器名为u，则地址为<code>\\\\u</code> 。</p>\n<p>从macOS和Ubuntu访问共享文件（不论Windows或Ubuntu提供的）的路径格式是<code>smb://10.1.1.5</code>或<code>smb://u</code>。macOS会自动把共享文件挂载到<code>/Volumes</code>下。</p>\n<blockquote>\n<p>Windows可以通过机器名来访问Ubuntu是因为Samba默认开启了局域网内的<code>WINS</code>名字服务。<br>另一种方法是在<code>hosts</code>文件中为IP地址指定名字。</p>\n</blockquote>\n<p><img src=\"/img/smb.png\" alt=\"\"></p>\n<blockquote>\n<p>Samba共享文件与<code>sftp</code>的区别在于，<code>sftp</code>不能直接编辑文件，必须要把文件拷贝下来后才能处理，而操作共享文件跟本机的文件没有太大区别。<br>PS, <code>testparm</code>命令可以用来检查<code>smb.conf</code>的配置是否正确。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://wiki.samba.org/index.php/Setting_up_Samba_as_a_Standalone_Server\" target=\"_blank\" rel=\"external\">Setting up Samba as a Standalone Server - samba wiki</a></li>\n<li><a href=\"http://lybing.blog.51cto.com/3286625/1676515\" target=\"_blank\" rel=\"external\">在CentOS 7中Samba服务安装和配置</a></li>\n</ul>\n</blockquote>\n<h2 id=\"更改Samba的默认端口号\"><a href=\"#更改Samba的默认端口号\" class=\"headerlink\" title=\"更改Samba的默认端口号\"></a>更改Samba的默认端口号</h2><p>2017年5月份的勒索病毒WanaCrypt会扫描开放445文件共享端口的Windows设备，导致网络管理员禁封了445端口。如果客户端和服务器在同一局域网，通讯都是在二层，不会受到影响，可以正常使用共享文件，但如果经过路由器，就不能使用了。实际中发现即便是在同一个局域网，另外的实验室也无法访问我们实验室的共享文件，可能两个实验室各自的交换机又连到一个三层交换机上了吧。<br>估计445一封了之，是不会再有解封之日了。好在还可以变通一下，修改Samba的端口号，绕过封锁。不爽的是，Windows的默认端口号是无法修改的，而Linux，macOS，Android的ES文件管理器都支持指定端口号，地址格式是<code>smb://10.1.1.5:4455/home/</code>，其中4455是修改后的端口号。</p>\n<p>修改Samba的端口号只需在<code>/etc/samba/smb.conf</code>中增加<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">   smb ports = 4455 445  # 可以同时监听多个端口号</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h1 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h1><h2 id=\"mstsc\"><a href=\"#mstsc\" class=\"headerlink\" title=\"mstsc\"></a>mstsc</h2><p>Windows除家庭版之外均内置了远程桌面服务和客户端，使用的是远程桌面协议<a href=\"https://en.wikipedia.org/wiki/Remote_Desktop_Protocol\" target=\"_blank\" rel=\"external\">Remote Desktop Protocol，RDP</a>。</p>\n<ul>\n<li>客户端在<code>所有程序→Windows附件→远程桌面连接</code>，或直接执行命令<code>mstsc</code>。</li>\n<li>服务程序：依次打开<code>控制面板→所有控制面板项→系统</code>，或<code>Win+X，Y</code>，然后单击左侧的<code>高级系统设置</code>，打开<code>系统属性</code>对话框，在<code>远程</code>选项卡中的<code>远程桌面</code>部分选中<code>允许远程连接到此计算机</code>，并选择某个用户。<br><img src=\"/img/win-mstsc.png\" alt=\"Windows上的远程桌面客户端\"><br><img src=\"/img/win-mstsc-svr.png\" alt=\"Windows上启用远程桌面\"></li>\n</ul>\n<p>Ubuntu桌面版内置了可以访问Windows远程桌面的客户端；安卓和iOS系统也有远程桌面的App，但这三个系统都没有远程桌面的服务程序，Windows无法通过mstsc远程连接到它们的图形界面。<br>如果是在安卓平板或iPad上使用远程桌面连接到Windows系统，那么Windows会自动切换到触屏模式，就相当于在使用一个Windows系统的平板了，当然是台式机的性能。</p>\n<p>Windows远程桌面一般只支持单个用户访问，如果有用户在使用远程桌面，那么本地的就会锁屏；但是服务器版可以设置支持多个用户同时使用远程桌面，彼此都是独立的窗口。</p>\n<h2 id=\"vnc\"><a href=\"#vnc\" class=\"headerlink\" title=\"vnc\"></a>vnc</h2><p>VNC（<a href=\"https://en.wikipedia.org/wiki/Virtual_Network_Computing\" target=\"_blank\" rel=\"external\">Virtual Network Computing</a>）是Linux上的远程桌面共享协议。Linux下有多个桌面环境，如Gnome，KDE，unity，xfce等，VNC对不同桌面系统的支持不同。此外，VNC的客户端及服务端也有多种实现，如x11vnc、realvnc、tigervnc、tightvnc、ultravnc等。Ubuntu Unity下自带了<code>远程共享</code>程序实现了VNC功能。由于vnc远比ssh占用的网络带宽大，而Linux上的大部分操作可以通过ssh来执行，所以不推荐使用VNC。<br>VNC默认桌面会话使用5900端口，可以开启多个桌面会话，新的VNC桌面会话的端口号依次增加。与Windows的远程桌面不同，VNC在远程访问时不会锁屏，而是同步显示默认桌面会话的显示。</p>\n<p>可以参考教程[<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04\" target=\"_blank\" rel=\"external\">https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-16-04</a>] ，在Ubuntu上安装和配置xfce桌面及tightvnc服务端。</p>\n<p>Windows上没有内置的VNC客户端，有一些免费的<code>VNC-Viewer</code>程序。</p>\n<blockquote>\n<p>注意： 按上面的设置启用VNC后，使用的是xfce桌面环境，<br>默认的 <code>Tab</code> 键补全终端命令与窗口管理的快捷键冲突，需要在“Settings-&gt; Window Manager -&gt; Keyboard”中清除 <code>Switch Window from same application</code> 关联的快捷键<br>还可以在 “Settings-&gt; Keyboard -&gt; application shortcut” 中设置打开终端的快捷键 <code>exo-open --launch TerminalEmulator ~ Ctrl+Alt+T</code></p>\n</blockquote>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>在局域网之外，如果网络连接比较复杂，mstsc或vnc可能都无法穿过机构强制的防火墙。有一些远程访问软件，比如 <strong><a href=\"https://www.teamviewer.com\" target=\"_blank\" rel=\"external\">TeamViewer</a></strong>，<a href=\"http://sunlogin.oray.com/zh_CN/\" target=\"_blank\" rel=\"external\">向日葵</a>等，可以实现广域网情形的远程访问，前提是两端的机器都能访问Internet公网，而mstsc和vnc则不要求必须能够访问公网。另一种方法是申请机构内的VPN。</p>"},{"title":"罗网是坚韧的","date":"2016-05-31T16:00:00.000Z","_content":"\n这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。\n为了清净，把日期改了，手工置底。\n\n====================\n\n<!--more-->\n\n吉檀迦利\n> 第28\n> 罗网是坚韧的，但是要撕破它的时候我又心痛。\n> 我只要自由，为希望自由我却觉得羞愧。\n> 我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。\n> 我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。\n> 我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。\n\n\n\n飞鸟集\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n\n> 第278\n> 我们在热爱世界时便生活在这世界上。\n\n![](/img/4books_IMG_20150328_201923.jpg)\n\n-----\n\n每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。\n\n[《瓦尔登湖》PDF](/doc/walden.pdf)是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时[积累了一些Word排版知识](https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html)，再者是受[《从一到无穷大》PDF](http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf) 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。\n\n\n-----\n\n# 离开是怎样的一种体验？\n转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。\n年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。\n顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。\n预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。\n今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。\n\n离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。\n真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。\n三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。\n然而现在熟悉的人基本都走了。\n除了离开，留下来看别人离开，可能更难过。","source":"_posts/obstinate-are-the-trammels.md","raw":"title: 罗网是坚韧的\ncategory: [misc]\ntags: \ndate: 2016-06-01\n---\n\n这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。\n为了清净，把日期改了，手工置底。\n\n====================\n\n<!--more-->\n\n吉檀迦利\n> 第28\n> 罗网是坚韧的，但是要撕破它的时候我又心痛。\n> 我只要自由，为希望自由我却觉得羞愧。\n> 我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。\n> 我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。\n> 我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。\n\n\n\n飞鸟集\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n\n> 第278\n> 我们在热爱世界时便生活在这世界上。\n\n![](/img/4books_IMG_20150328_201923.jpg)\n\n-----\n\n每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。\n\n[《瓦尔登湖》PDF](/doc/walden.pdf)是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时[积累了一些Word排版知识](https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html)，再者是受[《从一到无穷大》PDF](http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf) 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。\n\n\n-----\n\n# 离开是怎样的一种体验？\n转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。\n年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。\n顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。\n预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。\n今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。\n\n离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。\n真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。\n三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。\n然而现在熟悉的人基本都走了。\n除了离开，留下来看别人离开，可能更难过。","slug":"obstinate-are-the-trammels","published":1,"updated":"2017-10-30T03:42:14.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh0000g9s4frocodlyo","content":"<p>这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。<br>为了清净，把日期改了，手工置底。</p>\n<p>====================</p>\n<a id=\"more\"></a>\n<p>吉檀迦利</p>\n<blockquote>\n<p>第28<br>罗网是坚韧的，但是要撕破它的时候我又心痛。<br>我只要自由，为希望自由我却觉得羞愧。<br>我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。<br>我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。<br>我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。</p>\n</blockquote>\n<p>飞鸟集</p>\n<blockquote>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n<p>第278<br>我们在热爱世界时便生活在这世界上。</p>\n</blockquote>\n<p><img src=\"/img/4books_IMG_20150328_201923.jpg\" alt=\"\"></p>\n<hr>\n<p>每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。</p>\n<p><a href=\"/doc/walden.pdf\">《瓦尔登湖》PDF</a>是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时<a href=\"https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html\" target=\"_blank\" rel=\"external\">积累了一些Word排版知识</a>，再者是受<a href=\"http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf\" target=\"_blank\" rel=\"external\">《从一到无穷大》PDF</a> 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。</p>\n<hr>\n<h1 id=\"离开是怎样的一种体验？\"><a href=\"#离开是怎样的一种体验？\" class=\"headerlink\" title=\"离开是怎样的一种体验？\"></a>离开是怎样的一种体验？</h1><p>转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。<br>年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。<br>顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。<br>预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。<br>今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。</p>\n<p>离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。<br>真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。<br>三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。<br>然而现在熟悉的人基本都走了。<br>除了离开，留下来看别人离开，可能更难过。</p>\n","site":{"data":{}},"excerpt":"<p>这是一篇吐槽文，想到啥就写啥，不定期吐槽。。。<br>为了清净，把日期改了，手工置底。</p>\n<p>====================</p>","more":"<p>吉檀迦利</p>\n<blockquote>\n<p>第28<br>罗网是坚韧的，但是要撕破它的时候我又心痛。<br>我只要自由，为希望自由我却觉得羞愧。<br>我确知那无价之宝是在你那里，而且你是我最好的朋友，但我却舍不得清除我满屋的俗物。<br>我身上披的是尘灰和死亡之衣；我恨它，却又热爱地把它抱紧。<br>我的债务很多，我的失败很大，我的耻辱秘密而又深重；但当我来祈福的时候，我又战栗，唯恐我的祈求得到了允诺。</p>\n</blockquote>\n<p>飞鸟集</p>\n<blockquote>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n<p>第278<br>我们在热爱世界时便生活在这世界上。</p>\n</blockquote>\n<p><img src=\"/img/4books_IMG_20150328_201923.jpg\" alt=\"\"></p>\n<hr>\n<p>每当一段时间心情低落，我就会念两句诗，当然，不是“他”念的『苟利国家生死以，岂因祸福避趋之』，而是泰戈尔的几篇。我是高中时候读的《泰戈尔诗选》，那一版收录了《吉檀迦利》，《飞鸟集》，《新月集》等。我念的是我们县的高中，好多年都没有考上过清华北大的，不过我们的物理老师兼班主任收了班费为我们买了一套语文课列的文学读物，这也算是素质教育了吧。高中读的另外几本好书是《伯克利物理学教程》的力学和电磁学部分，所以本科专业是电气工程；《从一到无穷大》，科普佳作，这几本书都是从高中的校图书馆软磨硬泡混进书架找到的，当时的校图书馆只有一间屋子，不是开放式的书架，而是一个老师在窗口，我们从抽屉里不完整的图书卡片里翻找要借的书；此外还有姥爷的一大本手抄油印的文革后期的《解析几何和高等数学》。</p>\n<p><a href=\"/doc/walden.pdf\">《瓦尔登湖》PDF</a>是工作后才读的。它和《吉檀迦利》都是很安静的，很耐读的书。我记下了分别是2008-09、2009-05工作头一年，2010-07在英国出差独居的大半年，2013-01辞职前两个月和2013-07，2014-04考研前后读了《瓦尔登湖》。链接的PDF文件是我根据纸书，从网上的文字版整理校对排版制作出来的。自己排版当然首先是非常喜欢这本书，还有本科在教务处帮史老师制作毕设Word模板和自己毕设时<a href=\"https://wenku.baidu.com/view/a668646a1eb91a37f1115c35.html\" target=\"_blank\" rel=\"external\">积累了一些Word排版知识</a>，再者是受<a href=\"http://www.sendsms.cn/box/dl/_25B6_25B9_25B0_25EA_25B6_25C1_25CA_25E9/_25BF_25C6_25C6_25D5/_25A1_25B6_25B4_25D3_25D2_25BB_25B5_25BD_25CE_25DE_25C7_25EE_25B4_25F3_25A1_25B7.pdf\" target=\"_blank\" rel=\"external\">《从一到无穷大》PDF</a> 的启发，这份PDF文件精确还原了纸书的排版，简直是强迫症和完美主义者的福音。不过我排版《瓦尔登湖》的时候没有按照纸书的尺寸排版（原因是不知道准确的尺寸，不过还原了英文初版的封面），第一版使用的字体是宋体，后来改成了仿宋，增加了一些章节的题图。</p>\n<hr>\n<h1 id=\"离开是怎样的一种体验？\"><a href=\"#离开是怎样的一种体验？\" class=\"headerlink\" title=\"离开是怎样的一种体验？\"></a>离开是怎样的一种体验？</h1><p>转眼半年过去了，很多熟悉的同学离开了，有的是远走异国他乡，有的只在楼下，然而离开就是离开了。旁边的格子来来去去换了两个人了。<br>年初魏大神还一直不想搬下去，我和mio一直劝他搬到三楼独占的办公室去，mio是觊觎他的格子，我则是认为要尽快换个环境，才好转换身份，适应工作才好。拖来拖去，直到办公室有了另外的新老师魏大神才搬下去。mio终于如愿获得了角落里的这个格子，据说这个是风水最好的位子了，然而mio直到很晚才拿到阿里的offer，位子刚坐热，就去杭州了。<br>顾博则是坚持发完了paper才奔赴UC Davis，从此再也没有咖啡机的噪音，顾博也不会过来吐槽，时不时揭露我四十岁也不一定能毕业的事实了。<br>预答辩之后，猴子和我在食堂偶遇翔总，正好可以好好向翔总总结一下我们的人生经验，避免重蹈覆辙，来到南大这三年，从来没有像那天说了那么多的话，而且看来对翔总还是有点帮助的。昨天（2017-06-22）系里的毕业典礼，之后吃了最后一顿散伙饭，把他们四个从群里移除去了，然而老板不但没有注意到，还告诫他们“好日子到头了”，难道不会说句“前程似锦”吗？我只好截了图分别转发给当事人。<br>今天看到猴子把桌子收拾干净了，多余的毕业论文都扔掉了，拉着箱子等电梯，我犹豫了一下要不要目送他进了电梯，然而还是转身走开了。我去年曾告诉他，2014年我来南大报到时，第一个见到的就是坐在系楼大堂接待桌后的他。当时已经是下午了，我应该算最后一批报到的了，他还问我是老师还是学生，好吧，我以为脸上还有学生气，然而实际那时已经是大叔模样了，更不用说现在。</p>\n<p>离开是怎样的一种体验？当时考完研，我从知乎看到这个问题，想尝试答一下离开大亚湾、大鹏镇的体验呢。同事的传统是离开之前都会给科里群发发一份邮件告别的，我在走之前都收集了好几封了，有调去外地公司的，也有辞职当公务员的，连当年关老板的告别邮件都见到过了。然而我只是悄悄的走了，那天又一轮大修开始了，大家都在通宵停机保驾，而且我的下场也不怎么样，还是灰溜溜地走吧，至少老刘还去吃饭送了一下呢。QQ上的好友删到只剩十几个，通讯录只剩9个，手机也换了号。QQ的签名从Long March改成了海阔天空，普文留言说就这点感慨，我回复说还没开始感慨呢，其实因为马上要投入复习，而且因为离开早就是计划之中的事，心中是期待的，也就真的没有太多感慨了。我选了3月18日跟高科说辞职的事，一是为了拿到年终奖（后来发现是多虑了），二来是两轮大修的间隙，再者是取“散了吧”的谐音。Long March即是当时的纠结，也是对不确定的将来的担忧与期待，好在当时老婆坚定地支持我，当然是希望能在长征之后有所作为的，即便考研失败，还有师傅经过关老板的关系去秦山搞老本行。所以离开大鹏镇去了嘉兴，那里既有普文两口，又有海盐秦山，而且再没其他熟人，可以专心复习。<br>真是神奇，居然考上了。现在看来，长征只是开始，而且没有剧透说只有两万五千里。虽然离开嘉兴时有点不舍，当时还是满心计划着南京的生活的。<br>三年过去了。头一年住在和园，泡在实验室的时间很少，即便是14级的几位同学也没混熟，后来呆在实验室的时间多了，有的是讨论班、有的是上课小组合作、有的是同去印度出差，之后换了组，居然有猴子，也算是有点缘分吧。<br>然而现在熟悉的人基本都走了。<br>除了离开，留下来看别人离开，可能更难过。</p>"},{"title":"CentOS 7 及 Ubuntu 16.04 设置 NAT 网络","date":"2017-04-14T16:00:00.000Z","_content":"记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。\n<!--more-->\n\n<!-- TOC -->\n\n- [CentOS 7 设置和使用NAT](#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [NAT网关的设置](#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置`iptables`规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它 CentOS 7 机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n        - [切换默认网关](#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3)\n        - [为`em1`添加静态路由](#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1)\n- [Ubuntu 16.04 设置和使用NAT](#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [设置NAT](#%E8%AE%BE%E7%BD%AEnat)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置iptables规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n- [其它问题](#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98)\n    - [禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题](#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [取消原来设置的http代理](#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86)\n- [PS: 使用 SSH 隧道](#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93)\n\n<!-- /TOC -->\n\n小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。\n+ 一个LAN是学校的公网IP（下文记为`2.2.2.0/24`网段）。装好CentOS 7系统后，`em1`网卡在公网LAN，可以在校内直接访问`em1`的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。\n+ 另一个LAN是用于远程管理的机房内私网IP（下文记为`10.0.0.0/24`网段），`em2`网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是`10.0.0.1`。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。\n\n一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。\n\n# CentOS 7 设置和使用NAT\n虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个`147`的公网IP（记对应的机器是`n147`）直通校外网。\n之前是通过在`n147`上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将`n147`的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，`n147`就像一个软件实现的家用路由器。\n## NAT网关的设置\n作为网关的机器名是`n147`，公网IP是`2.2.2.147/24`，对应`em1`网卡；私网IP是`10.0.0.147/24`，对应`em2`网卡。\n\n### 允许IP转发\n其它机器从`10.0.0.0/24`网段发送的数据包会被`em2`网卡接收，如果目标IP是外网，需要交给`em1`网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：\n```\n# 查看是否启用IP转发，如果是0则没有开启，是1则已经开启\ncat /proc/sys/net/ipv4/ip_forward\n\n# 可以修改上述文件的值来改变设置，但重启后会恢复默认值。\n# 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf\n# 内容为\nnet.ipv4.ip_forward = 1\n```\n\n### 设置`iptables`规则\n安装必要软件并启用服务：\n```\nyum install -y net-tools iproute iptables iptables-services\nsystemctl disable firewalld\nsystemctl stop firewalld\nsystemctl enable iptables\n```\n\n>`net-tools`这个程序包有 `ifconfig`，`netstat`，`route`等命令，而`iproute2`（rpm包名为`iproute`）包括`tc`，`ip`，`ss`等命令，是`net-tools`的改进。\n\n通过`iptables`命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用`iptables-save`命令输出，然后保存起来。\n这里直接使用`iptables-save`生成的配置项，保存到配置文件 `/etc/sysconfig/iptables`，内容如下：\n```\n# Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017\n*nat\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n-A POSTROUTING -o em1 -j MASQUERADE  \nCOMMIT\n\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT\n-A FORWARD -i em2 -j ACCEPT\nCOMMIT\n```\n\n其中涉及NAT转发的是`-A POSTROUTING -o em1 -j MASQUERADE ` 和 `-A FORWARD -i em2 -j ACCEPT`。\n此外还删除了原来禁止`ping`的规则：\n`-A INPUT -j REJECT --reject-with icmp-host-prohibited`\n`\u000b-A FORWARD -j REJECT --reject-with icmp-host-prohibited`\n\n重启`iptables`服务`systemctl restart iptables`。\n\n>可以修改`/etc/sysconfig/iptables-config` 配置文件，设置下面三个选项均为`yes`来自动保存`iptables`规则\n+ `IPTABLES_MODULES_UNLOAD=\"yes\"`\n+ `IPTABLES_SAVE_ON_STOP=\"yes\"`\n+ `IPTABLES_SAVE_ON_RESTART=\"yes\"`\n\n>参考\n+ [保存iptable规则并开机自动加载](http://salogs.com/news/2015/08/20/iptables-save/)\n+ [iptables用法初解](http://blog.csdn.net/hepeng597/article/details/8270138)\n\n## 设置其它 CentOS 7 机器使用NAT网络\n### 切换默认网关\n安装系统后，默认网关是`em1`所在LAN的`2.2.2.1`，需要将其更改为`em2`所在LAN的`10.0.0.147`，修改如下的网卡配置文件：\n```\n# /etc/sysconfig/network-scripts/ifcfg-em1\nDEFROUTE=no\n\n# /etc/sysconfig/network-scripts/ifcfg-em2\nDEFROUTE=yes\n# ...\nGATEWAY=10.0.0.147\nDNS1=233.5.5.5\nDNS2=223.6.6.6\n```\n\n其中`em2`的网关即刚才配置的`n147`的私网IP，由于没有在`n147`上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置`dnsmasq`等DNS服务器。\n### 为`em1`添加静态路由\n修改默认网关后，查看路由表，\n```\n# route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2\n10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2\n2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n发现从`em1`收发的数据包也要经过默认网关`10.0.0.147`，而这个网关在机房的私网内，**外部不能直接访问，导致外部无法公网IP访问服务器**。为此，需要为`em1`添加静态路由，不走`10.0.0.147`，新建文件`/etc/sysconfig/network-scripts/route-em1`，内容如下：\n```\n2.2.0.0/16    via 2.2.2.1\n172.0.0.0/8   via 2.2.2.1\n```\n\n其中\n+ `2.2.0.0/16`网段是学校 **有线** 网络的IP网段\n+ `172.0.0.0/8`网段是学校 **无线** 网络的IP网段。\n>注意\n+ `docker0`网桥默认也是B类私网的`172.x.0.0/16`网段，但其路由项更具体，所以[不会造成冲突](http://answ.me/post/configure-docker-subnet/)。\n+ `docker0`网桥实际也工作在NAT模式，也需要开启IP转发。\n\n重启网络，更新配置，`systemctl restart network`。\n\n> 参考：[Two Default Gateways on One System](https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System)\n\n# Ubuntu 16.04 设置和使用NAT\n\nUbuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！\n因为用到的工具都是`net-tools`，`iproute`和`iptables`这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。\n## 设置NAT\n\n### 允许IP转发\n直接修改系统配置文件 `/etc/sysctl.conf`，里面已经有支持的配置项，取消`net.ipv4.ip_forward = 1`的注释即可。\n\n### 设置iptables规则\n还是使用的`iptables`，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是`em1`，`em2`，Ubuntu 16.04下是`eno1`，`eno2`，所以要把规则中对应的网卡名改过来。\n\n然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考[IptablesHowTo - Ubuntu wiki](https://help.ubuntu.com/community/IptablesHowTo)，，**随便把规则保存到哪，反正系统不会自动加载**，需要自己添加一个启动脚本。\n因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 `/etc/network/if-pre-up.d/iptablesload`，内容如下，\n```\n#!/bin/sh\niptables-restore < /etc/iptables.rules\nexit 0\n```\n\n可见`/etc/iptables.rules`是保存的`iptables`规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。**但是，你要自己来写这个脚本**。\n\n编辑好`/etc/iptables.rules` 和 `/etc/network/if-pre-up.d/iptablesload`之后，重启网络服务。\n\n虽然都是用`systemd`来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是`network.service`，而Ubuntu则是`networking.service`。\n执行命令`sudo systemctl restart networking`，重启网络服务。不过，其实我们是用`iptables`来实现的NAT，而不是`networking.service`相关服务，不过由于上面的那个脚本`iptablesload`会在网卡启动之前被执行，所以顺便完成了我们的目标。\n\n## 设置其它机器使用NAT网络\n\n同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在`/etc/network/interface`这个文件里，这个倒是方便了—— **[如果面对空空的配置文件，你能猜到各配置项是什么的时候](https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server)**。\n好在安装系统的时候设置了网卡，给`eno2`生成了一些配置项可以参考。修改后的内容如下。\n```\nauto lo\niface lo inet loopback\n\nauto eno1\niface eno1 inet static\n  address 2.2.2.140\n  netmask 255.255.255.0\n  network 2.2.2.0\n  broadcast 2.2.2.255\n  # gateway 2.2.2.1\n  up ip route add 2.2.0.0/16   via 2.2.2.1 || true\n  up ip route add 2.2.2.0/24   via 2.2.2.1 || true\n  up ip route add 172.0.0.0/8  via 2.2.2.1 || true\n\n# The primary network interface\nauto eno2\niface eno2 inet static\n  address 10.0.0.140\n  netmask 255.255.255.0\n  network 10.0.0.0\n  broadcast 10.0.0.255\n  gateway 10.0.0.147\n  # dns-* options are implemented by the resolvconf package, if installed\n  dns-nameservers 233.5.5.5\n```\n>注意\n+ 不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了`gateway`就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个`gateway`项。\n+ `up ip route add 2.2.0.0/16   via 2.2.2.1 || true`其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句`up echo helloworld`也没问题。后面的`|| true`是让脚本执行时忽略可能的错误，继续执行。这里使用的是`ip`命令，如果使用`route`命令，效果也是一样的，前提是已经安装了`net-tools`或`iproute`软件包。使用`netmask`和`CIDR`格式都可以。\n+ 哪个网卡的路由就写到对应的网卡下，这样执行`ifup eno1`这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。\n\n执行命令`sudo systemctl restart networking`，重启网络服务。\n查看一下更新后的路由表，\n```\n# route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2\n10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2\n2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1\n2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1\n172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1\n```\n\n注意倒数第二行：`2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1`，这个是自动添加的。\n它的网关并不是`2.2.2.1`，即便在`interface`中强制器网关为`2.2.2.1`，也会被改为`0.0.0.0`。因为`2.2.2.0/24`是本LAN的数据包，经`ARP`协议获得目标的`MAC`地址后，会被直接发到目标地址，而不会经网关`2.2.2.1`转发，虽然路由表中默认网关是`0.0.0.0`，也不会按路由表转发到`10.0.0.147`。\n\n# 其它问题\n下面的问题是在除NAT网关外的其它机器上设置的。\n\n## 禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\n修改默认网关，添加路由之后，虽然可以从外部通过公网IP `ping`通机房内的机器，但`ssh`登录过程需要等待很长时间。\n参考[ssh连接的时候很慢，ping的速度非常好](http://blog.itpub.net/7345798/viewspace-1055461/)这篇文章，修改各机器上`sshd`的选项如下：\n```\nsed -i \"'s/.*UseDNS.*/UseDNS no/g'\" /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## 取消原来设置的http代理\n注释掉配置文件中`http_proxy`和`https_proxy`环境变量的声明，并执行\n```\nunset http_proxy\nunset https_proxy\n```\n\n# PS: 使用 SSH 隧道\n一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。\n以Windows客户端为例，安装了Windows版的`git`后，会附带一些`mingw`命令程序（不是完整的`mingw`），首先将这些命令的可执行文件所在路径添加到`Path`环境变量，比如是`E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin`，然后就可以在Windows命令行使用这些命令了。其中就有`ssh.exe`。\n在Windows命令行窗口执行\n```\nssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147\n```\n\n这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口`127.0.0.1:1088`。**如果需要停止SSH隧道，关闭该命令窗口即可**。\n因为我在Windows的`C:\\Windows\\System32\\drivers\\etc\\hosts`文件中添加了`n147`的项，所以可以直接输入名字而不必是IP地址。\n\n在IE或控制面板打开`Internet选项`，\n+ 在`连接`选项卡单击`局域网设置`按钮，\n+ 在弹出的对话框勾选`为LAN使用代理服务器`，然后单击`高级`，\n+ 在弹出的对话框取消勾选`对所有协议使用相同的代理服务器`，然后在`套接字`对应的文本框填入`127.0.0.1`和上面命令中监听的端口号`1088`，\n+ 在`例外`文本框中删掉`10.*0;`的内容，然后一路确定关闭所有对话框。\n这时应该可以用IE或Chrome访问机房内网的iDRAC。**如果需要正常访问网页，需要取消勾选`为LAN使用代理服务器`**。\n\n![](/img/sock5-proxy.png)\n","source":"_posts/setup-nat-x-route.md","raw":"title: CentOS 7 及 Ubuntu 16.04 设置 NAT 网络\ndate: 2017-04-15\ncategory: [misc]\ntags:\n\n---\n记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。\n<!--more-->\n\n<!-- TOC -->\n\n- [CentOS 7 设置和使用NAT](#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [NAT网关的设置](#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置`iptables`规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它 CentOS 7 机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n        - [切换默认网关](#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3)\n        - [为`em1`添加静态路由](#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1)\n- [Ubuntu 16.04 设置和使用NAT](#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat)\n    - [设置NAT](#%E8%AE%BE%E7%BD%AEnat)\n        - [允许IP转发](#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91)\n        - [设置iptables规则](#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99)\n    - [设置其它机器使用NAT网络](#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C)\n- [其它问题](#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98)\n    - [禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题](#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98)\n    - [取消原来设置的http代理](#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86)\n- [PS: 使用 SSH 隧道](#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93)\n\n<!-- /TOC -->\n\n小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。\n+ 一个LAN是学校的公网IP（下文记为`2.2.2.0/24`网段）。装好CentOS 7系统后，`em1`网卡在公网LAN，可以在校内直接访问`em1`的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。\n+ 另一个LAN是用于远程管理的机房内私网IP（下文记为`10.0.0.0/24`网段），`em2`网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是`10.0.0.1`。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。\n\n一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。\n\n# CentOS 7 设置和使用NAT\n虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个`147`的公网IP（记对应的机器是`n147`）直通校外网。\n之前是通过在`n147`上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将`n147`的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，`n147`就像一个软件实现的家用路由器。\n## NAT网关的设置\n作为网关的机器名是`n147`，公网IP是`2.2.2.147/24`，对应`em1`网卡；私网IP是`10.0.0.147/24`，对应`em2`网卡。\n\n### 允许IP转发\n其它机器从`10.0.0.0/24`网段发送的数据包会被`em2`网卡接收，如果目标IP是外网，需要交给`em1`网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：\n```\n# 查看是否启用IP转发，如果是0则没有开启，是1则已经开启\ncat /proc/sys/net/ipv4/ip_forward\n\n# 可以修改上述文件的值来改变设置，但重启后会恢复默认值。\n# 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf\n# 内容为\nnet.ipv4.ip_forward = 1\n```\n\n### 设置`iptables`规则\n安装必要软件并启用服务：\n```\nyum install -y net-tools iproute iptables iptables-services\nsystemctl disable firewalld\nsystemctl stop firewalld\nsystemctl enable iptables\n```\n\n>`net-tools`这个程序包有 `ifconfig`，`netstat`，`route`等命令，而`iproute2`（rpm包名为`iproute`）包括`tc`，`ip`，`ss`等命令，是`net-tools`的改进。\n\n通过`iptables`命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用`iptables-save`命令输出，然后保存起来。\n这里直接使用`iptables-save`生成的配置项，保存到配置文件 `/etc/sysconfig/iptables`，内容如下：\n```\n# Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017\n*nat\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n-A POSTROUTING -o em1 -j MASQUERADE  \nCOMMIT\n\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT\n-A FORWARD -i em2 -j ACCEPT\nCOMMIT\n```\n\n其中涉及NAT转发的是`-A POSTROUTING -o em1 -j MASQUERADE ` 和 `-A FORWARD -i em2 -j ACCEPT`。\n此外还删除了原来禁止`ping`的规则：\n`-A INPUT -j REJECT --reject-with icmp-host-prohibited`\n`\u000b-A FORWARD -j REJECT --reject-with icmp-host-prohibited`\n\n重启`iptables`服务`systemctl restart iptables`。\n\n>可以修改`/etc/sysconfig/iptables-config` 配置文件，设置下面三个选项均为`yes`来自动保存`iptables`规则\n+ `IPTABLES_MODULES_UNLOAD=\"yes\"`\n+ `IPTABLES_SAVE_ON_STOP=\"yes\"`\n+ `IPTABLES_SAVE_ON_RESTART=\"yes\"`\n\n>参考\n+ [保存iptable规则并开机自动加载](http://salogs.com/news/2015/08/20/iptables-save/)\n+ [iptables用法初解](http://blog.csdn.net/hepeng597/article/details/8270138)\n\n## 设置其它 CentOS 7 机器使用NAT网络\n### 切换默认网关\n安装系统后，默认网关是`em1`所在LAN的`2.2.2.1`，需要将其更改为`em2`所在LAN的`10.0.0.147`，修改如下的网卡配置文件：\n```\n# /etc/sysconfig/network-scripts/ifcfg-em1\nDEFROUTE=no\n\n# /etc/sysconfig/network-scripts/ifcfg-em2\nDEFROUTE=yes\n# ...\nGATEWAY=10.0.0.147\nDNS1=233.5.5.5\nDNS2=223.6.6.6\n```\n\n其中`em2`的网关即刚才配置的`n147`的私网IP，由于没有在`n147`上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置`dnsmasq`等DNS服务器。\n### 为`em1`添加静态路由\n修改默认网关后，查看路由表，\n```\n# route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2\n10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2\n2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n发现从`em1`收发的数据包也要经过默认网关`10.0.0.147`，而这个网关在机房的私网内，**外部不能直接访问，导致外部无法公网IP访问服务器**。为此，需要为`em1`添加静态路由，不走`10.0.0.147`，新建文件`/etc/sysconfig/network-scripts/route-em1`，内容如下：\n```\n2.2.0.0/16    via 2.2.2.1\n172.0.0.0/8   via 2.2.2.1\n```\n\n其中\n+ `2.2.0.0/16`网段是学校 **有线** 网络的IP网段\n+ `172.0.0.0/8`网段是学校 **无线** 网络的IP网段。\n>注意\n+ `docker0`网桥默认也是B类私网的`172.x.0.0/16`网段，但其路由项更具体，所以[不会造成冲突](http://answ.me/post/configure-docker-subnet/)。\n+ `docker0`网桥实际也工作在NAT模式，也需要开启IP转发。\n\n重启网络，更新配置，`systemctl restart network`。\n\n> 参考：[Two Default Gateways on One System](https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System)\n\n# Ubuntu 16.04 设置和使用NAT\n\nUbuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！\n因为用到的工具都是`net-tools`，`iproute`和`iptables`这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。\n## 设置NAT\n\n### 允许IP转发\n直接修改系统配置文件 `/etc/sysctl.conf`，里面已经有支持的配置项，取消`net.ipv4.ip_forward = 1`的注释即可。\n\n### 设置iptables规则\n还是使用的`iptables`，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是`em1`，`em2`，Ubuntu 16.04下是`eno1`，`eno2`，所以要把规则中对应的网卡名改过来。\n\n然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考[IptablesHowTo - Ubuntu wiki](https://help.ubuntu.com/community/IptablesHowTo)，，**随便把规则保存到哪，反正系统不会自动加载**，需要自己添加一个启动脚本。\n因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 `/etc/network/if-pre-up.d/iptablesload`，内容如下，\n```\n#!/bin/sh\niptables-restore < /etc/iptables.rules\nexit 0\n```\n\n可见`/etc/iptables.rules`是保存的`iptables`规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。**但是，你要自己来写这个脚本**。\n\n编辑好`/etc/iptables.rules` 和 `/etc/network/if-pre-up.d/iptablesload`之后，重启网络服务。\n\n虽然都是用`systemd`来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是`network.service`，而Ubuntu则是`networking.service`。\n执行命令`sudo systemctl restart networking`，重启网络服务。不过，其实我们是用`iptables`来实现的NAT，而不是`networking.service`相关服务，不过由于上面的那个脚本`iptablesload`会在网卡启动之前被执行，所以顺便完成了我们的目标。\n\n## 设置其它机器使用NAT网络\n\n同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在`/etc/network/interface`这个文件里，这个倒是方便了—— **[如果面对空空的配置文件，你能猜到各配置项是什么的时候](https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server)**。\n好在安装系统的时候设置了网卡，给`eno2`生成了一些配置项可以参考。修改后的内容如下。\n```\nauto lo\niface lo inet loopback\n\nauto eno1\niface eno1 inet static\n  address 2.2.2.140\n  netmask 255.255.255.0\n  network 2.2.2.0\n  broadcast 2.2.2.255\n  # gateway 2.2.2.1\n  up ip route add 2.2.0.0/16   via 2.2.2.1 || true\n  up ip route add 2.2.2.0/24   via 2.2.2.1 || true\n  up ip route add 172.0.0.0/8  via 2.2.2.1 || true\n\n# The primary network interface\nauto eno2\niface eno2 inet static\n  address 10.0.0.140\n  netmask 255.255.255.0\n  network 10.0.0.0\n  broadcast 10.0.0.255\n  gateway 10.0.0.147\n  # dns-* options are implemented by the resolvconf package, if installed\n  dns-nameservers 233.5.5.5\n```\n>注意\n+ 不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了`gateway`就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个`gateway`项。\n+ `up ip route add 2.2.0.0/16   via 2.2.2.1 || true`其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句`up echo helloworld`也没问题。后面的`|| true`是让脚本执行时忽略可能的错误，继续执行。这里使用的是`ip`命令，如果使用`route`命令，效果也是一样的，前提是已经安装了`net-tools`或`iproute`软件包。使用`netmask`和`CIDR`格式都可以。\n+ 哪个网卡的路由就写到对应的网卡下，这样执行`ifup eno1`这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。\n\n执行命令`sudo systemctl restart networking`，重启网络服务。\n查看一下更新后的路由表，\n```\n# route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2\n10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2\n2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1\n2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1\n172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1\n```\n\n注意倒数第二行：`2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1`，这个是自动添加的。\n它的网关并不是`2.2.2.1`，即便在`interface`中强制器网关为`2.2.2.1`，也会被改为`0.0.0.0`。因为`2.2.2.0/24`是本LAN的数据包，经`ARP`协议获得目标的`MAC`地址后，会被直接发到目标地址，而不会经网关`2.2.2.1`转发，虽然路由表中默认网关是`0.0.0.0`，也不会按路由表转发到`10.0.0.147`。\n\n# 其它问题\n下面的问题是在除NAT网关外的其它机器上设置的。\n\n## 禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\n修改默认网关，添加路由之后，虽然可以从外部通过公网IP `ping`通机房内的机器，但`ssh`登录过程需要等待很长时间。\n参考[ssh连接的时候很慢，ping的速度非常好](http://blog.itpub.net/7345798/viewspace-1055461/)这篇文章，修改各机器上`sshd`的选项如下：\n```\nsed -i \"'s/.*UseDNS.*/UseDNS no/g'\" /etc/ssh/sshd_config\nsystemctl restart sshd\n```\n\n## 取消原来设置的http代理\n注释掉配置文件中`http_proxy`和`https_proxy`环境变量的声明，并执行\n```\nunset http_proxy\nunset https_proxy\n```\n\n# PS: 使用 SSH 隧道\n一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。\n以Windows客户端为例，安装了Windows版的`git`后，会附带一些`mingw`命令程序（不是完整的`mingw`），首先将这些命令的可执行文件所在路径添加到`Path`环境变量，比如是`E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin`，然后就可以在Windows命令行使用这些命令了。其中就有`ssh.exe`。\n在Windows命令行窗口执行\n```\nssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147\n```\n\n这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口`127.0.0.1:1088`。**如果需要停止SSH隧道，关闭该命令窗口即可**。\n因为我在Windows的`C:\\Windows\\System32\\drivers\\etc\\hosts`文件中添加了`n147`的项，所以可以直接输入名字而不必是IP地址。\n\n在IE或控制面板打开`Internet选项`，\n+ 在`连接`选项卡单击`局域网设置`按钮，\n+ 在弹出的对话框勾选`为LAN使用代理服务器`，然后单击`高级`，\n+ 在弹出的对话框取消勾选`对所有协议使用相同的代理服务器`，然后在`套接字`对应的文本框填入`127.0.0.1`和上面命令中监听的端口号`1088`，\n+ 在`例外`文本框中删掉`10.*0;`的内容，然后一路确定关闭所有对话框。\n这时应该可以用IE或Chrome访问机房内网的iDRAC。**如果需要正常访问网页，需要取消勾选`为LAN使用代理服务器`**。\n\n![](/img/sock5-proxy.png)\n","slug":"setup-nat-x-route","published":1,"updated":"2017-10-30T03:42:06.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh1000i9s4fw6qu90a8","content":"<p>记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">CentOS 7 设置和使用NAT</a><ul>\n<li><a href=\"#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE\">NAT网关的设置</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置<code>iptables</code>规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它 CentOS 7 机器使用NAT网络</a><ul>\n<li><a href=\"#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3\">切换默认网关</a></li>\n<li><a href=\"#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1\">为<code>em1</code>添加静态路由</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">Ubuntu 16.04 设置和使用NAT</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEnat\">设置NAT</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置iptables规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它机器使用NAT网络</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98\">其它问题</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98\">禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</a></li>\n<li><a href=\"#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86\">取消原来设置的http代理</a></li>\n</ul>\n</li>\n<li><a href=\"#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93\">PS: 使用 SSH 隧道</a></li>\n</ul>\n<!-- /TOC -->\n<p>小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。</p>\n<ul>\n<li>一个LAN是学校的公网IP（下文记为<code>2.2.2.0/24</code>网段）。装好CentOS 7系统后，<code>em1</code>网卡在公网LAN，可以在校内直接访问<code>em1</code>的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。</li>\n<li>另一个LAN是用于远程管理的机房内私网IP（下文记为<code>10.0.0.0/24</code>网段），<code>em2</code>网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是<code>10.0.0.1</code>。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。</li>\n</ul>\n<p>一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。</p>\n<h1 id=\"CentOS-7-设置和使用NAT\"><a href=\"#CentOS-7-设置和使用NAT\" class=\"headerlink\" title=\"CentOS 7 设置和使用NAT\"></a>CentOS 7 设置和使用NAT</h1><p>虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个<code>147</code>的公网IP（记对应的机器是<code>n147</code>）直通校外网。<br>之前是通过在<code>n147</code>上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将<code>n147</code>的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，<code>n147</code>就像一个软件实现的家用路由器。</p>\n<h2 id=\"NAT网关的设置\"><a href=\"#NAT网关的设置\" class=\"headerlink\" title=\"NAT网关的设置\"></a>NAT网关的设置</h2><p>作为网关的机器名是<code>n147</code>，公网IP是<code>2.2.2.147/24</code>，对应<code>em1</code>网卡；私网IP是<code>10.0.0.147/24</code>，对应<code>em2</code>网卡。</p>\n<h3 id=\"允许IP转发\"><a href=\"#允许IP转发\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>其它机器从<code>10.0.0.0/24</code>网段发送的数据包会被<code>em2</code>网卡接收，如果目标IP是外网，需要交给<code>em1</code>网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 查看是否启用IP转发，如果是0则没有开启，是1则已经开启</div><div class=\"line\">cat /proc/sys/net/ipv4/ip_forward</div><div class=\"line\"></div><div class=\"line\"># 可以修改上述文件的值来改变设置，但重启后会恢复默认值。</div><div class=\"line\"># 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf</div><div class=\"line\"># 内容为</div><div class=\"line\">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"设置iptables规则\"><a href=\"#设置iptables规则\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置<code>iptables</code>规则</h3><p>安装必要软件并启用服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y net-tools iproute iptables iptables-services</div><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div><div class=\"line\">systemctl enable iptables</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>net-tools</code>这个程序包有 <code>ifconfig</code>，<code>netstat</code>，<code>route</code>等命令，而<code>iproute2</code>（rpm包名为<code>iproute</code>）包括<code>tc</code>，<code>ip</code>，<code>ss</code>等命令，是<code>net-tools</code>的改进。</p>\n</blockquote>\n<p>通过<code>iptables</code>命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用<code>iptables-save</code>命令输出，然后保存起来。<br>这里直接使用<code>iptables-save</code>生成的配置项，保存到配置文件 <code>/etc/sysconfig/iptables</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017</div><div class=\"line\">*nat</div><div class=\"line\">:PREROUTING ACCEPT [0:0]</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">:POSTROUTING ACCEPT [0:0]</div><div class=\"line\">-A POSTROUTING -o em1 -j MASQUERADE  </div><div class=\"line\">COMMIT</div><div class=\"line\"></div><div class=\"line\">*filter</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:FORWARD ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class=\"line\">-A INPUT -p icmp -j ACCEPT</div><div class=\"line\">-A INPUT -i lo -j ACCEPT</div><div class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class=\"line\">-A FORWARD -i em2 -j ACCEPT</div><div class=\"line\">COMMIT</div></pre></td></tr></table></figure></p>\n<p>其中涉及NAT转发的是<code>-A POSTROUTING -o em1 -j MASQUERADE</code> 和 <code>-A FORWARD -i em2 -j ACCEPT</code>。<br>此外还删除了原来禁止<code>ping</code>的规则：<br><code>-A INPUT -j REJECT --reject-with icmp-host-prohibited</code><br><code>-A FORWARD -j REJECT --reject-with icmp-host-prohibited</code></p>\n<p>重启<code>iptables</code>服务<code>systemctl restart iptables</code>。</p>\n<blockquote>\n<p>可以修改<code>/etc/sysconfig/iptables-config</code> 配置文件，设置下面三个选项均为<code>yes</code>来自动保存<code>iptables</code>规则</p>\n<ul>\n<li><code>IPTABLES_MODULES_UNLOAD=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_STOP=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_RESTART=&quot;yes&quot;</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li><a href=\"http://salogs.com/news/2015/08/20/iptables-save/\" target=\"_blank\" rel=\"external\">保存iptable规则并开机自动加载</a></li>\n<li><a href=\"http://blog.csdn.net/hepeng597/article/details/8270138\" target=\"_blank\" rel=\"external\">iptables用法初解</a></li>\n</ul>\n</blockquote>\n<h2 id=\"设置其它-CentOS-7-机器使用NAT网络\"><a href=\"#设置其它-CentOS-7-机器使用NAT网络\" class=\"headerlink\" title=\"设置其它 CentOS 7 机器使用NAT网络\"></a>设置其它 CentOS 7 机器使用NAT网络</h2><h3 id=\"切换默认网关\"><a href=\"#切换默认网关\" class=\"headerlink\" title=\"切换默认网关\"></a>切换默认网关</h3><p>安装系统后，默认网关是<code>em1</code>所在LAN的<code>2.2.2.1</code>，需要将其更改为<code>em2</code>所在LAN的<code>10.0.0.147</code>，修改如下的网卡配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em1</div><div class=\"line\">DEFROUTE=no</div><div class=\"line\"></div><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em2</div><div class=\"line\">DEFROUTE=yes</div><div class=\"line\"># ...</div><div class=\"line\">GATEWAY=10.0.0.147</div><div class=\"line\">DNS1=233.5.5.5</div><div class=\"line\">DNS2=223.6.6.6</div></pre></td></tr></table></figure></p>\n<p>其中<code>em2</code>的网关即刚才配置的<code>n147</code>的私网IP，由于没有在<code>n147</code>上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置<code>dnsmasq</code>等DNS服务器。</p>\n<h3 id=\"为em1添加静态路由\"><a href=\"#为em1添加静态路由\" class=\"headerlink\" title=\"为em1添加静态路由\"></a>为<code>em1</code>添加静态路由</h3><p>修改默认网关后，查看路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1</div><div class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div></pre></td></tr></table></figure></p>\n<p>发现从<code>em1</code>收发的数据包也要经过默认网关<code>10.0.0.147</code>，而这个网关在机房的私网内，<strong>外部不能直接访问，导致外部无法公网IP访问服务器</strong>。为此，需要为<code>em1</code>添加静态路由，不走<code>10.0.0.147</code>，新建文件<code>/etc/sysconfig/network-scripts/route-em1</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2.2.0.0/16    via 2.2.2.1</div><div class=\"line\">172.0.0.0/8   via 2.2.2.1</div></pre></td></tr></table></figure></p>\n<p>其中</p>\n<ul>\n<li><code>2.2.0.0/16</code>网段是学校 <strong>有线</strong> 网络的IP网段</li>\n<li><code>172.0.0.0/8</code>网段是学校 <strong>无线</strong> 网络的IP网段。<blockquote>\n<p>注意</p>\n</blockquote>\n</li>\n<li><code>docker0</code>网桥默认也是B类私网的<code>172.x.0.0/16</code>网段，但其路由项更具体，所以<a href=\"http://answ.me/post/configure-docker-subnet/\" target=\"_blank\" rel=\"external\">不会造成冲突</a>。</li>\n<li><code>docker0</code>网桥实际也工作在NAT模式，也需要开启IP转发。</li>\n</ul>\n<p>重启网络，更新配置，<code>systemctl restart network</code>。</p>\n<blockquote>\n<p>参考：<a href=\"https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System\" target=\"_blank\" rel=\"external\">Two Default Gateways on One System</a></p>\n</blockquote>\n<h1 id=\"Ubuntu-16-04-设置和使用NAT\"><a href=\"#Ubuntu-16-04-设置和使用NAT\" class=\"headerlink\" title=\"Ubuntu 16.04 设置和使用NAT\"></a>Ubuntu 16.04 设置和使用NAT</h1><p>Ubuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！<br>因为用到的工具都是<code>net-tools</code>，<code>iproute</code>和<code>iptables</code>这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。</p>\n<h2 id=\"设置NAT\"><a href=\"#设置NAT\" class=\"headerlink\" title=\"设置NAT\"></a>设置NAT</h2><h3 id=\"允许IP转发-1\"><a href=\"#允许IP转发-1\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>直接修改系统配置文件 <code>/etc/sysctl.conf</code>，里面已经有支持的配置项，取消<code>net.ipv4.ip_forward = 1</code>的注释即可。</p>\n<h3 id=\"设置iptables规则-1\"><a href=\"#设置iptables规则-1\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置iptables规则</h3><p>还是使用的<code>iptables</code>，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是<code>em1</code>，<code>em2</code>，Ubuntu 16.04下是<code>eno1</code>，<code>eno2</code>，所以要把规则中对应的网卡名改过来。</p>\n<p>然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考<a href=\"https://help.ubuntu.com/community/IptablesHowTo\" target=\"_blank\" rel=\"external\">IptablesHowTo - Ubuntu wiki</a>，，<strong>随便把规则保存到哪，反正系统不会自动加载</strong>，需要自己添加一个启动脚本。<br>因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 <code>/etc/network/if-pre-up.d/iptablesload</code>，内容如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">iptables-restore &lt; /etc/iptables.rules</div><div class=\"line\">exit 0</div></pre></td></tr></table></figure></p>\n<p>可见<code>/etc/iptables.rules</code>是保存的<code>iptables</code>规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。<strong>但是，你要自己来写这个脚本</strong>。</p>\n<p>编辑好<code>/etc/iptables.rules</code> 和 <code>/etc/network/if-pre-up.d/iptablesload</code>之后，重启网络服务。</p>\n<p>虽然都是用<code>systemd</code>来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是<code>network.service</code>，而Ubuntu则是<code>networking.service</code>。<br>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。不过，其实我们是用<code>iptables</code>来实现的NAT，而不是<code>networking.service</code>相关服务，不过由于上面的那个脚本<code>iptablesload</code>会在网卡启动之前被执行，所以顺便完成了我们的目标。</p>\n<h2 id=\"设置其它机器使用NAT网络\"><a href=\"#设置其它机器使用NAT网络\" class=\"headerlink\" title=\"设置其它机器使用NAT网络\"></a>设置其它机器使用NAT网络</h2><p>同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在<code>/etc/network/interface</code>这个文件里，这个倒是方便了—— <strong><a href=\"https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server\" target=\"_blank\" rel=\"external\">如果面对空空的配置文件，你能猜到各配置项是什么的时候</a></strong>。<br>好在安装系统的时候设置了网卡，给<code>eno2</code>生成了一些配置项可以参考。修改后的内容如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto lo</div><div class=\"line\">iface lo inet loopback</div><div class=\"line\"></div><div class=\"line\">auto eno1</div><div class=\"line\">iface eno1 inet static</div><div class=\"line\">  address 2.2.2.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 2.2.2.0</div><div class=\"line\">  broadcast 2.2.2.255</div><div class=\"line\">  # gateway 2.2.2.1</div><div class=\"line\">  up ip route add 2.2.0.0/16   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 2.2.2.0/24   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 172.0.0.0/8  via 2.2.2.1 || true</div><div class=\"line\"></div><div class=\"line\"># The primary network interface</div><div class=\"line\">auto eno2</div><div class=\"line\">iface eno2 inet static</div><div class=\"line\">  address 10.0.0.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 10.0.0.0</div><div class=\"line\">  broadcast 10.0.0.255</div><div class=\"line\">  gateway 10.0.0.147</div><div class=\"line\">  # dns-* options are implemented by the resolvconf package, if installed</div><div class=\"line\">  dns-nameservers 233.5.5.5</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了<code>gateway</code>就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个<code>gateway</code>项。</li>\n<li><code>up ip route add 2.2.0.0/16   via 2.2.2.1 || true</code>其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句<code>up echo helloworld</code>也没问题。后面的<code>|| true</code>是让脚本执行时忽略可能的错误，继续执行。这里使用的是<code>ip</code>命令，如果使用<code>route</code>命令，效果也是一样的，前提是已经安装了<code>net-tools</code>或<code>iproute</code>软件包。使用<code>netmask</code>和<code>CIDR</code>格式都可以。</li>\n<li>哪个网卡的路由就写到对应的网卡下，这样执行<code>ifup eno1</code>这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。</li>\n</ul>\n</blockquote>\n<p>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。<br>查看一下更新后的路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Kernel IP routing table</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2</div><div class=\"line\">2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1</div><div class=\"line\">172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1</div></pre></td></tr></table></figure></p>\n<p>注意倒数第二行：<code>2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1</code>，这个是自动添加的。<br>它的网关并不是<code>2.2.2.1</code>，即便在<code>interface</code>中强制器网关为<code>2.2.2.1</code>，也会被改为<code>0.0.0.0</code>。因为<code>2.2.2.0/24</code>是本LAN的数据包，经<code>ARP</code>协议获得目标的<code>MAC</code>地址后，会被直接发到目标地址，而不会经网关<code>2.2.2.1</code>转发，虽然路由表中默认网关是<code>0.0.0.0</code>，也不会按路由表转发到<code>10.0.0.147</code>。</p>\n<h1 id=\"其它问题\"><a href=\"#其它问题\" class=\"headerlink\" title=\"其它问题\"></a>其它问题</h1><p>下面的问题是在除NAT网关外的其它机器上设置的。</p>\n<h2 id=\"禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\"><a href=\"#禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\" class=\"headerlink\" title=\"禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\"></a>禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</h2><p>修改默认网关，添加路由之后，虽然可以从外部通过公网IP <code>ping</code>通机房内的机器，但<code>ssh</code>登录过程需要等待很长时间。<br>参考<a href=\"http://blog.itpub.net/7345798/viewspace-1055461/\" target=\"_blank\" rel=\"external\">ssh连接的时候很慢，ping的速度非常好</a>这篇文章，修改各机器上<code>sshd</code>的选项如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &quot;&apos;s/.*UseDNS.*/UseDNS no/g&apos;&quot; /etc/ssh/sshd_config</div><div class=\"line\">systemctl restart sshd</div></pre></td></tr></table></figure></p>\n<h2 id=\"取消原来设置的http代理\"><a href=\"#取消原来设置的http代理\" class=\"headerlink\" title=\"取消原来设置的http代理\"></a>取消原来设置的http代理</h2><p>注释掉配置文件中<code>http_proxy</code>和<code>https_proxy</code>环境变量的声明，并执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unset http_proxy</div><div class=\"line\">unset https_proxy</div></pre></td></tr></table></figure></p>\n<h1 id=\"PS-使用-SSH-隧道\"><a href=\"#PS-使用-SSH-隧道\" class=\"headerlink\" title=\"PS: 使用 SSH 隧道\"></a>PS: 使用 SSH 隧道</h1><p>一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。<br>以Windows客户端为例，安装了Windows版的<code>git</code>后，会附带一些<code>mingw</code>命令程序（不是完整的<code>mingw</code>），首先将这些命令的可执行文件所在路径添加到<code>Path</code>环境变量，比如是<code>E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin</code>，然后就可以在Windows命令行使用这些命令了。其中就有<code>ssh.exe</code>。<br>在Windows命令行窗口执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147</div></pre></td></tr></table></figure></p>\n<p>这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口<code>127.0.0.1:1088</code>。<strong>如果需要停止SSH隧道，关闭该命令窗口即可</strong>。<br>因为我在Windows的<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>文件中添加了<code>n147</code>的项，所以可以直接输入名字而不必是IP地址。</p>\n<p>在IE或控制面板打开<code>Internet选项</code>，</p>\n<ul>\n<li>在<code>连接</code>选项卡单击<code>局域网设置</code>按钮，</li>\n<li>在弹出的对话框勾选<code>为LAN使用代理服务器</code>，然后单击<code>高级</code>，</li>\n<li>在弹出的对话框取消勾选<code>对所有协议使用相同的代理服务器</code>，然后在<code>套接字</code>对应的文本框填入<code>127.0.0.1</code>和上面命令中监听的端口号<code>1088</code>，</li>\n<li>在<code>例外</code>文本框中删掉<code>10.*0;</code>的内容，然后一路确定关闭所有对话框。<br>这时应该可以用IE或Chrome访问机房内网的iDRAC。<strong>如果需要正常访问网页，需要取消勾选<code>为LAN使用代理服务器</code></strong>。</li>\n</ul>\n<p><img src=\"/img/sock5-proxy.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>记录一下设置一台双网卡的CentOS服务器提供 NAT 转发，作为内网网关，其它服务器的默认网关更改为此节点，添加路由，以及处理外部ssh登录变慢的问题。<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#centos-7-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">CentOS 7 设置和使用NAT</a><ul>\n<li><a href=\"#nat%E7%BD%91%E5%85%B3%E7%9A%84%E8%AE%BE%E7%BD%AE\">NAT网关的设置</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置<code>iptables</code>规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83-centos-7-%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它 CentOS 7 机器使用NAT网络</a><ul>\n<li><a href=\"#%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4%E7%BD%91%E5%85%B3\">切换默认网关</a></li>\n<li><a href=\"#%E4%B8%BAem1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1\">为<code>em1</code>添加静态路由</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#ubuntu-1604-%E8%AE%BE%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8nat\">Ubuntu 16.04 设置和使用NAT</a><ul>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEnat\">设置NAT</a><ul>\n<li><a href=\"#%E5%85%81%E8%AE%B8ip%E8%BD%AC%E5%8F%91\">允许IP转发</a></li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AEiptables%E8%A7%84%E5%88%99\">设置iptables规则</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%B6%E5%AE%83%E6%9C%BA%E5%99%A8%E4%BD%BF%E7%94%A8nat%E7%BD%91%E7%BB%9C\">设置其它机器使用NAT网络</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98\">其它问题</a><ul>\n<li><a href=\"#%E7%A6%81%E7%94%A8%E5%90%84%E6%9C%BA%E5%99%A8%E7%9A%84sshd-dns%E9%80%89%E9%A1%B9%EF%BC%8C%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95%E5%BE%88%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98\">禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</a></li>\n<li><a href=\"#%E5%8F%96%E6%B6%88%E5%8E%9F%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%9A%84http%E4%BB%A3%E7%90%86\">取消原来设置的http代理</a></li>\n</ul>\n</li>\n<li><a href=\"#ps-%E4%BD%BF%E7%94%A8-ssh-%E9%9A%A7%E9%81%93\">PS: 使用 SSH 隧道</a></li>\n</ul>\n<!-- /TOC -->\n<p>小组有一个Dell的刀片服务器机柜，每台机器都是双网卡，分别连到了2个LAN。</p>\n<ul>\n<li>一个LAN是学校的公网IP（下文记为<code>2.2.2.0/24</code>网段）。装好CentOS 7系统后，<code>em1</code>网卡在公网LAN，可以在校内直接访问<code>em1</code>的IP，但由于学校网络管理限制，校外无法访问。所以说这个公网IP跟私网IP差不了多少。</li>\n<li>另一个LAN是用于远程管理的机房内私网IP（下文记为<code>10.0.0.0/24</code>网段），<code>em2</code>网卡在这个私网LAN。服务器的iDRAC也在这个私网里。这个私网的网关是某个机器上的VPN服务提供的，IP是<code>10.0.0.1</code>。登录到这个VPN之后，就可以远程访问iDRAC，也可以通过私网IP ssh登录到机器。</li>\n</ul>\n<p>一直是远程管理，只去过一次机房，还不清楚服务器的具体组网拓扑。按理也可以修改一些设置，通过VPN的网关访问外网，不过没有VPN这台机器的管理权限，只好另外找机器设置NAT。</p>\n<h1 id=\"CentOS-7-设置和使用NAT\"><a href=\"#CentOS-7-设置和使用NAT\" class=\"headerlink\" title=\"CentOS 7 设置和使用NAT\"></a>CentOS 7 设置和使用NAT</h1><p>虽然学校的网络管理限制了刀片集群的LAN使用公网IP连不了校外网络，而且不能登录个人的外网帐号，好在可以填表申请一个<code>147</code>的公网IP（记对应的机器是<code>n147</code>）直通校外网。<br>之前是通过在<code>n147</code>上提供Squid HTTP代理服务的方式使其它机器能够访问外网，但代理用起来实在是不方便，所以改成NAT方式，这样其它机器将<code>n147</code>的私网IP作为网关，使用私网IP就可以访问外网了。在NAT模式下，<code>n147</code>就像一个软件实现的家用路由器。</p>\n<h2 id=\"NAT网关的设置\"><a href=\"#NAT网关的设置\" class=\"headerlink\" title=\"NAT网关的设置\"></a>NAT网关的设置</h2><p>作为网关的机器名是<code>n147</code>，公网IP是<code>2.2.2.147/24</code>，对应<code>em1</code>网卡；私网IP是<code>10.0.0.147/24</code>，对应<code>em2</code>网卡。</p>\n<h3 id=\"允许IP转发\"><a href=\"#允许IP转发\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>其它机器从<code>10.0.0.0/24</code>网段发送的数据包会被<code>em2</code>网卡接收，如果目标IP是外网，需要交给<code>em1</code>网卡发送出去。需要开启IP转发选项，才能允许不同网卡间转发数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 查看是否启用IP转发，如果是0则没有开启，是1则已经开启</div><div class=\"line\">cat /proc/sys/net/ipv4/ip_forward</div><div class=\"line\"></div><div class=\"line\"># 可以修改上述文件的值来改变设置，但重启后会恢复默认值。</div><div class=\"line\"># 需要将设置写入系统配置文件 /etc/sysctl.conf 或 /etc/sysctl.d/ip_forward.conf</div><div class=\"line\"># 内容为</div><div class=\"line\">net.ipv4.ip_forward = 1</div></pre></td></tr></table></figure></p>\n<h3 id=\"设置iptables规则\"><a href=\"#设置iptables规则\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置<code>iptables</code>规则</h3><p>安装必要软件并启用服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y net-tools iproute iptables iptables-services</div><div class=\"line\">systemctl disable firewalld</div><div class=\"line\">systemctl stop firewalld</div><div class=\"line\">systemctl enable iptables</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>net-tools</code>这个程序包有 <code>ifconfig</code>，<code>netstat</code>，<code>route</code>等命令，而<code>iproute2</code>（rpm包名为<code>iproute</code>）包括<code>tc</code>，<code>ip</code>，<code>ss</code>等命令，是<code>net-tools</code>的改进。</p>\n</blockquote>\n<p>通过<code>iptables</code>命令行可以添加NAT规则，但重启后也是会恢复默认值，应当将修改后的规则设置用<code>iptables-save</code>命令输出，然后保存起来。<br>这里直接使用<code>iptables-save</code>生成的配置项，保存到配置文件 <code>/etc/sysconfig/iptables</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Generated by iptables-save v1.4.21 on Thu Apr 20 22:14:39 2017</div><div class=\"line\">*nat</div><div class=\"line\">:PREROUTING ACCEPT [0:0]</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">:POSTROUTING ACCEPT [0:0]</div><div class=\"line\">-A POSTROUTING -o em1 -j MASQUERADE  </div><div class=\"line\">COMMIT</div><div class=\"line\"></div><div class=\"line\">*filter</div><div class=\"line\">:INPUT ACCEPT [0:0]</div><div class=\"line\">:FORWARD ACCEPT [0:0]</div><div class=\"line\">:OUTPUT ACCEPT [0:0]</div><div class=\"line\">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class=\"line\">-A INPUT -p icmp -j ACCEPT</div><div class=\"line\">-A INPUT -i lo -j ACCEPT</div><div class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class=\"line\">-A FORWARD -i em2 -j ACCEPT</div><div class=\"line\">COMMIT</div></pre></td></tr></table></figure></p>\n<p>其中涉及NAT转发的是<code>-A POSTROUTING -o em1 -j MASQUERADE</code> 和 <code>-A FORWARD -i em2 -j ACCEPT</code>。<br>此外还删除了原来禁止<code>ping</code>的规则：<br><code>-A INPUT -j REJECT --reject-with icmp-host-prohibited</code><br><code>-A FORWARD -j REJECT --reject-with icmp-host-prohibited</code></p>\n<p>重启<code>iptables</code>服务<code>systemctl restart iptables</code>。</p>\n<blockquote>\n<p>可以修改<code>/etc/sysconfig/iptables-config</code> 配置文件，设置下面三个选项均为<code>yes</code>来自动保存<code>iptables</code>规则</p>\n<ul>\n<li><code>IPTABLES_MODULES_UNLOAD=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_STOP=&quot;yes&quot;</code></li>\n<li><code>IPTABLES_SAVE_ON_RESTART=&quot;yes&quot;</code></li>\n</ul>\n<p>参考</p>\n<ul>\n<li><a href=\"http://salogs.com/news/2015/08/20/iptables-save/\" target=\"_blank\" rel=\"external\">保存iptable规则并开机自动加载</a></li>\n<li><a href=\"http://blog.csdn.net/hepeng597/article/details/8270138\" target=\"_blank\" rel=\"external\">iptables用法初解</a></li>\n</ul>\n</blockquote>\n<h2 id=\"设置其它-CentOS-7-机器使用NAT网络\"><a href=\"#设置其它-CentOS-7-机器使用NAT网络\" class=\"headerlink\" title=\"设置其它 CentOS 7 机器使用NAT网络\"></a>设置其它 CentOS 7 机器使用NAT网络</h2><h3 id=\"切换默认网关\"><a href=\"#切换默认网关\" class=\"headerlink\" title=\"切换默认网关\"></a>切换默认网关</h3><p>安装系统后，默认网关是<code>em1</code>所在LAN的<code>2.2.2.1</code>，需要将其更改为<code>em2</code>所在LAN的<code>10.0.0.147</code>，修改如下的网卡配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em1</div><div class=\"line\">DEFROUTE=no</div><div class=\"line\"></div><div class=\"line\"># /etc/sysconfig/network-scripts/ifcfg-em2</div><div class=\"line\">DEFROUTE=yes</div><div class=\"line\"># ...</div><div class=\"line\">GATEWAY=10.0.0.147</div><div class=\"line\">DNS1=233.5.5.5</div><div class=\"line\">DNS2=223.6.6.6</div></pre></td></tr></table></figure></p>\n<p>其中<code>em2</code>的网关即刚才配置的<code>n147</code>的私网IP，由于没有在<code>n147</code>上运行DNS服务，这里使用的是阿里的DNS。也可以安装配置<code>dnsmasq</code>等DNS服务器。</p>\n<h3 id=\"为em1添加静态路由\"><a href=\"#为em1添加静态路由\" class=\"headerlink\" title=\"为em1添加静态路由\"></a>为<code>em1</code>添加静态路由</h3><p>修改默认网关后，查看路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    100    0        0 em2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.0.0     U     100    0        0 em2</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     100    0        0 em1</div><div class=\"line\">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div></pre></td></tr></table></figure></p>\n<p>发现从<code>em1</code>收发的数据包也要经过默认网关<code>10.0.0.147</code>，而这个网关在机房的私网内，<strong>外部不能直接访问，导致外部无法公网IP访问服务器</strong>。为此，需要为<code>em1</code>添加静态路由，不走<code>10.0.0.147</code>，新建文件<code>/etc/sysconfig/network-scripts/route-em1</code>，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2.2.0.0/16    via 2.2.2.1</div><div class=\"line\">172.0.0.0/8   via 2.2.2.1</div></pre></td></tr></table></figure></p>\n<p>其中</p>\n<ul>\n<li><code>2.2.0.0/16</code>网段是学校 <strong>有线</strong> 网络的IP网段</li>\n<li><code>172.0.0.0/8</code>网段是学校 <strong>无线</strong> 网络的IP网段。<blockquote>\n<p>注意</p>\n</blockquote>\n</li>\n<li><code>docker0</code>网桥默认也是B类私网的<code>172.x.0.0/16</code>网段，但其路由项更具体，所以<a href=\"http://answ.me/post/configure-docker-subnet/\" target=\"_blank\" rel=\"external\">不会造成冲突</a>。</li>\n<li><code>docker0</code>网桥实际也工作在NAT模式，也需要开启IP转发。</li>\n</ul>\n<p>重启网络，更新配置，<code>systemctl restart network</code>。</p>\n<blockquote>\n<p>参考：<a href=\"https://www.thomas-krenn.com/en/wiki/Two_Default_Gateways_on_One_System\" target=\"_blank\" rel=\"external\">Two Default Gateways on One System</a></p>\n</blockquote>\n<h1 id=\"Ubuntu-16-04-设置和使用NAT\"><a href=\"#Ubuntu-16-04-设置和使用NAT\" class=\"headerlink\" title=\"Ubuntu 16.04 设置和使用NAT\"></a>Ubuntu 16.04 设置和使用NAT</h1><p>Ubuntu 16.04 参考上面 CentOS 7 设置和使用NAT的步骤即可————怎么可能！<br>因为用到的工具都是<code>net-tools</code>，<code>iproute</code>和<code>iptables</code>这3个包里的，配置文件的内容是一样的，但配置文件的路径和启动方式就不一样了。</p>\n<h2 id=\"设置NAT\"><a href=\"#设置NAT\" class=\"headerlink\" title=\"设置NAT\"></a>设置NAT</h2><h3 id=\"允许IP转发-1\"><a href=\"#允许IP转发-1\" class=\"headerlink\" title=\"允许IP转发\"></a>允许IP转发</h3><p>直接修改系统配置文件 <code>/etc/sysctl.conf</code>，里面已经有支持的配置项，取消<code>net.ipv4.ip_forward = 1</code>的注释即可。</p>\n<h3 id=\"设置iptables规则-1\"><a href=\"#设置iptables规则-1\" class=\"headerlink\" title=\"设置iptables规则\"></a>设置iptables规则</h3><p>还是使用的<code>iptables</code>，为了使修改后的规则能够保存，规则跟上面CentOS的基本一样。为什么说是基本呢？网卡的默认名字改了： CentOS 7下是<code>em1</code>，<code>em2</code>，Ubuntu 16.04下是<code>eno1</code>，<code>eno2</code>，所以要把规则中对应的网卡名改过来。</p>\n<p>然后要找到Ubuntu 16.04下系统会自动读取的iptables规则文件路径，参考<a href=\"https://help.ubuntu.com/community/IptablesHowTo\" target=\"_blank\" rel=\"external\">IptablesHowTo - Ubuntu wiki</a>，，<strong>随便把规则保存到哪，反正系统不会自动加载</strong>，需要自己添加一个启动脚本。<br>因为机器是多网卡，启动脚本不好关联某个网卡，所以放在与网卡启动关联的脚本目录里，脚本文件是 <code>/etc/network/if-pre-up.d/iptablesload</code>，内容如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">iptables-restore &lt; /etc/iptables.rules</div><div class=\"line\">exit 0</div></pre></td></tr></table></figure></p>\n<p>可见<code>/etc/iptables.rules</code>是保存的<code>iptables</code>规则，这个位置是任意的，只要跟启动脚本中保持一致就行了。启动脚本的名字也是任意的，只要放在那个路径下就可以了。<strong>但是，你要自己来写这个脚本</strong>。</p>\n<p>编辑好<code>/etc/iptables.rules</code> 和 <code>/etc/network/if-pre-up.d/iptablesload</code>之后，重启网络服务。</p>\n<p>虽然都是用<code>systemd</code>来管理系统服务，但服务的名字又不一样了，CentOS的网络服务名称是<code>network.service</code>，而Ubuntu则是<code>networking.service</code>。<br>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。不过，其实我们是用<code>iptables</code>来实现的NAT，而不是<code>networking.service</code>相关服务，不过由于上面的那个脚本<code>iptablesload</code>会在网卡启动之前被执行，所以顺便完成了我们的目标。</p>\n<h2 id=\"设置其它机器使用NAT网络\"><a href=\"#设置其它机器使用NAT网络\" class=\"headerlink\" title=\"设置其它机器使用NAT网络\"></a>设置其它机器使用NAT网络</h2><p>同样，在其它Ubuntu机器上也要切换默认网关，为eno1添加静态路由。情况又不一样了，Ubuntu的所有网卡配置和静态路由都保存在<code>/etc/network/interface</code>这个文件里，这个倒是方便了—— <strong><a href=\"https://askubuntu.com/questions/168033/how-to-set-static-routes-in-ubuntu-server\" target=\"_blank\" rel=\"external\">如果面对空空的配置文件，你能猜到各配置项是什么的时候</a></strong>。<br>好在安装系统的时候设置了网卡，给<code>eno2</code>生成了一些配置项可以参考。修改后的内容如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto lo</div><div class=\"line\">iface lo inet loopback</div><div class=\"line\"></div><div class=\"line\">auto eno1</div><div class=\"line\">iface eno1 inet static</div><div class=\"line\">  address 2.2.2.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 2.2.2.0</div><div class=\"line\">  broadcast 2.2.2.255</div><div class=\"line\">  # gateway 2.2.2.1</div><div class=\"line\">  up ip route add 2.2.0.0/16   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 2.2.2.0/24   via 2.2.2.1 || true</div><div class=\"line\">  up ip route add 172.0.0.0/8  via 2.2.2.1 || true</div><div class=\"line\"></div><div class=\"line\"># The primary network interface</div><div class=\"line\">auto eno2</div><div class=\"line\">iface eno2 inet static</div><div class=\"line\">  address 10.0.0.140</div><div class=\"line\">  netmask 255.255.255.0</div><div class=\"line\">  network 10.0.0.0</div><div class=\"line\">  broadcast 10.0.0.255</div><div class=\"line\">  gateway 10.0.0.147</div><div class=\"line\">  # dns-* options are implemented by the resolvconf package, if installed</div><div class=\"line\">  dns-nameservers 233.5.5.5</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>不是像CentOS那样明确地在各网卡的配置文件中说明是否该网卡作为默认路由网关，而是哪个网卡写了<code>gateway</code>就以它作为默认网关，如果2个网卡都写了，只有最后写的那个有效，所以最好明确地只保留一个<code>gateway</code>项。</li>\n<li><code>up ip route add 2.2.0.0/16   via 2.2.2.1 || true</code>其实也就是一句启动网卡后顺便执行的脚本，如果你愿意，这里写一句<code>up echo helloworld</code>也没问题。后面的<code>|| true</code>是让脚本执行时忽略可能的错误，继续执行。这里使用的是<code>ip</code>命令，如果使用<code>route</code>命令，效果也是一样的，前提是已经安装了<code>net-tools</code>或<code>iproute</code>软件包。使用<code>netmask</code>和<code>CIDR</code>格式都可以。</li>\n<li>哪个网卡的路由就写到对应的网卡下，这样执行<code>ifup eno1</code>这样的单独启动某个网卡的命令也会自动执行相应的命令添加该网卡的路由。</li>\n</ul>\n</blockquote>\n<p>执行命令<code>sudo systemctl restart networking</code>，重启网络服务。<br>查看一下更新后的路由表，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"># route -n</div><div class=\"line\">Kernel IP routing table</div><div class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class=\"line\">0.0.0.0         10.0.0.147      0.0.0.0         UG    0      0        0 eno2</div><div class=\"line\">10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eno2</div><div class=\"line\">2.2.0.0         2.2.2.1         255.255.0.0     UG    0      0        0 eno1</div><div class=\"line\">2.2.2.0         0.0.0.0         255.255.255.0   U     0      0        0 eno1</div><div class=\"line\">172.0.0.0       2.2.2.1         255.0.0.0       UG    0      0        0 eno1</div></pre></td></tr></table></figure></p>\n<p>注意倒数第二行：<code>2.2.2.0    0.0.0.0    255.255.255.0   U    0    0    0    eno1</code>，这个是自动添加的。<br>它的网关并不是<code>2.2.2.1</code>，即便在<code>interface</code>中强制器网关为<code>2.2.2.1</code>，也会被改为<code>0.0.0.0</code>。因为<code>2.2.2.0/24</code>是本LAN的数据包，经<code>ARP</code>协议获得目标的<code>MAC</code>地址后，会被直接发到目标地址，而不会经网关<code>2.2.2.1</code>转发，虽然路由表中默认网关是<code>0.0.0.0</code>，也不会按路由表转发到<code>10.0.0.147</code>。</p>\n<h1 id=\"其它问题\"><a href=\"#其它问题\" class=\"headerlink\" title=\"其它问题\"></a>其它问题</h1><p>下面的问题是在除NAT网关外的其它机器上设置的。</p>\n<h2 id=\"禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\"><a href=\"#禁用各机器的SSHD-DNS选项，解决ssh登录很慢的问题\" class=\"headerlink\" title=\"禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题\"></a>禁用各机器的SSHD DNS选项，解决ssh登录很慢的问题</h2><p>修改默认网关，添加路由之后，虽然可以从外部通过公网IP <code>ping</code>通机房内的机器，但<code>ssh</code>登录过程需要等待很长时间。<br>参考<a href=\"http://blog.itpub.net/7345798/viewspace-1055461/\" target=\"_blank\" rel=\"external\">ssh连接的时候很慢，ping的速度非常好</a>这篇文章，修改各机器上<code>sshd</code>的选项如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sed -i &quot;&apos;s/.*UseDNS.*/UseDNS no/g&apos;&quot; /etc/ssh/sshd_config</div><div class=\"line\">systemctl restart sshd</div></pre></td></tr></table></figure></p>\n<h2 id=\"取消原来设置的http代理\"><a href=\"#取消原来设置的http代理\" class=\"headerlink\" title=\"取消原来设置的http代理\"></a>取消原来设置的http代理</h2><p>注释掉配置文件中<code>http_proxy</code>和<code>https_proxy</code>环境变量的声明，并执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unset http_proxy</div><div class=\"line\">unset https_proxy</div></pre></td></tr></table></figure></p>\n<h1 id=\"PS-使用-SSH-隧道\"><a href=\"#PS-使用-SSH-隧道\" class=\"headerlink\" title=\"PS: 使用 SSH 隧道\"></a>PS: 使用 SSH 隧道</h1><p>一般可以通过服务器的公网IP在校内登录到机器上，有时把机器的配置搞乱了，需要连接到内网，使用iDRAC来管理机器，这时就要连接VPN了。其实也可以不连接VPN，而利用其它正常机器的SSH创建隧道，实现连接内网的目的。<br>以Windows客户端为例，安装了Windows版的<code>git</code>后，会附带一些<code>mingw</code>命令程序（不是完整的<code>mingw</code>），首先将这些命令的可执行文件所在路径添加到<code>Path</code>环境变量，比如是<code>E:\\App\\git\\usr\\bin;E:\\App\\git\\mingw64\\bin;E:\\App\\git\\bin</code>，然后就可以在Windows命令行使用这些命令了。其中就有<code>ssh.exe</code>。<br>在Windows命令行窗口执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -NfD 1088 -i C:\\Users\\ying\\.ssh\\id_rsa root@n147</div></pre></td></tr></table></figure></p>\n<p>这个命令执行成功后会退出，返回到命令提示符，但实际仍在后台监听本机的1088端口<code>127.0.0.1:1088</code>。<strong>如果需要停止SSH隧道，关闭该命令窗口即可</strong>。<br>因为我在Windows的<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>文件中添加了<code>n147</code>的项，所以可以直接输入名字而不必是IP地址。</p>\n<p>在IE或控制面板打开<code>Internet选项</code>，</p>\n<ul>\n<li>在<code>连接</code>选项卡单击<code>局域网设置</code>按钮，</li>\n<li>在弹出的对话框勾选<code>为LAN使用代理服务器</code>，然后单击<code>高级</code>，</li>\n<li>在弹出的对话框取消勾选<code>对所有协议使用相同的代理服务器</code>，然后在<code>套接字</code>对应的文本框填入<code>127.0.0.1</code>和上面命令中监听的端口号<code>1088</code>，</li>\n<li>在<code>例外</code>文本框中删掉<code>10.*0;</code>的内容，然后一路确定关闭所有对话框。<br>这时应该可以用IE或Chrome访问机房内网的iDRAC。<strong>如果需要正常访问网页，需要取消勾选<code>为LAN使用代理服务器</code></strong>。</li>\n</ul>\n<p><img src=\"/img/sock5-proxy.png\" alt=\"\"></p>"},{"title":"设置及使用HTTP代理","date":"2017-04-13T16:00:00.000Z","_content":"记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。\n<!--more-->\n\n<!-- TOC -->\n\n- [使用Squid提供HTTP代理](#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86)\n    - [主机上安装和设置Squid](#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid)\n    - [以Docker容器的方式运行Squid](#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid)\n- [使用HTTP代理](#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86)\n    - [全局的环境变量](#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n    - [Docker](#docker)\n    - [yum](#yum)\n    - [apt](#apt)\n\n<!-- /TOC -->\n\n# 使用Squid提供HTTP代理\n\n## 主机上安装和设置Squid\n作为网关的`n147`机器，公网IP是`2.2.2.147`。安装Squid，然后修改配置，启用服务。\n```\nyum install -y squid # CentOS\napt install -y squid # Ubuntu\napk add squid     # Alpine\n\n# squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile\n\n# 修改配置后，初始化squid的工作目录\nsquid -z\n\n# 启动服务\nsystemctl enable squid\nsystemctl start  squid\n```\n\n## 以Docker容器的方式运行Squid\nDockerfile内容如下：\n```\nFROM alpine:latest\n\nRUN apk update --no-cache; \\\n    apk add squid --no-cache\n\n# 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问\nRUN sed  -i \"/RFC 4291/a acl ics src 2.2.2.0/24\" squid.conf; \\\n    sed  -i \"/RFC 4291/a acl ics src 2.2.3.3/32\" squid.conf\n\n# 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分\nRUN sed -i \"/http_port/c http_port 8888\" squid.conf\n\n# 开启cache\nRUN sed -i '/cache_dir/s/#//g' /etc/squid/squid.conf\n\n# 或者直接使用修改过的配置文件\n# ADD squid.conf /etc/squid/squid.conf\n\n# squid -z用于初始化，创建cache目录，但直接在Dockerfile中\n# RUN squid -z\n# 却无法创建cache目录，导致squid无法启动\n# 故将初始化和启动命令写入脚本中\n\nRUN echo -e '#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N' >/squid.sh; \\\n    chmod +x /squid.sh\n\nEXPOSE 3128\nCMD [\"/squid.sh\"]\n```\n\n构造镜像：`docker build ./ -t squid:latest`\n启动容器：`docker run -d -p 3128:3128 --name squid squid:latest`\n\n\n# 使用HTTP代理\n内网其它不能直接访问外网的机器可以设置使用`n147`提供的代理服务。\n\n## 全局的环境变量\n在`/etc/environment`（不需要`export`），`/etc/profile`或`/etc/profile.d/http_proxy.sh`导出`http_proxy`和`https_proxy`\n```\nexport http_proxy=http://2.2.2.147:3128\nexport https_proxy=http://2.2.2.147:3128\n```\n\n`squid`可以作为https代理，只要设置 `https_proxy=http://2.2.2.147:3128`， 即这个环境变量以`http://`开头。\n\n## Docker\nDocker需要[单独设置代理](https://docs.docker.com/engine/admin/systemd/)，新建文件`/etc/systemd/system/docker.service.d/http-proxy.conf`，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：\n```\n[Service]\nEnvironment=\"HTTP_PROXY=http://2.2.2.147:3128\" \"HTTPS_PROXY=http://2.2.2.147:3128\"  \"NO_PROXY=localhost,10.0.0.147\"\n```\n重启docker daemon： `systemctl restart docker`，执行`docker info`查看是否生效。\n\n## yum\nyum 会使用全局代理设置，也可以单独设置代理，在`/etc/yum.conf`中增加：\n```\nproxy=http://2.2.2.147:3128\n```\n\n## apt\n在文件`/etc/apt/apt.conf`中增加：\n```\nAcquire::http::proxy  \"http://2.2.2.147:3128\";\nAcquire::https::proxy \"http://2.2.2.147:3128\";\n```\n","source":"_posts/setup-squid-proxy.md","raw":"title: 设置及使用HTTP代理\ndate: 2017-04-14\ncategory: [misc]\ntags:\n\n---\n记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。\n<!--more-->\n\n<!-- TOC -->\n\n- [使用Squid提供HTTP代理](#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86)\n    - [主机上安装和设置Squid](#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid)\n    - [以Docker容器的方式运行Squid](#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid)\n- [使用HTTP代理](#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86)\n    - [全局的环境变量](#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)\n    - [Docker](#docker)\n    - [yum](#yum)\n    - [apt](#apt)\n\n<!-- /TOC -->\n\n# 使用Squid提供HTTP代理\n\n## 主机上安装和设置Squid\n作为网关的`n147`机器，公网IP是`2.2.2.147`。安装Squid，然后修改配置，启用服务。\n```\nyum install -y squid # CentOS\napt install -y squid # Ubuntu\napk add squid     # Alpine\n\n# squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile\n\n# 修改配置后，初始化squid的工作目录\nsquid -z\n\n# 启动服务\nsystemctl enable squid\nsystemctl start  squid\n```\n\n## 以Docker容器的方式运行Squid\nDockerfile内容如下：\n```\nFROM alpine:latest\n\nRUN apk update --no-cache; \\\n    apk add squid --no-cache\n\n# 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问\nRUN sed  -i \"/RFC 4291/a acl ics src 2.2.2.0/24\" squid.conf; \\\n    sed  -i \"/RFC 4291/a acl ics src 2.2.3.3/32\" squid.conf\n\n# 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分\nRUN sed -i \"/http_port/c http_port 8888\" squid.conf\n\n# 开启cache\nRUN sed -i '/cache_dir/s/#//g' /etc/squid/squid.conf\n\n# 或者直接使用修改过的配置文件\n# ADD squid.conf /etc/squid/squid.conf\n\n# squid -z用于初始化，创建cache目录，但直接在Dockerfile中\n# RUN squid -z\n# 却无法创建cache目录，导致squid无法启动\n# 故将初始化和启动命令写入脚本中\n\nRUN echo -e '#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N' >/squid.sh; \\\n    chmod +x /squid.sh\n\nEXPOSE 3128\nCMD [\"/squid.sh\"]\n```\n\n构造镜像：`docker build ./ -t squid:latest`\n启动容器：`docker run -d -p 3128:3128 --name squid squid:latest`\n\n\n# 使用HTTP代理\n内网其它不能直接访问外网的机器可以设置使用`n147`提供的代理服务。\n\n## 全局的环境变量\n在`/etc/environment`（不需要`export`），`/etc/profile`或`/etc/profile.d/http_proxy.sh`导出`http_proxy`和`https_proxy`\n```\nexport http_proxy=http://2.2.2.147:3128\nexport https_proxy=http://2.2.2.147:3128\n```\n\n`squid`可以作为https代理，只要设置 `https_proxy=http://2.2.2.147:3128`， 即这个环境变量以`http://`开头。\n\n## Docker\nDocker需要[单独设置代理](https://docs.docker.com/engine/admin/systemd/)，新建文件`/etc/systemd/system/docker.service.d/http-proxy.conf`，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：\n```\n[Service]\nEnvironment=\"HTTP_PROXY=http://2.2.2.147:3128\" \"HTTPS_PROXY=http://2.2.2.147:3128\"  \"NO_PROXY=localhost,10.0.0.147\"\n```\n重启docker daemon： `systemctl restart docker`，执行`docker info`查看是否生效。\n\n## yum\nyum 会使用全局代理设置，也可以单独设置代理，在`/etc/yum.conf`中增加：\n```\nproxy=http://2.2.2.147:3128\n```\n\n## apt\n在文件`/etc/apt/apt.conf`中增加：\n```\nAcquire::http::proxy  \"http://2.2.2.147:3128\";\nAcquire::https::proxy \"http://2.2.2.147:3128\";\n```\n","slug":"setup-squid-proxy","published":1,"updated":"2017-10-30T02:47:23.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh2000k9s4fwggigh48","content":"<p>记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。<br><a id=\"more\"></a></p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86\">使用Squid提供HTTP代理</a><ul>\n<li><a href=\"#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid\">主机上安装和设置Squid</a></li>\n<li><a href=\"#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid\">以Docker容器的方式运行Squid</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86\">使用HTTP代理</a><ul>\n<li><a href=\"#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">全局的环境变量</a></li>\n<li><a href=\"#docker\">Docker</a></li>\n<li><a href=\"#yum\">yum</a></li>\n<li><a href=\"#apt\">apt</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"使用Squid提供HTTP代理\"><a href=\"#使用Squid提供HTTP代理\" class=\"headerlink\" title=\"使用Squid提供HTTP代理\"></a>使用Squid提供HTTP代理</h1><h2 id=\"主机上安装和设置Squid\"><a href=\"#主机上安装和设置Squid\" class=\"headerlink\" title=\"主机上安装和设置Squid\"></a>主机上安装和设置Squid</h2><p>作为网关的<code>n147</code>机器，公网IP是<code>2.2.2.147</code>。安装Squid，然后修改配置，启用服务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y squid # CentOS</div><div class=\"line\">apt install -y squid # Ubuntu</div><div class=\"line\">apk add squid     # Alpine</div><div class=\"line\"></div><div class=\"line\"># squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile</div><div class=\"line\"></div><div class=\"line\"># 修改配置后，初始化squid的工作目录</div><div class=\"line\">squid -z</div><div class=\"line\"></div><div class=\"line\"># 启动服务</div><div class=\"line\">systemctl enable squid</div><div class=\"line\">systemctl start  squid</div></pre></td></tr></table></figure></p>\n<h2 id=\"以Docker容器的方式运行Squid\"><a href=\"#以Docker容器的方式运行Squid\" class=\"headerlink\" title=\"以Docker容器的方式运行Squid\"></a>以Docker容器的方式运行Squid</h2><p>Dockerfile内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM alpine:latest</div><div class=\"line\"></div><div class=\"line\">RUN apk update --no-cache; \\</div><div class=\"line\">    apk add squid --no-cache</div><div class=\"line\"></div><div class=\"line\"># 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问</div><div class=\"line\">RUN sed  -i &quot;/RFC 4291/a acl ics src 2.2.2.0/24&quot; squid.conf; \\</div><div class=\"line\">    sed  -i &quot;/RFC 4291/a acl ics src 2.2.3.3/32&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分</div><div class=\"line\">RUN sed -i &quot;/http_port/c http_port 8888&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 开启cache</div><div class=\"line\">RUN sed -i &apos;/cache_dir/s/#//g&apos; /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># 或者直接使用修改过的配置文件</div><div class=\"line\"># ADD squid.conf /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># squid -z用于初始化，创建cache目录，但直接在Dockerfile中</div><div class=\"line\"># RUN squid -z</div><div class=\"line\"># 却无法创建cache目录，导致squid无法启动</div><div class=\"line\"># 故将初始化和启动命令写入脚本中</div><div class=\"line\"></div><div class=\"line\">RUN echo -e &apos;#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N&apos; &gt;/squid.sh; \\</div><div class=\"line\">    chmod +x /squid.sh</div><div class=\"line\"></div><div class=\"line\">EXPOSE 3128</div><div class=\"line\">CMD [&quot;/squid.sh&quot;]</div></pre></td></tr></table></figure></p>\n<p>构造镜像：<code>docker build ./ -t squid:latest</code><br>启动容器：<code>docker run -d -p 3128:3128 --name squid squid:latest</code></p>\n<h1 id=\"使用HTTP代理\"><a href=\"#使用HTTP代理\" class=\"headerlink\" title=\"使用HTTP代理\"></a>使用HTTP代理</h1><p>内网其它不能直接访问外网的机器可以设置使用<code>n147</code>提供的代理服务。</p>\n<h2 id=\"全局的环境变量\"><a href=\"#全局的环境变量\" class=\"headerlink\" title=\"全局的环境变量\"></a>全局的环境变量</h2><p>在<code>/etc/environment</code>（不需要<code>export</code>），<code>/etc/profile</code>或<code>/etc/profile.d/http_proxy.sh</code>导出<code>http_proxy</code>和<code>https_proxy</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export http_proxy=http://2.2.2.147:3128</div><div class=\"line\">export https_proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<p><code>squid</code>可以作为https代理，只要设置 <code>https_proxy=http://2.2.2.147:3128</code>， 即这个环境变量以<code>http://</code>开头。</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>Docker需要<a href=\"https://docs.docker.com/engine/admin/systemd/\" target=\"_blank\" rel=\"external\">单独设置代理</a>，新建文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Service]</div><div class=\"line\">Environment=&quot;HTTP_PROXY=http://2.2.2.147:3128&quot; &quot;HTTPS_PROXY=http://2.2.2.147:3128&quot;  &quot;NO_PROXY=localhost,10.0.0.147&quot;</div></pre></td></tr></table></figure></p>\n<p>重启docker daemon： <code>systemctl restart docker</code>，执行<code>docker info</code>查看是否生效。</p>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>yum 会使用全局代理设置，也可以单独设置代理，在<code>/etc/yum.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<h2 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h2><p>在文件<code>/etc/apt/apt.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Acquire::http::proxy  &quot;http://2.2.2.147:3128&quot;;</div><div class=\"line\">Acquire::https::proxy &quot;http://2.2.2.147:3128&quot;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>记录一下设置Squid作为HTTP代理，及docker、yum、apt等的代理配置。<br>","more":"</p>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8squid%E6%8F%90%E4%BE%9Bhttp%E4%BB%A3%E7%90%86\">使用Squid提供HTTP代理</a><ul>\n<li><a href=\"#%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEsquid\">主机上安装和设置Squid</a></li>\n<li><a href=\"#%E4%BB%A5docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Csquid\">以Docker容器的方式运行Squid</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8http%E4%BB%A3%E7%90%86\">使用HTTP代理</a><ul>\n<li><a href=\"#%E5%85%A8%E5%B1%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">全局的环境变量</a></li>\n<li><a href=\"#docker\">Docker</a></li>\n<li><a href=\"#yum\">yum</a></li>\n<li><a href=\"#apt\">apt</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"使用Squid提供HTTP代理\"><a href=\"#使用Squid提供HTTP代理\" class=\"headerlink\" title=\"使用Squid提供HTTP代理\"></a>使用Squid提供HTTP代理</h1><h2 id=\"主机上安装和设置Squid\"><a href=\"#主机上安装和设置Squid\" class=\"headerlink\" title=\"主机上安装和设置Squid\"></a>主机上安装和设置Squid</h2><p>作为网关的<code>n147</code>机器，公网IP是<code>2.2.2.147</code>。安装Squid，然后修改配置，启用服务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install -y squid # CentOS</div><div class=\"line\">apt install -y squid # Ubuntu</div><div class=\"line\">apk add squid     # Alpine</div><div class=\"line\"></div><div class=\"line\"># squid的配置文件在 /etc/squid/squid.conf，修改内容可参考下面的 Dockerfile</div><div class=\"line\"></div><div class=\"line\"># 修改配置后，初始化squid的工作目录</div><div class=\"line\">squid -z</div><div class=\"line\"></div><div class=\"line\"># 启动服务</div><div class=\"line\">systemctl enable squid</div><div class=\"line\">systemctl start  squid</div></pre></td></tr></table></figure></p>\n<h2 id=\"以Docker容器的方式运行Squid\"><a href=\"#以Docker容器的方式运行Squid\" class=\"headerlink\" title=\"以Docker容器的方式运行Squid\"></a>以Docker容器的方式运行Squid</h2><p>Dockerfile内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM alpine:latest</div><div class=\"line\"></div><div class=\"line\">RUN apk update --no-cache; \\</div><div class=\"line\">    apk add squid --no-cache</div><div class=\"line\"></div><div class=\"line\"># 可以在squid.conf中限制允许访问此代理的IP范围，否则只有内网IP可以访问</div><div class=\"line\">RUN sed  -i &quot;/RFC 4291/a acl ics src 2.2.2.0/24&quot; squid.conf; \\</div><div class=\"line\">    sed  -i &quot;/RFC 4291/a acl ics src 2.2.3.3/32&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 可以修改默认的端口号，如果修改了默认端口，需要修改下面的 EXPOSE 部分</div><div class=\"line\">RUN sed -i &quot;/http_port/c http_port 8888&quot; squid.conf</div><div class=\"line\"></div><div class=\"line\"># 开启cache</div><div class=\"line\">RUN sed -i &apos;/cache_dir/s/#//g&apos; /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># 或者直接使用修改过的配置文件</div><div class=\"line\"># ADD squid.conf /etc/squid/squid.conf</div><div class=\"line\"></div><div class=\"line\"># squid -z用于初始化，创建cache目录，但直接在Dockerfile中</div><div class=\"line\"># RUN squid -z</div><div class=\"line\"># 却无法创建cache目录，导致squid无法启动</div><div class=\"line\"># 故将初始化和启动命令写入脚本中</div><div class=\"line\"></div><div class=\"line\">RUN echo -e &apos;#!/bin/sh\\n[ -d /var/cache/squid/00 ] || squid -z\\nsquid -N&apos; &gt;/squid.sh; \\</div><div class=\"line\">    chmod +x /squid.sh</div><div class=\"line\"></div><div class=\"line\">EXPOSE 3128</div><div class=\"line\">CMD [&quot;/squid.sh&quot;]</div></pre></td></tr></table></figure></p>\n<p>构造镜像：<code>docker build ./ -t squid:latest</code><br>启动容器：<code>docker run -d -p 3128:3128 --name squid squid:latest</code></p>\n<h1 id=\"使用HTTP代理\"><a href=\"#使用HTTP代理\" class=\"headerlink\" title=\"使用HTTP代理\"></a>使用HTTP代理</h1><p>内网其它不能直接访问外网的机器可以设置使用<code>n147</code>提供的代理服务。</p>\n<h2 id=\"全局的环境变量\"><a href=\"#全局的环境变量\" class=\"headerlink\" title=\"全局的环境变量\"></a>全局的环境变量</h2><p>在<code>/etc/environment</code>（不需要<code>export</code>），<code>/etc/profile</code>或<code>/etc/profile.d/http_proxy.sh</code>导出<code>http_proxy</code>和<code>https_proxy</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export http_proxy=http://2.2.2.147:3128</div><div class=\"line\">export https_proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<p><code>squid</code>可以作为https代理，只要设置 <code>https_proxy=http://2.2.2.147:3128</code>， 即这个环境变量以<code>http://</code>开头。</p>\n<h2 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h2><p>Docker需要<a href=\"https://docs.docker.com/engine/admin/systemd/\" target=\"_blank\" rel=\"external\">单独设置代理</a>，新建文件<code>/etc/systemd/system/docker.service.d/http-proxy.conf</code>，内容如下（注意多项环境变量之间要有空格，还设置了对私有镜像仓库不使用代理）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[Service]</div><div class=\"line\">Environment=&quot;HTTP_PROXY=http://2.2.2.147:3128&quot; &quot;HTTPS_PROXY=http://2.2.2.147:3128&quot;  &quot;NO_PROXY=localhost,10.0.0.147&quot;</div></pre></td></tr></table></figure></p>\n<p>重启docker daemon： <code>systemctl restart docker</code>，执行<code>docker info</code>查看是否生效。</p>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>yum 会使用全局代理设置，也可以单独设置代理，在<code>/etc/yum.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">proxy=http://2.2.2.147:3128</div></pre></td></tr></table></figure></p>\n<h2 id=\"apt\"><a href=\"#apt\" class=\"headerlink\" title=\"apt\"></a>apt</h2><p>在文件<code>/etc/apt/apt.conf</code>中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Acquire::http::proxy  &quot;http://2.2.2.147:3128&quot;;</div><div class=\"line\">Acquire::https::proxy &quot;http://2.2.2.147:3128&quot;;</div></pre></td></tr></table></figure></p>"},{"title":"虚拟机及docker的存储，快照和镜像","date":"2016-09-20T16:00:00.000Z","_content":"VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 **封装** 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 **差分硬盘** 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n- [虚拟硬盘](#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98)\n- [部署和迁移](#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB)\n- [差分硬盘](#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98)\n- [**快照和克隆**](#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86)\n- [镜像管理](#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86)\n- [docker的镜像，容器](#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8)\n- [**Windows的diskpart工具**](#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7)\n- [**Windows从VHD启动实现极速快照和恢复**](#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D)\n\n<!-- /TOC -->\n\n# 虚拟硬盘\n\n硬盘被称为 **块设备**，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。\n\n虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。\n虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。\n\n下面是几种VMM的虚拟硬盘格式。\n\n| VMM        | 虚拟硬盘格式                          | 备注                            |\n|-           |-                                      |-                                |\n| VirtualBox | **vdi** , virtual disk image          | 还支持vmdk，vhd，qcow等多种格式 |\n| VMware     | **vmdk** , vm disk                    | vmdk有单文件和多文件2种方式     |\n| Hyper-V    | **vhd** / **vhdx**, virutal hard disk |                                 |\n| KVM        | **qcow**, qemu copy on write          | 还支持vmdk，raw格式             |\n\n各种虚拟硬盘格式大同小异，其中[vhd格式](https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;)不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的`diskpart`工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。\n\nVMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。\n重置一个虚拟硬盘GUID可以执行下面的命令\n\n{% codeblock line_number:false%}\nVBoxManage internalcommands sethduuid \"/path/file.vhd\"\n{% endcodeblock %}\n\n> vbox支持多种虚拟硬盘格式，使用`VBoxManage.exe`这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。\n> VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM->VM）。\n> VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。\n\n虚拟硬盘有固定和动态大小两种：\n + 前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；\n + 而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。\n\n\n# 部署和迁移\n\n在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法\n+ 使用OS本身支持的`应答文件`\n+ 比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。\n这两种方法效率上相差不多。\n\nVM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。\n\n基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 **在线** 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。\n\nVM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。\n\n# 差分硬盘\n\n虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。\n\n差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。\n\n子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 **纵向** 延续下去。比如vhd可以支持创建127代，而且 **每代差分硬盘的性能基本一致，不受代数层次的影响**。另外，一个父盘还可以有多个子盘，也就是 **横向** 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。![](/img/vmware-snapshot.png)\n\n差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的[性能测试的文档](http://go.microsoft.com/fwlink/p/?LinkId=186519)，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。\n\n创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。\n理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。\n\n# **快照和克隆**\n\n上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中\n>“删除”：会将选中快照对应的虚拟硬盘数据 **合并** 到它的差分子盘上，然后删除该差分盘。**不会改变** VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。\n>“转到”：将当前位置恢复到选中的快照。\n\nvbox的也有类似的快照功能，不过用起来不太直观。\n\n![vbox快照](/img/vbox-snapshot.png)\n\n>注：快照工具栏中的按钮分别是\n> `快照`：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。\n> `恢复`：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作\n> `删除`：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 **“合并快照”** 比 **删除快照** 更合适些。\n> `明细`：查看创建快照时写的备注和VM的参数变化。\n> `克隆`：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。\n\n# 镜像管理\n\n“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。\n所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。\n\n随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。\n\nOpenstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。\n\n# docker的镜像，容器\ndocker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及`build`，`pull`，`push`命令内置了镜像管理功能。\n\ndocker为实现镜像管理采用了类似于差分硬盘的[aufs文件系统](http://coolshell.cn/articles/17061.html)。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。\ndocker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。\n通过`docker commit`命令，可以将容器固化成镜像。\n<a name=\"docker-image\"></a>\ndocker的镜像管理还有一些不足：\n+ 虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。[FAST16 - Slacker: Fast Distribution with Lazy Docker Containers](https://www.usenix.org/node/194431) 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。\n+ 从dockerfile构造镜像时，每行`RUN`命令对应一层镜像，需要注意避免分层太多，而一个`RUN`命令太复杂又会限制了重用镜像的可能，如果能够 **显示地指定分层点** 可能会好些，这也算是镜像分层结构精细化的一部分。\n+ 从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如`apt`安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。\n\n`docker run`命令基于镜像创建并运行一个容器。新手容易通过`docker run`创建很多临时的容器，占用过多物理硬盘空间，这需要在执行`docker run`命令时加上`--rm`参数，容器退出后就会被docker删除掉。\n\ndocker官方建议开发人员应尽量避免通过`docker exec`或`ssh`进入容器执行操作，而应通过dockerfile将所有操作`build`到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。\n有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。\n\n<a name=\"win-vhd-boot\"></a>\n# **Windows的diskpart工具**\n\n因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的`diskpart`来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令\n\n{% codeblock line_number:false%}\nC:\\>diskpart\n\nDISKPART> create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd\n{% endcodeblock %}\n\n# **Windows从VHD启动实现极速快照和恢复**\n\nWindows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。\n+ 一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。\n+ 另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。\n+ 还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。\n\nvhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为`Current.vhd`和`Recovery.vhd`，分别添加这两个差分vhd的启动项为 **Current** 和 **Recovery**，这样就相当于已经安装了两个windows系统。正常使用 **Current** 系统，需要恢复时重启到 **Recovery** 系统，删除原来的`Current.vhd`，然后再基于父vhd创建一个新的差分vhd并命名为`Current.vhd`，再重启到 **Current** 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。\n\n系统盘的文件布局如下：\n{% codeblock line_number:false%}\nC:.\n│  Win8-Current.vhd    #正常工作系统\n│  Win8-Recovery.vhd   #恢复用系统\n│  Win8.vhd            #父vhd\n│  bootmgr             #启动管理器  \n└─boot                #系统启动相关文件\n        bcd\n        memtest.exe\n        ...\n\n{% endcodeblock %}\n\n`bootice`是一个操作vhd和系统启动项的小工具。此外还有`EasyBCD`和一些PE工具。当然，可以直接使用Windows内置的命令行工具`bcdboot`和`bcdedit`。\n\nLinux **还没有** 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。\n最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。\n\n前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -> VM；而 vhd native boot则相当于从 VM -> PM。\n\n---\n这个介绍数据中心的[视频](http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html) 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。\n","source":"_posts/vm-disk.md","raw":"title: 虚拟机及docker的存储，快照和镜像\ncategory: [cloud]\ntags:\ndate: 2016-09-21\n---\nVM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 **封装** 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 **差分硬盘** 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n- [虚拟硬盘](#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98)\n- [部署和迁移](#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB)\n- [差分硬盘](#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98)\n- [**快照和克隆**](#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86)\n- [镜像管理](#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86)\n- [docker的镜像，容器](#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8)\n- [**Windows的diskpart工具**](#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7)\n- [**Windows从VHD启动实现极速快照和恢复**](#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D)\n\n<!-- /TOC -->\n\n# 虚拟硬盘\n\n硬盘被称为 **块设备**，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。\n\n虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。\n虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。\n\n下面是几种VMM的虚拟硬盘格式。\n\n| VMM        | 虚拟硬盘格式                          | 备注                            |\n|-           |-                                      |-                                |\n| VirtualBox | **vdi** , virtual disk image          | 还支持vmdk，vhd，qcow等多种格式 |\n| VMware     | **vmdk** , vm disk                    | vmdk有单文件和多文件2种方式     |\n| Hyper-V    | **vhd** / **vhdx**, virutal hard disk |                                 |\n| KVM        | **qcow**, qemu copy on write          | 还支持vmdk，raw格式             |\n\n各种虚拟硬盘格式大同小异，其中[vhd格式](https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;)不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的`diskpart`工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。\n\nVMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。\n重置一个虚拟硬盘GUID可以执行下面的命令\n\n{% codeblock line_number:false%}\nVBoxManage internalcommands sethduuid \"/path/file.vhd\"\n{% endcodeblock %}\n\n> vbox支持多种虚拟硬盘格式，使用`VBoxManage.exe`这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。\n> VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM->VM）。\n> VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。\n\n虚拟硬盘有固定和动态大小两种：\n + 前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；\n + 而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。\n\n\n# 部署和迁移\n\n在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法\n+ 使用OS本身支持的`应答文件`\n+ 比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。\n这两种方法效率上相差不多。\n\nVM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。\n\n基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 **在线** 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。\n\nVM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。\n\n# 差分硬盘\n\n虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。\n\n差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。\n\n子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 **纵向** 延续下去。比如vhd可以支持创建127代，而且 **每代差分硬盘的性能基本一致，不受代数层次的影响**。另外，一个父盘还可以有多个子盘，也就是 **横向** 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。![](/img/vmware-snapshot.png)\n\n差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的[性能测试的文档](http://go.microsoft.com/fwlink/p/?LinkId=186519)，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。\n\n创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。\n理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。\n\n# **快照和克隆**\n\n上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中\n>“删除”：会将选中快照对应的虚拟硬盘数据 **合并** 到它的差分子盘上，然后删除该差分盘。**不会改变** VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。\n>“转到”：将当前位置恢复到选中的快照。\n\nvbox的也有类似的快照功能，不过用起来不太直观。\n\n![vbox快照](/img/vbox-snapshot.png)\n\n>注：快照工具栏中的按钮分别是\n> `快照`：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。\n> `恢复`：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作\n> `删除`：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 **“合并快照”** 比 **删除快照** 更合适些。\n> `明细`：查看创建快照时写的备注和VM的参数变化。\n> `克隆`：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。\n\n# 镜像管理\n\n“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。\n所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。\n\n随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。\n\nOpenstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。\n\n# docker的镜像，容器\ndocker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及`build`，`pull`，`push`命令内置了镜像管理功能。\n\ndocker为实现镜像管理采用了类似于差分硬盘的[aufs文件系统](http://coolshell.cn/articles/17061.html)。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。\ndocker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。\n通过`docker commit`命令，可以将容器固化成镜像。\n<a name=\"docker-image\"></a>\ndocker的镜像管理还有一些不足：\n+ 虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。[FAST16 - Slacker: Fast Distribution with Lazy Docker Containers](https://www.usenix.org/node/194431) 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。\n+ 从dockerfile构造镜像时，每行`RUN`命令对应一层镜像，需要注意避免分层太多，而一个`RUN`命令太复杂又会限制了重用镜像的可能，如果能够 **显示地指定分层点** 可能会好些，这也算是镜像分层结构精细化的一部分。\n+ 从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如`apt`安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。\n\n`docker run`命令基于镜像创建并运行一个容器。新手容易通过`docker run`创建很多临时的容器，占用过多物理硬盘空间，这需要在执行`docker run`命令时加上`--rm`参数，容器退出后就会被docker删除掉。\n\ndocker官方建议开发人员应尽量避免通过`docker exec`或`ssh`进入容器执行操作，而应通过dockerfile将所有操作`build`到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。\n有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。\n\n<a name=\"win-vhd-boot\"></a>\n# **Windows的diskpart工具**\n\n因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的`diskpart`来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令\n\n{% codeblock line_number:false%}\nC:\\>diskpart\n\nDISKPART> create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd\n{% endcodeblock %}\n\n# **Windows从VHD启动实现极速快照和恢复**\n\nWindows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。\n+ 一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。\n+ 另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。\n+ 还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。\n\nvhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为`Current.vhd`和`Recovery.vhd`，分别添加这两个差分vhd的启动项为 **Current** 和 **Recovery**，这样就相当于已经安装了两个windows系统。正常使用 **Current** 系统，需要恢复时重启到 **Recovery** 系统，删除原来的`Current.vhd`，然后再基于父vhd创建一个新的差分vhd并命名为`Current.vhd`，再重启到 **Current** 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。\n\n系统盘的文件布局如下：\n{% codeblock line_number:false%}\nC:.\n│  Win8-Current.vhd    #正常工作系统\n│  Win8-Recovery.vhd   #恢复用系统\n│  Win8.vhd            #父vhd\n│  bootmgr             #启动管理器  \n└─boot                #系统启动相关文件\n        bcd\n        memtest.exe\n        ...\n\n{% endcodeblock %}\n\n`bootice`是一个操作vhd和系统启动项的小工具。此外还有`EasyBCD`和一些PE工具。当然，可以直接使用Windows内置的命令行工具`bcdboot`和`bcdedit`。\n\nLinux **还没有** 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。\n最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。\n\n前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -> VM；而 vhd native boot则相当于从 VM -> PM。\n\n---\n这个介绍数据中心的[视频](http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html) 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。\n","slug":"vm-disk","published":1,"updated":"2017-10-30T03:41:50.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh4000m9s4f6kzbtko3","content":"<p>VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 <strong>封装</strong> 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 <strong>差分硬盘</strong> 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n</code></pre><ul>\n<li><a href=\"#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98\">虚拟硬盘</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB\">部署和迁移</a></li>\n<li><a href=\"#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98\">差分硬盘</a></li>\n<li><a href=\"#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86\"><strong>快照和克隆</strong></a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86\">镜像管理</a></li>\n<li><a href=\"#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8\">docker的镜像，容器</a></li>\n<li><a href=\"#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7\"><strong>Windows的diskpart工具</strong></a></li>\n<li><a href=\"#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D\"><strong>Windows从VHD启动实现极速快照和恢复</strong></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"虚拟硬盘\"><a href=\"#虚拟硬盘\" class=\"headerlink\" title=\"虚拟硬盘\"></a>虚拟硬盘</h1><p>硬盘被称为 <strong>块设备</strong>，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。</p>\n<p>虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。<br>虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。</p>\n<p>下面是几种VMM的虚拟硬盘格式。</p>\n<table>\n<thead>\n<tr>\n<th>VMM</th>\n<th>虚拟硬盘格式</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VirtualBox</td>\n<td><strong>vdi</strong> , virtual disk image</td>\n<td>还支持vmdk，vhd，qcow等多种格式</td>\n</tr>\n<tr>\n<td>VMware</td>\n<td><strong>vmdk</strong> , vm disk</td>\n<td>vmdk有单文件和多文件2种方式</td>\n</tr>\n<tr>\n<td>Hyper-V</td>\n<td><strong>vhd</strong> / <strong>vhdx</strong>, virutal hard disk</td>\n<td></td>\n</tr>\n<tr>\n<td>KVM</td>\n<td><strong>qcow</strong>, qemu copy on write</td>\n<td>还支持vmdk，raw格式</td>\n</tr>\n</tbody>\n</table>\n<p>各种虚拟硬盘格式大同小异，其中<a href=\"https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;\" target=\"_blank\" rel=\"external\">vhd格式</a>不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的<code>diskpart</code>工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。</p>\n<p>VMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。<br>重置一个虚拟硬盘GUID可以执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">VBoxManage internalcommands sethduuid &quot;/path/file.vhd&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>vbox支持多种虚拟硬盘格式，使用<code>VBoxManage.exe</code>这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。<br>VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM-&gt;VM）。<br>VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。</p>\n</blockquote>\n<p>虚拟硬盘有固定和动态大小两种：</p>\n<ul>\n<li>前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；</li>\n<li>而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。</li>\n</ul>\n<h1 id=\"部署和迁移\"><a href=\"#部署和迁移\" class=\"headerlink\" title=\"部署和迁移\"></a>部署和迁移</h1><p>在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法</p>\n<ul>\n<li>使用OS本身支持的<code>应答文件</code></li>\n<li>比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。<br>这两种方法效率上相差不多。</li>\n</ul>\n<p>VM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。</p>\n<p>基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 <strong>在线</strong> 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。</p>\n<p>VM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。</p>\n<h1 id=\"差分硬盘\"><a href=\"#差分硬盘\" class=\"headerlink\" title=\"差分硬盘\"></a>差分硬盘</h1><p>虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。</p>\n<p>差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。</p>\n<p>子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 <strong>纵向</strong> 延续下去。比如vhd可以支持创建127代，而且 <strong>每代差分硬盘的性能基本一致，不受代数层次的影响</strong>。另外，一个父盘还可以有多个子盘，也就是 <strong>横向</strong> 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。<img src=\"/img/vmware-snapshot.png\" alt=\"\"></p>\n<p>差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的<a href=\"http://go.microsoft.com/fwlink/p/?LinkId=186519\" target=\"_blank\" rel=\"external\">性能测试的文档</a>，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。</p>\n<p>创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。<br>理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。</p>\n<h1 id=\"快照和克隆\"><a href=\"#快照和克隆\" class=\"headerlink\" title=\"快照和克隆\"></a><strong>快照和克隆</strong></h1><p>上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中</p>\n<blockquote>\n<p>“删除”：会将选中快照对应的虚拟硬盘数据 <strong>合并</strong> 到它的差分子盘上，然后删除该差分盘。<strong>不会改变</strong> VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。<br>“转到”：将当前位置恢复到选中的快照。</p>\n</blockquote>\n<p>vbox的也有类似的快照功能，不过用起来不太直观。</p>\n<p><img src=\"/img/vbox-snapshot.png\" alt=\"vbox快照\"></p>\n<blockquote>\n<p>注：快照工具栏中的按钮分别是<br><code>快照</code>：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。<br><code>恢复</code>：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作<br><code>删除</code>：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 <strong>“合并快照”</strong> 比 <strong>删除快照</strong> 更合适些。<br><code>明细</code>：查看创建快照时写的备注和VM的参数变化。<br><code>克隆</code>：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。</p>\n</blockquote>\n<h1 id=\"镜像管理\"><a href=\"#镜像管理\" class=\"headerlink\" title=\"镜像管理\"></a>镜像管理</h1><p>“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。<br>所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。</p>\n<p>随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。</p>\n<p>Openstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。</p>\n<h1 id=\"docker的镜像，容器\"><a href=\"#docker的镜像，容器\" class=\"headerlink\" title=\"docker的镜像，容器\"></a>docker的镜像，容器</h1><p>docker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及<code>build</code>，<code>pull</code>，<code>push</code>命令内置了镜像管理功能。</p>\n<p>docker为实现镜像管理采用了类似于差分硬盘的<a href=\"http://coolshell.cn/articles/17061.html\" target=\"_blank\" rel=\"external\">aufs文件系统</a>。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。<br>docker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。<br>通过<code>docker commit</code>命令，可以将容器固化成镜像。<br><a name=\"docker-image\"></a><br>docker的镜像管理还有一些不足：</p>\n<ul>\n<li>虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。<a href=\"https://www.usenix.org/node/194431\" target=\"_blank\" rel=\"external\">FAST16 - Slacker: Fast Distribution with Lazy Docker Containers</a> 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。</li>\n<li>从dockerfile构造镜像时，每行<code>RUN</code>命令对应一层镜像，需要注意避免分层太多，而一个<code>RUN</code>命令太复杂又会限制了重用镜像的可能，如果能够 <strong>显示地指定分层点</strong> 可能会好些，这也算是镜像分层结构精细化的一部分。</li>\n<li>从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如<code>apt</code>安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。</li>\n</ul>\n<p><code>docker run</code>命令基于镜像创建并运行一个容器。新手容易通过<code>docker run</code>创建很多临时的容器，占用过多物理硬盘空间，这需要在执行<code>docker run</code>命令时加上<code>--rm</code>参数，容器退出后就会被docker删除掉。</p>\n<p>docker官方建议开发人员应尽量避免通过<code>docker exec</code>或<code>ssh</code>进入容器执行操作，而应通过dockerfile将所有操作<code>build</code>到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。<br>有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。</p>\n<p><a name=\"win-vhd-boot\"></a></p>\n<h1 id=\"Windows的diskpart工具\"><a href=\"#Windows的diskpart工具\" class=\"headerlink\" title=\"Windows的diskpart工具\"></a><strong>Windows的diskpart工具</strong></h1><p>因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的<code>diskpart</code>来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:\\&gt;diskpart</div><div class=\"line\"></div><div class=\"line\">DISKPART&gt; create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd</div></pre></td></tr></table></figure>\n<h1 id=\"Windows从VHD启动实现极速快照和恢复\"><a href=\"#Windows从VHD启动实现极速快照和恢复\" class=\"headerlink\" title=\"Windows从VHD启动实现极速快照和恢复\"></a><strong>Windows从VHD启动实现极速快照和恢复</strong></h1><p>Windows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。</p>\n<ul>\n<li>一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。</li>\n<li>另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。</li>\n<li>还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。</li>\n</ul>\n<p>vhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为<code>Current.vhd</code>和<code>Recovery.vhd</code>，分别添加这两个差分vhd的启动项为 <strong>Current</strong> 和 <strong>Recovery</strong>，这样就相当于已经安装了两个windows系统。正常使用 <strong>Current</strong> 系统，需要恢复时重启到 <strong>Recovery</strong> 系统，删除原来的<code>Current.vhd</code>，然后再基于父vhd创建一个新的差分vhd并命名为<code>Current.vhd</code>，再重启到 <strong>Current</strong> 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。</p>\n<p>系统盘的文件布局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:.</div><div class=\"line\">│  Win8-Current.vhd    #正常工作系统</div><div class=\"line\">│  Win8-Recovery.vhd   #恢复用系统</div><div class=\"line\">│  Win8.vhd            #父vhd</div><div class=\"line\">│  bootmgr             #启动管理器  </div><div class=\"line\">└─boot                #系统启动相关文件</div><div class=\"line\">        bcd</div><div class=\"line\">        memtest.exe</div><div class=\"line\">        ...</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p><code>bootice</code>是一个操作vhd和系统启动项的小工具。此外还有<code>EasyBCD</code>和一些PE工具。当然，可以直接使用Windows内置的命令行工具<code>bcdboot</code>和<code>bcdedit</code>。</p>\n<p>Linux <strong>还没有</strong> 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。<br>最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。</p>\n<p>前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -&gt; VM；而 vhd native boot则相当于从 VM -&gt; PM。</p>\n<hr>\n<p>这个介绍数据中心的<a href=\"http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html\" target=\"_blank\" rel=\"external\">视频</a> 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。</p>\n","site":{"data":{}},"excerpt":"<p>VM的虚拟硬盘让我们能够把整个操作系统和应用软件、配置、数据都 <strong>封装</strong> 在一个（或多个）文件里，这样就实现了VM的迁移，再加上 <strong>差分硬盘</strong> 功能，实现了VM的快速克隆和快照。对VM镜像管理的需求也就随之而来了。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的存储，快照和镜像](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%AB%E7%85%A7%E5%92%8C%E9%95%9C%E5%83%8F)\n</code></pre><ul>\n<li><a href=\"#%E8%99%9A%E6%8B%9F%E7%A1%AC%E7%9B%98\">虚拟硬盘</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%92%8C%E8%BF%81%E7%A7%BB\">部署和迁移</a></li>\n<li><a href=\"#%E5%B7%AE%E5%88%86%E7%A1%AC%E7%9B%98\">差分硬盘</a></li>\n<li><a href=\"#%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86\"><strong>快照和克隆</strong></a></li>\n<li><a href=\"#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86\">镜像管理</a></li>\n<li><a href=\"#docker%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E5%AE%B9%E5%99%A8\">docker的镜像，容器</a></li>\n<li><a href=\"#windows%E7%9A%84diskpart%E5%B7%A5%E5%85%B7\"><strong>Windows的diskpart工具</strong></a></li>\n<li><a href=\"#windows%E4%BB%8Evhd%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E5%BF%AB%E7%85%A7%E5%92%8C%E6%81%A2%E5%A4%8D\"><strong>Windows从VHD启动实现极速快照和恢复</strong></a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"虚拟硬盘\"><a href=\"#虚拟硬盘\" class=\"headerlink\" title=\"虚拟硬盘\"></a>虚拟硬盘</h1><p>硬盘被称为 <strong>块设备</strong>，传统的机械硬盘最小的读写单元是一个扇区（sector），而文件系统（FS）在引入了逻辑存储块（block），可能与物理扇区大小相同，也可以是扇区的整数倍。一个文件对应了若干block，多个文件又以文件夹的形式组成一棵树，这是FS的两层结构。</p>\n<p>虚拟硬盘只需要模拟出扇区结构就可以了，上层的逻辑块和文件树由VM里的Guest OS来负责。可以简单地创建一个空白的大文件（raw格式）来作为Guest OS的虚拟硬盘，Guest OS再将其格式化为某种FS。<br>虚拟硬盘在Host上是一个文件（vhd）或若干个相关的文件（vmdk），而其中又有Guest OS创建的文件。</p>\n<p>下面是几种VMM的虚拟硬盘格式。</p>\n<table>\n<thead>\n<tr>\n<th>VMM</th>\n<th>虚拟硬盘格式</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>VirtualBox</td>\n<td><strong>vdi</strong> , virtual disk image</td>\n<td>还支持vmdk，vhd，qcow等多种格式</td>\n</tr>\n<tr>\n<td>VMware</td>\n<td><strong>vmdk</strong> , vm disk</td>\n<td>vmdk有单文件和多文件2种方式</td>\n</tr>\n<tr>\n<td>Hyper-V</td>\n<td><strong>vhd</strong> / <strong>vhdx</strong>, virutal hard disk</td>\n<td></td>\n</tr>\n<tr>\n<td>KVM</td>\n<td><strong>qcow</strong>, qemu copy on write</td>\n<td>还支持vmdk，raw格式</td>\n</tr>\n</tbody>\n</table>\n<p>各种虚拟硬盘格式大同小异，其中<a href=\"https://en.wikipedia.org/wiki/VHD_&#40;file_format&#41;\" target=\"_blank\" rel=\"external\">vhd格式</a>不仅在vbox和hyper-v中得到支持，Windows7及以后版本的Windows系统中也内置了对它支持，所以用vbox创建VM建议选择vhd格式。Win7及以后的版本内置的<code>diskpart</code>工具（下面会介绍）可以创建vhd的差分镜像，Win8及以后版本可以通过双击挂载vhd镜像。如果vhd镜像的分区是windows支持的NTFS等格式，就可以在不用启动VM的情况下直接读写vhd，这就像把一台机器（VM）的硬盘拆下来拿到其它机器（Host）读写，然后再装回去。</p>\n<p>VMM为了管理虚拟硬盘，还会在虚拟硬盘文件中增加一些元数据信息，比如作为硬盘唯一标识的GUID。在vbox中，如果直接复制一个虚拟硬盘镜像挂载到其它的VM，就会报告已经存在了相同GUID的虚拟硬盘。<br>重置一个虚拟硬盘GUID可以执行下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">VBoxManage internalcommands sethduuid &quot;/path/file.vhd&quot;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>vbox支持多种虚拟硬盘格式，使用<code>VBoxManage.exe</code>这个命令行工具还可以进行不同虚拟硬盘格式之间的转换，启停VM等很多操作。<br>VMware可以将物理硬盘转换为虚拟硬盘，这样实际上是把一个物理机器（部分地）克隆到了VM（PM-&gt;VM）。<br>VMware还可以将一个物理硬盘分区直接加载给VM，这样会稍许提高一下访问硬盘的性能。</p>\n</blockquote>\n<p>虚拟硬盘有固定和动态大小两种：</p>\n<ul>\n<li>前者直接分配了全部硬盘空间，创建的时候会比较费时，而且通常会有大部分硬盘空间是空闲的，优势是所需空间已经预先分配好了，访问性能会好一些；</li>\n<li>而动态大小的虚拟硬盘在创建时是一个很小的文件，只有基本的信息。随着Guest OS使用硬盘，才会逐渐自动扩展，这样能极大节约硬盘空间，但动态分配会降低性能。要注意扩展是自动的，一旦扩展就不会收缩回去，哪怕Guest OS格式化了虚拟硬盘。</li>\n</ul>\n<h1 id=\"部署和迁移\"><a href=\"#部署和迁移\" class=\"headerlink\" title=\"部署和迁移\"></a>部署和迁移</h1><p>在VM出现之前，要想批量地安装OS，也就是部署OS的问题，有两种常用的方法</p>\n<ul>\n<li>使用OS本身支持的<code>应答文件</code></li>\n<li>比较常用的方法就是先在一台机器上安装好系统、驱动、应用软件，修改一些配置，然后用ghost克隆操作系统的分区到一个.gho镜像（所谓的基准镜像golden image），然后分别拷贝这个.gho到其它机器上，启动到pe环境，再从.gho镜像恢复系统；也可以从局域网的某个ghost server服务器上获取.gho镜像来恢复系统。gho系统镜像一般有几个GB，就算自动安装的话也要十几分钟。<br>这两种方法效率上相差不多。</li>\n</ul>\n<p>VM将整个OS放在一个虚拟硬盘文件里，在加上一个很小的VM配置文件（比如xml格式的.vbox文件）就是一个完整的计算机了，而且是统一的虚拟设备驱动，把这些文件拷贝到另一个Host上就可以得到一个新的VM。虽然一个虚拟硬盘文件也有几个GB，但只需要拷贝过去，节省了ghost从镜像恢复这一步，还是方便一些的。不足之处是虚拟化带来的一些性能开销，随着硬件对虚拟化的支持，这些开销已经很小了。</p>\n<p>基于虚拟硬盘实现的VM的封装性是虚拟化技术一个很重要的特性，这样就实现了VM的（离线）迁移。在此基础上，还开发出了VMM的 <strong>在线</strong> 迁移技术，就是在VM不停机的情况下迁移到其它Host上。在线迁移跟离线迁移一样需要拷贝虚拟硬盘文件，区别是在线迁移还要拷贝运行时刻的内存，一般有若干GB，经过网络传输比较耗时，所以内存迁移需要几次迭代才能完成。</p>\n<p>VM的迁移虽然是一个可以提高VM可用性的功能，但毕竟虚拟硬盘还是太大了，传统上除了视频文件，网络上很少有这种大流量传输的需求。VM迁移对已有网络的承受能力是一个考验。还有一个问题是很多虚拟硬盘中的数据都是重复的，占用了大量的存储空间。为了解决这些问题，就出现了下面的差分硬盘功能。</p>\n<h1 id=\"差分硬盘\"><a href=\"#差分硬盘\" class=\"headerlink\" title=\"差分硬盘\"></a>差分硬盘</h1><p>虽然可以预先制作一个标准VM镜像，然后批量拷贝得到很多VM，但VM运行后会在虚拟硬盘中写入不同的数据，所以每个VM的虚拟硬盘内的数据都是不同的，迁移时必须要分别拷贝。即便是给VM添加两个虚拟硬盘，一个OS（系统盘），另一个空白硬盘专门保存用户数据（数据盘），还是难以避免Guest OS在系统盘修改文件数据。</p>\n<p>差分硬盘的思路类似内存管理中的copy on write (COW) 技术。基于父虚拟硬盘创建一个差分硬盘（子盘），VM挂载子盘后，看上去跟父盘完全一样，只是后续增删的数据都是保存在子盘上的。</p>\n<p>子盘还可以再继续创建差分盘（孙盘），这样子子孙孙 <strong>纵向</strong> 延续下去。比如vhd可以支持创建127代，而且 <strong>每代差分硬盘的性能基本一致，不受代数层次的影响</strong>。另外，一个父盘还可以有多个子盘，也就是 <strong>横向</strong> 扩展，同一个父盘下面生成子盘的个数没有限制，因为父子关系信息，即父盘的位置和GUID，只保存在子盘里。横向和纵向的差分盘可能形成一棵树。下面就是VMware的快照管理器截图（快照实际上包括虚拟硬盘快照和VM配置快照两部分，显然硬盘快照是占大头的部分）。<img src=\"/img/vmware-snapshot.png\" alt=\"\"></p>\n<p>差分硬盘相比普通虚拟硬盘在性能上会有一点损失，但给运维带来的便利是很大的。微软有一个关于vhd在windows server 2008和2008 R2多种应用场景下的<a href=\"http://go.microsoft.com/fwlink/p/?LinkId=186519\" target=\"_blank\" rel=\"external\">性能测试的文档</a>，包括物理硬盘 vs 固定分配的vhd vs 动态分配的vhd vs 差分vhd。结果是动态分配的vhd性能下降比较明显，固定分配的vhd和差分vhd的性能都接近物理硬盘。</p>\n<p>创建一个差分硬盘基本不到1秒钟，于是就可以实现秒级创建/克隆/离线迁移VM，秒级创建快照，克隆是针对多个VM，而快照是针对某一个VM的。<br>理论上来说，所有VM公用的父虚拟硬盘可以只保存一个，会减少很多原来虚拟硬盘占用的实际存储空间，当然这个父盘需要保存在可以远程访问的共享存储上，一般是samba/cifs或者NFS共享目录。</p>\n<h1 id=\"快照和克隆\"><a href=\"#快照和克隆\" class=\"headerlink\" title=\"快照和克隆\"></a><strong>快照和克隆</strong></h1><p>上面截图是VMware的快照功能，可以创建出一棵快照树。VMware这个快照管理器中</p>\n<blockquote>\n<p>“删除”：会将选中快照对应的虚拟硬盘数据 <strong>合并</strong> 到它的差分子盘上，然后删除该差分盘。<strong>不会改变</strong> VM的当前状态，只是删除了选中层次的差分硬盘。合并差分盘是一个比较耗时的操作。要求当前的虚拟硬盘只有一个子盘才能合并。<br>“转到”：将当前位置恢复到选中的快照。</p>\n</blockquote>\n<p>vbox的也有类似的快照功能，不过用起来不太直观。</p>\n<p><img src=\"/img/vbox-snapshot.png\" alt=\"vbox快照\"></p>\n<blockquote>\n<p>注：快照工具栏中的按钮分别是<br><code>快照</code>：只能对“当前状态”生成快照，实际是以“当前状态”的虚拟硬盘为父盘，创建一个差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。<br><code>恢复</code>：基于选择快照的虚拟硬盘创建一个新的差分盘，并将VM的虚拟硬盘设置为这个差分盘，即作为新的“当前状态”。需要在VM停机状态下才能执行“恢复”操作<br><code>删除</code>：这个功能和VMware的“删除”一样。注意这个功能跟“恢复”的区别，我经常想恢复VM，结果搞不清这两个功能，选择了删除，不但耗时，还把中间的快照层次给弄丢了，相当于版本库中丢失了中间某个版本，虽然对当前版本没有影响，但还是丢掉了一些数据的。创建快照是为了尽可能快速恢复，快照越多，恢复的粒度就越细，重用的VM操作/数据就越多，当然管理起来会增加点工作量，通常情况是没有必要合并快照的，因此这个功能是不太常用的，而且称为 <strong>“合并快照”</strong> 比 <strong>删除快照</strong> 更合适些。<br><code>明细</code>：查看创建快照时写的备注和VM的参数变化。<br><code>克隆</code>：基于当前的VM克隆一个新的VM，既可以选择使用差分硬盘方式（连接），也可以使用传统的复制整个虚拟硬盘。</p>\n</blockquote>\n<h1 id=\"镜像管理\"><a href=\"#镜像管理\" class=\"headerlink\" title=\"镜像管理\"></a>镜像管理</h1><p>“镜像”现在有了两层含义，一个是前面一直说的虚拟硬盘，可以在VM运行中修改从而发生变化，一个是作为基准模板的VM，其中最重要的文件是差分硬盘的父盘。<br>所谓基准模板，或基准镜像 golden image ，与普通的VM并没有什么本质的区别，只是被标识了一个特别的身份而已，最多就是把相关的文件（配置，虚拟硬盘等）都打包在一起。</p>\n<p>随之而来的是基准镜像的管理问题，因为基准镜像也不是一成不变的，其中的软件或者用户应用/数据可能需要更新，这一般都是通过在VM里执行系统维护命令来实现的。基准镜像也不只有一个，为了减少重复操作，应该为常见的功能特征都创建好基准镜像，甚至实现开箱可用的目标。镜像管理要给镜像关联尽可能详细的描述信息，让开发人员方便地找的合适的镜像，避免发明轮子。从基础镜像出发，相当于IaaS的模式，而从一个安装和配置了特定功能的镜像开始，则相当于提升到PaaS的层次了。</p>\n<p>Openstack 中的Glance模块是镜像管理模块，vagrant使用的.box也算是一种简单的镜像管理方案，但与docker的镜像管理功能相比还有一定的差距。</p>\n<h1 id=\"docker的镜像，容器\"><a href=\"#docker的镜像，容器\" class=\"headerlink\" title=\"docker的镜像，容器\"></a>docker的镜像，容器</h1><p>docker一开始就通过公共镜像仓库docker hub和私有仓库docker registery，以及<code>build</code>，<code>pull</code>，<code>push</code>命令内置了镜像管理功能。</p>\n<p>docker为实现镜像管理采用了类似于差分硬盘的<a href=\"http://coolshell.cn/articles/17061.html\" target=\"_blank\" rel=\"external\">aufs文件系统</a>。aufs是一个虚拟文件系统，是在某个实际的底层文件系统上重新组织的虚拟文件视图，aufs并不处理底层的硬盘数据块，只是把多个主机上已经存在的不同目录分层次挂载到同一个虚拟的目录下，上层会覆盖下层的同名文件，不同名的文件则会相安无事，这样每个层就类似于差分硬盘的一个子盘。然而aufs是在文件层次实现的，而VM的差分硬盘则是在更底层的数据块层实现的。<br>docker基于镜像创建容器container，容器类似于虚拟机实例，有创建、启动、运行、暂停、停止的生命周期。镜像的层是只读的，容器会重用这些层，然后在最上面新创建一个可读写的层。<br>通过<code>docker commit</code>命令，可以将容器固化成镜像。<br><a name=\"docker-image\"></a><br>docker的镜像管理还有一些不足：</p>\n<ul>\n<li>虽然docker会管理单个Host下的镜像，利用graph功能重用已有的镜像层，但每个Host还是有重复的镜像拷贝。虚拟机为了实现在线迁移，要求VM镜像保存在一个共享目录，恰好实现了部分的去重效果。不过docker有私有的仓库，而且能跟共享目录结合起来就好了。<a href=\"https://www.usenix.org/node/194431\" target=\"_blank\" rel=\"external\">FAST16 - Slacker: Fast Distribution with Lazy Docker Containers</a> 这篇文章为了加速Docker容器的启动速度，采用了集中的共享存储镜像仓库和惰性加载镜像的方式，只加载当前使用的镜像到本地，与我们的思路很相近了。另外，Docker镜像分层的结构还可以更精细，以提高重用的可能。</li>\n<li>从dockerfile构造镜像时，每行<code>RUN</code>命令对应一层镜像，需要注意避免分层太多，而一个<code>RUN</code>命令太复杂又会限制了重用镜像的可能，如果能够 <strong>显示地指定分层点</strong> 可能会好些，这也算是镜像分层结构精细化的一部分。</li>\n<li>从dockerfile构造镜像也不是完全可重现的，如果基于同一个dockerfile的2次构建相隔了比较长的时间，而dockerfile中又要从外部获取应用或数据，比如<code>apt</code>安装软件，有可能安装的软件版本就不同了，而且这还涉及到层的重用。docker目前已经通过计算镜像各层内文件的内容的Hash来唯一地确定该层，部分缓解了这一问题。</li>\n</ul>\n<p><code>docker run</code>命令基于镜像创建并运行一个容器。新手容易通过<code>docker run</code>创建很多临时的容器，占用过多物理硬盘空间，这需要在执行<code>docker run</code>命令时加上<code>--rm</code>参数，容器退出后就会被docker删除掉。</p>\n<p>docker官方建议开发人员应尽量避免通过<code>docker exec</code>或<code>ssh</code>进入容器执行操作，而应通过dockerfile将所有操作<code>build</code>到镜像中。这样的好处是所有的操作都在dockerfile中，从而可以被版本管理系统跟踪。对VM的操作一般是经chef，puppet，ansible或salt这类自动化工具，在多个VM上批量执行的。自动化工具的问题是每个VM都需要重复执行，不同VM执行可能会产生错误或不同的结果，而dockerfile只要build一次，然后基于镜像创建容器即可，能更好的保证一致性，而且节约了重复执行的时间和网络流量（没有缓存的情况下）。<br>有人将VM比喻为宠物：一个Host只能支持若干个VM，所以开发人员都小心翼翼地像宠物一样对待VM；而一个Host可以支持多得多的容器，对待容器就像家畜一样，生死都不足惜。</p>\n<p><a name=\"win-vhd-boot\"></a></p>\n<h1 id=\"Windows的diskpart工具\"><a href=\"#Windows的diskpart工具\" class=\"headerlink\" title=\"Windows的diskpart工具\"></a><strong>Windows的diskpart工具</strong></h1><p>因为曾被vbox的“恢复”和“删除”搞晕，所以之前都是用windows的<code>diskpart</code>来创建差分硬盘，然后重新设置VM的硬盘，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:\\&gt;diskpart</div><div class=\"line\"></div><div class=\"line\">DISKPART&gt; create vdisk file=c:\\diff.vhd parent=c:\\parent.vhd</div></pre></td></tr></table></figure>\n<h1 id=\"Windows从VHD启动实现极速快照和恢复\"><a href=\"#Windows从VHD启动实现极速快照和恢复\" class=\"headerlink\" title=\"Windows从VHD启动实现极速快照和恢复\"></a><strong>Windows从VHD启动实现极速快照和恢复</strong></h1><p>Windows对vhd的内置支持远不止创建，挂载。最大的特色是支持从vhd启动（vhd native boot）：就是说把windows系统安装到一个vhd中，向普通硬盘分区一样从这个vhd启动windows。</p>\n<ul>\n<li>一种做法是把windows安装文件写入vhd中，然后将其加入BCD启动项，重启后系统会安装vhd在内。</li>\n<li>另一种做法比较费事，需要用安装盘中的维护工具，在命令行执行diskpart创建vhd，挂载并格式化，然后就可以像物理硬盘一样把系统装到vhd了。</li>\n<li>还有一种做法，将已经安装在物理硬盘上的系统用ghost克隆到vhd上，这需要在另一个windows系统或PE下进行，然后添加这个vhd的启动项到BCD。</li>\n</ul>\n<p>vhd加上差分硬盘功能，就可以实现windows的快速恢复了。具体的一种做法是基于一个父vhd创建两个差分vhd，分别称为<code>Current.vhd</code>和<code>Recovery.vhd</code>，分别添加这两个差分vhd的启动项为 <strong>Current</strong> 和 <strong>Recovery</strong>，这样就相当于已经安装了两个windows系统。正常使用 <strong>Current</strong> 系统，需要恢复时重启到 <strong>Recovery</strong> 系统，删除原来的<code>Current.vhd</code>，然后再基于父vhd创建一个新的差分vhd并命名为<code>Current.vhd</code>，再重启到 <strong>Current</strong> 系统，就完成了系统恢复。其中Recovery系统不是必须的，因为只需要能够进行简单的文件操作，用一个PE系统代替也可以。</p>\n<p>系统盘的文件布局如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">C:.</div><div class=\"line\">│  Win8-Current.vhd    #正常工作系统</div><div class=\"line\">│  Win8-Recovery.vhd   #恢复用系统</div><div class=\"line\">│  Win8.vhd            #父vhd</div><div class=\"line\">│  bootmgr             #启动管理器  </div><div class=\"line\">└─boot                #系统启动相关文件</div><div class=\"line\">        bcd</div><div class=\"line\">        memtest.exe</div><div class=\"line\">        ...</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<p><code>bootice</code>是一个操作vhd和系统启动项的小工具。此外还有<code>EasyBCD</code>和一些PE工具。当然，可以直接使用Windows内置的命令行工具<code>bcdboot</code>和<code>bcdedit</code>。</p>\n<p>Linux <strong>还没有</strong> 类似 vhd native boot的功能。虽然grub支持ramdisk或iso启动项，但功能上还是有些差距。<br>最近推出的CoreOS采用了双分区滚动升级的做法，实现了类似的功能，不过需要占用两倍的系统存储空间（没有差分），好在CoreOS本身比较精简。</p>\n<p>前面提到可以将物理硬盘转换成虚拟硬盘，相当于实现了从物理机到虚拟机的转换 PM -&gt; VM；而 vhd native boot则相当于从 VM -&gt; PM。</p>\n<hr>\n<p>这个介绍数据中心的<a href=\"http://v.youku.com/v_show/id_XMTMyMTI1ODQ4NA==.html\" target=\"_blank\" rel=\"external\">视频</a> 里面有一段关于替换故障硬盘的细节值得注意。服务器的CPU，内存，硬盘和网卡 这几个主要部件里，因为硬盘是机械部件，而且一直在运转，不像普通机器大部分时间关机或休眠，所以是最容易出故障的，换硬盘应该是数据中心的日常维护工作了。 即便升级成没有了机械转动部件的SSD，还是有写入寿命的限制。</p>"},{"title":"【译文】Spanner, TrueTime 和CAP理论","date":"2017-03-05T16:00:00.000Z","_content":"作者：[Eric Brewer，VP, Infrastructure, Google](https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29)\n2017-02-14\n英文原文：[Spanner, TrueTime and the CAP Theorem](https://research.google.com/pubs/pub45855.html) ,[英文全文 PDF](https://research.google.com/pubs/archive/45855.pdf)\n[译文全文PDF](/doc/Spanner-TrueTime-CAP.pdf)\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n- [译者注](#%E8%AF%91%E8%80%85%E6%B3%A8)\n    - [CAP定理和一致性相关文章](#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0)\n    - [关于物理时间](#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4)\n    - [Cloud Spanner的相关报道](#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93)\n    - [分布式系统课程](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B)\n- [译文](#%E8%AF%91%E6%96%87)\n    - [Spanner声称同时达到了CA](#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca)\n    - [可用性的统计数据](#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE)\n    - [这就是网络](#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C)\n    - [网络分区时会发生什么](#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n    - [关于TrueTime](#%E5%85%B3%E4%BA%8Etruetime)\n    - [结论](#%E7%BB%93%E8%AE%BA)\n    - [致谢](#%E8%87%B4%E8%B0%A2)\n    - [参考文献](#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)\n\n<!-- /TOC -->\n\n# 译者注\n[CAP定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer's theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “[哥德尔不完备性定理](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86)”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。\n实际上 **这个定理的重要性被高估了**。注意到 **就是本文的作者（Eric Brewer）提出了CAP定理**，而他还在2012年发表了一篇文章 “[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 的文章，再加上这篇 **借Spanner来讨论CAP定理** 的文章，实际上是委婉地承认了这一点。\n\nCAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。\n**网络总是可能会断的**。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 **在正常情况下并没有什么作用**。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 **准备预案**，可能是 **技术上的**，也可能是 **公关** 预案）。 **AC** 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。\nCAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：\n+ 对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？\n+ 对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ **12306.cn** 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。\n+ 对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 这篇文章中也有讨论。\n\n## CAP定理和一致性相关文章\nBlog\n+ [不懂点CAP理论，你好意思说你是做分布式的吗？](http://www.yunweipai.com/archives/8432.html)\n+ [You Can’t Sacrifice Partition Tolerance](https://codahale.com/you-cant-sacrifice-partition-tolerance/)\n+ [Please stop calling databases CP or AP](http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n+ [关于网络分区的一篇blog](https://github.com/aphyr/partitions-post)\n\nPaper\n+ [Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305](http://queue.acm.org/detail.cfm?id=2462076)\n+ [Replicated Data Consistency Explained Through Baseball - CACM1312](https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/)，译文[以棒球赛为例解释复制数据的一致性问题](/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf)\n+ [Quantifying Eventual Consistency with PBS - CACM1408](www.bailis.org/papers/pbs-vldbj2014.pd)，译文[利用PBS 量化最终一致性](/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf)；作者[Peter Bailis](http://www.bailis.org/)也是一位大牛。\n+ [Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems](http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf)， [IEEE Xplore上的版本](http://ieeexplore.ieee.org/document/7547362/)\n+ [PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach](https://www.ksp.kit.edu/9783731501862)\n+ [IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem's Growing Impact](http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638)\n+ [A Critique of the CAP Theorem](https://arxiv.org/abs/1509.05393)\n> The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a \"delay-sensitivity\" framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.\n\n## 关于物理时间\n+ [Toward higher precision - PTP协议 - CACM-2012-10](http://dl.acm.org/citation.cfm?id=2347750)\n+ [Time for Data Centers to Consider Time as a Service](https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf)\n+ [GPS - Global Positioning System - wiki](https://en.wikipedia.org/wiki/Global_Positioning_System)\n+ [中国北斗卫星导航系统白皮书](http://www.beidou.gov.cn/attach/beidou/China's%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf)\n> 正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，**授时精度优于50纳秒**。\n\n+ [Time Scales](http://www.ucolick.org/~sla/leapsecs/timescales.html)\n+ [长短波授时系统](http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html)\n\n如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）\n高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。\n通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 **固有的通信延迟不确定性**。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。\n+ [西安同步电子科技有限公司](http://www.syn029.com/h-index.html)，[他们的淘宝店](https://shop102437782.taobao.com/index.htm)\n+ [西安景驰电子科技有限公司](http://www.jingtech.cn/col.jsp?id=130)，[TS3200 系列GPS/BD 同步时钟 - 知乎专栏](https://zhuanlan.zhihu.com/p/21596625)\n+ [广州邦正电力科技有限公司](http://www.bonzn.cn/col.jsp?id=105)，\n\n为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。\n只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。\n\n## Cloud Spanner的相关报道\n[Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？](http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP)\n[Infoq - 谷歌对外发布了云Spanner Beta版](http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta)\n\n## 分布式系统课程\n+ [Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013](https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html)\n+ [MIT 6.824: Distributed Systems - Spring 2016](http://nil.csail.mit.edu/6.824/2016/schedule.html)\n+ [分布式算法入门](http://www.bigoh.net/wiki/index.php/Dis-alg)\n+ [Notes on Distributed Systems for Young Bloods](https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/)\n\n-----\n\n# 译文\n\nSpanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。\nCAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：\n+ C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；\n+ A：读取和更新的100％可用性（Availability）；\n+ P：对网络分区（Partitions）的容忍。\n\n舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。\n对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。\n\n## Spanner声称同时达到了CA\n尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。\n纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。\n考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。\n第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。\n第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。\n\n## 可用性的统计数据\n在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。\n对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，**目前的广域分布的Chubby集群能提供99.99958％的平均可用性**（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。\n在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。\n![Spanner可用性数据](/img/spanner-availability.png)\n上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。\n+ 大量的事件（**用户事件**）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。\n+ **集群事件** 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。\n+ **运维事件** 是由SRE引起的事故，例如配置错误。\n+ **Bug事件** 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。\n+ **其它事件** 是各种大多只发生一次的问题。\n\n**网络事件** （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。\n总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：\n1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；\n2）由网络分区造成的运行中断应只占很小一部分。\nSpanner同时满足两者。\n\n## 这就是网络\n许多人认为，Spanner通过使用`TrueTime` 可以绕过CAP。`TrueTime` 是一个提供全局同步时钟的服务。`TrueTime` 是非比寻常的，但为实现CA，`TrueTime` 的作用并不显著。后面的小节会介绍`TrueTime` 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。\n首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。\n因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。\n虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。\n具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。\n\n## 网络分区时会发生什么\n为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。\n前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：\n+ 使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；\n+ 对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。\n\n在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。\n只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。\n除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。\n因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：\n1. 对于发起读操作的一侧网络分区，每个组至少存在一个副本\n2. 对于这些副本，读时间戳是过去的。\n\n如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。\n\n## 关于TrueTime\n通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，`TrueTime` 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。\nSpanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用`TrueTime` 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），** 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。**\n引自Liskov [Lis91，第7节]：\n> 同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。\n> ...\n> 该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。\n\nSpanner使用`TrueTime` 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。\nSpanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。\n然而，`TrueTime` 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。\n例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。\n`TrueTime` 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）`TrueTime` 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。\n你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。\n快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。\n`TrueTime` 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于`TrueTime` 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。\n\n## 结论\nSpanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。\nSpanner使用两阶段提交来实现顺序一致性，它使用`TrueTime` 实现外部一致性、无锁的一致性读取、以及一致性快照。\n \n## 致谢\n特别感谢Spanner 和`TrueTime` 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。\n\n## 参考文献\n[BK14] P. Bailis and K. Kingsbury. [The Network is Reliable](http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract), Communications of the ACM. Vol. 57 No. 9,\nPages 48-55. September 2014. Also: [https://aphyr.com/posts/288-the-network-is-reliable]\n[Bre12] E. Brewer. [CAP Twelve Years Later: How the “Rules” Have Changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed), IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23--29. [CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)（译注：这是本文作者之前的一篇文章）\n[Bur06] M. Burrows. [The Chubby lock service for loosely-coupled distributed systems](https://research.google.com/archive/chubby-osdi06.pdf). Proceedings of OSDI \\`06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.\n[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. [厦门大学计算机系 林子雨 老师的译文](http://dblab.xmu.edu.cn/post/google-spanner/)\n[Hel16] P. Helland. [Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!](http://queue.acm.org/detail.cfm?id=2953944) ACM Queue, Vol. 14, Issue 2, March-April 2016.\n[Lis91] B. Liskov. [Practical Uses of Synchronized Clocks in Distributed Systems](http://dl.acm.org/citation.cfm?id=112601). ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.\n[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. [ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging](http://dl.acm.org/citation.cfm?id=128770). ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.\n[Ree78] D. Reed. [Naming and Synchronization in a Decentralized Computer System](http://publications.csail.mit.edu/lcs/specpub.php?id=773), PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]\n\n\n-----\n\n![](/img/spanner-books.jpg)\n\n","source":"_posts/spanner-truetime-cap.md","raw":"title: 【译文】Spanner, TrueTime 和CAP理论\ncategory: [cloud]\ntags:\ndate: 2017-3-6\n---\n作者：[Eric Brewer，VP, Infrastructure, Google](https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29)\n2017-02-14\n英文原文：[Spanner, TrueTime and the CAP Theorem](https://research.google.com/pubs/pub45855.html) ,[英文全文 PDF](https://research.google.com/pubs/archive/45855.pdf)\n[译文全文PDF](/doc/Spanner-TrueTime-CAP.pdf)\n\n<!--more-->\n\n<!-- TOC -->\n\n    - [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n- [译者注](#%E8%AF%91%E8%80%85%E6%B3%A8)\n    - [CAP定理和一致性相关文章](#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0)\n    - [关于物理时间](#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4)\n    - [Cloud Spanner的相关报道](#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93)\n    - [分布式系统课程](#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B)\n- [译文](#%E8%AF%91%E6%96%87)\n    - [Spanner声称同时达到了CA](#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca)\n    - [可用性的统计数据](#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE)\n    - [这就是网络](#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C)\n    - [网络分区时会发生什么](#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)\n    - [关于TrueTime](#%E5%85%B3%E4%BA%8Etruetime)\n    - [结论](#%E7%BB%93%E8%AE%BA)\n    - [致谢](#%E8%87%B4%E8%B0%A2)\n    - [参考文献](#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)\n\n<!-- /TOC -->\n\n# 译者注\n[CAP定理](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer's theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “[哥德尔不完备性定理](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86)”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。\n实际上 **这个定理的重要性被高估了**。注意到 **就是本文的作者（Eric Brewer）提出了CAP定理**，而他还在2012年发表了一篇文章 “[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 的文章，再加上这篇 **借Spanner来讨论CAP定理** 的文章，实际上是委婉地承认了这一点。\n\nCAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。\n**网络总是可能会断的**。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 **在正常情况下并没有什么作用**。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 **准备预案**，可能是 **技术上的**，也可能是 **公关** 预案）。 **AC** 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。\nCAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：\n+ 对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？\n+ 对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ **12306.cn** 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。\n+ 对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“[CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)” 这篇文章中也有讨论。\n\n## CAP定理和一致性相关文章\nBlog\n+ [不懂点CAP理论，你好意思说你是做分布式的吗？](http://www.yunweipai.com/archives/8432.html)\n+ [You Can’t Sacrifice Partition Tolerance](https://codahale.com/you-cant-sacrifice-partition-tolerance/)\n+ [Please stop calling databases CP or AP](http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html)\n+ [关于网络分区的一篇blog](https://github.com/aphyr/partitions-post)\n\nPaper\n+ [Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305](http://queue.acm.org/detail.cfm?id=2462076)\n+ [Replicated Data Consistency Explained Through Baseball - CACM1312](https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/)，译文[以棒球赛为例解释复制数据的一致性问题](/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf)\n+ [Quantifying Eventual Consistency with PBS - CACM1408](www.bailis.org/papers/pbs-vldbj2014.pd)，译文[利用PBS 量化最终一致性](/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf)；作者[Peter Bailis](http://www.bailis.org/)也是一位大牛。\n+ [Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems](http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf)， [IEEE Xplore上的版本](http://ieeexplore.ieee.org/document/7547362/)\n+ [PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach](https://www.ksp.kit.edu/9783731501862)\n+ [IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem's Growing Impact](http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638)\n+ [A Critique of the CAP Theorem](https://arxiv.org/abs/1509.05393)\n> The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a \"delay-sensitivity\" framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.\n\n## 关于物理时间\n+ [Toward higher precision - PTP协议 - CACM-2012-10](http://dl.acm.org/citation.cfm?id=2347750)\n+ [Time for Data Centers to Consider Time as a Service](https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf)\n+ [GPS - Global Positioning System - wiki](https://en.wikipedia.org/wiki/Global_Positioning_System)\n+ [中国北斗卫星导航系统白皮书](http://www.beidou.gov.cn/attach/beidou/China's%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf)\n> 正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，**授时精度优于50纳秒**。\n\n+ [Time Scales](http://www.ucolick.org/~sla/leapsecs/timescales.html)\n+ [长短波授时系统](http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html)\n\n如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）\n高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。\n通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 **固有的通信延迟不确定性**。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。\n+ [西安同步电子科技有限公司](http://www.syn029.com/h-index.html)，[他们的淘宝店](https://shop102437782.taobao.com/index.htm)\n+ [西安景驰电子科技有限公司](http://www.jingtech.cn/col.jsp?id=130)，[TS3200 系列GPS/BD 同步时钟 - 知乎专栏](https://zhuanlan.zhihu.com/p/21596625)\n+ [广州邦正电力科技有限公司](http://www.bonzn.cn/col.jsp?id=105)，\n\n为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。\n只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。\n\n## Cloud Spanner的相关报道\n[Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？](http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP)\n[Infoq - 谷歌对外发布了云Spanner Beta版](http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta)\n\n## 分布式系统课程\n+ [Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013](https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html)\n+ [MIT 6.824: Distributed Systems - Spring 2016](http://nil.csail.mit.edu/6.824/2016/schedule.html)\n+ [分布式算法入门](http://www.bigoh.net/wiki/index.php/Dis-alg)\n+ [Notes on Distributed Systems for Young Bloods](https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/)\n\n-----\n\n# 译文\n\nSpanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。\nCAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：\n+ C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；\n+ A：读取和更新的100％可用性（Availability）；\n+ P：对网络分区（Partitions）的容忍。\n\n舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。\n对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。\n\n## Spanner声称同时达到了CA\n尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。\n纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。\n考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。\n第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。\n第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。\n\n## 可用性的统计数据\n在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。\n对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，**目前的广域分布的Chubby集群能提供99.99958％的平均可用性**（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。\n在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。\n![Spanner可用性数据](/img/spanner-availability.png)\n上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。\n+ 大量的事件（**用户事件**）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。\n+ **集群事件** 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。\n+ **运维事件** 是由SRE引起的事故，例如配置错误。\n+ **Bug事件** 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。\n+ **其它事件** 是各种大多只发生一次的问题。\n\n**网络事件** （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。\n总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：\n1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；\n2）由网络分区造成的运行中断应只占很小一部分。\nSpanner同时满足两者。\n\n## 这就是网络\n许多人认为，Spanner通过使用`TrueTime` 可以绕过CAP。`TrueTime` 是一个提供全局同步时钟的服务。`TrueTime` 是非比寻常的，但为实现CA，`TrueTime` 的作用并不显著。后面的小节会介绍`TrueTime` 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。\n首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。\n因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。\n虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。\n具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。\n\n## 网络分区时会发生什么\n为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。\n前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：\n+ 使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；\n+ 对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。\n\n在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。\n只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。\n除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。\n因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：\n1. 对于发起读操作的一侧网络分区，每个组至少存在一个副本\n2. 对于这些副本，读时间戳是过去的。\n\n如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。\n\n## 关于TrueTime\n通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，`TrueTime` 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。\nSpanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用`TrueTime` 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），** 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。**\n引自Liskov [Lis91，第7节]：\n> 同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。\n> ...\n> 该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。\n\nSpanner使用`TrueTime` 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。\nSpanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。\n然而，`TrueTime` 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。\n例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。\n`TrueTime` 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）`TrueTime` 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。\n你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。\n快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。\n`TrueTime` 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于`TrueTime` 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。\n\n## 结论\nSpanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。\nSpanner使用两阶段提交来实现顺序一致性，它使用`TrueTime` 实现外部一致性、无锁的一致性读取、以及一致性快照。\n \n## 致谢\n特别感谢Spanner 和`TrueTime` 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。\n\n## 参考文献\n[BK14] P. Bailis and K. Kingsbury. [The Network is Reliable](http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract), Communications of the ACM. Vol. 57 No. 9,\nPages 48-55. September 2014. Also: [https://aphyr.com/posts/288-the-network-is-reliable]\n[Bre12] E. Brewer. [CAP Twelve Years Later: How the “Rules” Have Changed](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed), IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23--29. [CAP理论十二年回顾：\"规则\"变了](http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed)（译注：这是本文作者之前的一篇文章）\n[Bur06] M. Burrows. [The Chubby lock service for loosely-coupled distributed systems](https://research.google.com/archive/chubby-osdi06.pdf). Proceedings of OSDI \\`06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.\n[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. [厦门大学计算机系 林子雨 老师的译文](http://dblab.xmu.edu.cn/post/google-spanner/)\n[Hel16] P. Helland. [Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!](http://queue.acm.org/detail.cfm?id=2953944) ACM Queue, Vol. 14, Issue 2, March-April 2016.\n[Lis91] B. Liskov. [Practical Uses of Synchronized Clocks in Distributed Systems](http://dl.acm.org/citation.cfm?id=112601). ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.\n[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. [ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging](http://dl.acm.org/citation.cfm?id=128770). ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.\n[Ree78] D. Reed. [Naming and Synchronization in a Decentralized Computer System](http://publications.csail.mit.edu/lcs/specpub.php?id=773), PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]\n\n\n-----\n\n![](/img/spanner-books.jpg)\n\n","slug":"spanner-truetime-cap","published":1,"updated":"2017-10-30T03:41:56.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh5000o9s4fp1jsh6uq","content":"<p>作者：<a href=\"https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29\" target=\"_blank\" rel=\"external\">Eric Brewer，VP, Infrastructure, Google</a><br>2017-02-14<br>英文原文：<a href=\"https://research.google.com/pubs/pub45855.html\" target=\"_blank\" rel=\"external\">Spanner, TrueTime and the CAP Theorem</a> ,<a href=\"https://research.google.com/pubs/archive/45855.pdf\" target=\"_blank\" rel=\"external\">英文全文 PDF</a><br><a href=\"/doc/Spanner-TrueTime-CAP.pdf\">译文全文PDF</a></p>\n<a id=\"more\"></a>\n<!-- TOC -->\n<pre><code>- [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n</code></pre><ul>\n<li><a href=\"#%E8%AF%91%E8%80%85%E6%B3%A8\">译者注</a><ul>\n<li><a href=\"#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0\">CAP定理和一致性相关文章</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4\">关于物理时间</a></li>\n<li><a href=\"#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93\">Cloud Spanner的相关报道</a></li>\n<li><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B\">分布式系统课程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%91%E6%96%87\">译文</a><ul>\n<li><a href=\"#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca\">Spanner声称同时达到了CA</a></li>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE\">可用性的统计数据</a></li>\n<li><a href=\"#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C\">这就是网络</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\">网络分区时会发生什么</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8Etruetime\">关于TrueTime</a></li>\n<li><a href=\"#%E7%BB%93%E8%AE%BA\">结论</a></li>\n<li><a href=\"#%E8%87%B4%E8%B0%A2\">致谢</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"译者注\"><a href=\"#译者注\" class=\"headerlink\" title=\"译者注\"></a>译者注</h1><p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">CAP定理</a>是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer’s theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “<a href=\"https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">哥德尔不完备性定理</a>”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。<br>实际上 <strong>这个定理的重要性被高估了</strong>。注意到 <strong>就是本文的作者（Eric Brewer）提出了CAP定理</strong>，而他还在2012年发表了一篇文章 “<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 的文章，再加上这篇 <strong>借Spanner来讨论CAP定理</strong> 的文章，实际上是委婉地承认了这一点。</p>\n<p>CAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。<br><strong>网络总是可能会断的</strong>。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 <strong>在正常情况下并没有什么作用</strong>。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 <strong>准备预案</strong>，可能是 <strong>技术上的</strong>，也可能是 <strong>公关</strong> 预案）。 <strong>AC</strong> 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。<br>CAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：</p>\n<ul>\n<li>对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？</li>\n<li>对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ <strong>12306.cn</strong> 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。</li>\n<li>对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 这篇文章中也有讨论。</li>\n</ul>\n<h2 id=\"CAP定理和一致性相关文章\"><a href=\"#CAP定理和一致性相关文章\" class=\"headerlink\" title=\"CAP定理和一致性相关文章\"></a>CAP定理和一致性相关文章</h2><p>Blog</p>\n<ul>\n<li><a href=\"http://www.yunweipai.com/archives/8432.html\" target=\"_blank\" rel=\"external\">不懂点CAP理论，你好意思说你是做分布式的吗？</a></li>\n<li><a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" target=\"_blank\" rel=\"external\">You Can’t Sacrifice Partition Tolerance</a></li>\n<li><a href=\"http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"external\">Please stop calling databases CP or AP</a></li>\n<li><a href=\"https://github.com/aphyr/partitions-post\" target=\"_blank\" rel=\"external\">关于网络分区的一篇blog</a></li>\n</ul>\n<p>Paper</p>\n<ul>\n<li><a href=\"http://queue.acm.org/detail.cfm?id=2462076\" target=\"_blank\" rel=\"external\">Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/\" target=\"_blank\" rel=\"external\">Replicated Data Consistency Explained Through Baseball - CACM1312</a>，译文<a href=\"/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf\">以棒球赛为例解释复制数据的一致性问题</a></li>\n<li><a href=\"www.bailis.org/papers/pbs-vldbj2014.pd\">Quantifying Eventual Consistency with PBS - CACM1408</a>，译文<a href=\"/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf\">利用PBS 量化最终一致性</a>；作者<a href=\"http://www.bailis.org/\" target=\"_blank\" rel=\"external\">Peter Bailis</a>也是一位大牛。</li>\n<li><a href=\"http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf\" target=\"_blank\" rel=\"external\">Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems</a>， <a href=\"http://ieeexplore.ieee.org/document/7547362/\" target=\"_blank\" rel=\"external\">IEEE Xplore上的版本</a></li>\n<li><a href=\"https://www.ksp.kit.edu/9783731501862\" target=\"_blank\" rel=\"external\">PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach</a></li>\n<li><a href=\"http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638\" target=\"_blank\" rel=\"external\">IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem’s Growing Impact</a></li>\n<li><a href=\"https://arxiv.org/abs/1509.05393\" target=\"_blank\" rel=\"external\">A Critique of the CAP Theorem</a><blockquote>\n<p>The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a “delay-sensitivity” framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"关于物理时间\"><a href=\"#关于物理时间\" class=\"headerlink\" title=\"关于物理时间\"></a>关于物理时间</h2><ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=2347750\" target=\"_blank\" rel=\"external\">Toward higher precision - PTP协议 - CACM-2012-10</a></li>\n<li><a href=\"https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf\" target=\"_blank\" rel=\"external\">Time for Data Centers to Consider Time as a Service</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Global_Positioning_System\" target=\"_blank\" rel=\"external\">GPS - Global Positioning System - wiki</a></li>\n<li><p><a href=\"http://www.beidou.gov.cn/attach/beidou/China&#39;s%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf\" target=\"_blank\" rel=\"external\">中国北斗卫星导航系统白皮书</a></p>\n<blockquote>\n<p>正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，<strong>授时精度优于50纳秒</strong>。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.ucolick.org/~sla/leapsecs/timescales.html\" target=\"_blank\" rel=\"external\">Time Scales</a></p>\n</li>\n<li><a href=\"http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html\" target=\"_blank\" rel=\"external\">长短波授时系统</a></li>\n</ul>\n<p>如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）<br>高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。<br>通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 <strong>固有的通信延迟不确定性</strong>。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。</p>\n<ul>\n<li><a href=\"http://www.syn029.com/h-index.html\" target=\"_blank\" rel=\"external\">西安同步电子科技有限公司</a>，<a href=\"https://shop102437782.taobao.com/index.htm\" target=\"_blank\" rel=\"external\">他们的淘宝店</a></li>\n<li><a href=\"http://www.jingtech.cn/col.jsp?id=130\" target=\"_blank\" rel=\"external\">西安景驰电子科技有限公司</a>，<a href=\"https://zhuanlan.zhihu.com/p/21596625\" target=\"_blank\" rel=\"external\">TS3200 系列GPS/BD 同步时钟 - 知乎专栏</a></li>\n<li><a href=\"http://www.bonzn.cn/col.jsp?id=105\" target=\"_blank\" rel=\"external\">广州邦正电力科技有限公司</a>，</li>\n</ul>\n<p>为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。<br>只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。</p>\n<h2 id=\"Cloud-Spanner的相关报道\"><a href=\"#Cloud-Spanner的相关报道\" class=\"headerlink\" title=\"Cloud Spanner的相关报道\"></a>Cloud Spanner的相关报道</h2><p><a href=\"http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP\" target=\"_blank\" rel=\"external\">Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？</a><br><a href=\"http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta\" target=\"_blank\" rel=\"external\">Infoq - 谷歌对外发布了云Spanner Beta版</a></p>\n<h2 id=\"分布式系统课程\"><a href=\"#分布式系统课程\" class=\"headerlink\" title=\"分布式系统课程\"></a>分布式系统课程</h2><ul>\n<li><a href=\"https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html\" target=\"_blank\" rel=\"external\">Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013</a></li>\n<li><a href=\"http://nil.csail.mit.edu/6.824/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.824: Distributed Systems - Spring 2016</a></li>\n<li><a href=\"http://www.bigoh.net/wiki/index.php/Dis-alg\" target=\"_blank\" rel=\"external\">分布式算法入门</a></li>\n<li><a href=\"https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/\" target=\"_blank\" rel=\"external\">Notes on Distributed Systems for Young Bloods</a></li>\n</ul>\n<hr>\n<h1 id=\"译文\"><a href=\"#译文\" class=\"headerlink\" title=\"译文\"></a>译文</h1><p>Spanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。<br>CAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：</p>\n<ul>\n<li>C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；</li>\n<li>A：读取和更新的100％可用性（Availability）；</li>\n<li>P：对网络分区（Partitions）的容忍。</li>\n</ul>\n<p>舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。<br>对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。</p>\n<h2 id=\"Spanner声称同时达到了CA\"><a href=\"#Spanner声称同时达到了CA\" class=\"headerlink\" title=\"Spanner声称同时达到了CA\"></a>Spanner声称同时达到了CA</h2><p>尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。<br>纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。<br>考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。<br>第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。<br>第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。</p>\n<h2 id=\"可用性的统计数据\"><a href=\"#可用性的统计数据\" class=\"headerlink\" title=\"可用性的统计数据\"></a>可用性的统计数据</h2><p>在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。<br>对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，<strong>目前的广域分布的Chubby集群能提供99.99958％的平均可用性</strong>（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。<br>在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。<br><img src=\"/img/spanner-availability.png\" alt=\"Spanner可用性数据\"><br>上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。</p>\n<ul>\n<li>大量的事件（<strong>用户事件</strong>）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。</li>\n<li><strong>集群事件</strong> 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。</li>\n<li><strong>运维事件</strong> 是由SRE引起的事故，例如配置错误。</li>\n<li><strong>Bug事件</strong> 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。</li>\n<li><strong>其它事件</strong> 是各种大多只发生一次的问题。</li>\n</ul>\n<p><strong>网络事件</strong> （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。<br>总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：<br>1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；<br>2）由网络分区造成的运行中断应只占很小一部分。<br>Spanner同时满足两者。</p>\n<h2 id=\"这就是网络\"><a href=\"#这就是网络\" class=\"headerlink\" title=\"这就是网络\"></a>这就是网络</h2><p>许多人认为，Spanner通过使用<code>TrueTime</code> 可以绕过CAP。<code>TrueTime</code> 是一个提供全局同步时钟的服务。<code>TrueTime</code> 是非比寻常的，但为实现CA，<code>TrueTime</code> 的作用并不显著。后面的小节会介绍<code>TrueTime</code> 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。<br>首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。<br>因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。<br>虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。<br>具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。</p>\n<h2 id=\"网络分区时会发生什么\"><a href=\"#网络分区时会发生什么\" class=\"headerlink\" title=\"网络分区时会发生什么\"></a>网络分区时会发生什么</h2><p>为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。<br>前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：</p>\n<ul>\n<li>使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；</li>\n<li>对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。</li>\n</ul>\n<p>在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。<br>只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。<br>除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。<br>因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：</p>\n<ol>\n<li>对于发起读操作的一侧网络分区，每个组至少存在一个副本</li>\n<li>对于这些副本，读时间戳是过去的。</li>\n</ol>\n<p>如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。</p>\n<h2 id=\"关于TrueTime\"><a href=\"#关于TrueTime\" class=\"headerlink\" title=\"关于TrueTime\"></a>关于TrueTime</h2><p>通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，<code>TrueTime</code> 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。<br>Spanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用<code>TrueTime</code> 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），<strong> 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。</strong><br>引自Liskov [Lis91，第7节]：</p>\n<blockquote>\n<p>同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。<br>…<br>该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。</p>\n</blockquote>\n<p>Spanner使用<code>TrueTime</code> 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。<br>Spanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。<br>然而，<code>TrueTime</code> 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。<br>例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。<br><code>TrueTime</code> 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）<code>TrueTime</code> 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。<br>你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。<br>快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。<br><code>TrueTime</code> 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于<code>TrueTime</code> 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Spanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。<br>Spanner使用两阶段提交来实现顺序一致性，它使用<code>TrueTime</code> 实现外部一致性、无锁的一致性读取、以及一致性快照。\n </p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>特别感谢Spanner 和<code>TrueTime</code> 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[BK14] P. Bailis and K. Kingsbury. <a href=\"http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract\" target=\"_blank\" rel=\"external\">The Network is Reliable</a>, Communications of the ACM. Vol. 57 No. 9,<br>Pages 48-55. September 2014. Also: [<a href=\"https://aphyr.com/posts/288-the-network-is-reliable\" target=\"_blank\" rel=\"external\">https://aphyr.com/posts/288-the-network-is-reliable</a>]<br>[Bre12] E. Brewer. <a href=\"https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP Twelve Years Later: How the “Rules” Have Changed</a>, IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23–29. <a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>（译注：这是本文作者之前的一篇文章）<br>[Bur06] M. Burrows. <a href=\"https://research.google.com/archive/chubby-osdi06.pdf\" target=\"_blank\" rel=\"external\">The Chubby lock service for loosely-coupled distributed systems</a>. Proceedings of OSDI `06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.<br>[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. <a href=\"http://dblab.xmu.edu.cn/post/google-spanner/\" target=\"_blank\" rel=\"external\">厦门大学计算机系 林子雨 老师的译文</a><br>[Hel16] P. Helland. <a href=\"http://queue.acm.org/detail.cfm?id=2953944\" target=\"_blank\" rel=\"external\">Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!</a> ACM Queue, Vol. 14, Issue 2, March-April 2016.<br>[Lis91] B. Liskov. <a href=\"http://dl.acm.org/citation.cfm?id=112601\" target=\"_blank\" rel=\"external\">Practical Uses of Synchronized Clocks in Distributed Systems</a>. ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.<br>[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. <a href=\"http://dl.acm.org/citation.cfm?id=128770\" target=\"_blank\" rel=\"external\">ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>. ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.<br>[Ree78] D. Reed. <a href=\"http://publications.csail.mit.edu/lcs/specpub.php?id=773\" target=\"_blank\" rel=\"external\">Naming and Synchronization in a Decentralized Computer System</a>, PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]</p>\n<hr>\n<p><img src=\"/img/spanner-books.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>作者：<a href=\"https://en.wikipedia.org/wiki/Eric_Brewer_%28scientist%29\" target=\"_blank\" rel=\"external\">Eric Brewer，VP, Infrastructure, Google</a><br>2017-02-14<br>英文原文：<a href=\"https://research.google.com/pubs/pub45855.html\" target=\"_blank\" rel=\"external\">Spanner, TrueTime and the CAP Theorem</a> ,<a href=\"https://research.google.com/pubs/archive/45855.pdf\" target=\"_blank\" rel=\"external\">英文全文 PDF</a><br><a href=\"/doc/Spanner-TrueTime-CAP.pdf\">译文全文PDF</a></p>","more":"<!-- TOC -->\n<pre><code>- [title: 【译文】Spanner, TrueTime 和CAP理论](#title-%E3%80%90%E8%AF%91%E6%96%87%E3%80%91spanner-truetime-%E5%92%8Ccap%E7%90%86%E8%AE%BA)\n</code></pre><ul>\n<li><a href=\"#%E8%AF%91%E8%80%85%E6%B3%A8\">译者注</a><ul>\n<li><a href=\"#cap%E5%AE%9A%E7%90%86%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0\">CAP定理和一致性相关文章</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E7%89%A9%E7%90%86%E6%97%B6%E9%97%B4\">关于物理时间</a></li>\n<li><a href=\"#cloud-spanner%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93\">Cloud Spanner的相关报道</a></li>\n<li><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B\">分布式系统课程</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AF%91%E6%96%87\">译文</a><ul>\n<li><a href=\"#spanner%E5%A3%B0%E7%A7%B0%E5%90%8C%E6%97%B6%E8%BE%BE%E5%88%B0%E4%BA%86ca\">Spanner声称同时达到了CA</a></li>\n<li><a href=\"#%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE\">可用性的统计数据</a></li>\n<li><a href=\"#%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C\">这就是网络</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\">网络分区时会发生什么</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8Etruetime\">关于TrueTime</a></li>\n<li><a href=\"#%E7%BB%93%E8%AE%BA\">结论</a></li>\n<li><a href=\"#%E8%87%B4%E8%B0%A2\">致谢</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"译者注\"><a href=\"#译者注\" class=\"headerlink\" title=\"译者注\"></a>译者注</h1><p><a href=\"https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">CAP定理</a>是分布式系统中一个“著名”的结论，它又被称为布鲁尔定理（Brewer’s theorem，看看上面的本文作者是谁？）。CAP定理说的是一种不可能性，可能让人联想到另一个类似的不可能定理 “<a href=\"https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86\" target=\"_blank\" rel=\"external\">哥德尔不完备性定理</a>”。CAP定理可能是互联网公司在面试时用来区分科班和半路出家程序员的必考题了。<br>实际上 <strong>这个定理的重要性被高估了</strong>。注意到 <strong>就是本文的作者（Eric Brewer）提出了CAP定理</strong>，而他还在2012年发表了一篇文章 “<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 的文章，再加上这篇 <strong>借Spanner来讨论CAP定理</strong> 的文章，实际上是委婉地承认了这一点。</p>\n<p>CAP定理说这3个字母最多只能同时实现2个字母的组合，但这3个字母并非同一层次的概念：A（可用性）和C（一致性）是数据副本的属性，但P（容忍网络分区）反映的是物理世界网络的状态。<br><strong>网络总是可能会断的</strong>。为实现A，需要客户端到服务器之间的网络正常，为实现C，需要服务器之间的网络正常。如果网络一切正常，那么AC能同时实现，CAP定理 <strong>在正常情况下并没有什么作用</strong>。如果网络中断，AC或者有1个无法实现，或者2个都无法实现，好吧，等着挨老板的骂吧（一个更好的办法是 <strong>准备预案</strong>，可能是 <strong>技术上的</strong>，也可能是 <strong>公关</strong> 预案）。 <strong>AC</strong> 不可能同时实现，是物理世界本身的限制。 下面的文章中认为Google的网络可靠性是足够高的，所以他们认为同时实现了CAP。<br>CAP只是一个定性的理论，讨论的情况或者是0， 或者是100%。首先，工程上的事没有什么能100%，比如系统可用性，可以说99.99%，99.999%，但没有一个工程师拍胸脯说能达到100%；其次，这3个字母都是可以更细致地量化的（C的量化比较复杂）：</p>\n<ul>\n<li>对于P，如果一台机器与集群失联了，一般不会认为发生了网络分区，分布式集群的管理系统应该能够容忍这个故障，继续正常运行；那么2台机器呢，n台机器呢？恰好 1：1的分裂为2个分区只是无数可能中的一种，其概率是 0 （$ 1/\\infty $）。到何种程度才认为处于网络分区状态呢？</li>\n<li>对于A，就是常说的“n个9”了，通过可用时间可以准确地测量。如果一个系统不可用会怎样？ <strong>12306.cn</strong> 网站每天23:00~06:00停止购票服务，好像也没有造成多大的不便嘛。</li>\n<li>对于C，一致性的量化比较复杂，从Linearisability，Atomicity/Strong Consistency，到Eventually Consistency，有多种不同程度的一致性。对于最终一致性（Eventually Consistency），而言，多久算是 “最终” 也是需要量化的。关于量化这一点，在“<a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>” 这篇文章中也有讨论。</li>\n</ul>\n<h2 id=\"CAP定理和一致性相关文章\"><a href=\"#CAP定理和一致性相关文章\" class=\"headerlink\" title=\"CAP定理和一致性相关文章\"></a>CAP定理和一致性相关文章</h2><p>Blog</p>\n<ul>\n<li><a href=\"http://www.yunweipai.com/archives/8432.html\" target=\"_blank\" rel=\"external\">不懂点CAP理论，你好意思说你是做分布式的吗？</a></li>\n<li><a href=\"https://codahale.com/you-cant-sacrifice-partition-tolerance/\" target=\"_blank\" rel=\"external\">You Can’t Sacrifice Partition Tolerance</a></li>\n<li><a href=\"http://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\" target=\"_blank\" rel=\"external\">Please stop calling databases CP or AP</a></li>\n<li><a href=\"https://github.com/aphyr/partitions-post\" target=\"_blank\" rel=\"external\">关于网络分区的一篇blog</a></li>\n</ul>\n<p>Paper</p>\n<ul>\n<li><a href=\"http://queue.acm.org/detail.cfm?id=2462076\" target=\"_blank\" rel=\"external\">Eventual Consistency Today - Limitations, Extensions,and Beyond - CACM1305</a></li>\n<li><a href=\"https://www.microsoft.com/en-us/research/publication/replicated-data-consistency-explained-through-baseball/\" target=\"_blank\" rel=\"external\">Replicated Data Consistency Explained Through Baseball - CACM1312</a>，译文<a href=\"/doc/CACM1312_Replicated_Data_Consistency_Explained_Through_Baseball.pdf\">以棒球赛为例解释复制数据的一致性问题</a></li>\n<li><a href=\"www.bailis.org/papers/pbs-vldbj2014.pd\">Quantifying Eventual Consistency with PBS - CACM1408</a>，译文<a href=\"/doc/CACM1408_Quantifying_Eventual_Consistency_with_PBS.pdf\">利用PBS 量化最终一致性</a>；作者<a href=\"http://www.bailis.org/\" target=\"_blank\" rel=\"external\">Peter Bailis</a>也是一位大牛。</li>\n<li><a href=\"http://cs.nju.edu.cn/yuhuang/huangyufiles/papers/2017-pa2a-tc.pdf\" target=\"_blank\" rel=\"external\">Probabilistically-Atomic 2-Atomicity: Enabling Almost Strong Consistency in Distributed Storage Systems</a>， <a href=\"http://ieeexplore.ieee.org/document/7547362/\" target=\"_blank\" rel=\"external\">IEEE Xplore上的版本</a></li>\n<li><a href=\"https://www.ksp.kit.edu/9783731501862\" target=\"_blank\" rel=\"external\">PhD14 - Benchmarking Eventually Consistent Distributed Storage System - David Bermbach</a></li>\n<li><a href=\"http://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=6155638\" target=\"_blank\" rel=\"external\">IEEE Computer - ( Vol. 45 Issue 2 ) The CAP Theorem’s Growing Impact</a></li>\n<li><a href=\"https://arxiv.org/abs/1509.05393\" target=\"_blank\" rel=\"external\">A Critique of the CAP Theorem</a><blockquote>\n<p>The CAP Theorem is a frequently cited impossibility result in distributed systems, especially among NoSQL distributed databases. In this paper we survey some of the confusion about the meaning of CAP, including inconsistencies and ambiguities in its definitions, and we highlight some problems in its formalization. CAP is often interpreted as proof that eventually consistent databases have better availability properties than strongly consistent databases; although there is some truth in this, we show that more careful reasoning is required. These problems cast doubt on the utility of CAP as a tool for reasoning about trade-offs in practical systems. As alternative to CAP, we propose a “delay-sensitivity” framework, which analyzes the sensitivity of operation latency to network delay, and which may help practitioners reason about the trade-offs between consistency guarantees and tolerance of network faults.</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"关于物理时间\"><a href=\"#关于物理时间\" class=\"headerlink\" title=\"关于物理时间\"></a>关于物理时间</h2><ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=2347750\" target=\"_blank\" rel=\"external\">Toward higher precision - PTP协议 - CACM-2012-10</a></li>\n<li><a href=\"https://spectracom.com/sites/default/files/document-files/Time%20for%20Datacenters%20to%20Consider%20Time%20as%20a%20Service_WP12-101_A.pdf\" target=\"_blank\" rel=\"external\">Time for Data Centers to Consider Time as a Service</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Global_Positioning_System\" target=\"_blank\" rel=\"external\">GPS - Global Positioning System - wiki</a></li>\n<li><p><a href=\"http://www.beidou.gov.cn/attach/beidou/China&#39;s%20BeiDou%20Navigation%20Satellite%20System%28Chinese%29.pdf\" target=\"_blank\" rel=\"external\">中国北斗卫星导航系统白皮书</a></p>\n<blockquote>\n<p>正在运行的北斗二号系统发播B1I和B2I公开服务信号，免费向亚太地区提供公开服务。服务区为南北纬55度、东经55度到180度区域，定位精度优于10米，测速精度优于0.2米/秒，<strong>授时精度优于50纳秒</strong>。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.ucolick.org/~sla/leapsecs/timescales.html\" target=\"_blank\" rel=\"external\">Time Scales</a></p>\n</li>\n<li><a href=\"http://gjss.ndrc.gov.cn/gzdtx/201309/t20130926_683874.html\" target=\"_blank\" rel=\"external\">长短波授时系统</a></li>\n</ul>\n<p>如果在万能的淘宝上搜“时钟同步服务器，GPS，北斗”，就会看到很多产品，价格不比一台服务器贵。比如下面的链接（免费的广告啊~~）<br>高精度的时间同步是一个系统工程。即便是局域网的范围，不是简单买一台NTP服务器，然后接到网络里就算完工了。当然，还是要看精度要求有多高，NTP的精度还是比较低的。<br>通过网络同步时间的问题在于计算机网络（以太网）尽力而为和多层协议带来的 <strong>固有的通信延迟不确定性</strong>。延迟大并不可怕，只要是稳定的延迟，就可以预先扣除，但延迟的不确定性就很难处理了。可能的方案是使用专用，没有任何协议的物理线路，就跟电力线路一样，延迟几乎没有波动。</p>\n<ul>\n<li><a href=\"http://www.syn029.com/h-index.html\" target=\"_blank\" rel=\"external\">西安同步电子科技有限公司</a>，<a href=\"https://shop102437782.taobao.com/index.htm\" target=\"_blank\" rel=\"external\">他们的淘宝店</a></li>\n<li><a href=\"http://www.jingtech.cn/col.jsp?id=130\" target=\"_blank\" rel=\"external\">西安景驰电子科技有限公司</a>，<a href=\"https://zhuanlan.zhihu.com/p/21596625\" target=\"_blank\" rel=\"external\">TS3200 系列GPS/BD 同步时钟 - 知乎专栏</a></li>\n<li><a href=\"http://www.bonzn.cn/col.jsp?id=105\" target=\"_blank\" rel=\"external\">广州邦正电力科技有限公司</a>，</li>\n</ul>\n<p>为什么2家都是西安的？不一定是巧合，很可能是因为中国科学院国家授时中心就在西安临潼。<br>只说GPS/北斗芯片的话，其实只有几十块钱，不但智能手机必备，现在比较流行的共享单车都装了这些定位芯片。当然，从一个GPS芯片到一个时钟同步服务器产品还是要有很多外围设备的，作为外行，就不深入讨论了。</p>\n<h2 id=\"Cloud-Spanner的相关报道\"><a href=\"#Cloud-Spanner的相关报道\" class=\"headerlink\" title=\"Cloud Spanner的相关报道\"></a>Cloud Spanner的相关报道</h2><p><a href=\"http://www.infoq.com/cn/news/2017/02/Google-Cloud-Spanner-hit-CAP\" target=\"_blank\" rel=\"external\">Infoq - 谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？</a><br><a href=\"http://www.infoq.com/cn/news/2017/03/google-cloud-spanner-beta\" target=\"_blank\" rel=\"external\">Infoq - 谷歌对外发布了云Spanner Beta版</a></p>\n<h2 id=\"分布式系统课程\"><a href=\"#分布式系统课程\" class=\"headerlink\" title=\"分布式系统课程\"></a>分布式系统课程</h2><ul>\n<li><a href=\"https://courses.cs.washington.edu/courses/cse552/13au/calendar/lecturelist.html\" target=\"_blank\" rel=\"external\">Washington Univ. CSE552: Distributed and Parallel Systems - Fall 2013</a></li>\n<li><a href=\"http://nil.csail.mit.edu/6.824/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.824: Distributed Systems - Spring 2016</a></li>\n<li><a href=\"http://www.bigoh.net/wiki/index.php/Dis-alg\" target=\"_blank\" rel=\"external\">分布式算法入门</a></li>\n<li><a href=\"https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/\" target=\"_blank\" rel=\"external\">Notes on Distributed Systems for Young Bloods</a></li>\n</ul>\n<hr>\n<h1 id=\"译文\"><a href=\"#译文\" class=\"headerlink\" title=\"译文\"></a>译文</h1><p>Spanner是Google的高可用的全球SQL数据库[CDE + 12：Spanner]。它管理着大规模的复制的数据。大规模既指数据量方面，又有事务量方面。它为写入其中的每项数据分配全局一致的实时时间戳，客户端可以在整个数据库上执行全局一致的读操作，而无需使用锁（译注：因为Spanner使用的是物理时间，而且是全球分布的，所以这里的全局既可以理解为逻辑上的整体，也可以理解为全球性的）。<br>CAP定理[Bre12]说，下面三个期望的属性中，你最多只能同时达到两个：</p>\n<ul>\n<li>C：一致性（Consistency），本文中我们可以认为这是指顺序一致性（Serializability）；</li>\n<li>A：读取和更新的100％可用性（Availability）；</li>\n<li>P：对网络分区（Partitions）的容忍。</li>\n</ul>\n<p>舍弃其中一个字母，就剩下三种系统：CA，CP和AP。请注意，并非自然就会有这三个属性中的两个，有许多系统只有其中的一个属性，甚至一个也没有。<br>对于“广域”上的分布式系统，通常认为网络分区是不可避免的，尽管不一定常见[BK14]。一旦你认为网络分区是不可避免的，任何分布式系统必须准备好放弃一致性（剩下AP）或可用性（剩下CP），这不是人们想做的选择。事实上，CAP定理的出发点是让设计者认真对待这种权衡。但是有两个重要的警告：首先，你只需要在实际发生网络分区期间放弃去某些东西，即时那时也有有许多缓解措施（参见文章“CAP理论12年回顾”[Bre12]）。其次，CAP定理关注的是100%可用性，而本文是关于现实的高可用性涉及的权衡（译注：高但不是100%）。</p>\n<h2 id=\"Spanner声称同时达到了CA\"><a href=\"#Spanner声称同时达到了CA\" class=\"headerlink\" title=\"Spanner声称同时达到了CA\"></a>Spanner声称同时达到了CA</h2><p>尽管是一个全球分布式系统，Spanner却声称具有一致性和高可用性，这意味着没有网络分区，因此很多人表示怀疑 。这是否意味着Spanner是CAP定义的CA系统？简短的答案是技术上“不是”，但效果上“是”，用户可以并确实认为是CA系统。<br>纯粹主义的答案是“否”，因为网络分区总是可能发生，事实上在Google也确实发生过。在网络分区时，Spanner选择C而放弃了A。因此从技术上来说，它是一个CP系统。我们下面探讨网络分区的影响。<br>考虑到始终提供一致性（C），Spanner声称为CA的真正问题是，它的核心用户是否认可它的可用性（A）。如果实际可用性足够高，用户可以忽略运行中断，则Spanner是可以声称达到了“有效CA”的。这并不意味着100％的可用性（Spanner目前和将来也不会提供），而是如5个或更多个“9”（即1/〖10〗^5或更少的失效）。反过来，真正的试金石是，那些希望自己本身的服务高可用的用户，他们是否会编写处理运行中断异常的代码：如果他们没有编写这些代码，那么他们已经假设Spanner的高可用性了。基于大量的Spanner内部用户，我们知道他们认为Spanner是高可用的。<br>第二点是存在许多其它运行中断的原因，除了“生死与共”的Spanner之外，其它原因也会让用户的服务失效。我们实际上关心差异化可用性，即用户是否确实已经发现Spanner已停掉了。差异化可用性比Spanner的实际可用性还要高。也就是说，你必须真的听到大树倒下的声音才算是出了麻烦（译注：也就是说，Spanner的短暂不可用不一定会立即造成用户的系统不可用）。<br>第三个问题是运行中断是否由于网络分区造成的。如果Spanner运行中断的主要原因不是网络分区，那么声称CA就更充分了。例如，任何数据库在所有副本都脱机的情况下都不能提供可用性，这与网络分区无关。这种多副本情况下的运行中断应该是非常罕见的，但如果网络分区的概率显著的更小，那么就可以有效地忽略网络分区对可用性的影响。对于Spanner，这意味着可用性中断的发生，实际并非是由于网络分区，而是一些其它的多种故障（因为单一故障不会造成可用性中断）。</p>\n<h2 id=\"可用性的统计数据\"><a href=\"#可用性的统计数据\" class=\"headerlink\" title=\"可用性的统计数据\"></a>可用性的统计数据</h2><p>在深入Spanner之前，值得先讨论一下Chubby的演进。Chubby是另一个提供CA的广域系统。在Chubby的论文[Bur06]中提到700天中发生了9次30 s或更长时间的运行中断，其中6次与网络相关（如[BK14]中讨论的）。这对应的可用性最多也不超过5个9，如果我们更贴近实际，假设每次中断平均有10 min，那么就只有4个9；如果每次中断有几个小时的话，就只有3个9了。<br>对于锁和一致性读/写操作，随着多项网络、架构和运维的改进，<strong>目前的广域分布的Chubby集群能提供99.99958％的平均可用性</strong>（即仅有30 s多一点的运行中断）。从2009年开始，由于可用性“超额”，Chubby的站点可靠性工程师（SRE）开始人为地强制定期中断服务（译注：即应急演习），以确保我们能发现对Chubby的依赖和其故障可能造成的影响。<br>在内部，Spanner提供与Chubby水平相当的可靠性，少于5.9 s。云版本与内部版本有相同的基础，但添加了一些新的部分，所以它的可靠性在短期内可能稍低一些。<br><img src=\"/img/spanner-availability.png\" alt=\"Spanner可用性数据\"><br>上面的饼图显示了内部Spanner意外事件的原因。事件是意外的，但并非所有都严重到中断服务。一些事件可以轻易地处理掉。图中的数值是事件发生的频率而不是造成的后果。</p>\n<ul>\n<li>大量的事件（<strong>用户事件</strong>）是由于用户错误，例如超载或配置错误，并且大多只影响该用户，然而其它类别则可能影响区域中的所有用户。</li>\n<li><strong>集群事件</strong> 反映除网络外的底层基础架构问题，如服务器和电源的问题。Spanner通过使用其它副本自动地处理这些事件，但有时需要SRE参与修复不完整的副本。</li>\n<li><strong>运维事件</strong> 是由SRE引起的事故，例如配置错误。</li>\n<li><strong>Bug事件</strong> 意味着软件bug触发的问题，这可能导致或大或小不同范围的运行中断。两个最大的中断都是由同时影响了某个数据库的所有副本的软件bug造成的。</li>\n<li><strong>其它事件</strong> 是各种大多只发生一次的问题。</li>\n</ul>\n<p><strong>网络事件</strong> （低于8％）是网络分区和网络配置问题。还没有发生过较大集群的网络分区事件，也没有发生过一个分区的少数一方超过Spanner的Quorum的情况。我们确实看到个别数据中心或区域与其它网络断开。我们还有一些错误配置，短时调低了带宽，还有一些与硬件故障相关的暂时的延迟。曾经有一个事件，其中某个方向的网络中断，导致一个奇怪的分区，必须通过关闭一些节点才能解决。到目前为止，网络事件没有造成过大规模的运行中断。<br>总而言之，要声称“有效CA”，系统必须处于这种相对概率状态：<br>1）至少它在实践中必须具有非常高的可用性，以便用户可以忽略异常；<br>2）由网络分区造成的运行中断应只占很小一部分。<br>Spanner同时满足两者。</p>\n<h2 id=\"这就是网络\"><a href=\"#这就是网络\" class=\"headerlink\" title=\"这就是网络\"></a>这就是网络</h2><p>许多人认为，Spanner通过使用<code>TrueTime</code> 可以绕过CAP。<code>TrueTime</code> 是一个提供全局同步时钟的服务。<code>TrueTime</code> 是非比寻常的，但为实现CA，<code>TrueTime</code> 的作用并不显著。后面的小节会介绍<code>TrueTime</code> 。某种程度说，Spanner的特别之处是，Google私有的广域网，加上多年的运维改进，显著降低了网络分区的发生，从而使高可用性成为可能。<br>首先，Google运行自己的私有全球网络。Spanner并非在公共的互联网上运行 —— 实际上，Spanner的每个数据包只流过Google控制的路由器和链路（不包括到远程客户端的任何边缘链路）。此外，每个数据中心通常至少有三个独立的光纤将其连接到私有的全球网络。因此确保任何两个数据中心之间有多条网络通路 。类似的，数据中心内的设备和链路也是冗余的。因此，通常的灾难性事件，如光纤被切断，不会导致网络分区或运行中断。<br>因此，网络分区的真正风险不是网络被切断，而是某些大范围的配置或软件升级同时破坏了多个链路。这是一个真正的风险，并且Google持续地努力防止和缓解这一风险。一般的策略是限制任何更新的影响范围（“爆炸半径”），以便我们不可避免地推送一个错误的变更后，它只破坏一部分链路或副本。我们在修复问题之前不会尝试任何其它变更。<br>虽然网络分区大大减少了，但光速是有限的。广域上的一致性操作的往返时间（RTT）下限仍比较大，洲际约有几十毫秒或更长。（光速约0.5 ft/ns，若洲际为1 000 mile的距离，约合5 000 000 ft，则最少需要10 ms）。Google将一个“区域”的范围限制在RTT 2 ms之内，以在延迟和容灾之间达到平衡。Spanner通过尽可能的事务批量化来缓解延迟，但这并不能降低单个事务的延迟。对于读操作，延迟通常较低，这是由于全局时间戳和使用本地副本的能力（如下节所述）。<br>具有较弱一致性的模型可能具有较低的更新延迟。然而，如果距离不够远，就会存在一个持久性较低的窗口。因为在数据被复制到另一个站点之前，如果本地站点遭受了灾害，所有的数据都可能被彻底破坏掉（译注：弱一致性模型会推迟数据的跨站点复制操作以降低延迟）。</p>\n<h2 id=\"网络分区时会发生什么\"><a href=\"#网络分区时会发生什么\" class=\"headerlink\" title=\"网络分区时会发生什么\"></a>网络分区时会发生什么</h2><p>为了理解分区，我们需要更多地了解一下Spanner的工作原理。和大多数ACID数据库一样，Spanner使用两阶段提交（2PC）和严格的两阶段锁，以确保隔离性和强一致性。2PC被称为“反可用性”协议[Hel16]，因为事务期间所有成员必须正常工作。为缓解这一问题，Spanner的每个成员实际是一个Paxos组（译注：多个节点组成逻辑上的单个节点），即便Paxos组中某个节点宕机了，每个2PC“成员”也是高可用的。每个分组也是数据放置和复制的基本单元。<br>前面提到，一般来说当发生网络分区时，Spanner会选择C而非A。在实践中，这是考虑到：</p>\n<ul>\n<li>使用Paxos组来达成关于某个更新的共识；如果Paxos Leader由于网络分区而不能维持Quorum，则更新被暂停，并且系统不可用（由CAP的定义）。最终，如果大多数成员可用的话，新的Leader就可能选举出来；</li>\n<li>对跨组事务使用2PC还意味着组内成员的网络分区可以阻止提交。</li>\n</ul>\n<p>在实践中最可能的结果是，网络分区的一侧满足Quorum，并将继续运行，也许需要重新选举Leader。因此，服务继续可用，但是另一侧分区的成员数较少，不满足Quorum，它们的用户无法访问该服务。这个例子说明了差异化可用性的重要性：那些无法访问服务的用户可能会有其它更严重的问题，例如失去连接，也可能已经宕机了。这意味着构建在Spanner之上的多区域服务，即使在网络分区时也能相对良好地运行。存在比较小的可能性，Spanner的某一部分会完全不可用。<br>只要所有事务相关的组都有Quorum选举的Leader，并位于分区的同一侧，Spanner中的事务就会正常运行。这意味着一些事务正常提交，有些事务则会超时，但它们总是满足一致性的。Spanner的一个特性是，任何正常返回的读操作都是一致的，即使事务稍后终止了（由于超时在内的任何原因）。<br>除了常规事务之外，Spanner还支持快照读，即读取过去特定时刻的数据值。Spanner维护多个时间版本的值，每个版本都有一个时间戳，因此可以为快照读操作返回正确的版本。特别地，每个副本都知道生成快照的时间，并且任何副本能以本节点直接回复该时间点之前的读操作（除非它太旧了，以至于已经被垃圾收集）（译注：一般需要从多个节点读取数据并验证多数节点间是否一致）。类似地，很容易同时跨多个组异步读取。快照读完全不需要锁。事实上，只读事务被实现为在当前时刻（在任何最新的副本上）的快照读。<br>因此，快照读对网络分区而言更加健壮。特别的，快照读能在以下情况下正常工作：</p>\n<ol>\n<li>对于发起读操作的一侧网络分区，每个组至少存在一个副本</li>\n<li>对于这些副本，读时间戳是过去的。</li>\n</ol>\n<p>如果Leader由于网络分区而暂停（这可能一直持续到网络分区结束），这时第2种情况可能就不成立了。因为这一侧的网络分区上可能无法选出新的Leader（译注：见下节引用的解释）。在网络分区期间，时间戳在分区开始之前的读操作很可能在分区的两侧都能成功，因为任何可达的副本有要读取的数据就足够了。</p>\n<h2 id=\"关于TrueTime\"><a href=\"#关于TrueTime\" class=\"headerlink\" title=\"关于TrueTime\"></a>关于TrueTime</h2><p>通常，同步时钟可以用于避免分布式系统中的通信。Barbara Liskov提供了一个不错的概述和多个示例[Lis91] 。对于我们的目的，<code>TrueTime</code> 是一个误差有界但非0的全局同步时钟：它返回的是一个时间区间，能保证执行调用的真实时刻落在这个区间内。因此，如果两个区间不重叠，我们能明确地将调用按真实时间排序。但如果区间存在重叠，我们就无法给出这两个调用的顺序了（译注：即并发的）。<br>Spanner的一个微妙的之处是它用锁来实现顺序一致性（Serializability），但它用<code>TrueTime</code> 来实现外部一致性（External Consistency，接近于线性一致性，Linearizability）。Spanner的外部一致性不变量（Invariant）是：对任何两个事务 $T_1$ 和 $T_2$ （即使在地球的两端），<strong> 如果 $T_2$ 在 $T_1$ 提交之后才开始提交，则 $T_2$ 的时间戳大于 $T_1$ 的时间戳。</strong><br>引自Liskov [Lis91，第7节]：</p>\n<blockquote>\n<p>同步时钟可以用来降低违反外部一致性的概率。假设主节点（Primary）拥有租约（Lease，即一段时间的所有权），需要考虑整个副本组。副节点（Backup）发送到主节点的每条消息相当于是对主节点的一个租约。如果主节点持有一个来自次多数（Sub-majority ）副节点的未到期租约，则主节点能以单节点进行读操作。<br>…<br>该系统中的不变量是：每当主节点执行读取时，它持有来自多数副节点的一个有效租约。如果时钟不同步，这个不变量将不再成立。</p>\n</blockquote>\n<p>Spanner使用<code>TrueTime</code> 作为时钟，以确保不变量成立。具体地，在提交期间，Leader可能必须等待，直到它确定提交时间在过去（基于误差界限）。实践中，这种“提交等待”的时间并不太长，而且与（内部）事务通信并行地进行。一般来说，外部一致性需要单调增加的时间戳，“等待不确定性结束”也是一种常见的模式。<br>Spanner旨在通过对当选的Leader使用可顺延的租约，来延长Leader的在位时间（通常为10s）。如Liskov所讨论的，每次Quorum达成共识时（译注：可能是关于其它事项），租约就会被顺延，因为参与者刚刚验证了Leader是有效的。当Leader失效时，有两个选项：1）等待租约过期，然后选举新的Leader；或2）重启旧的Leader，这可能更快些。对于一些故障，我们可以发出一个“最后一息”的UDP数据包来释放租约，这是一个优化，以使租约尽快到期。由于计划外故障在Google的数据中心中很少见，所以长期的租约是合理的。租约还确保时间在Leader之间都是单调增长的，并且在没有Leader的情况下，使副节点能够在租约有效期内继续提供读取服务。<br>然而，<code>TrueTime</code> 的真正价值在于它在一致性快照方面的能力。回顾一下，多版本并发控制系统（Multi-Version Concurrency-Control systems，MVCC）[Ree78]有悠久的历史，它将旧版本分开保存，从而允许读取过时的版本，而不考虑当前的事务活动。这是一个非常有用和被低估的特性：具体到Spanner上，快照是一致的（在抓取快照时），因此如果你的系统中的某个不变量成立，它在快照中也会成立。即使你不知道是什么不变量！基本上，快照是在持续不断的多个事务之间抓取的，并且反映截至此时的所有内容，当然不会超过这些内容。如果没有事务一致的快照，则很难从过去的时刻重新开始，因为这种快照的内容可能反映的是未完成的事务，这种事务可能违反一些不变量或完整性约束。正是缺乏一致性，导致有时难以从备份恢复系统。特别是有可能出现数据损坏，需要手动修复 。<br>例如，考虑使用MapReduce对数据库执行大规模的分析查询。Bigtable存储着旧版本的数据，时间在数据分片上是“锯齿状”的，这使得结果不可预测，有时不一致（特别是对于较近的数据）。在Spanner上，同一个MapReduce可以选择精确的时间戳，并获得可重复和一致的结果。<br><code>TrueTime</code> 还使得跨多个独立系统抓取快照成为可能，只要它们使用（单调增加的）<code>TrueTime</code> 时间戳提交，对抓取快照的时间达成一致，并存储多个时间版本的数据（通常在日志中）。这不仅限于Spanner：你可以实现自己的事务系统，然后确保在两个系统（或甚至k个系统）上一致的快照。一般来说，在这些系统上需要一个2PC（同时持有锁）以就抓取快照的时间达成一致，并确认成功，但系统不需要就其它事项达成一致，甚至这些系统可能会有很大的差异。<br>你还可以使用时间戳做为工作流传递的令牌。例如，如果对系统进行更新，则可以将更新的时间戳传递到工作流的下一个阶段，以便可以确定系统时间是否在该事件之后。在网络分区的情况下，这可能是不成立的，在这种情况下，如果想要一致性，下一个阶段应该等待（或如果想要可用性就继续下去）。没有时间令牌，很难知道你是否需要等待。使用时间戳不是解决这个问题的唯一方法，但这种方法是优雅且健壮的，能够保证最终一致性（Eventual Consistency）。当不同的阶段没有约定规则且管理员不同时，这是特别有用的——因为双方可以在没有通信的情况下对时间达成一致 。<br>快照是关于过去的，但你也可以对未来达成一致。Spanner的一项特性是，为实现模式变更，可以就未来的某个时刻达成一致。这允许暂存对新模式的变更，以便能够同时提供新旧两个版本。一旦就绪，就可以选择一个时刻，在所有副本上以原子的方式切换到新的模式上（也可以选择暂存之前的时刻，但那时你可能还没有准备好）。至少理论上，你可以执行一些未来的操作，如计划删除或可预见的变更。<br><code>TrueTime</code> 本身可能受到网络分区的影响。时间的来源是GPS接收器和原子钟的组合，两者都可以通过它们自身的微小漂移来保持精确的时间（译注：微小漂移是保持时间同步的调节手段，并不是说这两种时钟源不稳定）。由于每个数据中心都有冗余的“Time Master”，因此网络分区的两侧很可能继续获取准确的时间。然而，各个节点需要与Time Master的网络连接，否则它们自己的时钟将偏移。因此，在网络分区期间，它们与Time Master的偏差会逐渐地增长，取决于本地时钟漂移的速率限值。基于<code>TrueTime</code> 的操作，例如Paxos Leader选举或事务提交，必须等待一段时间，但操作仍能够完成（假设2PC及Quorum通信正常）。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>Spanner合理地声称是一个“有效CA”系统。尽管运行在广域上，但它总是一致的，并达到了大于5个 9的可用性。与Chubby一样，同时达到CA在实践中是可能的，前提是像Google那样能控制整个网络，但这在广域上是罕见的。此外，还需要大量冗余的网络链路、处理相关故障的架构规划、以及非常细致的运维，特别是对于升级。如果还是不幸发生了运行中断，Spanner选择一致性而不是可用性。<br>Spanner使用两阶段提交来实现顺序一致性，它使用<code>TrueTime</code> 实现外部一致性、无锁的一致性读取、以及一致性快照。\n </p>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>特别感谢Spanner 和<code>TrueTime</code> 的专家：Andrew Fikes，Wilson Hsieh，和Peter Hochschild。 另外还要感谢 Brian Cooper，Kurt Rosenfeld，Chris Taylor，Susan Shepard，Sunil Mushran，Steve Middlekauff，Cliff Frey，Cian Cullinan，Robert Kubis，Deepti Srivastava，Sean Quinlan，Mike Burrows 和 Sebastian Kanthak。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>[BK14] P. Bailis and K. Kingsbury. <a href=\"http://cacm.acm.org/magazines/2014/9/177925-the-network-is-reliable/abstract\" target=\"_blank\" rel=\"external\">The Network is Reliable</a>, Communications of the ACM. Vol. 57 No. 9,<br>Pages 48-55. September 2014. Also: [<a href=\"https://aphyr.com/posts/288-the-network-is-reliable\" target=\"_blank\" rel=\"external\">https://aphyr.com/posts/288-the-network-is-reliable</a>]<br>[Bre12] E. Brewer. <a href=\"https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP Twelve Years Later: How the “Rules” Have Changed</a>, IEEE Computer, Vol. 45, Issue 2, February 2012. pp. 23–29. <a href=\"http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed\" target=\"_blank\" rel=\"external\">CAP理论十二年回顾：”规则”变了</a>（译注：这是本文作者之前的一篇文章）<br>[Bur06] M. Burrows. <a href=\"https://research.google.com/archive/chubby-osdi06.pdf\" target=\"_blank\" rel=\"external\">The Chubby lock service for loosely-coupled distributed systems</a>. Proceedings of OSDI `06: Fourth Symposium on Operating System Design and Implementation, Seattle, WA, November 2006.<br>[CDE+12] J. Corbett, J. Dean, et. al.  Spanner: Google’s Globally-Distributed Database. Proceedings of OSDI ‘12: Tenth Symposium on Operating System Design and Implementation, Hollywood, CA, October, 2012. <a href=\"http://dblab.xmu.edu.cn/post/google-spanner/\" target=\"_blank\" rel=\"external\">厦门大学计算机系 林子雨 老师的译文</a><br>[Hel16] P. Helland. <a href=\"http://queue.acm.org/detail.cfm?id=2953944\" target=\"_blank\" rel=\"external\">Standing on Giant Distributed Shoulders: Farsighted Physicists of Yore were Danged  Smart!</a> ACM Queue, Vol. 14, Issue 2, March-April 2016.<br>[Lis91] B. Liskov. <a href=\"http://dl.acm.org/citation.cfm?id=112601\" target=\"_blank\" rel=\"external\">Practical Uses of Synchronized Clocks in Distributed Systems</a>. ACM Principles of Distributed Computing (PODC). Montreal, Canada, August 1991.<br>[MHL+92] C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh and P. Schwartz. <a href=\"http://dl.acm.org/citation.cfm?id=128770\" target=\"_blank\" rel=\"external\">ARIES: A Transaction Recovery  Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging</a>. ACM Transactions on Database Systems, Vol. 17, No. 1, March 1992, pp. 94-162.<br>[Ree78] D. Reed. <a href=\"http://publications.csail.mit.edu/lcs/specpub.php?id=773\" target=\"_blank\" rel=\"external\">Naming and Synchronization in a Decentralized Computer System</a>, PhD Dissertation, MIT Laboratory for Computer Science, Technical Report MIT-LCS-TR-205. October 1978 [See Section 6.3 for list of versions with timestamps]</p>\n<hr>\n<p><img src=\"/img/spanner-books.jpg\" alt=\"\"></p>"},{"title":"再说docker及云中的网络连接","date":"2017-04-07T16:00:00.000Z","_content":"之前写过一篇[关于虚拟机和docker网络的日志](https://ying-zhang.github.io/cloud/2016/vm-net/)，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。\n经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。\n去年[与一个大四做毕设的学弟折腾过一段时间docker网络](https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md)，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） **4.2节 Docker高级网络实战** ，整理一下相关内容。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [再说Docker桥接模式，路由器，NAT，交换机](#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [Docker跨主机的网络](#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C)\n- [跨主机网络的实现机制](#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6)\n- [macvlan](#macvlan)\n- [overlay网络](#overlay%E7%BD%91%E7%BB%9C)\n- [对容器网络的需求](#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82)\n- [其它](#%E5%85%B6%E5%AE%83)\n- [脑洞](#%E8%84%91%E6%B4%9E)\n\n<!-- /TOC -->\n\n# 再说Docker桥接模式，路由器，NAT，交换机\n[上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式](https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge)，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。\n实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 **虚拟路由器**，也是一个 **虚拟交换机**，因为（家用）路由器的一侧就包括了一个交换机。\n参考下图。\n![家用无线路由器拓扑](/img/wifi-router.png)\n+ 如果把墙上的网口用网线接到路由器的 **WAN口**，把家里的PC，手机等接到路由器的 **有线LAN口** 或 **wifi**，这是路由器的正常工作模式，即 **NAT模式**，类似于 **docker的bridge模式**。\n+ 如果稍稍开一下脑洞，把网线接到 **有线LAN口中的任意一个**，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 **交换机** 模式，这类似于 **VM的bridge模式**。其实交换机的功能就是把一个网络端口变成多个网络端口。\n\n# Docker跨主机的网络\n上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。\n多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。\n\n回顾一下docker支持的网络模式 https://docs.docker.com/engine/userguide/networking/ ：\n+ none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；\n+ host：直接使用主机的网络栈，即没有网络隔离；\n+ bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在`docker run`命令中提供`-p`参数\n+ overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。\n\n>docker还有一种`container`模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 [**史上最小的docker镜像** `pause` ](https://github.com/kubernetes/kubernetes/tree/master/build/pause)创建的。\n>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是`docker run --net container:<network-container-name> <image> <entrypoint>`\n\n# 跨主机网络的实现机制\n跨主机网络需要处理：\n+ 容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。\n+ 数据包的转发：iptables，VXLAN等。\n+ 子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 **不通**，属于不同子网的容器之间不能通讯。\n\n不同的实现机制，在功能和性能上有所区别：\n+ 将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 **外部机制** 来支持子网，一般是传统的 **VLAN**，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。\n+ 路由转发：如`calico`，仍然使用docker的bridge模式，但不再使用NAT，而是 **路由转发**；NAT的出现是解决私有子网（`10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24`），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 **虚拟交换机** 就不够用了， 需要 **虚拟路由器**，`iptables` 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。\n+ overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。\n\n>路由转发和overlay方式都有一个 **限制**：每个物理主机上的容器子网必须在 **不同** 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。\n不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如`10.0.0.0/16`），但实际上每个主机上的容器子网是更细的网段，比如主机A上是`10.0.1.0/24`，主机B上是`10.0.2.0/24`，甚至使用了`10.0.0.1/32`这样的“子网”。\n\n>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。\n\n# macvlan\nLinux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。\n目前的docker内置了macvlan支持。参考[docker的macvlan文档](https://docs.docker.com/engine/userguide/networking/get-started-macvlan/) 和 [数人云的一篇文档 - docker跨主机macvlan网络配置](https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md)，按下面的例子可以设置macvlan：\n```\n# 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式\nip link set ens33 promisc on\n\n# 创建名为macvlan_net的docker网络\ndocker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net\n\n# 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突\ndocker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash\ndocker run -ti --net macvlan_net centos:net /bin/bash\n```\n\n上面使用的`centos:net`镜像是在centos:7基础上安装了`iproute`和`net-tools`软件包，以在镜像内提供`ip`，`ifconfig`等网络管理命令。\n```\n# Dockerfile\nFROM centos:7\nRUN yum install net-tools iproute -y\n\n# docker build . -t centos:net\n```\n\n按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 **不能ping同本主机**，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考[linux 网络虚拟化： macvlan](https://cizixs.github.io/2017/02/14/network-virtualization-macvlan)、[Linux 上虚拟网络与真实网络的映射](https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/)和[Some notes on macvlan/macvtap](http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/)，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。\n使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 [基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方](http://t.cn/RXpdDrf) 和 [Virtual switching technologies and Linux bridge - ppt](/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf)。\n\n# overlay网络\nflannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。\n早期版本flannel的配置可以参考[一篇文章带你了解Flannel](http://dockone.io/article/618)。\n关于[VXLAN](https://tools.ietf.org/html/rfc7348)，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。\nVLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 **升级交换机** 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。\n![](/img/vnet-vxlan.png)。\n\nVXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。\ndocker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。\n>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。\n\nVXLAN是由VMware为主提出来的，微软提出了类似的[NVGRE](https://tools.ietf.org/html/rfc7637)。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。\n\n>参考\n+ [【华为悦读汇】技术发烧友：认识VXLAN](http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html)\n+ [【华为悦读汇】技术发烧友：闲话大二层网络](http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html)\n+ [Overlay 网络技术，最想解决什么问题？](https://www.zhihu.com/question/24393680)\n+ [基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方](http://t.cn/RXpdege)\n\n# 对容器网络的需求\n\n+ 提供类似传统网络的体验\n  + VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；\n  + 租户可以有多个子网，设置虚拟路由器；\n  + 安全组，防火墙，负载均衡，DNS；\n+ 性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。\n+ 容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。\n\n# 其它\n关于Calico，可参考[其官网](http://docs.projectcalico.org/v2.1/getting-started/docker/)和[将Docker网络方案进行到底](http://blog.dataman-inc.com/shurenyun-docker-133/)。\n关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇[Docker network on cloud 中文](https://www.douban.com/note/530365327/)或者 https://cmgs.me/life/docker-network-cloud 。这里盗个图。\n![](/img/vnet-pk.png)\n\n# 脑洞\n上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。\n**被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：[Jumpers and the Software Defined Localhost](https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html)：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。**\n隔离是肯定没问题，都不需要子网的概念了，但都只有一个`127.0.0.1`的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个[DNS（127.0.0.11）](https://www.infoq.com/news/2016/08/docker-service-load-balancing)来帮助实现服务发现。\n\n\n[DockOne微信分享（一三零）：探究PaaS网络模型设计](http://dockone.io/article/2504)","source":"_posts/vm-net-2.md","raw":"title: 再说docker及云中的网络连接\ncategory: [cloud]\ntags:\ndate: 2017-04-08\n---\n之前写过一篇[关于虚拟机和docker网络的日志](https://ying-zhang.github.io/cloud/2016/vm-net/)，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。\n经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。\n去年[与一个大四做毕设的学弟折腾过一段时间docker网络](https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md)，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） **4.2节 Docker高级网络实战** ，整理一下相关内容。\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [再说Docker桥接模式，路由器，NAT，交换机](#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [Docker跨主机的网络](#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C)\n- [跨主机网络的实现机制](#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6)\n- [macvlan](#macvlan)\n- [overlay网络](#overlay%E7%BD%91%E7%BB%9C)\n- [对容器网络的需求](#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82)\n- [其它](#%E5%85%B6%E5%AE%83)\n- [脑洞](#%E8%84%91%E6%B4%9E)\n\n<!-- /TOC -->\n\n# 再说Docker桥接模式，路由器，NAT，交换机\n[上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式](https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge)，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。\n实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 **虚拟路由器**，也是一个 **虚拟交换机**，因为（家用）路由器的一侧就包括了一个交换机。\n参考下图。\n![家用无线路由器拓扑](/img/wifi-router.png)\n+ 如果把墙上的网口用网线接到路由器的 **WAN口**，把家里的PC，手机等接到路由器的 **有线LAN口** 或 **wifi**，这是路由器的正常工作模式，即 **NAT模式**，类似于 **docker的bridge模式**。\n+ 如果稍稍开一下脑洞，把网线接到 **有线LAN口中的任意一个**，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 **交换机** 模式，这类似于 **VM的bridge模式**。其实交换机的功能就是把一个网络端口变成多个网络端口。\n\n# Docker跨主机的网络\n上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。\n多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。\n\n回顾一下docker支持的网络模式 https://docs.docker.com/engine/userguide/networking/ ：\n+ none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；\n+ host：直接使用主机的网络栈，即没有网络隔离；\n+ bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在`docker run`命令中提供`-p`参数\n+ overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。\n\n>docker还有一种`container`模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 [**史上最小的docker镜像** `pause` ](https://github.com/kubernetes/kubernetes/tree/master/build/pause)创建的。\n>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是`docker run --net container:<network-container-name> <image> <entrypoint>`\n\n# 跨主机网络的实现机制\n跨主机网络需要处理：\n+ 容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。\n+ 数据包的转发：iptables，VXLAN等。\n+ 子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 **不通**，属于不同子网的容器之间不能通讯。\n\n不同的实现机制，在功能和性能上有所区别：\n+ 将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 **外部机制** 来支持子网，一般是传统的 **VLAN**，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。\n+ 路由转发：如`calico`，仍然使用docker的bridge模式，但不再使用NAT，而是 **路由转发**；NAT的出现是解决私有子网（`10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24`），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 **虚拟交换机** 就不够用了， 需要 **虚拟路由器**，`iptables` 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。\n+ overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。\n\n>路由转发和overlay方式都有一个 **限制**：每个物理主机上的容器子网必须在 **不同** 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。\n不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如`10.0.0.0/16`），但实际上每个主机上的容器子网是更细的网段，比如主机A上是`10.0.1.0/24`，主机B上是`10.0.2.0/24`，甚至使用了`10.0.0.1/32`这样的“子网”。\n\n>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。\n\n# macvlan\nLinux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。\n目前的docker内置了macvlan支持。参考[docker的macvlan文档](https://docs.docker.com/engine/userguide/networking/get-started-macvlan/) 和 [数人云的一篇文档 - docker跨主机macvlan网络配置](https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md)，按下面的例子可以设置macvlan：\n```\n# 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式\nip link set ens33 promisc on\n\n# 创建名为macvlan_net的docker网络\ndocker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net\n\n# 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突\ndocker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash\ndocker run -ti --net macvlan_net centos:net /bin/bash\n```\n\n上面使用的`centos:net`镜像是在centos:7基础上安装了`iproute`和`net-tools`软件包，以在镜像内提供`ip`，`ifconfig`等网络管理命令。\n```\n# Dockerfile\nFROM centos:7\nRUN yum install net-tools iproute -y\n\n# docker build . -t centos:net\n```\n\n按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 **不能ping同本主机**，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考[linux 网络虚拟化： macvlan](https://cizixs.github.io/2017/02/14/network-virtualization-macvlan)、[Linux 上虚拟网络与真实网络的映射](https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/)和[Some notes on macvlan/macvtap](http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/)，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。\n使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 [基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方](http://t.cn/RXpdDrf) 和 [Virtual switching technologies and Linux bridge - ppt](/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf)。\n\n# overlay网络\nflannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。\n早期版本flannel的配置可以参考[一篇文章带你了解Flannel](http://dockone.io/article/618)。\n关于[VXLAN](https://tools.ietf.org/html/rfc7348)，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。\nVLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 **升级交换机** 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。\n![](/img/vnet-vxlan.png)。\n\nVXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。\ndocker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。\n>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。\n\nVXLAN是由VMware为主提出来的，微软提出了类似的[NVGRE](https://tools.ietf.org/html/rfc7637)。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。\n\n>参考\n+ [【华为悦读汇】技术发烧友：认识VXLAN](http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html)\n+ [【华为悦读汇】技术发烧友：闲话大二层网络](http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html)\n+ [Overlay 网络技术，最想解决什么问题？](https://www.zhihu.com/question/24393680)\n+ [基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方](http://t.cn/RXpdege)\n\n# 对容器网络的需求\n\n+ 提供类似传统网络的体验\n  + VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；\n  + 租户可以有多个子网，设置虚拟路由器；\n  + 安全组，防火墙，负载均衡，DNS；\n+ 性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。\n+ 容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。\n\n# 其它\n关于Calico，可参考[其官网](http://docs.projectcalico.org/v2.1/getting-started/docker/)和[将Docker网络方案进行到底](http://blog.dataman-inc.com/shurenyun-docker-133/)。\n关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇[Docker network on cloud 中文](https://www.douban.com/note/530365327/)或者 https://cmgs.me/life/docker-network-cloud 。这里盗个图。\n![](/img/vnet-pk.png)\n\n# 脑洞\n上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。\n**被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：[Jumpers and the Software Defined Localhost](https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html)：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。**\n隔离是肯定没问题，都不需要子网的概念了，但都只有一个`127.0.0.1`的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个[DNS（127.0.0.11）](https://www.infoq.com/news/2016/08/docker-service-load-balancing)来帮助实现服务发现。\n\n\n[DockOne微信分享（一三零）：探究PaaS网络模型设计](http://dockone.io/article/2504)","slug":"vm-net-2","published":1,"updated":"2017-10-30T03:41:43.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh7000q9s4fa77omfb9","content":"<p>之前写过一篇<a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/\">关于虚拟机和docker网络的日志</a>，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。<br>经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。<br>去年<a href=\"https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md\" target=\"_blank\" rel=\"external\">与一个大四做毕设的学弟折腾过一段时间docker网络</a>，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） <strong>4.2节 Docker高级网络实战</strong> ，整理一下相关内容。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">再说Docker桥接模式，路由器，NAT，交换机</a></li>\n<li><a href=\"#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C\">Docker跨主机的网络</a></li>\n<li><a href=\"#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\">跨主机网络的实现机制</a></li>\n<li><a href=\"#macvlan\">macvlan</a></li>\n<li><a href=\"#overlay%E7%BD%91%E7%BB%9C\">overlay网络</a></li>\n<li><a href=\"#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82\">对容器网络的需求</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n<li><a href=\"#%E8%84%91%E6%B4%9E\">脑洞</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"再说Docker桥接模式，路由器，NAT，交换机\"><a href=\"#再说Docker桥接模式，路由器，NAT，交换机\" class=\"headerlink\" title=\"再说Docker桥接模式，路由器，NAT，交换机\"></a>再说Docker桥接模式，路由器，NAT，交换机</h1><p><a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge\">上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式</a>，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。<br>实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 <strong>虚拟路由器</strong>，也是一个 <strong>虚拟交换机</strong>，因为（家用）路由器的一侧就包括了一个交换机。<br>参考下图。<br><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<ul>\n<li>如果把墙上的网口用网线接到路由器的 <strong>WAN口</strong>，把家里的PC，手机等接到路由器的 <strong>有线LAN口</strong> 或 <strong>wifi</strong>，这是路由器的正常工作模式，即 <strong>NAT模式</strong>，类似于 <strong>docker的bridge模式</strong>。</li>\n<li>如果稍稍开一下脑洞，把网线接到 <strong>有线LAN口中的任意一个</strong>，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 <strong>交换机</strong> 模式，这类似于 <strong>VM的bridge模式</strong>。其实交换机的功能就是把一个网络端口变成多个网络端口。</li>\n</ul>\n<h1 id=\"Docker跨主机的网络\"><a href=\"#Docker跨主机的网络\" class=\"headerlink\" title=\"Docker跨主机的网络\"></a>Docker跨主机的网络</h1><p>上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。<br>多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。</p>\n<p>回顾一下docker支持的网络模式 <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/userguide/networking/</a> ：</p>\n<ul>\n<li>none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；</li>\n<li>host：直接使用主机的网络栈，即没有网络隔离；</li>\n<li>bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在<code>docker run</code>命令中提供<code>-p</code>参数</li>\n<li>overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。</li>\n</ul>\n<blockquote>\n<p>docker还有一种<code>container</code>模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 <a href=\"https://github.com/kubernetes/kubernetes/tree/master/build/pause\" target=\"_blank\" rel=\"external\"><strong>史上最小的docker镜像</strong> <code>pause</code> </a>创建的。<br>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是<code>docker run --net container:&lt;network-container-name&gt; &lt;image&gt; &lt;entrypoint&gt;</code></p>\n</blockquote>\n<h1 id=\"跨主机网络的实现机制\"><a href=\"#跨主机网络的实现机制\" class=\"headerlink\" title=\"跨主机网络的实现机制\"></a>跨主机网络的实现机制</h1><p>跨主机网络需要处理：</p>\n<ul>\n<li>容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。</li>\n<li>数据包的转发：iptables，VXLAN等。</li>\n<li>子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 <strong>不通</strong>，属于不同子网的容器之间不能通讯。</li>\n</ul>\n<p>不同的实现机制，在功能和性能上有所区别：</p>\n<ul>\n<li>将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 <strong>外部机制</strong> 来支持子网，一般是传统的 <strong>VLAN</strong>，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。</li>\n<li>路由转发：如<code>calico</code>，仍然使用docker的bridge模式，但不再使用NAT，而是 <strong>路由转发</strong>；NAT的出现是解决私有子网（<code>10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24</code>），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 <strong>虚拟交换机</strong> 就不够用了， 需要 <strong>虚拟路由器</strong>，<code>iptables</code> 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。</li>\n<li>overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。</li>\n</ul>\n<blockquote>\n<p>路由转发和overlay方式都有一个 <strong>限制</strong>：每个物理主机上的容器子网必须在 <strong>不同</strong> 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。<br>不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如<code>10.0.0.0/16</code>），但实际上每个主机上的容器子网是更细的网段，比如主机A上是<code>10.0.1.0/24</code>，主机B上是<code>10.0.2.0/24</code>，甚至使用了<code>10.0.0.1/32</code>这样的“子网”。</p>\n<p>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。</p>\n</blockquote>\n<h1 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a>macvlan</h1><p>Linux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。<br>目前的docker内置了macvlan支持。参考<a href=\"https://docs.docker.com/engine/userguide/networking/get-started-macvlan/\" target=\"_blank\" rel=\"external\">docker的macvlan文档</a> 和 <a href=\"https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">数人云的一篇文档 - docker跨主机macvlan网络配置</a>，按下面的例子可以设置macvlan：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式</div><div class=\"line\">ip link set ens33 promisc on</div><div class=\"line\"></div><div class=\"line\"># 创建名为macvlan_net的docker网络</div><div class=\"line\">docker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net</div><div class=\"line\"></div><div class=\"line\"># 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突</div><div class=\"line\">docker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash</div><div class=\"line\">docker run -ti --net macvlan_net centos:net /bin/bash</div></pre></td></tr></table></figure></p>\n<p>上面使用的<code>centos:net</code>镜像是在centos:7基础上安装了<code>iproute</code>和<code>net-tools</code>软件包，以在镜像内提供<code>ip</code>，<code>ifconfig</code>等网络管理命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dockerfile</div><div class=\"line\">FROM centos:7</div><div class=\"line\">RUN yum install net-tools iproute -y</div><div class=\"line\"></div><div class=\"line\"># docker build . -t centos:net</div></pre></td></tr></table></figure></p>\n<p>按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 <strong>不能ping同本主机</strong>，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考<a href=\"https://cizixs.github.io/2017/02/14/network-virtualization-macvlan\" target=\"_blank\" rel=\"external\">linux 网络虚拟化： macvlan</a>、<a href=\"https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/\" target=\"_blank\" rel=\"external\">Linux 上虚拟网络与真实网络的映射</a>和<a href=\"http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/\" target=\"_blank\" rel=\"external\">Some notes on macvlan/macvtap</a>，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。<br>使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 <a href=\"http://t.cn/RXpdDrf\" target=\"_blank\" rel=\"external\">基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方</a> 和 <a href=\"/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf\">Virtual switching technologies and Linux bridge - ppt</a>。</p>\n<h1 id=\"overlay网络\"><a href=\"#overlay网络\" class=\"headerlink\" title=\"overlay网络\"></a>overlay网络</h1><p>flannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。<br>早期版本flannel的配置可以参考<a href=\"http://dockone.io/article/618\" target=\"_blank\" rel=\"external\">一篇文章带你了解Flannel</a>。<br>关于<a href=\"https://tools.ietf.org/html/rfc7348\" target=\"_blank\" rel=\"external\">VXLAN</a>，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。<br>VLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 <strong>升级交换机</strong> 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。<br><img src=\"/img/vnet-vxlan.png\" alt=\"\">。</p>\n<p>VXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。<br>docker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。</p>\n<blockquote>\n<p>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。</p>\n</blockquote>\n<p>VXLAN是由VMware为主提出来的，微软提出了类似的<a href=\"https://tools.ietf.org/html/rfc7637\" target=\"_blank\" rel=\"external\">NVGRE</a>。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：认识VXLAN</a></li>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：闲话大二层网络</a></li>\n<li><a href=\"https://www.zhihu.com/question/24393680\" target=\"_blank\" rel=\"external\">Overlay 网络技术，最想解决什么问题？</a></li>\n<li><a href=\"http://t.cn/RXpdege\" target=\"_blank\" rel=\"external\">基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方</a></li>\n</ul>\n</blockquote>\n<h1 id=\"对容器网络的需求\"><a href=\"#对容器网络的需求\" class=\"headerlink\" title=\"对容器网络的需求\"></a>对容器网络的需求</h1><ul>\n<li>提供类似传统网络的体验<ul>\n<li>VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；</li>\n<li>租户可以有多个子网，设置虚拟路由器；</li>\n<li>安全组，防火墙，负载均衡，DNS；</li>\n</ul>\n</li>\n<li>性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。</li>\n<li>容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。</li>\n</ul>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p>关于Calico，可参考<a href=\"http://docs.projectcalico.org/v2.1/getting-started/docker/\" target=\"_blank\" rel=\"external\">其官网</a>和<a href=\"http://blog.dataman-inc.com/shurenyun-docker-133/\" target=\"_blank\" rel=\"external\">将Docker网络方案进行到底</a>。<br>关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇<a href=\"https://www.douban.com/note/530365327/\" target=\"_blank\" rel=\"external\">Docker network on cloud 中文</a>或者 <a href=\"https://cmgs.me/life/docker-network-cloud\" target=\"_blank\" rel=\"external\">https://cmgs.me/life/docker-network-cloud</a> 。这里盗个图。<br><img src=\"/img/vnet-pk.png\" alt=\"\"></p>\n<h1 id=\"脑洞\"><a href=\"#脑洞\" class=\"headerlink\" title=\"脑洞\"></a>脑洞</h1><p>上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。<br><strong>被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：<a href=\"https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html\" target=\"_blank\" rel=\"external\">Jumpers and the Software Defined Localhost</a>：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。</strong><br>隔离是肯定没问题，都不需要子网的概念了，但都只有一个<code>127.0.0.1</code>的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个<a href=\"https://www.infoq.com/news/2016/08/docker-service-load-balancing\" target=\"_blank\" rel=\"external\">DNS（127.0.0.11）</a>来帮助实现服务发现。</p>\n<p><a href=\"http://dockone.io/article/2504\" target=\"_blank\" rel=\"external\">DockOne微信分享（一三零）：探究PaaS网络模型设计</a></p>\n","site":{"data":{}},"excerpt":"<p>之前写过一篇<a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/\">关于虚拟机和docker网络的日志</a>，主要介绍的是VM的虚拟网络，顺带提了一下docker的桥接。<br>经过2016年的几次版本升级，docker的网络功能有了很大的改善，已经基本稳定可用了。<br>去年<a href=\"https://github.com/NAP-GHJ/NetTool/blob/master/blog/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.md\" target=\"_blank\" rel=\"external\">与一个大四做毕设的学弟折腾过一段时间docker网络</a>，这里参考浙大SEL实验室的《Docker容器与容器云 第2版》（下面简称《容器云》书） <strong>4.2节 Docker高级网络实战</strong> ，整理一下相关内容。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 再说docker及云中的网络连接](#title-%E5%86%8D%E8%AF%B4docker%E5%8F%8A%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E5%86%8D%E8%AF%B4docker%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">再说Docker桥接模式，路由器，NAT，交换机</a></li>\n<li><a href=\"#docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C\">Docker跨主机的网络</a></li>\n<li><a href=\"#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6\">跨主机网络的实现机制</a></li>\n<li><a href=\"#macvlan\">macvlan</a></li>\n<li><a href=\"#overlay%E7%BD%91%E7%BB%9C\">overlay网络</a></li>\n<li><a href=\"#%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9C%80%E6%B1%82\">对容器网络的需求</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83\">其它</a></li>\n<li><a href=\"#%E8%84%91%E6%B4%9E\">脑洞</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"再说Docker桥接模式，路由器，NAT，交换机\"><a href=\"#再说Docker桥接模式，路由器，NAT，交换机\" class=\"headerlink\" title=\"再说Docker桥接模式，路由器，NAT，交换机\"></a>再说Docker桥接模式，路由器，NAT，交换机</h1><p><a href=\"https://ying-zhang.github.io/cloud/2016/vm-net/index.html#docker-bridge\">上篇日志提到Docker的桥接模式（bridge）实际上是NAT方式</a>，也给了两个设置Docker“名副其实”的bridge模式的链接，这点在《容器云》的 “4.2.2 pipework 原理解析：1. 将Docker配置到本地网络环境中” 一节也提到了。<br>实际为NAT的docker bridge模式和类似VM的bridge模式都是用到了Linux bridge虚拟网桥。这个虚拟设备其实既是一个 <strong>虚拟路由器</strong>，也是一个 <strong>虚拟交换机</strong>，因为（家用）路由器的一侧就包括了一个交换机。<br>参考下图。<br><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<ul>\n<li>如果把墙上的网口用网线接到路由器的 <strong>WAN口</strong>，把家里的PC，手机等接到路由器的 <strong>有线LAN口</strong> 或 <strong>wifi</strong>，这是路由器的正常工作模式，即 <strong>NAT模式</strong>，类似于 <strong>docker的bridge模式</strong>。</li>\n<li>如果稍稍开一下脑洞，把网线接到 <strong>有线LAN口中的任意一个</strong>，留着WAN口什么也不接，这时PC，手机等设备还是能连到网络上的！这时只用了路由器的LAN一侧，只工作在 <strong>交换机</strong> 模式，这类似于 <strong>VM的bridge模式</strong>。其实交换机的功能就是把一个网络端口变成多个网络端口。</li>\n</ul>\n<h1 id=\"Docker跨主机的网络\"><a href=\"#Docker跨主机的网络\" class=\"headerlink\" title=\"Docker跨主机的网络\"></a>Docker跨主机的网络</h1><p>上面强调docker的bridge模式名不副实，其实是因为docker早期版本缺少跨主机的网络功能，造成了诸多不便。在“传统的”VM技术中，是使用bridge模式来实现不同物理主机上VM直接联网的，即将VM网络接入到主机网络环境中。docker虽然用了同样的称呼，但没有提供同样的功能，除了端口映射和host模式，没有办法方便地将不同物理主机上的容器互相连通，让docker的用户非常痛苦。<br>多个第三方工具，比如pipework、weave、socketplane、flannel，calico等都是为了实现docker的跨主机网络。最终，在docker 1.9，docker提供了内置的Overlay网络模式。</p>\n<p>回顾一下docker支持的网络模式 <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/userguide/networking/</a> ：</p>\n<ul>\n<li>none：docker撒手不管，由用户或第三方工具提供网络功能，上节中pipework就是这样的工具；</li>\n<li>host：直接使用主机的网络栈，即没有网络隔离；</li>\n<li>bridge：NAT模式，容器可以使用主机的网络访问外部，但外部访问容器的应用需要做端口映射，即在<code>docker run</code>命令中提供<code>-p</code>参数</li>\n<li>overlay, gwbridge：这是ver 1.9引入的覆盖网络，下面会单独介绍。</li>\n</ul>\n<blockquote>\n<p>docker还有一种<code>container</code>模式，使用已有容器的网络。Kubernetes的Pod是依赖于这种网络模式的：一个Pod包括多个功能相关的容器，它们共用一个网络栈，是 <a href=\"https://github.com/kubernetes/kubernetes/tree/master/build/pause\" target=\"_blank\" rel=\"external\"><strong>史上最小的docker镜像</strong> <code>pause</code> </a>创建的。<br>新版本（我使用的17.05.0-ce版）的docker使用这种模式的命令参数是<code>docker run --net container:&lt;network-container-name&gt; &lt;image&gt; &lt;entrypoint&gt;</code></p>\n</blockquote>\n<h1 id=\"跨主机网络的实现机制\"><a href=\"#跨主机网络的实现机制\" class=\"headerlink\" title=\"跨主机网络的实现机制\"></a>跨主机网络的实现机制</h1><p>跨主机网络需要处理：</p>\n<ul>\n<li>容器和主机网络的拓扑：即哪个容器子网对应于哪台物理主机。拓扑信息的源头当然是容器启动命令，可以通过标准路由协议在各主机的网络组件守护进程之间交换信息，也可以将拓扑信息写入etcd这样的高可用集中存储。</li>\n<li>数据包的转发：iptables，VXLAN等。</li>\n<li>子网隔离：对跨主机的网络，除了实现不同主机上的容器之间能够联网互通，还要能 <strong>不通</strong>，属于不同子网的容器之间不能通讯。</li>\n</ul>\n<p>不同的实现机制，在功能和性能上有所区别：</p>\n<ul>\n<li>将容器置于主机网络中：类似上面提到的VM的bridge模式，及macvlan方式；这种方式需要 <strong>外部机制</strong> 来支持子网，一般是传统的 <strong>VLAN</strong>，即交换机端口设置不同的VLAN ID；VLAN的12位长度限制了子网的数量，对公有云平台是一个限制，但对企业内的私有云一般是够用了。</li>\n<li>路由转发：如<code>calico</code>，仍然使用docker的bridge模式，但不再使用NAT，而是 <strong>路由转发</strong>；NAT的出现是解决私有子网（<code>10.0.0.0/8， 172.16.0.0/12， 192.168.0.0/24</code>），所以路由器对这几个IP网段特别处理了。如果把这3个网段当成普通的IP网段，容器网络和主机网络就跟普通的多层IP网络是一样的（当然主机可以直接通讯，多数情况不必经过物理的核心路由器）。这样 <strong>虚拟交换机</strong> 就不够用了， 需要 <strong>虚拟路由器</strong>，<code>iptables</code> 就是这样一个虚拟路由器（软件路由器，也被作为防火墙）。可以手动添加iptables的路由条目；也可以使用工具自动化这个过程，比如通过标准的路由协议，或开发非标准的方式。</li>\n<li>overlay网络：docker内置了overlay支持，CoreOS的flannel也是早期比较常用的overlay网络工具，Kubernetes就是使用的flannel。overlay网络是将容器的数据包封装起来，当成普通的数据，到目的主机后再拆开，转发给对应的目的容器。</li>\n</ul>\n<blockquote>\n<p>路由转发和overlay方式都有一个 <strong>限制</strong>：每个物理主机上的容器子网必须在 <strong>不同</strong> 的网段。因为这2种方式都会用到docker网桥（docker0），网桥会聪明地通过子网掩码识别哪些数据包是它负责的本地LAN，只有不是同一子网的数据包才会从这个网桥发出去。<br>不过这个限制可以被绕过去。比如从calico或flannel的设置看起来，不同主机上的容器子网是在同一个IP网段的（比如<code>10.0.0.0/16</code>），但实际上每个主机上的容器子网是更细的网段，比如主机A上是<code>10.0.1.0/24</code>，主机B上是<code>10.0.2.0/24</code>，甚至使用了<code>10.0.0.1/32</code>这样的“子网”。</p>\n<p>早期docker在每个主机上只能设置一个bridge，同一主机上的容器彼此无法隔离。目前版本的docker可以设置多个网络。</p>\n</blockquote>\n<h1 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a>macvlan</h1><p>Linux bridge是一个软件实现的虚拟网桥，而macvlan则利用了网卡硬件的支持。<br>目前的docker内置了macvlan支持。参考<a href=\"https://docs.docker.com/engine/userguide/networking/get-started-macvlan/\" target=\"_blank\" rel=\"external\">docker的macvlan文档</a> 和 <a href=\"https://github.com/alfredhuang211/study-docker-doc/blob/master/docker%E8%B7%A8%E4%B8%BB%E6%9C%BAmacvlan%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.md\" target=\"_blank\" rel=\"external\">数人云的一篇文档 - docker跨主机macvlan网络配置</a>，按下面的例子可以设置macvlan：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 主机IP为10.1.1.10/24，网卡名称ens33，首先开启网卡的混杂模式</div><div class=\"line\">ip link set ens33 promisc on</div><div class=\"line\"></div><div class=\"line\"># 创建名为macvlan_net的docker网络</div><div class=\"line\">docker network create -d macvlan --subnet=10.1.1.0/24 --gateway=10.1.1.2 -o parent=ens33 macvlan_net</div><div class=\"line\"></div><div class=\"line\"># 运行容器时指定或动态分配IP。注意，动态分配的IP可能与主机IP冲突</div><div class=\"line\">docker run -ti --net macvlan_net --ip=10.1.1.101  centos:net /bin/bash</div><div class=\"line\">docker run -ti --net macvlan_net centos:net /bin/bash</div></pre></td></tr></table></figure></p>\n<p>上面使用的<code>centos:net</code>镜像是在centos:7基础上安装了<code>iproute</code>和<code>net-tools</code>软件包，以在镜像内提供<code>ip</code>，<code>ifconfig</code>等网络管理命令。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Dockerfile</div><div class=\"line\">FROM centos:7</div><div class=\"line\">RUN yum install net-tools iproute -y</div><div class=\"line\"></div><div class=\"line\"># docker build . -t centos:net</div></pre></td></tr></table></figure></p>\n<p>按上面的命令创建的2个容器彼此可以pin通，也可以ping通网关和其它主机，但 <strong>不能ping同本主机</strong>，这是macvlan本身的限制（摊手）。macvlan有4种工作模式，可以参考<a href=\"https://cizixs.github.io/2017/02/14/network-virtualization-macvlan\" target=\"_blank\" rel=\"external\">linux 网络虚拟化： macvlan</a>、<a href=\"https://www.ibm.com/developerworks/cn/linux/1312_xiawc_linuxvirtnet/\" target=\"_blank\" rel=\"external\">Linux 上虚拟网络与真实网络的映射</a>和<a href=\"http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/\" target=\"_blank\" rel=\"external\">Some notes on macvlan/macvtap</a>，分别为VEPA（不常用，需交换机支持hairpin模式，又称reflective relay反射中继），桥接，私有和Passthru（直通）。<br>使用macvlan网络的容器被置于主机网络中。子网隔离需要VLAN，但实际上同一主机上的容器都使用主机的网线，对应的是交换机的同一个端口，也就是同一个VLAN ID，所以需要macvlan作为一个虚拟交换机，也支持设置VLAN ID。这方面可以参考 <a href=\"http://t.cn/RXpdDrf\" target=\"_blank\" rel=\"external\">基于macvlan的Docker容器网络系统的设计与实现 - 浙江大学硕士学位论文 - 万方</a> 和 <a href=\"/doc/Virtual_switching_technologies_and_Linux_bridge_ppt.pdf\">Virtual switching technologies and Linux bridge - ppt</a>。</p>\n<h1 id=\"overlay网络\"><a href=\"#overlay网络\" class=\"headerlink\" title=\"overlay网络\"></a>overlay网络</h1><p>flannel开始是自己实现的overlay机制，将IP包封装到UDP的数据段，即IP in IP，需要拦截并应答容器的ARP包；后来加入了VXLAN的转发方式。VXLAN是将完整的二层以太网包封装到UDP的数据段，即MAC in IP，提供了完整的虚拟二层网络，而且VXLAN是内核支持的，性能好得多。<br>早期版本flannel的配置可以参考<a href=\"http://dockone.io/article/618\" target=\"_blank\" rel=\"external\">一篇文章带你了解Flannel</a>。<br>关于<a href=\"https://tools.ietf.org/html/rfc7348\" target=\"_blank\" rel=\"external\">VXLAN</a>，从名字上看似乎是VLAN的扩展，但它跟VLAN的实现方式有很大的差别。<br>VLAN是二层以太网包的一个段。对VLAN的支持和VLAN ID是在交换机上设置的（针对交换机各端口，计算机上不需要特别设置）。虽然把VLAN从12位拓展到24位似乎比较简单直接，但需要 <strong>升级交换机</strong> 才能支持新的以太网数据包格式。所以VXLAN把扩展的24位VLAN ID放到了UDP的数据段。VXLAN数据包的处理是通过虚拟的VTEP网卡实现的，实际上是发生在主机上，对交换机而言是透明的。交换机要支持VXLAN还比较复杂些，看起来VXLAN是为主机上的虚拟交换机量身定制的。VXLAN的下层网络可以手动设置点对点的拓扑，也支持通过组播自动发现并组网，不过这样就比较复杂了。<br><img src=\"/img/vnet-vxlan.png\" alt=\"\">。</p>\n<p>VXLAN设计的一个应用场景是在不同的三层网络（如多个数据中心）之上（即overlay）建立一个虚拟的二层网络，即所谓的“大二层”。大二层的需求是为了应对虚拟机的在线迁移。虚拟机一般使用桥接模式，与主机有相同的网络环境。当VM迁移到另一个主机后，VM的MAC和IP应保持不变，以便减少对VM内应用和其用户的影响（虽然VM的MAC和IP没有变化，但新主机对应于交换机的端口发生了变化，用户会经历一小段时间的网络中断，以等待交换机端口学习新的ARP映射）。如果不同主机在不同的VLAN甚至跨数据中心，那么迁移后VM将无法与原VLAN的节点通讯。所以在线迁移需要没有隔离的大二层网络，但这样会造成广播风暴。点对点的VXLAN overlay网络可以比较好的解决这个矛盾。<br>docker出现后，面临的跨主机网络与大二层需求不同但也有类似之处，docker内置的overlay网络就使用了VXLAN转发。</p>\n<blockquote>\n<p>VLAN作为传统的子网隔离机制，是工作在二层的。除了VLAN ID不同，每个VLAN的IP网段也不同，即三层通过IP子网来隔离。VLAN之间如果需要通讯，则需设置经路由转发。</p>\n</blockquote>\n<p>VXLAN是由VMware为主提出来的，微软提出了类似的<a href=\"https://tools.ietf.org/html/rfc7637\" target=\"_blank\" rel=\"external\">NVGRE</a>。NVGRE的数据包格式与VXLAN相比向下兼容性不够好，需要升级设备才能应用。</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-334207.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：认识VXLAN</a></li>\n<li><a href=\"http://support.huawei.com/huaweiconnect/enterprise/thread-333013.html\" target=\"_blank\" rel=\"external\">【华为悦读汇】技术发烧友：闲话大二层网络</a></li>\n<li><a href=\"https://www.zhihu.com/question/24393680\" target=\"_blank\" rel=\"external\">Overlay 网络技术，最想解决什么问题？</a></li>\n<li><a href=\"http://t.cn/RXpdege\" target=\"_blank\" rel=\"external\">基于容器云平台的网络资源管理与配置系统 - 浙江大学硕士论文 - 万方</a></li>\n</ul>\n</blockquote>\n<h1 id=\"对容器网络的需求\"><a href=\"#对容器网络的需求\" class=\"headerlink\" title=\"对容器网络的需求\"></a>对容器网络的需求</h1><ul>\n<li>提供类似传统网络的体验<ul>\n<li>VPS（Virtual Private Server）× n + 虚拟网络 = VPC（Virtual Private Cloud）：不同租户的子网彼此隔离，租户可以指定或被分配IP网段，DHCP或静态指定IP，关联公网IP以便与互联网连通；</li>\n<li>租户可以有多个子网，设置虚拟路由器；</li>\n<li>安全组，防火墙，负载均衡，DNS；</li>\n</ul>\n</li>\n<li>性能：高带宽，低延迟，扩展性。VXLAN和calico是目前性能比较好的2种技术。</li>\n<li>容器与物理主机，虚拟机互联共存：这一点目前还没有比较好的实现。</li>\n</ul>\n<h1 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h1><p>关于Calico，可参考<a href=\"http://docs.projectcalico.org/v2.1/getting-started/docker/\" target=\"_blank\" rel=\"external\">其官网</a>和<a href=\"http://blog.dataman-inc.com/shurenyun-docker-133/\" target=\"_blank\" rel=\"external\">将Docker网络方案进行到底</a>。<br>关于不同网络方式的性能，可参考豆瓣上（是的，豆瓣）的这篇<a href=\"https://www.douban.com/note/530365327/\" target=\"_blank\" rel=\"external\">Docker network on cloud 中文</a>或者 <a href=\"https://cmgs.me/life/docker-network-cloud\" target=\"_blank\" rel=\"external\">https://cmgs.me/life/docker-network-cloud</a> 。这里盗个图。<br><img src=\"/img/vnet-pk.png\" alt=\"\"></p>\n<h1 id=\"脑洞\"><a href=\"#脑洞\" class=\"headerlink\" title=\"脑洞\"></a>脑洞</h1><p>上面的一堆方案，有的自称为SDN，但实际与SDN还有些差距。SDN是针对网络设备的，而这些方案多是在服务器主机上实现虚拟网络设备（交换机，路由器），更接近NFV的目标。<br><strong>被上面一堆方案搞得头痛的，不妨看看这样一个有意思的想法：<a href=\"https://coreos.com/blog/jumpers-and-the-software-defined-localhost.html\" target=\"_blank\" rel=\"external\">Jumpers and the Software Defined Localhost</a>：容器中只有一个loop（127.0.0.1）网卡！完全由外部来管理容器网络。</strong><br>隔离是肯定没问题，都不需要子网的概念了，但都只有一个<code>127.0.0.1</code>的IP，如何与其它容器通讯呢？jumpers使用的是端口，域名应该更好些，Docker 已经为每个容器内置了一个<a href=\"https://www.infoq.com/news/2016/08/docker-service-load-balancing\" target=\"_blank\" rel=\"external\">DNS（127.0.0.11）</a>来帮助实现服务发现。</p>\n<p><a href=\"http://dockone.io/article/2504\" target=\"_blank\" rel=\"external\">DockOne微信分享（一三零）：探究PaaS网络模型设计</a></p>"},{"title":"双拼输入法","date":"2016-09-18T16:00:00.000Z","_content":"双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。\n除了介绍双拼输入法，还有一点关于语音输入的杂想。\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n- [双拼方案](#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88)\n    - [声母](#%E5%A3%B0%E6%AF%8D)\n    - [韵母](#%E9%9F%B5%E6%AF%8D)\n- [双拼输入法的软件](#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6)\n- [关于语音输入的杂想](#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3)\n\n<!-- /TOC -->\n\n[双拼](https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC)输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。\n双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 **不会太慢**，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。\n\n> 本文主要内容的[一页纸PDF文件，亦称Cheetsheet](/doc/shuang_pin_udpn_cheetsheet.pdf)\n\n# 双拼方案\n将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。\n\n## 声母\n`b p m f d t n l g k h j q x r z c s y w`这些单声母都是直接与各自的字母键对应的，对`zh ch sh`这三个，对应关系是`i：ch`，`u：sh`，`v：zh`；有的拼音不需要声母，比如`爱 ai`，只有韵母`ai`，为了保持编码规律，指定它们为 **零声母**，并对应为按键`o`。\n\n## 韵母\n韵母的对应关系稍微复杂一点，\n+ `a e i o u`这几个元音的对应比较简单；\n+ 对于复杂韵母，\n    - `u o`相关的多在第一行键位，\n    - `a e`相关的多在第二行键位，\n    - `i`  相关的多在第三行键位。\n\n下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按`Win+D`显示桌面即可。一般练习一两天就记住了。\n\n![微软双拼韵母键位](/img/udpn-ms-map.png)\n\n例如，输入“我爱双拼输入法”，对应的击键如下表，\n\n![微软双拼示例](/img/udpn-demo.png)\n\n说明：\n1.\t大部分声母都有直接对应的键位，只有`zh ch sh`需特别记忆一下。有的拼音没有声母，如`爱`，这时就需要零声母，即字母`o`，以表明后面的键是韵母；\n2.\t韵母`a  e  i  o  u`直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母`ing`对应分号键` ; `。\n\n双拼下也可以使用简拼，但需要用 `'` 作为分隔符划分音节。如果你刚才 **整句** 地输入过“我爱双拼输入法”，那么试试`w'i'u'p'u'r'f` ，看看你的输入法软件够不够智能。说实话，简拼用`'`实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。\n\n# 双拼输入法的软件\n好像没有专门支持双拼的输入法软件啊？\n其实Windows及Android上常见的 **拼音输入法软件**，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 **双拼展开提示**，初学时有所帮助。\n\n一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母`ing` 对应的是 **`,`**。\n\n![百度拼音设置](/img/udpn-baidu-ime.png)\n\n---\n# 关于语音输入的杂想\niPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：\n+ 首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。\n+ 语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。\n+ 提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。\n\n> 手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；\n> 但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。\n> 想到这里，可能淘宝客服最适合用语音识别了;-)\n> 要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。\n> 话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。\n> 弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于`Sensor offloading`，而且已经有了这样的App：[WO Mic](http://wirelessorange.com/womic-zh/)，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。\n\n再到[讯飞听见](http://www.iflyrec.com/)的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看[别人的体验](http://cn.technode.com/post/2016-01-13/iflyrec-examination/)了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？\n\n<a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\">![讯飞录音笔](/img/udpn-iflyrec-rec.png)</a>\n\n![讯飞智能会议系统](/img/udpn-iflyrec-meeting.png)\n","source":"_posts/udpnuurufa.md","raw":"title: 双拼输入法\ncategory: [misc]\ntags: \ndate: 2016-09-19\n---\n双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。\n除了介绍双拼输入法，还有一点关于语音输入的杂想。\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n- [双拼方案](#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88)\n    - [声母](#%E5%A3%B0%E6%AF%8D)\n    - [韵母](#%E9%9F%B5%E6%AF%8D)\n- [双拼输入法的软件](#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6)\n- [关于语音输入的杂想](#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3)\n\n<!-- /TOC -->\n\n[双拼](https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC)输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。\n双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 **不会太慢**，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。\n\n> 本文主要内容的[一页纸PDF文件，亦称Cheetsheet](/doc/shuang_pin_udpn_cheetsheet.pdf)\n\n# 双拼方案\n将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。\n\n## 声母\n`b p m f d t n l g k h j q x r z c s y w`这些单声母都是直接与各自的字母键对应的，对`zh ch sh`这三个，对应关系是`i：ch`，`u：sh`，`v：zh`；有的拼音不需要声母，比如`爱 ai`，只有韵母`ai`，为了保持编码规律，指定它们为 **零声母**，并对应为按键`o`。\n\n## 韵母\n韵母的对应关系稍微复杂一点，\n+ `a e i o u`这几个元音的对应比较简单；\n+ 对于复杂韵母，\n    - `u o`相关的多在第一行键位，\n    - `a e`相关的多在第二行键位，\n    - `i`  相关的多在第三行键位。\n\n下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按`Win+D`显示桌面即可。一般练习一两天就记住了。\n\n![微软双拼韵母键位](/img/udpn-ms-map.png)\n\n例如，输入“我爱双拼输入法”，对应的击键如下表，\n\n![微软双拼示例](/img/udpn-demo.png)\n\n说明：\n1.\t大部分声母都有直接对应的键位，只有`zh ch sh`需特别记忆一下。有的拼音没有声母，如`爱`，这时就需要零声母，即字母`o`，以表明后面的键是韵母；\n2.\t韵母`a  e  i  o  u`直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母`ing`对应分号键` ; `。\n\n双拼下也可以使用简拼，但需要用 `'` 作为分隔符划分音节。如果你刚才 **整句** 地输入过“我爱双拼输入法”，那么试试`w'i'u'p'u'r'f` ，看看你的输入法软件够不够智能。说实话，简拼用`'`实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。\n\n# 双拼输入法的软件\n好像没有专门支持双拼的输入法软件啊？\n其实Windows及Android上常见的 **拼音输入法软件**，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 **双拼展开提示**，初学时有所帮助。\n\n一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母`ing` 对应的是 **`,`**。\n\n![百度拼音设置](/img/udpn-baidu-ime.png)\n\n---\n# 关于语音输入的杂想\niPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：\n+ 首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。\n+ 语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。\n+ 提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。\n\n> 手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；\n> 但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。\n> 想到这里，可能淘宝客服最适合用语音识别了;-)\n> 要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。\n> 话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。\n> 弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于`Sensor offloading`，而且已经有了这样的App：[WO Mic](http://wirelessorange.com/womic-zh/)，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。\n\n再到[讯飞听见](http://www.iflyrec.com/)的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看[别人的体验](http://cn.technode.com/post/2016-01-13/iflyrec-examination/)了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？\n\n<a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\">![讯飞录音笔](/img/udpn-iflyrec-rec.png)</a>\n\n![讯飞智能会议系统](/img/udpn-iflyrec-meeting.png)\n","slug":"udpnuurufa","published":1,"updated":"2017-10-30T02:46:13.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmh9000s9s4f6d04jqz7","content":"<p>双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。<br>除了介绍双拼输入法，还有一点关于语音输入的杂想。<br><a id=\"more\"></a></p>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n</code></pre><ul>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88\">双拼方案</a><ul>\n<li><a href=\"#%E5%A3%B0%E6%AF%8D\">声母</a></li>\n<li><a href=\"#%E9%9F%B5%E6%AF%8D\">韵母</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6\">双拼输入法的软件</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3\">关于语音输入的杂想</a></li>\n</ul>\n<!-- /TOC -->\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC\" target=\"_blank\" rel=\"external\">双拼</a>输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。<br>双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 <strong>不会太慢</strong>，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。</p>\n<blockquote>\n<p>本文主要内容的<a href=\"/doc/shuang_pin_udpn_cheetsheet.pdf\">一页纸PDF文件，亦称Cheetsheet</a></p>\n</blockquote>\n<h1 id=\"双拼方案\"><a href=\"#双拼方案\" class=\"headerlink\" title=\"双拼方案\"></a>双拼方案</h1><p>将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。</p>\n<h2 id=\"声母\"><a href=\"#声母\" class=\"headerlink\" title=\"声母\"></a>声母</h2><p><code>b p m f d t n l g k h j q x r z c s y w</code>这些单声母都是直接与各自的字母键对应的，对<code>zh ch sh</code>这三个，对应关系是<code>i：ch</code>，<code>u：sh</code>，<code>v：zh</code>；有的拼音不需要声母，比如<code>爱 ai</code>，只有韵母<code>ai</code>，为了保持编码规律，指定它们为 <strong>零声母</strong>，并对应为按键<code>o</code>。</p>\n<h2 id=\"韵母\"><a href=\"#韵母\" class=\"headerlink\" title=\"韵母\"></a>韵母</h2><p>韵母的对应关系稍微复杂一点，</p>\n<ul>\n<li><code>a e i o u</code>这几个元音的对应比较简单；</li>\n<li>对于复杂韵母，<ul>\n<li><code>u o</code>相关的多在第一行键位，</li>\n<li><code>a e</code>相关的多在第二行键位，</li>\n<li><code>i</code>  相关的多在第三行键位。</li>\n</ul>\n</li>\n</ul>\n<p>下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按<code>Win+D</code>显示桌面即可。一般练习一两天就记住了。</p>\n<p><img src=\"/img/udpn-ms-map.png\" alt=\"微软双拼韵母键位\"></p>\n<p>例如，输入“我爱双拼输入法”，对应的击键如下表，</p>\n<p><img src=\"/img/udpn-demo.png\" alt=\"微软双拼示例\"></p>\n<p>说明：</p>\n<ol>\n<li>大部分声母都有直接对应的键位，只有<code>zh ch sh</code>需特别记忆一下。有的拼音没有声母，如<code>爱</code>，这时就需要零声母，即字母<code>o</code>，以表明后面的键是韵母；</li>\n<li>韵母<code>a  e  i  o  u</code>直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母<code>ing</code>对应分号键<code>;</code>。</li>\n</ol>\n<p>双拼下也可以使用简拼，但需要用 <code>&#39;</code> 作为分隔符划分音节。如果你刚才 <strong>整句</strong> 地输入过“我爱双拼输入法”，那么试试<code>w&#39;i&#39;u&#39;p&#39;u&#39;r&#39;f</code> ，看看你的输入法软件够不够智能。说实话，简拼用<code>&#39;</code>实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。</p>\n<h1 id=\"双拼输入法的软件\"><a href=\"#双拼输入法的软件\" class=\"headerlink\" title=\"双拼输入法的软件\"></a>双拼输入法的软件</h1><p>好像没有专门支持双拼的输入法软件啊？<br>其实Windows及Android上常见的 <strong>拼音输入法软件</strong>，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 <strong>双拼展开提示</strong>，初学时有所帮助。</p>\n<p>一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母<code>ing</code> 对应的是 <strong><code>,</code></strong>。</p>\n<p><img src=\"/img/udpn-baidu-ime.png\" alt=\"百度拼音设置\"></p>\n<hr>\n<h1 id=\"关于语音输入的杂想\"><a href=\"#关于语音输入的杂想\" class=\"headerlink\" title=\"关于语音输入的杂想\"></a>关于语音输入的杂想</h1><p>iPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：</p>\n<ul>\n<li>首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。</li>\n<li>语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。</li>\n<li>提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。</li>\n</ul>\n<blockquote>\n<p>手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；<br>但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。<br>想到这里，可能淘宝客服最适合用语音识别了;-)<br>要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。<br>话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。<br>弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于<code>Sensor offloading</code>，而且已经有了这样的App：<a href=\"http://wirelessorange.com/womic-zh/\" target=\"_blank\" rel=\"external\">WO Mic</a>，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。</p>\n</blockquote>\n<p>再到<a href=\"http://www.iflyrec.com/\" target=\"_blank\" rel=\"external\">讯飞听见</a>的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看<a href=\"http://cn.technode.com/post/2016-01-13/iflyrec-examination/\" target=\"_blank\" rel=\"external\">别人的体验</a>了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？</p>\n<p><a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\" target=\"_blank\" rel=\"external\"><img src=\"/img/udpn-iflyrec-rec.png\" alt=\"讯飞录音笔\"></a></p>\n<p><img src=\"/img/udpn-iflyrec-meeting.png\" alt=\"讯飞智能会议系统\"></p>\n","site":{"data":{}},"excerpt":"<p>双拼输入法是一个很典型的例子：一直就在我们日常使用的软件之中“隐藏”的功能，不为人所熟知，但是一旦掌握了，用起来就会很方便。<br>除了介绍双拼输入法，还有一点关于语音输入的杂想。<br>","more":"</p>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 双拼输入法](#title-%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95)\n</code></pre><ul>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E6%96%B9%E6%A1%88\">双拼方案</a><ul>\n<li><a href=\"#%E5%A3%B0%E6%AF%8D\">声母</a></li>\n<li><a href=\"#%E9%9F%B5%E6%AF%8D\">韵母</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E8%BD%AF%E4%BB%B6\">双拼输入法的软件</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E8%AF%AD%E9%9F%B3%E8%BE%93%E5%85%A5%E7%9A%84%E6%9D%82%E6%83%B3\">关于语音输入的杂想</a></li>\n</ul>\n<!-- /TOC -->\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC\" target=\"_blank\" rel=\"external\">双拼</a>输入法利用了汉语拼音的一个基本属性：包括声母和韵母两个部分。双拼输入法每输入一个汉字都要（最多）两次击键，第一次为声母，第二次为韵母，平均起来比全拼减少了击键次数，比简拼可能相差不多，但简拼一般是的特定短语，否则重码太多，双拼则没有这个限制。<br>双拼能不能显著提高输入汉字的速度没有定论，但它能保证输入速度 <strong>不会太慢</strong>，最重要的一点是每个字都是敲两个键，有很好的节奏感，让思路能很自然流畅地敲出来。</p>\n<blockquote>\n<p>本文主要内容的<a href=\"/doc/shuang_pin_udpn_cheetsheet.pdf\">一页纸PDF文件，亦称Cheetsheet</a></p>\n</blockquote>\n<h1 id=\"双拼方案\"><a href=\"#双拼方案\" class=\"headerlink\" title=\"双拼方案\"></a>双拼方案</h1><p>将汉语拼音中声母和韵母分别对应到键盘上的26个英文字母，这就是双拼方案。下面是微软双拼的方案。</p>\n<h2 id=\"声母\"><a href=\"#声母\" class=\"headerlink\" title=\"声母\"></a>声母</h2><p><code>b p m f d t n l g k h j q x r z c s y w</code>这些单声母都是直接与各自的字母键对应的，对<code>zh ch sh</code>这三个，对应关系是<code>i：ch</code>，<code>u：sh</code>，<code>v：zh</code>；有的拼音不需要声母，比如<code>爱 ai</code>，只有韵母<code>ai</code>，为了保持编码规律，指定它们为 <strong>零声母</strong>，并对应为按键<code>o</code>。</p>\n<h2 id=\"韵母\"><a href=\"#韵母\" class=\"headerlink\" title=\"韵母\"></a>韵母</h2><p>韵母的对应关系稍微复杂一点，</p>\n<ul>\n<li><code>a e i o u</code>这几个元音的对应比较简单；</li>\n<li>对于复杂韵母，<ul>\n<li><code>u o</code>相关的多在第一行键位，</li>\n<li><code>a e</code>相关的多在第二行键位，</li>\n<li><code>i</code>  相关的多在第三行键位。</li>\n</ul>\n</li>\n</ul>\n<p>下面的韵母键位需要记忆。初学时可以把这个图打印出来贴到屏幕边，或者拼到壁纸的一角，需要查看提示时按<code>Win+D</code>显示桌面即可。一般练习一两天就记住了。</p>\n<p><img src=\"/img/udpn-ms-map.png\" alt=\"微软双拼韵母键位\"></p>\n<p>例如，输入“我爱双拼输入法”，对应的击键如下表，</p>\n<p><img src=\"/img/udpn-demo.png\" alt=\"微软双拼示例\"></p>\n<p>说明：</p>\n<ol>\n<li>大部分声母都有直接对应的键位，只有<code>zh ch sh</code>需特别记忆一下。有的拼音没有声母，如<code>爱</code>，这时就需要零声母，即字母<code>o</code>，以表明后面的键是韵母；</li>\n<li>韵母<code>a  e  i  o  u</code>直接与各自的字母键对应，其它韵母的对应关系则需要记忆，注意，韵母<code>ing</code>对应分号键<code>;</code>。</li>\n</ol>\n<p>双拼下也可以使用简拼，但需要用 <code>&#39;</code> 作为分隔符划分音节。如果你刚才 <strong>整句</strong> 地输入过“我爱双拼输入法”，那么试试<code>w&#39;i&#39;u&#39;p&#39;u&#39;r&#39;f</code> ，看看你的输入法软件够不够智能。说实话，简拼用<code>&#39;</code>实在不够方便。如果连续敲的两个键不能组成一个合法的拼音，输入法一般会自动把它识别为简拼的两个拼音。</p>\n<h1 id=\"双拼输入法的软件\"><a href=\"#双拼输入法的软件\" class=\"headerlink\" title=\"双拼输入法的软件\"></a>双拼输入法的软件</h1><p>好像没有专门支持双拼的输入法软件啊？<br>其实Windows及Android上常见的 <strong>拼音输入法软件</strong>，如搜狗、百度、QQ、谷歌、紫光等，及Windows内置的微软拼音，Linux上的Fcitx，都支持双拼，只要在设置中选择一下即可。有的输入法支持 <strong>双拼展开提示</strong>，初学时有所帮助。</p>\n<p>一般输入法软件都支持多种双拼方案，有的还支持自定义方案。上面提到的几款软件都支持微软双拼方案，所以建议使用该方案。百度手机输入法的默认方案就是微软双拼，但韵母<code>ing</code> 对应的是 <strong><code>,</code></strong>。</p>\n<p><img src=\"/img/udpn-baidu-ime.png\" alt=\"百度拼音设置\"></p>\n<hr>\n<h1 id=\"关于语音输入的杂想\"><a href=\"#关于语音输入的杂想\" class=\"headerlink\" title=\"关于语音输入的杂想\"></a>关于语音输入的杂想</h1><p>iPhone上的siri当年是一大卖点（只是不知现在还有没有人用），Google，微软也相继发布类似的语音产品，不过一直都不感冒。前不久某著名相声演员在自家的手机发布会上大力赞扬友商讯飞输入法，看了该相声演员的演示后，马上在手机和PC上都安装了讯飞输入法来体验一下，感觉里预期还是有点差距，总结一些想法：</p>\n<ul>\n<li>首先不想对着手机或电脑大声说，特别是意识到是要讲给一个输入法软件时语气就会有点奇怪。</li>\n<li>语音输入的连续性也需要加强，目前的体验类似于对讲机，讲一句识别一句，确认有没有错误，如果有错误再去修改，不够自然。显然软件是可以根据声音自动断句的，用户应该可以以自然的语速不间断的讲下去，后台进行语音识别，间断输出，同时软件会保存录音，供后期集中校对，校对时可以提供多个备选及原始语音。校对其实就是机器学习里的有监督学习了，众多用户免费进行训练，而且是最真实场景的数据。</li>\n<li>提供上传mp3语音文件转换后输出文本的服务，就像已经有不少识图网站，可以输出上传图片的文字描述，这也是大数据啊~~ Youtube就有一个自动为视频生成字幕的功能；还有不少公司搞即时翻译； 或许讯飞认为他们的识别准确率已经很高，不需要再训练了。。。</li>\n</ul>\n<blockquote>\n<p>手机最初的功能就是语言通话，所以内置的麦克用来做语音识别是足够的，而且可以拿到嘴边轻声说话；<br>但电脑上就不一定有堪用的麦克了，一般笔记本是有麦克的，但效果难说，台式机就需要另外购买麦克了。<br>想到这里，可能淘宝客服最适合用语音识别了;-)<br>要是有一个高灵敏度，降噪，带录音，小巧，长时续航，USB充电，能无线接入电脑的麦克就好了。<br>话说这样的麦克应该接近于一个录音笔了，但增加了可以实时接入电脑作为麦克的功能。<br>弄个新硬件还是比较有难度的，也可以利用手机已有的麦克，在PC上虚拟出一个麦克，或许更容易些。这种思路类似于<code>Sensor offloading</code>，而且已经有了这样的App：<a href=\"http://wirelessorange.com/womic-zh/\" target=\"_blank\" rel=\"external\">WO Mic</a>，这个是通过wifi传数据的，需要PC客户端，有时间试用一下，这家还有WO Webcam和HiMic。另外的一个App则是需要一个两头都是3.5mm公头的音频线。</p>\n</blockquote>\n<p>再到<a href=\"http://www.iflyrec.com/\" target=\"_blank\" rel=\"external\">讯飞听见</a>的网站，发现了下面这两项产品/服务，看来想法差不多嘛;-) 不过录音笔有点小贵（相对其它品牌来说算是比较便宜了），云转换需要收钱，只好看看<a href=\"http://cn.technode.com/post/2016-01-13/iflyrec-examination/\" target=\"_blank\" rel=\"external\">别人的体验</a>了。话说能花钱把会议记录转成文本的，会不会考虑保密的问题？其实关于会议系统还可以做的很多，比如做网络视频会议的思科WebEx。讯飞讯飞智能会议系统可以算是关注了会议结束后，写会议纪要的工作。不过如果能在开会时就转换成文本，开完会就通过了会议纪要，效率不就更高了吗？</p>\n<p><a href=\"http://z.jd.com/project/details/34481.html\" title=\"讯飞录音笔众筹\" target=\"_blank\" rel=\"external\"><img src=\"/img/udpn-iflyrec-rec.png\" alt=\"讯飞录音笔\"></a></p>\n<p><img src=\"/img/udpn-iflyrec-meeting.png\" alt=\"讯飞智能会议系统\"></p>"},{"title":"虚拟机及docker的网络连接","date":"2016-09-19T16:00:00.000Z","_content":"网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。\n\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [路由器，NAT，交换机](#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [单机的网络地址转换（NAT）](#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89)\n- [NAT网络](#nat%E7%BD%91%E7%BB%9C)\n- [Host-Only 仅主机](#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA)\n- [桥接](#%E6%A1%A5%E6%8E%A5)\n- [Docker的桥接模式](#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F)\n- [内部网络/LAN区段](#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5)\n- [选择哪种连接方式？](#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F)\n- [Bonus](#bonus)\n\n<!-- /TOC -->\n\n# 路由器，NAT，交换机\n\n先简单介绍一下[NAT](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)。\n家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。\n\n接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问[ip.cn](http://ip.cn)，显示的IP跟当前计算机的IP是不同的。\n\n网络基础课上讲到IP v4有三类私有IP地址：\n\n+ 10.0.0.0 ~ 10.255.255.255      （A类）；\n+ 172.16.0.0 ~ 172.31.255.255    （B类）；\n+ 192.168.0.0 ~ 192.168.255.255  （C类）；\n\n\n![家用无线路由器拓扑](/img/wifi-router.png)\n\n接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。\n\n在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问[ip.cn](http://ip.cn) 或者在ubuntu上执行 `curl ip.cn` 可以查到这个公网IP，也可以执行`ip a` 、`ifconfig` 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 **发起** 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。\n曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。\n\n>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。\n\n另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。\n\n那么问题来了：\n1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？\n2、外网怎么区分路由器LAN的不同设备呢？\n\n实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。\n\n如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。\n\n把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。\n网络基础课上会介绍交换机是二层设备，路由器是三层设备。**所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。** 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。\n另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。\n\n<center>~</center>\n\n下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。\n\n![几种虚拟机的网络连接方式](/img/vnet.png)\n\n>注：**NAT网络**，Host->VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。\n\n# 单机的网络地址转换（NAT）\n 只有vbox支持 **单机NAT** 方式。这种方式与下面的 **NAT网络** 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。\n 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是`10.0.2.2`，一个DHCP服务器，也是`10.0.2.2`，VM的IP一般是`10.0.2.15`。\n 不管使用NAT的有多少个VM，它们的IP都是一样的。\n\n 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为`10.0.2.0/24`，`10.0.3.0/24`等。不过同一个VM设置多个NAT网卡并没有什么必要。\n\n VM可以直接访问Host，默认IP也是`10.0.2.2`，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。\n Host要想访问VM，需要设置端口映射，即设置`HostIP:HostPort`与`VM-IP:VM-Port`的关联，这样Host就可以通过`HostIP:HostPort`来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过`HostIP:Host-Port`来访问VM的指定端口。\n 可以添加多个映射规则来暴露不同的端口。\n\n# NAT网络\n 在VMware中则直接称为 **NAT** 。vbox刻意把这 **NAT** 和 **NAT网络** 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。\n vbox需要在 **全局配置->网络** 中增加一个 **NAT网络** 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是`10.0.2.0/24`，网关是`10.0.2.1`，DHCP服务器是`10.0.2.3`，Host是`10.0.2.2`，VM的IP是由DHCP自动分配的。\n 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。\n\n >外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 **公网** 上是不可路由的。\n >这里 **外网** 是Host之外的网络，它可能是一个Internet IP（**公网**），也可能是某个公司内部的私有IP地址的网络。\n >如果可以修改 **外网** 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。\n\n 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。\n vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段`10.0.2.0/24`，这不会彼此产生冲突，当然也可将其网段改为其它地址，如`10.0.3.0/24`，或`192.168.2.0/24`这样的，但`192.168.x.x`网段的DHCP可能不能正常工作，需设置静态IP。\n\n VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。\n\n VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 **NAT**、**仅主机** 和 **桥接** 三种不同的模式之一，但又 **限制只能有一个虚拟网卡工作在NAT模式** （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 **默认网关的IP**，及DHCP、DNS的设置。\n\n>注意，vbox在两种NAT模式下都有一个坑：\n>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，**即便这些值与DHCP分配到的值一模一样，也不能访问外网！**\n>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。\n>\n>在这个[博客](http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/) 中介绍了同样的问题（博客里的DNS IP `10.0.2.3`和`/etc/resolve.conf`设置在ubuntu上不能工作）。\n>对Ubuntu，需在 `/etc/network/interfaces` 设置网卡\n\n```\nauto eth0\niface eth0 inet static\naddress 10.0.2.15\nnetmask 255.255.255.0\ngateway 10.0.2.2\n\ndns-nameservers 10.0.2.1\n```\n\n>**设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！**\n>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。\n\n```\nVBoxManage modifyvm \"VM-Name\" --natdnsproxy1 on\nVBoxManage modifyvm \"VM-Name\" --natdnshostresolver1 on\n```\n\n>其中`VBoxManage`是vbox的命令行管理工具，在vbox的安装目录下，默认位置是`C:\\Program Files\\Oracle\\VirtualBox\\`。\n>\n>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，**NAT网络** 方式已经不需要执行上面2条命令了，但`/etc/network/interfaces`里dns-nameservers的设置还是需要的。\n>另外，经过实验发现gateway设置为`10.0.2.1` 或 `10.0.2.2`都可以连网，但DNS必须是`10.0.2.1`。\n>\n>VMware没有这个坑。\n\n# Host-Only 仅主机\n 这种连接方式是4种VMM都支持的，它的使用很简单。\n Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。\n 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 **虚拟 数据中心** 了。一个现实的数据中心里，除了多台服务器，还有 **交换机**，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。\n 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。\n Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：**内部交换机** 是很贴切的。\n\n 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。\n \n 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为`192.168.137.1`，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是`192.168.137.0/24`。\n 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考[Set up a NAT network for Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network)文档，在Powershell下以管理员权限执行\n```\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n```\n\n查看interfere index：`Get-NetAdapter`，即下面命令中虚拟网卡的`-InterfaceIndex 38`。\n```\nNew-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38\nNew-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24\n```\n\n这样就创建了一个可以通过Host以NAT方式访问外网的 **内部交换机**，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。\n\n# 桥接\n 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。\n 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。\n 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。\n\n 另外，虽然名叫 **桥接**，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。\n KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 **已有的** Linux的bridge-utils，TUN/TAP，iptables等功能。\n\n<a name=\"docker-bridge\">\n\n# Docker的桥接模式\n\n >注意：docker的网络连接方式也有 **桥接**，但实际上它的工作模式是 **NAT网络**。docker在添加了一个docker0网桥，IP网段在`172.17.0.0`，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，**不同Host** 的容器是不能直接通信的，这是个很大的局限。\n 实际上docker也可以实现KVM那样的真正的 **桥接** ，具体可参考文章 [桥接模式构建 docker 网络](http://my.oschina.net/astute/blog/293944) 和[Four ways to connect a docker container to a local network](http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/) 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。\n\n# 内部网络/LAN区段\n 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。\n 一个内部网络是由网络名来区分的。\n VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。\n 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。\n\n# 选择哪种连接方式？\n + **NAT网络**\t\t\t：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 **实验环境** 。\n + **Host-Only仅主机**\t：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。\n + **桥接**\t\t\t\t：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。\n\n 在 **数据中心** 里，网络环境不经常变化，**桥接** 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。\n 此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。\n\n\n# Bonus\n\n**[The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013](/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf)**\n\n![AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq](http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret)\n\n![Google的数据中心](/img/google_dc1.jpg)\n\n![Google的数据中心](/img/google_dc2.jpg)","source":"_posts/vm-net.md","raw":"title: 虚拟机及docker的网络连接\ncategory: [cloud]\ntags:\ndate: 2016-09-20\n---\n网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。\n\n\n<!--more-->\n\n---\n\n<!-- TOC -->\n\n    - [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n- [路由器，NAT，交换机](#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA)\n- [单机的网络地址转换（NAT）](#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89)\n- [NAT网络](#nat%E7%BD%91%E7%BB%9C)\n- [Host-Only 仅主机](#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA)\n- [桥接](#%E6%A1%A5%E6%8E%A5)\n- [Docker的桥接模式](#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F)\n- [内部网络/LAN区段](#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5)\n- [选择哪种连接方式？](#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F)\n- [Bonus](#bonus)\n\n<!-- /TOC -->\n\n# 路由器，NAT，交换机\n\n先简单介绍一下[NAT](https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2)。\n家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。\n\n接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问[ip.cn](http://ip.cn)，显示的IP跟当前计算机的IP是不同的。\n\n网络基础课上讲到IP v4有三类私有IP地址：\n\n+ 10.0.0.0 ~ 10.255.255.255      （A类）；\n+ 172.16.0.0 ~ 172.31.255.255    （B类）；\n+ 192.168.0.0 ~ 192.168.255.255  （C类）；\n\n\n![家用无线路由器拓扑](/img/wifi-router.png)\n\n接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。\n\n在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问[ip.cn](http://ip.cn) 或者在ubuntu上执行 `curl ip.cn` 可以查到这个公网IP，也可以执行`ip a` 、`ifconfig` 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 **发起** 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。\n曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。\n\n>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。\n\n另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。\n\n那么问题来了：\n1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？\n2、外网怎么区分路由器LAN的不同设备呢？\n\n实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。\n\n如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。\n\n把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。\n网络基础课上会介绍交换机是二层设备，路由器是三层设备。**所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。** 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。\n另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。\n\n<center>~</center>\n\n下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。\n\n![几种虚拟机的网络连接方式](/img/vnet.png)\n\n>注：**NAT网络**，Host->VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。\n\n# 单机的网络地址转换（NAT）\n 只有vbox支持 **单机NAT** 方式。这种方式与下面的 **NAT网络** 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。\n 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是`10.0.2.2`，一个DHCP服务器，也是`10.0.2.2`，VM的IP一般是`10.0.2.15`。\n 不管使用NAT的有多少个VM，它们的IP都是一样的。\n\n 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为`10.0.2.0/24`，`10.0.3.0/24`等。不过同一个VM设置多个NAT网卡并没有什么必要。\n\n VM可以直接访问Host，默认IP也是`10.0.2.2`，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。\n Host要想访问VM，需要设置端口映射，即设置`HostIP:HostPort`与`VM-IP:VM-Port`的关联，这样Host就可以通过`HostIP:HostPort`来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过`HostIP:Host-Port`来访问VM的指定端口。\n 可以添加多个映射规则来暴露不同的端口。\n\n# NAT网络\n 在VMware中则直接称为 **NAT** 。vbox刻意把这 **NAT** 和 **NAT网络** 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。\n vbox需要在 **全局配置->网络** 中增加一个 **NAT网络** 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是`10.0.2.0/24`，网关是`10.0.2.1`，DHCP服务器是`10.0.2.3`，Host是`10.0.2.2`，VM的IP是由DHCP自动分配的。\n 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。\n\n >外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 **公网** 上是不可路由的。\n >这里 **外网** 是Host之外的网络，它可能是一个Internet IP（**公网**），也可能是某个公司内部的私有IP地址的网络。\n >如果可以修改 **外网** 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。\n\n 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。\n vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段`10.0.2.0/24`，这不会彼此产生冲突，当然也可将其网段改为其它地址，如`10.0.3.0/24`，或`192.168.2.0/24`这样的，但`192.168.x.x`网段的DHCP可能不能正常工作，需设置静态IP。\n\n VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。\n\n VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 **NAT**、**仅主机** 和 **桥接** 三种不同的模式之一，但又 **限制只能有一个虚拟网卡工作在NAT模式** （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 **默认网关的IP**，及DHCP、DNS的设置。\n\n>注意，vbox在两种NAT模式下都有一个坑：\n>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，**即便这些值与DHCP分配到的值一模一样，也不能访问外网！**\n>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。\n>\n>在这个[博客](http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/) 中介绍了同样的问题（博客里的DNS IP `10.0.2.3`和`/etc/resolve.conf`设置在ubuntu上不能工作）。\n>对Ubuntu，需在 `/etc/network/interfaces` 设置网卡\n\n```\nauto eth0\niface eth0 inet static\naddress 10.0.2.15\nnetmask 255.255.255.0\ngateway 10.0.2.2\n\ndns-nameservers 10.0.2.1\n```\n\n>**设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！**\n>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。\n\n```\nVBoxManage modifyvm \"VM-Name\" --natdnsproxy1 on\nVBoxManage modifyvm \"VM-Name\" --natdnshostresolver1 on\n```\n\n>其中`VBoxManage`是vbox的命令行管理工具，在vbox的安装目录下，默认位置是`C:\\Program Files\\Oracle\\VirtualBox\\`。\n>\n>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，**NAT网络** 方式已经不需要执行上面2条命令了，但`/etc/network/interfaces`里dns-nameservers的设置还是需要的。\n>另外，经过实验发现gateway设置为`10.0.2.1` 或 `10.0.2.2`都可以连网，但DNS必须是`10.0.2.1`。\n>\n>VMware没有这个坑。\n\n# Host-Only 仅主机\n 这种连接方式是4种VMM都支持的，它的使用很简单。\n Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。\n 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 **虚拟 数据中心** 了。一个现实的数据中心里，除了多台服务器，还有 **交换机**，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。\n 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。\n Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：**内部交换机** 是很贴切的。\n\n 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。\n \n 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为`192.168.137.1`，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是`192.168.137.0/24`。\n 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考[Set up a NAT network for Hyper-V](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network)文档，在Powershell下以管理员权限执行\n```\nNew-VMSwitch -SwitchName \"NAT\" -SwitchType Internal\n```\n\n查看interfere index：`Get-NetAdapter`，即下面命令中虚拟网卡的`-InterfaceIndex 38`。\n```\nNew-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38\nNew-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24\n```\n\n这样就创建了一个可以通过Host以NAT方式访问外网的 **内部交换机**，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。\n\n# 桥接\n 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。\n 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。\n 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。\n\n 另外，虽然名叫 **桥接**，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。\n KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 **已有的** Linux的bridge-utils，TUN/TAP，iptables等功能。\n\n<a name=\"docker-bridge\">\n\n# Docker的桥接模式\n\n >注意：docker的网络连接方式也有 **桥接**，但实际上它的工作模式是 **NAT网络**。docker在添加了一个docker0网桥，IP网段在`172.17.0.0`，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，**不同Host** 的容器是不能直接通信的，这是个很大的局限。\n 实际上docker也可以实现KVM那样的真正的 **桥接** ，具体可参考文章 [桥接模式构建 docker 网络](http://my.oschina.net/astute/blog/293944) 和[Four ways to connect a docker container to a local network](http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/) 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。\n\n# 内部网络/LAN区段\n 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。\n 一个内部网络是由网络名来区分的。\n VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。\n 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。\n\n# 选择哪种连接方式？\n + **NAT网络**\t\t\t：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 **实验环境** 。\n + **Host-Only仅主机**\t：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。\n + **桥接**\t\t\t\t：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。\n\n 在 **数据中心** 里，网络环境不经常变化，**桥接** 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。\n 此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。\n\n\n# Bonus\n\n**[The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013](/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf)**\n\n![AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq](http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret)\n\n![Google的数据中心](/img/google_dc1.jpg)\n\n![Google的数据中心](/img/google_dc2.jpg)","slug":"vm-net","published":1,"updated":"2017-10-30T03:41:35.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmha000u9s4fafr54216","content":"<p>网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。</p>\n<a id=\"more\"></a>\n<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">路由器，NAT，交换机</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89\">单机的网络地址转换（NAT）</a></li>\n<li><a href=\"#nat%E7%BD%91%E7%BB%9C\">NAT网络</a></li>\n<li><a href=\"#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA\">Host-Only 仅主机</a></li>\n<li><a href=\"#%E6%A1%A5%E6%8E%A5\">桥接</a></li>\n<li><a href=\"#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\">Docker的桥接模式</a></li>\n<li><a href=\"#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5\">内部网络/LAN区段</a></li>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F\">选择哪种连接方式？</a></li>\n<li><a href=\"#bonus\">Bonus</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"路由器，NAT，交换机\"><a href=\"#路由器，NAT，交换机\" class=\"headerlink\" title=\"路由器，NAT，交换机\"></a>路由器，NAT，交换机</h1><p>先简单介绍一下<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"external\">NAT</a>。<br>家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。</p>\n<p>接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a>，显示的IP跟当前计算机的IP是不同的。</p>\n<p>网络基础课上讲到IP v4有三类私有IP地址：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255      （A类）；</li>\n<li>172.16.0.0 ~ 172.31.255.255    （B类）；</li>\n<li>192.168.0.0 ~ 192.168.255.255  （C类）；</li>\n</ul>\n<p><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<p>接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。</p>\n<p>在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a> 或者在ubuntu上执行 <code>curl ip.cn</code> 可以查到这个公网IP，也可以执行<code>ip a</code> 、<code>ifconfig</code> 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 <strong>发起</strong> 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。<br>曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。</p>\n<blockquote>\n<p>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。</p>\n</blockquote>\n<p>另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。</p>\n<p>那么问题来了：<br>1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？<br>2、外网怎么区分路由器LAN的不同设备呢？</p>\n<p>实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。</p>\n<p>如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。</p>\n<p>把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。<br>网络基础课上会介绍交换机是二层设备，路由器是三层设备。<strong>所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。</strong> 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。<br>另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。</p>\n<center>~</center>\n\n<p>下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。</p>\n<p><img src=\"/img/vnet.png\" alt=\"几种虚拟机的网络连接方式\"></p>\n<blockquote>\n<p>注：<strong>NAT网络</strong>，Host-&gt;VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。</p>\n</blockquote>\n<h1 id=\"单机的网络地址转换（NAT）\"><a href=\"#单机的网络地址转换（NAT）\" class=\"headerlink\" title=\"单机的网络地址转换（NAT）\"></a>单机的网络地址转换（NAT）</h1><p> 只有vbox支持 <strong>单机NAT</strong> 方式。这种方式与下面的 <strong>NAT网络</strong> 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。<br> 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是<code>10.0.2.2</code>，一个DHCP服务器，也是<code>10.0.2.2</code>，VM的IP一般是<code>10.0.2.15</code>。<br> 不管使用NAT的有多少个VM，它们的IP都是一样的。</p>\n<p> 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为<code>10.0.2.0/24</code>，<code>10.0.3.0/24</code>等。不过同一个VM设置多个NAT网卡并没有什么必要。</p>\n<p> VM可以直接访问Host，默认IP也是<code>10.0.2.2</code>，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。<br> Host要想访问VM，需要设置端口映射，即设置<code>HostIP:HostPort</code>与<code>VM-IP:VM-Port</code>的关联，这样Host就可以通过<code>HostIP:HostPort</code>来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过<code>HostIP:Host-Port</code>来访问VM的指定端口。<br> 可以添加多个映射规则来暴露不同的端口。</p>\n<h1 id=\"NAT网络\"><a href=\"#NAT网络\" class=\"headerlink\" title=\"NAT网络\"></a>NAT网络</h1><p> 在VMware中则直接称为 <strong>NAT</strong> 。vbox刻意把这 <strong>NAT</strong> 和 <strong>NAT网络</strong> 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。<br> vbox需要在 <strong>全局配置-&gt;网络</strong> 中增加一个 <strong>NAT网络</strong> 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是<code>10.0.2.0/24</code>，网关是<code>10.0.2.1</code>，DHCP服务器是<code>10.0.2.3</code>，Host是<code>10.0.2.2</code>，VM的IP是由DHCP自动分配的。<br> 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。</p>\n<blockquote>\n<p>外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 <strong>公网</strong> 上是不可路由的。<br>这里 <strong>外网</strong> 是Host之外的网络，它可能是一个Internet IP（<strong>公网</strong>），也可能是某个公司内部的私有IP地址的网络。<br>如果可以修改 <strong>外网</strong> 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。</p>\n</blockquote>\n<p> 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。<br> vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段<code>10.0.2.0/24</code>，这不会彼此产生冲突，当然也可将其网段改为其它地址，如<code>10.0.3.0/24</code>，或<code>192.168.2.0/24</code>这样的，但<code>192.168.x.x</code>网段的DHCP可能不能正常工作，需设置静态IP。</p>\n<p> VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。</p>\n<p> VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 <strong>NAT</strong>、<strong>仅主机</strong> 和 <strong>桥接</strong> 三种不同的模式之一，但又 <strong>限制只能有一个虚拟网卡工作在NAT模式</strong> （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 <strong>默认网关的IP</strong>，及DHCP、DNS的设置。</p>\n<blockquote>\n<p>注意，vbox在两种NAT模式下都有一个坑：<br>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，<strong>即便这些值与DHCP分配到的值一模一样，也不能访问外网！</strong><br>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。</p>\n<p>在这个<a href=\"http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/\" target=\"_blank\" rel=\"external\">博客</a> 中介绍了同样的问题（博客里的DNS IP <code>10.0.2.3</code>和<code>/etc/resolve.conf</code>设置在ubuntu上不能工作）。<br>对Ubuntu，需在 <code>/etc/network/interfaces</code> 设置网卡</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto eth0</div><div class=\"line\">iface eth0 inet static</div><div class=\"line\">address 10.0.2.15</div><div class=\"line\">netmask 255.255.255.0</div><div class=\"line\">gateway 10.0.2.2</div><div class=\"line\"></div><div class=\"line\">dns-nameservers 10.0.2.1</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！</strong><br>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnsproxy1 on</div><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnshostresolver1 on</div></pre></td></tr></table></figure>\n<blockquote>\n<p>其中<code>VBoxManage</code>是vbox的命令行管理工具，在vbox的安装目录下，默认位置是<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>。</p>\n<p>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，<strong>NAT网络</strong> 方式已经不需要执行上面2条命令了，但<code>/etc/network/interfaces</code>里dns-nameservers的设置还是需要的。<br>另外，经过实验发现gateway设置为<code>10.0.2.1</code> 或 <code>10.0.2.2</code>都可以连网，但DNS必须是<code>10.0.2.1</code>。</p>\n<p>VMware没有这个坑。</p>\n</blockquote>\n<h1 id=\"Host-Only-仅主机\"><a href=\"#Host-Only-仅主机\" class=\"headerlink\" title=\"Host-Only 仅主机\"></a>Host-Only 仅主机</h1><p> 这种连接方式是4种VMM都支持的，它的使用很简单。<br> Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。<br> 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 <strong>虚拟 数据中心</strong> 了。一个现实的数据中心里，除了多台服务器，还有 <strong>交换机</strong>，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。<br> 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。<br> Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：<strong>内部交换机</strong> 是很贴切的。</p>\n<p> 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。</p>\n<p> 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为<code>192.168.137.1</code>，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是<code>192.168.137.0/24</code>。<br> 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考<a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network\" target=\"_blank\" rel=\"external\">Set up a NAT network for Hyper-V</a>文档，在Powershell下以管理员权限执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-VMSwitch -SwitchName &quot;NAT&quot; -SwitchType Internal</div></pre></td></tr></table></figure></p>\n<p>查看interfere index：<code>Get-NetAdapter</code>，即下面命令中虚拟网卡的<code>-InterfaceIndex 38</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38</div><div class=\"line\">New-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24</div></pre></td></tr></table></figure></p>\n<p>这样就创建了一个可以通过Host以NAT方式访问外网的 <strong>内部交换机</strong>，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。</p>\n<h1 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h1><p> 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。<br> 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。<br> 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。</p>\n<p> 另外，虽然名叫 <strong>桥接</strong>，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。<br> KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 <strong>已有的</strong> Linux的bridge-utils，TUN/TAP，iptables等功能。</p>\n<p><a name=\"docker-bridge\"></a></p>\n<h1 id=\"Docker的桥接模式\"><a href=\"#Docker的桥接模式\" class=\"headerlink\" title=\"Docker的桥接模式\"></a>Docker的桥接模式</h1><blockquote>\n<p>注意：docker的网络连接方式也有 <strong>桥接</strong>，但实际上它的工作模式是 <strong>NAT网络</strong>。docker在添加了一个docker0网桥，IP网段在<code>172.17.0.0</code>，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，<strong>不同Host</strong> 的容器是不能直接通信的，这是个很大的局限。<br> 实际上docker也可以实现KVM那样的真正的 <strong>桥接</strong> ，具体可参考文章 <a href=\"http://my.oschina.net/astute/blog/293944\" target=\"_blank\" rel=\"external\">桥接模式构建 docker 网络</a> 和<a href=\"http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/\" target=\"_blank\" rel=\"external\">Four ways to connect a docker container to a local network</a> 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。</p>\n</blockquote>\n<h1 id=\"内部网络-LAN区段\"><a href=\"#内部网络-LAN区段\" class=\"headerlink\" title=\"内部网络/LAN区段\"></a>内部网络/LAN区段</h1><p> 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。<br> 一个内部网络是由网络名来区分的。<br> VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。<br> 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。</p>\n<h1 id=\"选择哪种连接方式？\"><a href=\"#选择哪种连接方式？\" class=\"headerlink\" title=\"选择哪种连接方式？\"></a>选择哪种连接方式？</h1><ul>\n<li><strong>NAT网络</strong>            ：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 <strong>实验环境</strong> 。</li>\n<li><strong>Host-Only仅主机</strong>    ：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。</li>\n<li><p><strong>桥接</strong>                ：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。</p>\n<p>在 <strong>数据中心</strong> 里，网络环境不经常变化，<strong>桥接</strong> 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。<br>此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。</p>\n</li>\n</ul>\n<h1 id=\"Bonus\"><a href=\"#Bonus\" class=\"headerlink\" title=\"Bonus\"></a>Bonus</h1><p><strong><a href=\"/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf\">The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013</a></strong></p>\n<p><img src=\"http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret\" alt=\"AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq\"></p>\n<p><img src=\"/img/google_dc1.jpg\" alt=\"Google的数据中心\"></p>\n<p><img src=\"/img/google_dc2.jpg\" alt=\"Google的数据中心\"></p>\n","site":{"data":{}},"excerpt":"<p>网络是云计算中重要的基础设施。这里比较了VirtualBox（简写为vbox），VMware，Hyper-V，KVM这些虚拟机管理器（VMM）及docker的网络连接方式。</p>","more":"<hr>\n<!-- TOC -->\n<pre><code>- [title: 虚拟机及docker的网络连接](#title-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8Adocker%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5)\n</code></pre><ul>\n<li><a href=\"#%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8Cnat%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA\">路由器，NAT，交换机</a></li>\n<li><a href=\"#%E5%8D%95%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88nat%EF%BC%89\">单机的网络地址转换（NAT）</a></li>\n<li><a href=\"#nat%E7%BD%91%E7%BB%9C\">NAT网络</a></li>\n<li><a href=\"#host-only-%E4%BB%85%E4%B8%BB%E6%9C%BA\">Host-Only 仅主机</a></li>\n<li><a href=\"#%E6%A1%A5%E6%8E%A5\">桥接</a></li>\n<li><a href=\"#docker%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\">Docker的桥接模式</a></li>\n<li><a href=\"#%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9Clan%E5%8C%BA%E6%AE%B5\">内部网络/LAN区段</a></li>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9F\">选择哪种连接方式？</a></li>\n<li><a href=\"#bonus\">Bonus</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"路由器，NAT，交换机\"><a href=\"#路由器，NAT，交换机\" class=\"headerlink\" title=\"路由器，NAT，交换机\"></a>路由器，NAT，交换机</h1><p>先简单介绍一下<a href=\"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"external\">NAT</a>。<br>家用的无线路由器就使用了NAT。连接到同一个无线路由器的手机，电脑等设备在使私有IP网段的局域网（LAN）中的多个设备经路由器的外网（WAN）IP访问外网。常见的家用无线路由器一般会使用192.168.0.0，192.168.1.0这样的IP网段。下面是从TP-LINK网站上找的一个图。路由器的WAN口接到了电信或者联通这些运营商提供的接口上，计算机可以用有线连接到路由器的LAN口，手机、平板也可以通过无线wifi信号连接到路由器。</p>\n<p>接到路由器上面的设备组成了一个局域网（LAN），这些设备彼此直接可以通过私网IP直接通信（Windows主机之间还可以通过机器名来访问），它们连接外网时则共享WAN口的IP，从外部来看，所有的连接都来自同一个IP。如果访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a>，显示的IP跟当前计算机的IP是不同的。</p>\n<p>网络基础课上讲到IP v4有三类私有IP地址：</p>\n<ul>\n<li>10.0.0.0 ~ 10.255.255.255      （A类）；</li>\n<li>172.16.0.0 ~ 172.31.255.255    （B类）；</li>\n<li>192.168.0.0 ~ 192.168.255.255  （C类）；</li>\n</ul>\n<p><img src=\"/img/wifi-router.png\" alt=\"家用无线路由器拓扑\"></p>\n<p>接到运营商的路由器WAN口有一个IP地址，一般是一个Internet（公网）上的动态IP，这个WAN口的IP不是固定的，每次重新连接可能会变化。如果需要一个静态的公网IP，一般则需要向运营商申请。</p>\n<p>在学校实验室的网络连接与此类似，每台机器都有一个公网的IP地址。访问<a href=\"http://ip.cn\" target=\"_blank\" rel=\"external\">ip.cn</a> 或者在ubuntu上执行 <code>curl ip.cn</code> 可以查到这个公网IP，也可以执行<code>ip a</code> 、<code>ifconfig</code> 命令来查询。公网IP理论上是可以被外界访问到的，但学校出口的防火墙屏蔽了外部 <strong>发起</strong> 的访问，只有经授权的IP和端口才能被外部访问，这样就减少了被外部攻击的可能，也就不能随便搭网站了。<br>曾经家里使用中国移动的宽带，分配的WAN口是一个B类的私有IP地址，也就是相当于我家的路由器又连到了中国移动的路由器的局域网里了，这样外部是不能访问这个WAN口IP的。</p>\n<blockquote>\n<p>学校访问外网先要登陆“网络接入认证系统”，这个系统登陆后只允许登陆设备的IP访问外网，而且不允许多台设备（多个IP）同时登录。如果自己先用路由器接到学校的网络上，然后再把多台设备接到自己的路由器上，只要这些设备中有一台登陆了“网络接入认证系统”，其它设备也就可以访问外网了。因为从认证系统看来，这些设备的IP地址都是路由器WAN口的IP地址。</p>\n</blockquote>\n<p>另外，路由器本身除了有WAN口IP之外，还有一个LAN口IP，一般是192.168.0.1/192.168.1.1，这样我们才可以通过这个IP登陆到路由器上修改相关设置。</p>\n<p>那么问题来了：<br>1、路由器LAN的设备可以访问外网，这是没有问题的，但外网怎么访问私有IP的内部设备呢？<br>2、外网怎么区分路由器LAN的不同设备呢？</p>\n<p>实际上外部网络什么也不用干，它看到的只是路由器的WAN口IP。这两个问题都是路由器通过NAT（网络地址转换）来解决的。内网向外网发送一个数据包时，路由器把数据包的源地址（实际是上还有端口号，即IP:Port格式，比如默认的http是80端口），也就是内网设备的私网IP改成自己的WAN口IP，并给不同的设备（随机）分配不同的端口号，并把随机端口号与内网设备的IP:Port的映射关系保存下来。路由器接收到外部返回的应答数据包后，根据端口号查询到实际的内网设备IP:Port，再改写数据包的目标地址，转发给LAN上的内网设备。因此NAT是分两个方向的，分别称为源NAT (SNAT) 和 目标NAT (DNAT)。</p>\n<p>如果外网直接访问路由器的WAN口IP，路由器找不到端口映射关系，就会直接drop掉这个数据包，导致外网不能直接访问内部设备。NAT默认要求一个网络通信必须由内部设备发起。也可以在路由器中设置好固定的端口映射，这样路由器就知道该转发给哪个设备，当然它还是可以判断出来是内部设备主动发起的通信，还是由外部设备发起的。还有一种DMZ技术，让路由器直接把一台内网设备暴露给外网，一般总还是有一些空闲的端口的，所以DMZ不会影响其它内网设备的联网。</p>\n<p>把路由器的WAN口那一块去掉，剩下的LAN口那部分功能就是一个交换机了，交换机所有的端口都是对等的，所连接的设备组成了一个LAN。<br>网络基础课上会介绍交换机是二层设备，路由器是三层设备。<strong>所谓二层，即物理链路层，最常见的就是以太网，设备之间以MAC地址区分；三层是网络层，设备之间以IP地址区分。三层的数据是封装在二层之中的。交换机只看数据包的MAC首部，而路由器则只看IP首部。但要是交换机偷看了IP首部也不会爆炸，而是变成更高级的三层交换机来抢路由器的生意了。具体三层交换机跟路由器的差别，因水平有限就不谈了。</strong> 网络编程基本都是在三层（IP）四层（TCP/UDP），很少直接接触二层的（MAC）。<br>另外，家用路由器一端是公网，另一端是不能直接路由的私网IP段，而数据中心或电信路由器各端口（不止两个）连接的一般都是公网，可以直接路由，不需要使用NAT。</p>\n<center>~</center>\n\n<p>下面的表格是几种虚拟机管理器（VMM）支持的网络连接方式，同一行的网络连接方式实现的功能是基本相同的，不过在不同的VMM里叫法有所不同。</p>\n<p><img src=\"/img/vnet.png\" alt=\"几种虚拟机的网络连接方式\"></p>\n<blockquote>\n<p>注：<strong>NAT网络</strong>，Host-&gt;VM的情况，VMware在Host创建了虚拟网卡，不需要端口映射，Host可以直接通过IP来访问VM。</p>\n</blockquote>\n<h1 id=\"单机的网络地址转换（NAT）\"><a href=\"#单机的网络地址转换（NAT）\" class=\"headerlink\" title=\"单机的网络地址转换（NAT）\"></a>单机的网络地址转换（NAT）</h1><p> 只有vbox支持 <strong>单机NAT</strong> 方式。这种方式与下面的 <strong>NAT网络</strong> 的唯一区别是，不同的VM之间不能互相通信。这个特性是为了方便创建多个单机VM，而不会彼此干扰。<br> 虽然是针对单机的，实际上NAT也有多个网络设备，包括一个网关，IP是<code>10.0.2.2</code>，一个DHCP服务器，也是<code>10.0.2.2</code>，VM的IP一般是<code>10.0.2.15</code>。<br> 不管使用NAT的有多少个VM，它们的IP都是一样的。</p>\n<p> 一个VM可以设置多个网卡，如果这些网卡有多个使用NAT模式，那么它们的IP区段就会递增，分别为<code>10.0.2.0/24</code>，<code>10.0.3.0/24</code>等。不过同一个VM设置多个NAT网卡并没有什么必要。</p>\n<p> VM可以直接访问Host，默认IP也是<code>10.0.2.2</code>，但这个IP在Host是看不到的，即Host跟VM不在同一个LAN，Host不能直接访问VM的IP。<br> Host要想访问VM，需要设置端口映射，即设置<code>HostIP:HostPort</code>与<code>VM-IP:VM-Port</code>的关联，这样Host就可以通过<code>HostIP:HostPort</code>来访问VM的端口了。如果映射的HostIP是可以从外部路由的，那么外部也可以通过<code>HostIP:Host-Port</code>来访问VM的指定端口。<br> 可以添加多个映射规则来暴露不同的端口。</p>\n<h1 id=\"NAT网络\"><a href=\"#NAT网络\" class=\"headerlink\" title=\"NAT网络\"></a>NAT网络</h1><p> 在VMware中则直接称为 <strong>NAT</strong> 。vbox刻意把这 <strong>NAT</strong> 和 <strong>NAT网络</strong> 这2种方式区分开，可能是因为他们认为不仅需要实现网络连通，还要能够实现隔离吧。<br> vbox需要在 <strong>全局配置-&gt;网络</strong> 中增加一个 <strong>NAT网络</strong> 的虚拟网卡才能使用NAT网络，但这个网卡在Host的网络设备里是看不到的。添加的第一个NAT网络的网段是<code>10.0.2.0/24</code>，网关是<code>10.0.2.1</code>，DHCP服务器是<code>10.0.2.3</code>，Host是<code>10.0.2.2</code>，VM的IP是由DHCP自动分配的。<br> 连接到同一个NAT网络的VM组成了一个LAN。这种情况跟前面提到的家用路由器的连接是很相似的，连接到路由器的多个设备是在一个私有IP网段的LAN，路由器有一个外网的IP，各种设备可以通过路由器连接外网，不做端口映射的话，外网不能直接访问内网的设备。</p>\n<blockquote>\n<p>外网是可以与内网通信的，否则我们就不能看到网站返回的网页了，但必须要内网设备发起连接，外网响应。这是因为内网的IP是私有的，在 <strong>公网</strong> 上是不可路由的。<br>这里 <strong>外网</strong> 是Host之外的网络，它可能是一个Internet IP（<strong>公网</strong>），也可能是某个公司内部的私有IP地址的网络。<br>如果可以修改 <strong>外网</strong> 的路由的话，还是可以实现不做端口映射，通过路由协议来路由到内网设备的，但一般只有运营商才有这样的能力。</p>\n</blockquote>\n<p> 连接到不同的虚拟网卡的VM，即便IP网段是相同，也不能连通。<br> vbox可以添加多个NAT网络，它们可以使用相同的默认IP网段<code>10.0.2.0/24</code>，这不会彼此产生冲突，当然也可将其网段改为其它地址，如<code>10.0.3.0/24</code>，或<code>192.168.2.0/24</code>这样的，但<code>192.168.x.x</code>网段的DHCP可能不能正常工作，需设置静态IP。</p>\n<p> VMware的NAT网络设置有所不同。VMware安装后，会在（Windows）Host添加一个VMnet8的虚拟网卡，工作在NAT模式。在VM中选择网卡为VMnet8和设置使用NAT模式的效果是一样的。有了这个虚拟网卡，Host也就在NAT网络的LAN里面了，所以VMware的NAT网络模式下Host是可以直接访问VM的，这点比vbox要方便些。</p>\n<p> VMware内置了VMnet0 ~ VMnet19共20个虚拟网卡可用，每个虚拟网卡对应了一个虚拟LAN，可以工作在 <strong>NAT</strong>、<strong>仅主机</strong> 和 <strong>桥接</strong> 三种不同的模式之一，但又 <strong>限制只能有一个虚拟网卡工作在NAT模式</strong> （这个限制是很奇怪的）。不过VMware在NAT模式下可以更改 <strong>默认网关的IP</strong>，及DHCP、DNS的设置。</p>\n<blockquote>\n<p>注意，vbox在两种NAT模式下都有一个坑：<br>VM在使用DHCP分配IP时能正常访问外网，但如果在VM中设置静态IP，<strong>即便这些值与DHCP分配到的值一模一样，也不能访问外网！</strong><br>虽然不能访问外网，但内网能正常访问，说明可能是DNS设置的问题。</p>\n<p>在这个<a href=\"http://geekynotebook.orangeonthewall.com/configure-static-ip-on-nat-in-oracle-virtualbox/\" target=\"_blank\" rel=\"external\">博客</a> 中介绍了同样的问题（博客里的DNS IP <code>10.0.2.3</code>和<code>/etc/resolve.conf</code>设置在ubuntu上不能工作）。<br>对Ubuntu，需在 <code>/etc/network/interfaces</code> 设置网卡</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto eth0</div><div class=\"line\">iface eth0 inet static</div><div class=\"line\">address 10.0.2.15</div><div class=\"line\">netmask 255.255.255.0</div><div class=\"line\">gateway 10.0.2.2</div><div class=\"line\"></div><div class=\"line\">dns-nameservers 10.0.2.1</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>设置静态IP后，VM还要执行下面2条命令才会使用Host的DNS！</strong><br>vbox在DHCP模式下会自动使用Host的DNS，但设置静态IP后默认不再使用Host的DNS，导致VM无法连接外网。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnsproxy1 on</div><div class=\"line\">VBoxManage modifyvm &quot;VM-Name&quot; --natdnshostresolver1 on</div></pre></td></tr></table></figure>\n<blockquote>\n<p>其中<code>VBoxManage</code>是vbox的命令行管理工具，在vbox的安装目录下，默认位置是<code>C:\\Program Files\\Oracle\\VirtualBox\\</code>。</p>\n<p>vbox 5.0.0 版有这个坑，而5.0.2 及以后的版本，<strong>NAT网络</strong> 方式已经不需要执行上面2条命令了，但<code>/etc/network/interfaces</code>里dns-nameservers的设置还是需要的。<br>另外，经过实验发现gateway设置为<code>10.0.2.1</code> 或 <code>10.0.2.2</code>都可以连网，但DNS必须是<code>10.0.2.1</code>。</p>\n<p>VMware没有这个坑。</p>\n</blockquote>\n<h1 id=\"Host-Only-仅主机\"><a href=\"#Host-Only-仅主机\" class=\"headerlink\" title=\"Host-Only 仅主机\"></a>Host-Only 仅主机</h1><p> 这种连接方式是4种VMM都支持的，它的使用很简单。<br> Host-Only模式下，vbox、VMware和Hyper-V都会在Host添加一个虚拟网卡，使用同一个虚拟网卡的VM会连接到同一个虚拟LAN，而且Host也在这个LAN。Host，VM之间都可以方便的连通，不需要端口映射，但VM不能访问外网。<br> 当我们创建了多个VM，并把这些VM连接到一个虚拟LAN，这就算是一个小型的 <strong>虚拟 数据中心</strong> 了。一个现实的数据中心里，除了多台服务器，还有 <strong>交换机</strong>，集中式存储设备，比如iSCSI，SAN，NAS等。一个机架里的多台服务器连接到机架顶部的交换机（ToR），多个机架交换机再连接到核心交换机。<br> 实际上数据中心的网络结构是很复杂的，并不只有一个LAN，而是分成了外部网络、内部业务网络、管理网络、存储网络等多个网络，还会划分成多个子网。<br> Host-Only连接方式物相当于机架顶部的交换机（ToR），所以Hyper-V的叫法：<strong>内部交换机</strong> 是很贴切的。</p>\n<p> 还可以添加多个虚拟网卡，组成多个彼此隔离的LAN（Host分别有一个虚拟网卡挂在每个LAN中）。</p>\n<p> 利用Windows的网络共享功能，将外部网络共享给Host的虚拟网卡，然后将VM设置为静态IP，网关和DNS设置为<code>192.168.137.1</code>，这样就可以连接外网了，但只能共享给一个虚拟网卡，而且IP网段必须是<code>192.168.137.0/24</code>。<br> 复杂点的办法是在Host配置NAT，以Hyper-V为例，它没有NAT网络，参考<a href=\"https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/setup-nat-network\" target=\"_blank\" rel=\"external\">Set up a NAT network for Hyper-V</a>文档，在Powershell下以管理员权限执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-VMSwitch -SwitchName &quot;NAT&quot; -SwitchType Internal</div></pre></td></tr></table></figure></p>\n<p>查看interfere index：<code>Get-NetAdapter</code>，即下面命令中虚拟网卡的<code>-InterfaceIndex 38</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">New-NetIPAddress -IPAddress 10.0.0.2 -PrefixLength 24 -InterfaceIndex 38</div><div class=\"line\">New-NetNat -Name NATx -InternalIPInterfaceAddressPrefix 10.0.0.0/24</div></pre></td></tr></table></figure></p>\n<p>这样就创建了一个可以通过Host以NAT方式访问外网的 <strong>内部交换机</strong>，不过这个内部交换机还缺少DHCP服务，需要为VM静态分配IP。</p>\n<h1 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h1><p> 桥接是最方便的一种连接方式。它需要绑定到物理网卡。如果Host的网络连接正常，那么VM一般也就没什么问题了，但如果Host的网络出现了故障，那么VM也无法联网了，即便是同一个Host的VM之间也不能正常通信。<br> 桥接模式下VM与Host的地位是完全对等的。从外部看，VM就像一台真实的机器一样，有自己的MAC和IP。这样极大地简化了网络结构。<br> 不过，在学校的网络环境下，每个IP需要登录web认证后才能访问外网，每个桥接的VM不能都需要登录，而每个账号只能同时登录一个IP的限制导致只能有一个台机器能连上外网，所以不适合采用桥接。</p>\n<p> 另外，虽然名叫 <strong>桥接</strong>，但vbox和VMware都没有用到“网桥”。桥接实际是用所谓的网卡的“混合模式”实现的，即一个网卡可以伪装成不同MAC地址的多个网卡。在Hyper-V中倒是添加了一个虚拟网桥和一个虚拟网卡，功能上是一样的。<br> KVM的各种网络连接方式都需要设置一个bridge，区别在于这个bridge与物理网卡（如eth0）的连接及路由设置。KVM的网络连接不是像vbox，VMware或Hyper-V那样由VMM实现的，而是利用了 <strong>已有的</strong> Linux的bridge-utils，TUN/TAP，iptables等功能。</p>\n<p><a name=\"docker-bridge\"></a></p>\n<h1 id=\"Docker的桥接模式\"><a href=\"#Docker的桥接模式\" class=\"headerlink\" title=\"Docker的桥接模式\"></a>Docker的桥接模式</h1><blockquote>\n<p>注意：docker的网络连接方式也有 <strong>桥接</strong>，但实际上它的工作模式是 <strong>NAT网络</strong>。docker在添加了一个docker0网桥，IP网段在<code>172.17.0.0</code>，如果外网要访问容器，需要做端口映射。这样的网络连接方式下，<strong>不同Host</strong> 的容器是不能直接通信的，这是个很大的局限。<br> 实际上docker也可以实现KVM那样的真正的 <strong>桥接</strong> ，具体可参考文章 <a href=\"http://my.oschina.net/astute/blog/293944\" target=\"_blank\" rel=\"external\">桥接模式构建 docker 网络</a> 和<a href=\"http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/\" target=\"_blank\" rel=\"external\">Four ways to connect a docker container to a local network</a> 。看起来这样的连接方式还是比较实现容易的，但目前docker还没有在官方的实现中直接支持这种连接方式。</p>\n</blockquote>\n<h1 id=\"内部网络-LAN区段\"><a href=\"#内部网络-LAN区段\" class=\"headerlink\" title=\"内部网络/LAN区段\"></a>内部网络/LAN区段</h1><p> 这种方式下只有连接到同一内部网络的VM之间能够通信，而VM与Host，与外网都不能通信。<br> 一个内部网络是由网络名来区分的。<br> VMware和Hyper-V的内部网络可以设置网络带宽，丢包率等，方便进行网络方面的实验，不过作为其它场景的实验环境就不太合适了。<br> 内部网络不支持DHCP，可以专门添加一个多网卡的VM作为网络服务器，完成DHCP，网关，路由等功能。</p>\n<h1 id=\"选择哪种连接方式？\"><a href=\"#选择哪种连接方式？\" class=\"headerlink\" title=\"选择哪种连接方式？\"></a>选择哪种连接方式？</h1><ul>\n<li><strong>NAT网络</strong>            ：优点是可以充分共享Host的网络连接，包括VPN；不足是Host和外部访问VM需要端口映射；VM的IP地址不受外部影响，适合搭建 <strong>实验环境</strong> 。</li>\n<li><strong>Host-Only仅主机</strong>    ：优点是Host可以方便地访问VM；不足是不能访问外网；VM的IP地址也不受外部影响，如果NAT网络需要较多的端口映射，可以考虑每台VM设置2个网卡，一个工作在NAT网络模式，另一个工作在Host-Only模式。</li>\n<li><p><strong>桥接</strong>                ：优点是设置简便，很容易实现互联互通；不足是不能共享Host的网络连接（web登录认证，VPN），而且VM的IP地址受外部影响，更换了网络环境，IP地址可能会发生变化。假设用笔记本电脑搭建的实验环境，VM使用桥接模式，在宿舍的IP地址和在会议室的IP地址是不同的，依赖IP的设置都要修改，是很不方便的。</p>\n<p>在 <strong>数据中心</strong> 里，网络环境不经常变化，<strong>桥接</strong> 模式屏蔽了VMM的影响，可以直接应用已有的交换机设备和配置，简化了网络配置操作。如果交换机支持VLAN，那么可以启用VLAN作为VM的网络隔离，虽然有不能超过4096（ $ 2^{12} $，12 bit）个VLAN的数量限制，但对企业内部的私有云场景应该是足够的。<br>此外，虚拟网络还要考虑IP地址的容量，分配和管理方式避免冲突，多租户的隔离，以及故障转移后的IP重用策略等，了解的不多，这里就不多说了。</p>\n</li>\n</ul>\n<h1 id=\"Bonus\"><a href=\"#Bonus\" class=\"headerlink\" title=\"Bonus\"></a>Bonus</h1><p><strong><a href=\"/doc/The_Datacenter_as_a_Computer_An_Introduction_to_the_Design_of_Warehouse_Scale_Machines_2e_2013.pdf\">The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines - 2e - 2013</a></strong></p>\n<p><img src=\"http://www.infoq.com/cn/presentations/aws-data-center-and-vpc-secret\" alt=\"AWS 数据中心与 VPC 揭秘 - QCon Beijing 2017 - infoq\"></p>\n<p><img src=\"/img/google_dc1.jpg\" alt=\"Google的数据中心\"></p>\n<p><img src=\"/img/google_dc2.jpg\" alt=\"Google的数据中心\"></p>"},{"title":"如何收集和整理论文（面向CS专业）","date":"2016-09-27T16:00:00.000Z","_content":"\n论文（Paper）是每个研究生读研路上挥之不去的“阴云”。\n无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展（State of the art & practice）。\n本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了相关的机构，学术会议和论文数据库。\n文末有 [**Bonus**](#hosts) 哦;-)\n\n<!--more-->\n\n---\n\n# tl;dr\n+ 从[CCF推荐目录](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)中自己感兴趣的方向的 **A类会议及期刊** 中找论文即可。\n+ 我关注的云计算，程序分析方向的[会议和期刊列表](#tldr)\n+ [**Bonus**](#hosts) 修改Hosts\n\n# 引子\n按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：\n+ 周志华老师的一篇关于[做研究与写论文的ppt](/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf)\n+ 凌晓峰和杨强的[《学术研究 - 你的成功之道》](http://item.jd.com/11127141.html)，这本书的英文原版是[Crafting Your Research Future - A Guide to Successful Master's and Ph.D. Degrees in Science & Engineering](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064)\n\n首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果（的一部分）。结果肯定是必要的，自然也就少不了Paper或者总结报告；\n再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。\n重要的是要 **有意识地探索和总结适合自己的科研方法**，既要低头苦干，又要抬头看路，还要回头总结。\n\n## 论文发表的过程\n\n<pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n简单介绍一下发表论文的过程：\n+ 首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如[UC Berkeley 的AMPLab](https://amplab.cs.berkeley.edu/)；还有一些公司的研究院，比如[微软](https://www.microsoft.com/en-us/research/)，[谷歌](https://research.google.com/pubs/papers.html)。显然，论文的出身对质量有很大影响。\n+ 期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期（Deadline，ddl）的压力。投稿后一般要经过同行评审（Peer Review），针对审稿人的建议做大修，小修（Major，Minor Revision）等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊（Special Issue）计划，会公布一个截稿日期，审稿的进度会稍快些。\n期刊分为 **Transaction, Journal 和 Magazine** 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 **不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是 [Communications of the ACM（CACM, ACM通讯）](http://dl.acm.org/citation.cfm?id=J79) 值得关注**。\n+ 对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等（有的期刊则动辄一卷几千页，所以，文章质量嘛……），所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。\n很多会议每年举行一次，时间上也是比较固定的月份，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。\n会议录用的所有Paper会结集出版，称为 **Proceedings** 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。\n会议分为 **Symposium , Conference 和 Workshop**。这三者的学术严肃性依次降低，大部分会议都称为 **Conference**。一般来说 **Workshop** 是随某个 **Conference** 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。\n\n通过这个过程，我们还可以知道如何 **尽快** 找到一篇感兴趣的文章：\n+ 对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access，即在线预出版；\n+ 对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。\n\n# CS论文数据库\n\n## ACM, IEEE Computer等\n\n一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及[图书馆页面截图](#lib)。\n> 注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。\n\n| 机构                                     | Digital Library （DL）                              | 机构首页                   |\n|------------------------------------------|----------------------------------------------------|----------------------------|\n| Association for Computing Machinery, ACM | ACM Digital Library  https://dl.acm.org/           | https://www.acm.org/       |\n| IEEE Computer Society                    | IEEE Xplore DL http://ieeexplore.ieee.org/         | https://www.computer.org/  |\n| Elsevier ScienceDirect                   | http://www.sciencedirect.com/                      | https://www.elsevier.com/  |\n| Springer                                 | Springer Link http://link.springer.com/            | http://www.springer.com/   |\n| Wiley                                    | Wiley Online Lib http://onlinelibrary.wiley.com/   | http://www.wiley.com/      |\n\nACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 **.org**，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。\nElsevier，Springer，Wiley的网址后缀则是 **.com** ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。\n上面这几个数据库是 **主要的论文全文来源**。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。\n> ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 **元数据**，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。\n> IEEE出版的一些论文在 computer.org （实际是[CSDL](https://www.computer.org/csdl/)）和 Xplore DL 都可能搜到，但这两个数据库是 **分别** 收费的，能在Xplore DL下载的不一定能在Computer.org下载。\n\n### ACM SIGs\nACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个[ACM SIGs](http://www.acm.org/sigs/)（或参考DL的这个链接[SIGs ACM DL](http://dl.acm.org/sigs.cfm)），比如\n+ 体系结构方向的[SIGARCH](http://www.sigarch.org/)、[SIGHPC](http://www.sighpc.org/)、[SIGMETRICS](http://www.sigmetrics.org/)、[SIGMICRO](http://www.sigmicro.org/)、[SIGMOBILE](http://www.sigmobile.org/)，\n+ 网络方向的[SIGCOMM](http://www.sigcomm.org/)，\n+ 数据库方向的[SIGMOD](http://www.sigmod.org/)，\n+ 系统方向的[SIGOPS](http://www.sigops.org/)，\n+ 软件工程方向的[SIGPLAN](http://www.sigplan.org/)、[SIGSOFT](http://www.sigsoft.org/)\n\n这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 **最佳论文**，**优秀博士论文** 等（在DL中一般没有标明哪篇是Best Paper）。此外，\n+ 有网站维护了一个[部分会议的最佳论文列表](http://jeffhuang.com/best_paper_awards.html)，\n+ 还有下面要介绍的USENIX的[各会议最佳论文](https://www.usenix.org/conferences/best-papers)。\n\n有的SIG会选择一些高质量的文章，以Review，Newsletter 或 Notes 的形式重新发表，引用的时候最好引用最初的来源。\n\n## [USENIX](https://www.usenix.org/)\n要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。\n话说**[USENIX](https://www.usenix.org/)** 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slides及演讲视频。slides是对文章的提炼，读论文时可以参考。拿slides和视频来学习做Presentation，练习英语听力和口语也不错。\n\n## [arXiv](http://arxiv.org/)\n[arXiv](http://arxiv.org/)， 是archive（归档）的意思，是一个由康乃尔大学维护的免费的多学科论文**预**出版（preprint）数据库。所谓**预**出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。\n\n<a name=\"lib\" />![图书馆电子资源](/img/lib.png)\n\n## EI和SCI\n分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，\n+ EI **Engineering Index** https://www.engineeringvillage.com/\n+ SCI **Science Citation Index** http://apps.webofknowledge.com/\n\n**只看 URL 还以为是 山寨网站**，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 **已知文章标题的情况下** 检索是不是被它们收录了，而 **不是** 用来收集文章的。\n\n要确定某个会议论文集或者期刊[是否被EI或SCI收录](http://www.philippe-fournier-viger.com/links.php)，\n+ 在[EI收录列表](https://www.elsevier.com/solutions/engineering-village/content) 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考[这个脚本解除保护](/doc/crack_xls_vb.txt)，还要建议把title列中每个单元格开头的`=`替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫`Computing`，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。**但是！**，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 **Compendex**。\n+ 在`webofknowledge`的网站查询之前，**一定** 要选择数据库为`检索 Web of Science 核心合集`，等自动刷新候，还要在页面下部展开“更多设置”，只选中`Science Citation Index Expanded (SCIEXPANDED) 1900年至今`这一项，然后才能查询出根正苗红的`SCI（E）`。请**务必**参考[这个截图](/doc/SCI_E_Web_of_Science.pdf)。可以在[SCI收录列表](http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K)直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：[中国科学技术信息研究所SCI（E）论文期刊分区列表（2016年）](http://scit.nju.edu.cn/Item/1162.aspx)，这是一个有13.8k多行的Excel表格，简洁粗暴。\n\n----\n上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。\n校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。\n话说只要是能花钱买到的东西，去万能的 **淘宝** 肯定能找到，就看是买 **VPN/代理，单篇文章，还是 整个数据库** 了。\n\n## dblp\ndblp [http://dblp.org] ，或[http://dblp.uni-trier.de]， 是专注于CS学科的文献 **元数据索引** 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 http://dblp.org/db/conf/sigsoft/fse2016.html 或者某个作者的全部论文列（dblp对重名作者处理得很好），但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。\n2015版CCF目录中的会议和期刊都是dblp的链接。\n\ndblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）\n+ [累计论文记录数量](http://dblp.dagstuhl.de/statistics/recordsindblp.html)，\n+ [每年发表的论文数量](http://dblp.dagstuhl.de/statistics/publicationsperyear.html)，\n+ [论文发表的类型](http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html)，其中会议论文占53%，\n+ 论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。\n\n另外，ACM DL也有一个[类似的统计](http://dl.acm.org/contents_guide.cfm)。\n![每年发表的CS论文数量](/img/pubs.png)\n\n而且dblp整站的数据都可以下载为一个[xml文件](http://dblp.dagstuhl.de/xml/)，以供进一步挖掘。\n\n## DOI\n在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，[wikipedia介绍DOI](https://zh.wikipedia.org/wiki/DOI)“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。\n\n## 其它\n从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。\n+ Semantic Scholar [https://www.semanticscholar.org]\n+ CiteSeerX [http://citeseerx.ist.psu.edu/]\n+ ResearchGate [https://www.researchgate.net/] ，这是一个学术社交网络\n\n# CCF目录\n\nEI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。\n更 “**不幸**” 的是，对于CS的学生，还有一个[CCF目录](http://history.ccf.org.cn/sites/ccf/paiming.jsp)（[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。\n\n首先说[中国计算机学会 CCF](http://www.ccf.org.cn/)是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然[精简得多](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)。\n考虑到对EI和SCI指标要求的实际情况，目录选取的 **大多** 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。\nA，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。\n\n> 如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 [FGCS\tFuture Generation Computer Systems](http://dblp.org/db/journals/fgcs/)上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。\n> 随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。\n\n上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的[分类系统CCS](http://dl.acm.org/ccs/ccs.cfm)，以及有重叠的[SIGs大类划分](https://www.acm.org/special-interest-groups/sigs-by-knowledge-area)，还有[wikipedia上的一个划分](https://en.wikipedia.org/wiki/Outline_of_computer_science)。\n\n# Google Scholar（谷歌学术）\n[Google Scholar](https://scholar.google.com/)非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 **高级搜索**，实在不行再去ACM DL、IEEE Xplore。\n![谷歌学术高级搜索](/img/scholar_adv.png)\n\n## 创建快讯\n与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；\n此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 **作者的个人资料页** 可以创建关于他的新文章或新引用的快讯，及时获取动态。\n\n> 话说体验一下[必应学术](http://www.bing.com/academic)、[百度学术](http://xueshu.baidu.com/)和[搜狗学术](http://scholar.sogou.com/)也未尝不可。\n\n<a name=\"tldr\" />\n\n# tl,dr：链接列表\n\n## 体系结构，系统，存储，分布式系统\n+ ASPLOS@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE178&tab=pubs) , [DBLP](http://dblp.org/db/conf/asplos/) Architectural Support for Programming Languages and Operating Systems\n+ FAST@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE425&tab=pubs) , [DBLP](http://dblp.org/db/conf/fast/) Conf. on File and Storage Technologies\n+ HPCA@**A**   [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=1000335) , [DBLP](http://dblp.org/db/conf/hpca/) High-Performance Computer Architecture\n+ ISCA@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE239&tab=pubs) , [DBLP](http://dblp.org/db/conf/isca/) Int. Symposium on Computer Architecture\n+ MICRO@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE203&tab=pubs) , [DBLP](http://dblp.org/db/conf/micro/) Microarchitecture\n+ PPoPP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE241&tab=pubs) , [DBLP](http://dblp.org/db/conf/ppopp/) Principles and Practice of Parallel Programming\n+ SC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE207&tab=pubs) , [DBLP](http://dblp.org/db/conf/sc/) Int. Conf. for High Performance Computing, Networking, Storage, and Analysis\n+ ATC@**A**   [USENIX](https://www.usenix.org/conferences/byname/131) , [DBLP](http://dblp.org/db/conf/usenix/) USENIX Annul Technical Conf.\n+ CGO@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE256&tab=pubs) , [DBLP](http://dblp.org/db/conf/cgo/) Code Generation and Optimization\n+ EuroSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE101&tab=pubs) , [DBLP](http://dblp.org/db/conf/eurosys/) European Conf. on Computer Systems\n+ HotCHIPS@**B**   [HotChips](http://www.hotchips.org/) Symposium on High Performance Chips\n+ HPDC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE300&tab=pubs) , [DBLP](http://dblp.org/db/conf/hpdc/) High-Performance Distributed Computing\n+ LISA@**B**   [USENIX](https://www.usenix.org/conferences/byname/5) , [DBLP](http://dblp.org/db/conf/lisa/) Large Installation system Administration Conf.\n+ PODC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE221&tab=pubs) , [DBLP](http://dblp.org/db/conf/podc/) Symposium on Principles of Distributed Computing\n+ SIGMETRICS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE187&tab=pubs)，[ACM](http://dl.acm.org/citation.cfm?id=J618) , [DBLP](http://dblp.org/db/conf/sigmetrics/) Int. Conf. on Measurement and Modeling of Computer Systems\n+ VEE@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE287&tab=pubs) , [DBLP](http://dblp.org/db/conf/vee/) Virtual Execution Environments\n+ TC@**A**   [IEEE](https://www.computer.org/web/tc) , [DBLP](http://dblp.org/db/journals/tc/) Trans. on Computers\n+ TOCS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J774&tab=pubs) , [DBLP](http://dblp.org/db/journals/tocs/) Trans. on Computer Systems\n+ TOS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J960&tab=pubs) , [DBLP](http://dblp.org/db/journals/tos/) Trans. on Storage\n+ TPDS@**A**   [IEEE](https://www.computer.org/web/tpds) , [DBLP](http://dblp.org/db/journals/tpds/) Trans. on Parallel and Distributed Systems\n+ ISMM   [ACM](http://dl.acm.org/event.cfm?id=RE149&tab=pubs) , [DBLP](http://dblp.org/db/conf/ismm/) Int. Conf. on Memory Management\n\n## 软件工程（软件分析）\n+ Github上的[软件工程方向会议的数据](https://github.com/tue-mdse/conferenceMetrics)\n+ UIUC的[谢涛老师](http://taoxie.cs.illinois.edu/)维护的[软件工程方向的会议统计列表](http://taoxie.cs.illinois.edu/seconferences.htm)\n+ ASE@**A**   [DBLP](http://dblp.org/db/conf/kbse/) Int. Conf. on Automated Software Engineering\n+ FSE/ESEC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE201&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigsoft/) SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.\n+ ICSE@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE228&tab=pubs) , [DBLP](http://dblp.org/db/conf/icse/) FOSE会议：七年一届的展望 Int. Conf. on Software Engineering\n+ OOPSLA/SPLASH@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE181&tab=pubs) , [DBLP](http://dblp.org/db/conf/oopsla/) Onward会议：创新（脑洞） Conf. on Object-Oriented Programming Systems, Languages, and Applications\n+ OSDI@**A**   [USENIX](https://www.usenix.org/conferences/byname/179) , [DBLP](http://dblp.org/db/conf/osdi/) USENIX Symposium on Operating Systems Design and Implementations，**双数** 年份召开\n+ SOSP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE208&tab=pubs) , [DBLP](http://dblp.org/db/conf/sosp/)，Symposium on Operating Systems Principles， **单数** 年份召开，另，[SOSP 2015 History Day](http://sigops.org/sosp/sosp15/history/index.html)\n+ PLDI@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE200&tab=pubs) , [DBLP](http://dblp.org/db/conf/pldi/) SIGPLAN Symposium on Programming Language Design and Implementation\n+ POPL@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE180&tab=pubs) , [DBLP](http://dblp.org/db/conf/popl/) SIGPLAN&SIGACT Symposium on Principles of Programming Languages\n+ ECOOP@**B**   [ECOOP](http://www.ecoop.org/) , [DBLP](http://dblp.org/db/conf/ecoop/) European Conf. on Object-Oriented Programming\n+ HotOS@**B**   [USENIX](https://www.usenix.org/conferences/byname/155) , [DBLP](http://dblp.org/db/conf/hotos/) USENIX Workshop on Hot Topics in Operating Systems\n+ ICSME@**B**   [IEEE](http://conferences.computer.org/icsm/) , [DBLP](http://dblp.org/db/conf/icsm/) Int. Conf. on Software Maintenance\n+ ISSTA@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE222&tab=pubs) , [DBLP](http://dblp.org/db/conf/issta/) Int. Symposium on Software Testing and Analysis\n+ TOPLAS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J783&tab=pubs) , [DBLP](http://dblp.org/db/journals/toplas/) Trans. on Programming Languages and Systems\n+ TOSEM@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J790&tab=pubs) , [DBLP](http://dblp.org/db/journals/tosem/) Trans. on Software Engineering Methodology\n+ TSE@**A**   [IEEE](https://www.computer.org/web/tse) , [DBLP](http://dblp.org/db/journals/tse/) Trans. on Software Engineering\n\n## 云计算，网络，大数据\n+ SIGMOD@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigmod/) Conf. on Management of Data\n+ SoCC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/cloud/) Symposium on Cloud Computing\n+ PODS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/pods/) SIGMOD Conf. on Principles of DB Systems\n+ VLDB Endowment@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J1174&tab=pubs) , [DBLP](http://dblp.org/db/conf/vldb/) Int. Conf. on Very Large Data Bases\n+ VLDB Journal@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J869&tab=pubs) , [DBLP](http://dblp.org/db/journals/vldb/) Int. Journal on Very Large Data Bases\n+ NSDI@**B**   [USENIX](https://www.usenix.org/conferences/byname/178) , [DBLP](http://dblp.org/db/conf/nsdi/) Network System Design and Implementation\n+ IEEE 云计算系列@**B/C**  [IEEE](http://cloudcomputing.ieee.org/conferences) , [DBLP](http://dblp.org/db/conf/IEEEcloud/)\n+ HotCloud   [USENIX](https://www.usenix.org/conferences/byname/1) , [DBLP](http://dblp.org/db/conf/hotcloud/) Hot Topics on Cloud Computing\n+ TCC   [IEEE](https://www.computer.org/web/tcc) , [DBLP](http://dblp.org/db/journals/tcc/) IEEE Trans. on Cloud Computing\n+ TSC@**B**   [IEEE](https://www.computer.org/web/tsc) , [DBLP](http://dblp.org/db/journals/tsc/) IEEE Trans. on Services Computing\n+ SigComm@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE258&tab=pubs) , [DBLP](http://dblp.org/conf/sigcomm/)\n上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。\n\n## 移动计算\n+ MobiCom@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE366&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobicom/) Mobile Computing and Networking\n+ MobiSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE191&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobisys/) Mobile Systems, Applications, and Services\n+ HotMobile   [ACM](http://dl.acm.org/event.cfm?id=RE142&tab=pubs) , [DBLP](http://dblp.org/db/conf/wmcsa/) Mobile Computing Systems and Applications\n\n## ACM DL列表\n+ [收录会议和期刊的完整列表](http://dl.acm.org/contents_dl.cfm)\n+ [会议](http://dl.acm.org/events.cfm)\n+ [会议历次论文集](http://dl.acm.org/proceedings.cfm)\n+ [期刊和学报](http://dl.acm.org/pubs.cfm)\n+ [杂志](http://dl.acm.org/mags.cfm)\n+ [ACM Conferences - past 12 months](http://dl.acm.org/conferences.cfm)\n+ [ACM Upcoming Conferences - RSS](http://dl.acm.org/UpcomingConfLocations.xml)\n\n关于ACM的杂志，特别推荐\n+ [Communications of the ACM, CACM](http://dl.acm.org/citation.cfm?id=J79)， [in dblp](http://dblp.org/db/journals/cacm/)\n+ [CACM中国版](http://dl.acm.org/toco_arch.cfm?id=J79&lang=chinese)，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去\n+ [Queue](http://dl.acm.org/citation.cfm?id=J882)也值得一看，不过它与CACM有很多重叠的文章\n\n期刊中，推荐[ACM Computing Surveys, CSUR](http://dl.acm.org/citation.cfm?id=J204)， [in dblp](http://dblp.org/db/journals/csur/)\n\n> 看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。\n\n##  IEEE Computer列表\n\n+ [会议日历](https://www.computer.org/web/conferences/calendar/)\n+ [期刊和学报](https://www.computer.org/web/publications/transactions)\n+ [杂志](https://www.computer.org/web/publications/magazines)\n\n## [USENIX组织的会议列表](https://www.usenix.org/conferences/byname)\n[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。\n\n## 国内三个学报\n\n+ [软件学报](http://www.jos.org.cn/ch/index.aspx)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS)\n+ [计算机学报](http://cjc.ict.ac.cn/)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS)\n+ [计算机研究与发展](http://crad.ict.ac.cn/CN/volumn/home.shtml) ，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS)\n\n## 国内论文数据库\n\n+ [知网CNKI](http://www.cnki.net/)\n+ [万方数据](http://www.wanfangdata.com.cn/)\n\n## 其它链接\n+ [微软研究院](https://www.microsoft.com/en-us/research/)\n+ [谷歌研究院](https://research.google.com/pubs/papers.html)\n+ [The morning paper](https://blog.acolyer.org/), an interesting-influential-important paper from the world of CS every weekday morning\n+ [IEEE Technical Committee on Data Engineering](http://sites.computer.org/debull/bull_issues.html)\n+ [YouTube](https://www.youtube.com)，\n+ **[Suggested Guidelines for Finding Materials to include in the \"Related Work\" Sections of Conference Papers](http://www1.cs.columbia.edu/~kaiser/relatedwork.htm)**\n+ [YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表](http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582)  \n\n# 如何读论文\n+ [Efficient Reading of Papers in Science and Technology(pdf)](http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf)\n+ [How to Read a Paper(pdf)](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)\n+ [How to Read a Technical Paper](https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html)\n+ [《学术研究 - 你的成功之道》第3章](http://item.jd.com/11127141.html)\n\n# [Todo]辅助工具\n+ [会伴](http://myhuiban.com)\n+ Trans. on BigData的学术文献处理专刊 [Vol. 2 Issue 1](https://www.computer.org/csdl/trans/bd/2016/01/index.html)，[Vol. 2 Issue 2](https://www.computer.org/csdl/trans/bd/2016/02/index.html)\n+ [Sciplore](http://www.sciplore.org/)\n+ [Scopus](https://www.scopus.com/)\n+ [Docear](http://www.docear.org/)\n+ [Mendeley](https://www.mendeley.com/)\n+ [Zotero](https://www.zotero.org/)\n+ [Teambition](https://www.teambition.com/)\n+ Todo，如何整理文献，如何管理时间，[科研小组里有哪些有效的组会形式 - 知乎](https://www.zhihu.com/question/27956707)\n\n如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，**总会觉得** 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去[wikipedia](https://en.wikipedia.org/)上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。\n如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。\n\n> PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)\n\n一些标题有`A systematic review on ...`综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。\n\n再列出知乎上的几个相关问题吧\n+ [如何总结和整理学术文献？](https://www.zhihu.com/question/26901116)\n+ [如何高效管理文献？](https://www.zhihu.com/question/26857521)\n+ [如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?](https://www.zhihu.com/question/22790506)\n\n<a name=\"hosts\" />\n# [Bonus] 如何访问Google Scholar\n\n## **改hosts**\n+ IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N\n+ IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk\n\n## **hosts文件的路径**\n+ Windows：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n+ Linux，Mac，Android（均需要root权限）：`/etc/hosts`\n\n# PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)\n\n---\n\n飞鸟集\n\n> 第83\n> 那想做好人的，在门外敲着门，那爱人的，看见门敞开着。\n\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n","source":"_posts/we-love-paper.md","raw":"title: 如何收集和整理论文（面向CS专业）\ncategory: misc\ndate: 2016-09-28\ntags:\n---\n\n论文（Paper）是每个研究生读研路上挥之不去的“阴云”。\n无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展（State of the art & practice）。\n本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了相关的机构，学术会议和论文数据库。\n文末有 [**Bonus**](#hosts) 哦;-)\n\n<!--more-->\n\n---\n\n# tl;dr\n+ 从[CCF推荐目录](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)中自己感兴趣的方向的 **A类会议及期刊** 中找论文即可。\n+ 我关注的云计算，程序分析方向的[会议和期刊列表](#tldr)\n+ [**Bonus**](#hosts) 修改Hosts\n\n# 引子\n按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：\n+ 周志华老师的一篇关于[做研究与写论文的ppt](/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf)\n+ 凌晓峰和杨强的[《学术研究 - 你的成功之道》](http://item.jd.com/11127141.html)，这本书的英文原版是[Crafting Your Research Future - A Guide to Successful Master's and Ph.D. Degrees in Science & Engineering](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064)\n\n首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果（的一部分）。结果肯定是必要的，自然也就少不了Paper或者总结报告；\n再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。\n重要的是要 **有意识地探索和总结适合自己的科研方法**，既要低头苦干，又要抬头看路，还要回头总结。\n\n## 论文发表的过程\n\n<pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n简单介绍一下发表论文的过程：\n+ 首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如[UC Berkeley 的AMPLab](https://amplab.cs.berkeley.edu/)；还有一些公司的研究院，比如[微软](https://www.microsoft.com/en-us/research/)，[谷歌](https://research.google.com/pubs/papers.html)。显然，论文的出身对质量有很大影响。\n+ 期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期（Deadline，ddl）的压力。投稿后一般要经过同行评审（Peer Review），针对审稿人的建议做大修，小修（Major，Minor Revision）等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊（Special Issue）计划，会公布一个截稿日期，审稿的进度会稍快些。\n期刊分为 **Transaction, Journal 和 Magazine** 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 **不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是 [Communications of the ACM（CACM, ACM通讯）](http://dl.acm.org/citation.cfm?id=J79) 值得关注**。\n+ 对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等（有的期刊则动辄一卷几千页，所以，文章质量嘛……），所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。\n很多会议每年举行一次，时间上也是比较固定的月份，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。\n会议录用的所有Paper会结集出版，称为 **Proceedings** 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。\n会议分为 **Symposium , Conference 和 Workshop**。这三者的学术严肃性依次降低，大部分会议都称为 **Conference**。一般来说 **Workshop** 是随某个 **Conference** 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。\n\n通过这个过程，我们还可以知道如何 **尽快** 找到一篇感兴趣的文章：\n+ 对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access，即在线预出版；\n+ 对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。\n\n# CS论文数据库\n\n## ACM, IEEE Computer等\n\n一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及[图书馆页面截图](#lib)。\n> 注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。\n\n| 机构                                     | Digital Library （DL）                              | 机构首页                   |\n|------------------------------------------|----------------------------------------------------|----------------------------|\n| Association for Computing Machinery, ACM | ACM Digital Library  https://dl.acm.org/           | https://www.acm.org/       |\n| IEEE Computer Society                    | IEEE Xplore DL http://ieeexplore.ieee.org/         | https://www.computer.org/  |\n| Elsevier ScienceDirect                   | http://www.sciencedirect.com/                      | https://www.elsevier.com/  |\n| Springer                                 | Springer Link http://link.springer.com/            | http://www.springer.com/   |\n| Wiley                                    | Wiley Online Lib http://onlinelibrary.wiley.com/   | http://www.wiley.com/      |\n\nACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 **.org**，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。\nElsevier，Springer，Wiley的网址后缀则是 **.com** ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。\n上面这几个数据库是 **主要的论文全文来源**。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。\n> ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 **元数据**，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。\n> IEEE出版的一些论文在 computer.org （实际是[CSDL](https://www.computer.org/csdl/)）和 Xplore DL 都可能搜到，但这两个数据库是 **分别** 收费的，能在Xplore DL下载的不一定能在Computer.org下载。\n\n### ACM SIGs\nACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个[ACM SIGs](http://www.acm.org/sigs/)（或参考DL的这个链接[SIGs ACM DL](http://dl.acm.org/sigs.cfm)），比如\n+ 体系结构方向的[SIGARCH](http://www.sigarch.org/)、[SIGHPC](http://www.sighpc.org/)、[SIGMETRICS](http://www.sigmetrics.org/)、[SIGMICRO](http://www.sigmicro.org/)、[SIGMOBILE](http://www.sigmobile.org/)，\n+ 网络方向的[SIGCOMM](http://www.sigcomm.org/)，\n+ 数据库方向的[SIGMOD](http://www.sigmod.org/)，\n+ 系统方向的[SIGOPS](http://www.sigops.org/)，\n+ 软件工程方向的[SIGPLAN](http://www.sigplan.org/)、[SIGSOFT](http://www.sigsoft.org/)\n\n这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 **最佳论文**，**优秀博士论文** 等（在DL中一般没有标明哪篇是Best Paper）。此外，\n+ 有网站维护了一个[部分会议的最佳论文列表](http://jeffhuang.com/best_paper_awards.html)，\n+ 还有下面要介绍的USENIX的[各会议最佳论文](https://www.usenix.org/conferences/best-papers)。\n\n有的SIG会选择一些高质量的文章，以Review，Newsletter 或 Notes 的形式重新发表，引用的时候最好引用最初的来源。\n\n## [USENIX](https://www.usenix.org/)\n要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。\n话说**[USENIX](https://www.usenix.org/)** 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slides及演讲视频。slides是对文章的提炼，读论文时可以参考。拿slides和视频来学习做Presentation，练习英语听力和口语也不错。\n\n## [arXiv](http://arxiv.org/)\n[arXiv](http://arxiv.org/)， 是archive（归档）的意思，是一个由康乃尔大学维护的免费的多学科论文**预**出版（preprint）数据库。所谓**预**出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。\n\n<a name=\"lib\" />![图书馆电子资源](/img/lib.png)\n\n## EI和SCI\n分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，\n+ EI **Engineering Index** https://www.engineeringvillage.com/\n+ SCI **Science Citation Index** http://apps.webofknowledge.com/\n\n**只看 URL 还以为是 山寨网站**，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 **已知文章标题的情况下** 检索是不是被它们收录了，而 **不是** 用来收集文章的。\n\n要确定某个会议论文集或者期刊[是否被EI或SCI收录](http://www.philippe-fournier-viger.com/links.php)，\n+ 在[EI收录列表](https://www.elsevier.com/solutions/engineering-village/content) 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考[这个脚本解除保护](/doc/crack_xls_vb.txt)，还要建议把title列中每个单元格开头的`=`替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫`Computing`，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。**但是！**，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 **Compendex**。\n+ 在`webofknowledge`的网站查询之前，**一定** 要选择数据库为`检索 Web of Science 核心合集`，等自动刷新候，还要在页面下部展开“更多设置”，只选中`Science Citation Index Expanded (SCIEXPANDED) 1900年至今`这一项，然后才能查询出根正苗红的`SCI（E）`。请**务必**参考[这个截图](/doc/SCI_E_Web_of_Science.pdf)。可以在[SCI收录列表](http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K)直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：[中国科学技术信息研究所SCI（E）论文期刊分区列表（2016年）](http://scit.nju.edu.cn/Item/1162.aspx)，这是一个有13.8k多行的Excel表格，简洁粗暴。\n\n----\n上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。\n校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。\n话说只要是能花钱买到的东西，去万能的 **淘宝** 肯定能找到，就看是买 **VPN/代理，单篇文章，还是 整个数据库** 了。\n\n## dblp\ndblp [http://dblp.org] ，或[http://dblp.uni-trier.de]， 是专注于CS学科的文献 **元数据索引** 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 http://dblp.org/db/conf/sigsoft/fse2016.html 或者某个作者的全部论文列（dblp对重名作者处理得很好），但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。\n2015版CCF目录中的会议和期刊都是dblp的链接。\n\ndblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）\n+ [累计论文记录数量](http://dblp.dagstuhl.de/statistics/recordsindblp.html)，\n+ [每年发表的论文数量](http://dblp.dagstuhl.de/statistics/publicationsperyear.html)，\n+ [论文发表的类型](http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html)，其中会议论文占53%，\n+ 论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。\n\n另外，ACM DL也有一个[类似的统计](http://dl.acm.org/contents_guide.cfm)。\n![每年发表的CS论文数量](/img/pubs.png)\n\n而且dblp整站的数据都可以下载为一个[xml文件](http://dblp.dagstuhl.de/xml/)，以供进一步挖掘。\n\n## DOI\n在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，[wikipedia介绍DOI](https://zh.wikipedia.org/wiki/DOI)“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。\n\n## 其它\n从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。\n+ Semantic Scholar [https://www.semanticscholar.org]\n+ CiteSeerX [http://citeseerx.ist.psu.edu/]\n+ ResearchGate [https://www.researchgate.net/] ，这是一个学术社交网络\n\n# CCF目录\n\nEI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。\n更 “**不幸**” 的是，对于CS的学生，还有一个[CCF目录](http://history.ccf.org.cn/sites/ccf/paiming.jsp)（[2015版的PDF](http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf)）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。\n\n首先说[中国计算机学会 CCF](http://www.ccf.org.cn/)是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然[精简得多](https://ying-zhang.github.io/misc/2017/ccf-all-in-one/)。\n考虑到对EI和SCI指标要求的实际情况，目录选取的 **大多** 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。\nA，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。\n\n> 如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 [FGCS\tFuture Generation Computer Systems](http://dblp.org/db/journals/fgcs/)上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。\n> 随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。\n\n上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的[分类系统CCS](http://dl.acm.org/ccs/ccs.cfm)，以及有重叠的[SIGs大类划分](https://www.acm.org/special-interest-groups/sigs-by-knowledge-area)，还有[wikipedia上的一个划分](https://en.wikipedia.org/wiki/Outline_of_computer_science)。\n\n# Google Scholar（谷歌学术）\n[Google Scholar](https://scholar.google.com/)非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 **高级搜索**，实在不行再去ACM DL、IEEE Xplore。\n![谷歌学术高级搜索](/img/scholar_adv.png)\n\n## 创建快讯\n与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；\n此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 **作者的个人资料页** 可以创建关于他的新文章或新引用的快讯，及时获取动态。\n\n> 话说体验一下[必应学术](http://www.bing.com/academic)、[百度学术](http://xueshu.baidu.com/)和[搜狗学术](http://scholar.sogou.com/)也未尝不可。\n\n<a name=\"tldr\" />\n\n# tl,dr：链接列表\n\n## 体系结构，系统，存储，分布式系统\n+ ASPLOS@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE178&tab=pubs) , [DBLP](http://dblp.org/db/conf/asplos/) Architectural Support for Programming Languages and Operating Systems\n+ FAST@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE425&tab=pubs) , [DBLP](http://dblp.org/db/conf/fast/) Conf. on File and Storage Technologies\n+ HPCA@**A**   [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=1000335) , [DBLP](http://dblp.org/db/conf/hpca/) High-Performance Computer Architecture\n+ ISCA@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE239&tab=pubs) , [DBLP](http://dblp.org/db/conf/isca/) Int. Symposium on Computer Architecture\n+ MICRO@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE203&tab=pubs) , [DBLP](http://dblp.org/db/conf/micro/) Microarchitecture\n+ PPoPP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE241&tab=pubs) , [DBLP](http://dblp.org/db/conf/ppopp/) Principles and Practice of Parallel Programming\n+ SC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE207&tab=pubs) , [DBLP](http://dblp.org/db/conf/sc/) Int. Conf. for High Performance Computing, Networking, Storage, and Analysis\n+ ATC@**A**   [USENIX](https://www.usenix.org/conferences/byname/131) , [DBLP](http://dblp.org/db/conf/usenix/) USENIX Annul Technical Conf.\n+ CGO@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE256&tab=pubs) , [DBLP](http://dblp.org/db/conf/cgo/) Code Generation and Optimization\n+ EuroSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE101&tab=pubs) , [DBLP](http://dblp.org/db/conf/eurosys/) European Conf. on Computer Systems\n+ HotCHIPS@**B**   [HotChips](http://www.hotchips.org/) Symposium on High Performance Chips\n+ HPDC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE300&tab=pubs) , [DBLP](http://dblp.org/db/conf/hpdc/) High-Performance Distributed Computing\n+ LISA@**B**   [USENIX](https://www.usenix.org/conferences/byname/5) , [DBLP](http://dblp.org/db/conf/lisa/) Large Installation system Administration Conf.\n+ PODC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE221&tab=pubs) , [DBLP](http://dblp.org/db/conf/podc/) Symposium on Principles of Distributed Computing\n+ SIGMETRICS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE187&tab=pubs)，[ACM](http://dl.acm.org/citation.cfm?id=J618) , [DBLP](http://dblp.org/db/conf/sigmetrics/) Int. Conf. on Measurement and Modeling of Computer Systems\n+ VEE@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE287&tab=pubs) , [DBLP](http://dblp.org/db/conf/vee/) Virtual Execution Environments\n+ TC@**A**   [IEEE](https://www.computer.org/web/tc) , [DBLP](http://dblp.org/db/journals/tc/) Trans. on Computers\n+ TOCS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J774&tab=pubs) , [DBLP](http://dblp.org/db/journals/tocs/) Trans. on Computer Systems\n+ TOS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J960&tab=pubs) , [DBLP](http://dblp.org/db/journals/tos/) Trans. on Storage\n+ TPDS@**A**   [IEEE](https://www.computer.org/web/tpds) , [DBLP](http://dblp.org/db/journals/tpds/) Trans. on Parallel and Distributed Systems\n+ ISMM   [ACM](http://dl.acm.org/event.cfm?id=RE149&tab=pubs) , [DBLP](http://dblp.org/db/conf/ismm/) Int. Conf. on Memory Management\n\n## 软件工程（软件分析）\n+ Github上的[软件工程方向会议的数据](https://github.com/tue-mdse/conferenceMetrics)\n+ UIUC的[谢涛老师](http://taoxie.cs.illinois.edu/)维护的[软件工程方向的会议统计列表](http://taoxie.cs.illinois.edu/seconferences.htm)\n+ ASE@**A**   [DBLP](http://dblp.org/db/conf/kbse/) Int. Conf. on Automated Software Engineering\n+ FSE/ESEC@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE201&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigsoft/) SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.\n+ ICSE@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE228&tab=pubs) , [DBLP](http://dblp.org/db/conf/icse/) FOSE会议：七年一届的展望 Int. Conf. on Software Engineering\n+ OOPSLA/SPLASH@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE181&tab=pubs) , [DBLP](http://dblp.org/db/conf/oopsla/) Onward会议：创新（脑洞） Conf. on Object-Oriented Programming Systems, Languages, and Applications\n+ OSDI@**A**   [USENIX](https://www.usenix.org/conferences/byname/179) , [DBLP](http://dblp.org/db/conf/osdi/) USENIX Symposium on Operating Systems Design and Implementations，**双数** 年份召开\n+ SOSP@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE208&tab=pubs) , [DBLP](http://dblp.org/db/conf/sosp/)，Symposium on Operating Systems Principles， **单数** 年份召开，另，[SOSP 2015 History Day](http://sigops.org/sosp/sosp15/history/index.html)\n+ PLDI@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE200&tab=pubs) , [DBLP](http://dblp.org/db/conf/pldi/) SIGPLAN Symposium on Programming Language Design and Implementation\n+ POPL@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE180&tab=pubs) , [DBLP](http://dblp.org/db/conf/popl/) SIGPLAN&SIGACT Symposium on Principles of Programming Languages\n+ ECOOP@**B**   [ECOOP](http://www.ecoop.org/) , [DBLP](http://dblp.org/db/conf/ecoop/) European Conf. on Object-Oriented Programming\n+ HotOS@**B**   [USENIX](https://www.usenix.org/conferences/byname/155) , [DBLP](http://dblp.org/db/conf/hotos/) USENIX Workshop on Hot Topics in Operating Systems\n+ ICSME@**B**   [IEEE](http://conferences.computer.org/icsm/) , [DBLP](http://dblp.org/db/conf/icsm/) Int. Conf. on Software Maintenance\n+ ISSTA@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE222&tab=pubs) , [DBLP](http://dblp.org/db/conf/issta/) Int. Symposium on Software Testing and Analysis\n+ TOPLAS@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J783&tab=pubs) , [DBLP](http://dblp.org/db/journals/toplas/) Trans. on Programming Languages and Systems\n+ TOSEM@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J790&tab=pubs) , [DBLP](http://dblp.org/db/journals/tosem/) Trans. on Software Engineering Methodology\n+ TSE@**A**   [IEEE](https://www.computer.org/web/tse) , [DBLP](http://dblp.org/db/journals/tse/) Trans. on Software Engineering\n\n## 云计算，网络，大数据\n+ SIGMOD@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/sigmod/) Conf. on Management of Data\n+ SoCC@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/cloud/) Symposium on Cloud Computing\n+ PODS@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE227&tab=pubs) , [DBLP](http://dblp.org/db/conf/pods/) SIGMOD Conf. on Principles of DB Systems\n+ VLDB Endowment@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J1174&tab=pubs) , [DBLP](http://dblp.org/db/conf/vldb/) Int. Conf. on Very Large Data Bases\n+ VLDB Journal@**A**   [ACM](http://dl.acm.org/pub.cfm?id=J869&tab=pubs) , [DBLP](http://dblp.org/db/journals/vldb/) Int. Journal on Very Large Data Bases\n+ NSDI@**B**   [USENIX](https://www.usenix.org/conferences/byname/178) , [DBLP](http://dblp.org/db/conf/nsdi/) Network System Design and Implementation\n+ IEEE 云计算系列@**B/C**  [IEEE](http://cloudcomputing.ieee.org/conferences) , [DBLP](http://dblp.org/db/conf/IEEEcloud/)\n+ HotCloud   [USENIX](https://www.usenix.org/conferences/byname/1) , [DBLP](http://dblp.org/db/conf/hotcloud/) Hot Topics on Cloud Computing\n+ TCC   [IEEE](https://www.computer.org/web/tcc) , [DBLP](http://dblp.org/db/journals/tcc/) IEEE Trans. on Cloud Computing\n+ TSC@**B**   [IEEE](https://www.computer.org/web/tsc) , [DBLP](http://dblp.org/db/journals/tsc/) IEEE Trans. on Services Computing\n+ SigComm@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE258&tab=pubs) , [DBLP](http://dblp.org/conf/sigcomm/)\n上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。\n\n## 移动计算\n+ MobiCom@**A**   [ACM](http://dl.acm.org/event.cfm?id=RE366&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobicom/) Mobile Computing and Networking\n+ MobiSys@**B**   [ACM](http://dl.acm.org/event.cfm?id=RE191&tab=pubs) , [DBLP](http://dblp.org/db/conf/mobisys/) Mobile Systems, Applications, and Services\n+ HotMobile   [ACM](http://dl.acm.org/event.cfm?id=RE142&tab=pubs) , [DBLP](http://dblp.org/db/conf/wmcsa/) Mobile Computing Systems and Applications\n\n## ACM DL列表\n+ [收录会议和期刊的完整列表](http://dl.acm.org/contents_dl.cfm)\n+ [会议](http://dl.acm.org/events.cfm)\n+ [会议历次论文集](http://dl.acm.org/proceedings.cfm)\n+ [期刊和学报](http://dl.acm.org/pubs.cfm)\n+ [杂志](http://dl.acm.org/mags.cfm)\n+ [ACM Conferences - past 12 months](http://dl.acm.org/conferences.cfm)\n+ [ACM Upcoming Conferences - RSS](http://dl.acm.org/UpcomingConfLocations.xml)\n\n关于ACM的杂志，特别推荐\n+ [Communications of the ACM, CACM](http://dl.acm.org/citation.cfm?id=J79)， [in dblp](http://dblp.org/db/journals/cacm/)\n+ [CACM中国版](http://dl.acm.org/toco_arch.cfm?id=J79&lang=chinese)，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去\n+ [Queue](http://dl.acm.org/citation.cfm?id=J882)也值得一看，不过它与CACM有很多重叠的文章\n\n期刊中，推荐[ACM Computing Surveys, CSUR](http://dl.acm.org/citation.cfm?id=J204)， [in dblp](http://dblp.org/db/journals/csur/)\n\n> 看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。\n\n##  IEEE Computer列表\n\n+ [会议日历](https://www.computer.org/web/conferences/calendar/)\n+ [期刊和学报](https://www.computer.org/web/publications/transactions)\n+ [杂志](https://www.computer.org/web/publications/magazines)\n\n## [USENIX组织的会议列表](https://www.usenix.org/conferences/byname)\n[USENIX组织的会议列表](https://www.usenix.org/conferences/byname)，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。\n\n## 国内三个学报\n\n+ [软件学报](http://www.jos.org.cn/ch/index.aspx)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS)\n+ [计算机学报](http://cjc.ict.ac.cn/)，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS)\n+ [计算机研究与发展](http://crad.ict.ac.cn/CN/volumn/home.shtml) ，[CNKI RSS](http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS)\n\n## 国内论文数据库\n\n+ [知网CNKI](http://www.cnki.net/)\n+ [万方数据](http://www.wanfangdata.com.cn/)\n\n## 其它链接\n+ [微软研究院](https://www.microsoft.com/en-us/research/)\n+ [谷歌研究院](https://research.google.com/pubs/papers.html)\n+ [The morning paper](https://blog.acolyer.org/), an interesting-influential-important paper from the world of CS every weekday morning\n+ [IEEE Technical Committee on Data Engineering](http://sites.computer.org/debull/bull_issues.html)\n+ [YouTube](https://www.youtube.com)，\n+ **[Suggested Guidelines for Finding Materials to include in the \"Related Work\" Sections of Conference Papers](http://www1.cs.columbia.edu/~kaiser/relatedwork.htm)**\n+ [YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表](http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582)  \n\n# 如何读论文\n+ [Efficient Reading of Papers in Science and Technology(pdf)](http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf)\n+ [How to Read a Paper(pdf)](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)\n+ [How to Read a Technical Paper](https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html)\n+ [《学术研究 - 你的成功之道》第3章](http://item.jd.com/11127141.html)\n\n# [Todo]辅助工具\n+ [会伴](http://myhuiban.com)\n+ Trans. on BigData的学术文献处理专刊 [Vol. 2 Issue 1](https://www.computer.org/csdl/trans/bd/2016/01/index.html)，[Vol. 2 Issue 2](https://www.computer.org/csdl/trans/bd/2016/02/index.html)\n+ [Sciplore](http://www.sciplore.org/)\n+ [Scopus](https://www.scopus.com/)\n+ [Docear](http://www.docear.org/)\n+ [Mendeley](https://www.mendeley.com/)\n+ [Zotero](https://www.zotero.org/)\n+ [Teambition](https://www.teambition.com/)\n+ Todo，如何整理文献，如何管理时间，[科研小组里有哪些有效的组会形式 - 知乎](https://www.zhihu.com/question/27956707)\n\n如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，**总会觉得** 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去[wikipedia](https://en.wikipedia.org/)上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。\n如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。\n\n> PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)\n\n一些标题有`A systematic review on ...`综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。\n\n再列出知乎上的几个相关问题吧\n+ [如何总结和整理学术文献？](https://www.zhihu.com/question/26901116)\n+ [如何高效管理文献？](https://www.zhihu.com/question/26857521)\n+ [如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?](https://www.zhihu.com/question/22790506)\n\n<a name=\"hosts\" />\n# [Bonus] 如何访问Google Scholar\n\n## **改hosts**\n+ IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N\n+ IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk\n\n## **hosts文件的路径**\n+ Windows：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n+ Linux，Mac，Android（均需要root权限）：`/etc/hosts`\n\n# PS: [A Survival Guide to a PhD](http://karpathy.github.io/2016/09/07/phd/)\n\n---\n\n飞鸟集\n\n> 第83\n> 那想做好人的，在门外敲着门，那爱人的，看见门敞开着。\n\n> 第142\n> 让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。\n","slug":"we-love-paper","published":1,"updated":"2017-12-02T12:22:12.879Z","_id":"cj9s6hmhb000w9s4fb2i2hegw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>论文（Paper）是每个研究生读研路上挥之不去的“阴云”。<br>无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展（State of the art &amp; practice）。<br>本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了相关的机构，学术会议和论文数据库。<br>文末有 <a href=\"#hosts\"><strong>Bonus</strong></a> 哦;-)</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"tl-dr\"><a href=\"#tl-dr\" class=\"headerlink\" title=\"tl;dr\"></a>tl;dr</h1><ul>\n<li>从<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">CCF推荐目录</a>中自己感兴趣的方向的 <strong>A类会议及期刊</strong> 中找论文即可。</li>\n<li>我关注的云计算，程序分析方向的<a href=\"#tldr\">会议和期刊列表</a></li>\n<li><a href=\"#hosts\"><strong>Bonus</strong></a> 修改Hosts</li>\n</ul>\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：</p>\n<ul>\n<li>周志华老师的一篇关于<a href=\"/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf\">做研究与写论文的ppt</a></li>\n<li>凌晓峰和杨强的<a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》</a>，这本书的英文原版是<a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064\" target=\"_blank\" rel=\"external\">Crafting Your Research Future - A Guide to Successful Master’s and Ph.D. Degrees in Science &amp; Engineering</a></li>\n</ul>\n<p>首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果（的一部分）。结果肯定是必要的，自然也就少不了Paper或者总结报告；<br>再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。<br>重要的是要 <strong>有意识地探索和总结适合自己的科研方法</strong>，既要低头苦干，又要抬头看路，还要回头总结。</p>\n<h2 id=\"论文发表的过程\"><a href=\"#论文发表的过程\" class=\"headerlink\" title=\"论文发表的过程\"></a>论文发表的过程</h2><pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n<p>简单介绍一下发表论文的过程：</p>\n<ul>\n<li>首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如<a href=\"https://amplab.cs.berkeley.edu/\" target=\"_blank\" rel=\"external\">UC Berkeley 的AMPLab</a>；还有一些公司的研究院，比如<a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软</a>，<a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌</a>。显然，论文的出身对质量有很大影响。</li>\n<li>期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期（Deadline，ddl）的压力。投稿后一般要经过同行评审（Peer Review），针对审稿人的建议做大修，小修（Major，Minor Revision）等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊（Special Issue）计划，会公布一个截稿日期，审稿的进度会稍快些。<br>期刊分为 <strong>Transaction, Journal 和 Magazine</strong> 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 <strong>不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是 <a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM（CACM, ACM通讯）</a> 值得关注</strong>。</li>\n<li>对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等（有的期刊则动辄一卷几千页，所以，文章质量嘛……），所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。<br>很多会议每年举行一次，时间上也是比较固定的月份，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。<br>会议录用的所有Paper会结集出版，称为 <strong>Proceedings</strong> 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。<br>会议分为 <strong>Symposium , Conference 和 Workshop</strong>。这三者的学术严肃性依次降低，大部分会议都称为 <strong>Conference</strong>。一般来说 <strong>Workshop</strong> 是随某个 <strong>Conference</strong> 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。</li>\n</ul>\n<p>通过这个过程，我们还可以知道如何 <strong>尽快</strong> 找到一篇感兴趣的文章：</p>\n<ul>\n<li>对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access，即在线预出版；</li>\n<li>对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。</li>\n</ul>\n<h1 id=\"CS论文数据库\"><a href=\"#CS论文数据库\" class=\"headerlink\" title=\"CS论文数据库\"></a>CS论文数据库</h1><h2 id=\"ACM-IEEE-Computer等\"><a href=\"#ACM-IEEE-Computer等\" class=\"headerlink\" title=\"ACM, IEEE Computer等\"></a>ACM, IEEE Computer等</h2><p>一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及<a href=\"#lib\">图书馆页面截图</a>。</p>\n<blockquote>\n<p>注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>机构</th>\n<th>Digital Library （DL）</th>\n<th>机构首页</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Association for Computing Machinery, ACM</td>\n<td>ACM Digital Library  <a href=\"https://dl.acm.org/\" target=\"_blank\" rel=\"external\">https://dl.acm.org/</a></td>\n<td><a href=\"https://www.acm.org/\" target=\"_blank\" rel=\"external\">https://www.acm.org/</a></td>\n</tr>\n<tr>\n<td>IEEE Computer Society</td>\n<td>IEEE Xplore DL <a href=\"http://ieeexplore.ieee.org/\" target=\"_blank\" rel=\"external\">http://ieeexplore.ieee.org/</a></td>\n<td><a href=\"https://www.computer.org/\" target=\"_blank\" rel=\"external\">https://www.computer.org/</a></td>\n</tr>\n<tr>\n<td>Elsevier ScienceDirect</td>\n<td><a href=\"http://www.sciencedirect.com/\" target=\"_blank\" rel=\"external\">http://www.sciencedirect.com/</a></td>\n<td><a href=\"https://www.elsevier.com/\" target=\"_blank\" rel=\"external\">https://www.elsevier.com/</a></td>\n</tr>\n<tr>\n<td>Springer</td>\n<td>Springer Link <a href=\"http://link.springer.com/\" target=\"_blank\" rel=\"external\">http://link.springer.com/</a></td>\n<td><a href=\"http://www.springer.com/\" target=\"_blank\" rel=\"external\">http://www.springer.com/</a></td>\n</tr>\n<tr>\n<td>Wiley</td>\n<td>Wiley Online Lib <a href=\"http://onlinelibrary.wiley.com/\" target=\"_blank\" rel=\"external\">http://onlinelibrary.wiley.com/</a></td>\n<td><a href=\"http://www.wiley.com/\" target=\"_blank\" rel=\"external\">http://www.wiley.com/</a></td>\n</tr>\n</tbody>\n</table>\n<p>ACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 <strong>.org</strong>，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。<br>Elsevier，Springer，Wiley的网址后缀则是 <strong>.com</strong> ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。<br>上面这几个数据库是 <strong>主要的论文全文来源</strong>。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。</p>\n<blockquote>\n<p>ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 <strong>元数据</strong>，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。<br>IEEE出版的一些论文在 computer.org （实际是<a href=\"https://www.computer.org/csdl/\" target=\"_blank\" rel=\"external\">CSDL</a>）和 Xplore DL 都可能搜到，但这两个数据库是 <strong>分别</strong> 收费的，能在Xplore DL下载的不一定能在Computer.org下载。</p>\n</blockquote>\n<h3 id=\"ACM-SIGs\"><a href=\"#ACM-SIGs\" class=\"headerlink\" title=\"ACM SIGs\"></a>ACM SIGs</h3><p>ACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个<a href=\"http://www.acm.org/sigs/\" target=\"_blank\" rel=\"external\">ACM SIGs</a>（或参考DL的这个链接<a href=\"http://dl.acm.org/sigs.cfm\" target=\"_blank\" rel=\"external\">SIGs ACM DL</a>），比如</p>\n<ul>\n<li>体系结构方向的<a href=\"http://www.sigarch.org/\" target=\"_blank\" rel=\"external\">SIGARCH</a>、<a href=\"http://www.sighpc.org/\" target=\"_blank\" rel=\"external\">SIGHPC</a>、<a href=\"http://www.sigmetrics.org/\" target=\"_blank\" rel=\"external\">SIGMETRICS</a>、<a href=\"http://www.sigmicro.org/\" target=\"_blank\" rel=\"external\">SIGMICRO</a>、<a href=\"http://www.sigmobile.org/\" target=\"_blank\" rel=\"external\">SIGMOBILE</a>，</li>\n<li>网络方向的<a href=\"http://www.sigcomm.org/\" target=\"_blank\" rel=\"external\">SIGCOMM</a>，</li>\n<li>数据库方向的<a href=\"http://www.sigmod.org/\" target=\"_blank\" rel=\"external\">SIGMOD</a>，</li>\n<li>系统方向的<a href=\"http://www.sigops.org/\" target=\"_blank\" rel=\"external\">SIGOPS</a>，</li>\n<li>软件工程方向的<a href=\"http://www.sigplan.org/\" target=\"_blank\" rel=\"external\">SIGPLAN</a>、<a href=\"http://www.sigsoft.org/\" target=\"_blank\" rel=\"external\">SIGSOFT</a></li>\n</ul>\n<p>这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 <strong>最佳论文</strong>，<strong>优秀博士论文</strong> 等（在DL中一般没有标明哪篇是Best Paper）。此外，</p>\n<ul>\n<li>有网站维护了一个<a href=\"http://jeffhuang.com/best_paper_awards.html\" target=\"_blank\" rel=\"external\">部分会议的最佳论文列表</a>，</li>\n<li>还有下面要介绍的USENIX的<a href=\"https://www.usenix.org/conferences/best-papers\" target=\"_blank\" rel=\"external\">各会议最佳论文</a>。</li>\n</ul>\n<p>有的SIG会选择一些高质量的文章，以Review，Newsletter 或 Notes 的形式重新发表，引用的时候最好引用最初的来源。</p>\n<h2 id=\"USENIX\"><a href=\"#USENIX\" class=\"headerlink\" title=\"USENIX\"></a><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></h2><p>要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。<br>话说<strong><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></strong> 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slides及演讲视频。slides是对文章的提炼，读论文时可以参考。拿slides和视频来学习做Presentation，练习英语听力和口语也不错。</p>\n<h2 id=\"arXiv\"><a href=\"#arXiv\" class=\"headerlink\" title=\"arXiv\"></a><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></h2><p><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a>， 是archive（归档）的意思，是一个由康乃尔大学维护的免费的多学科论文<strong>预</strong>出版（preprint）数据库。所谓<strong>预</strong>出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。</p>\n<p><a name=\"lib\"><img src=\"/img/lib.png\" alt=\"图书馆电子资源\"></a></p>\n<h2 id=\"EI和SCI\"><a href=\"#EI和SCI\" class=\"headerlink\" title=\"EI和SCI\"></a>EI和SCI</h2><p>分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，</p>\n<ul>\n<li>EI <strong>Engineering Index</strong> <a href=\"https://www.engineeringvillage.com/\" target=\"_blank\" rel=\"external\">https://www.engineeringvillage.com/</a></li>\n<li>SCI <strong>Science Citation Index</strong> <a href=\"http://apps.webofknowledge.com/\" target=\"_blank\" rel=\"external\">http://apps.webofknowledge.com/</a></li>\n</ul>\n<p><strong>只看 URL 还以为是 山寨网站</strong>，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 <strong>已知文章标题的情况下</strong> 检索是不是被它们收录了，而 <strong>不是</strong> 用来收集文章的。</p>\n<p>要确定某个会议论文集或者期刊<a href=\"http://www.philippe-fournier-viger.com/links.php\" target=\"_blank\" rel=\"external\">是否被EI或SCI收录</a>，</p>\n<ul>\n<li>在<a href=\"https://www.elsevier.com/solutions/engineering-village/content\" target=\"_blank\" rel=\"external\">EI收录列表</a> 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考<a href=\"/doc/crack_xls_vb.txt\">这个脚本解除保护</a>，还要建议把title列中每个单元格开头的<code>=</code>替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫<code>Computing</code>，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。<strong>但是！</strong>，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 <strong>Compendex</strong>。</li>\n<li>在<code>webofknowledge</code>的网站查询之前，<strong>一定</strong> 要选择数据库为<code>检索 Web of Science 核心合集</code>，等自动刷新候，还要在页面下部展开“更多设置”，只选中<code>Science Citation Index Expanded (SCIEXPANDED) 1900年至今</code>这一项，然后才能查询出根正苗红的<code>SCI（E）</code>。请<strong>务必</strong>参考<a href=\"/doc/SCI_E_Web_of_Science.pdf\">这个截图</a>。可以在<a href=\"http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K\" target=\"_blank\" rel=\"external\">SCI收录列表</a>直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：<a href=\"http://scit.nju.edu.cn/Item/1162.aspx\" target=\"_blank\" rel=\"external\">中国科学技术信息研究所SCI（E）论文期刊分区列表（2016年）</a>，这是一个有13.8k多行的Excel表格，简洁粗暴。</li>\n</ul>\n<hr>\n<p>上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。<br>校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。<br>话说只要是能花钱买到的东西，去万能的 <strong>淘宝</strong> 肯定能找到，就看是买 <strong>VPN/代理，单篇文章，还是 整个数据库</strong> 了。</p>\n<h2 id=\"dblp\"><a href=\"#dblp\" class=\"headerlink\" title=\"dblp\"></a>dblp</h2><p>dblp [<a href=\"http://dblp.org\" target=\"_blank\" rel=\"external\">http://dblp.org</a>] ，或[<a href=\"http://dblp.uni-trier.de]，\" target=\"_blank\" rel=\"external\">http://dblp.uni-trier.de]，</a> 是专注于CS学科的文献 <strong>元数据索引</strong> 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 <a href=\"http://dblp.org/db/conf/sigsoft/fse2016.html\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/sigsoft/fse2016.html</a> 或者某个作者的全部论文列（dblp对重名作者处理得很好），但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。<br>2015版CCF目录中的会议和期刊都是dblp的链接。</p>\n<p>dblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）</p>\n<ul>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/recordsindblp.html\" target=\"_blank\" rel=\"external\">累计论文记录数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/publicationsperyear.html\" target=\"_blank\" rel=\"external\">每年发表的论文数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html\" target=\"_blank\" rel=\"external\">论文发表的类型</a>，其中会议论文占53%，</li>\n<li>论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。</li>\n</ul>\n<p>另外，ACM DL也有一个<a href=\"http://dl.acm.org/contents_guide.cfm\" target=\"_blank\" rel=\"external\">类似的统计</a>。<br><img src=\"/img/pubs.png\" alt=\"每年发表的CS论文数量\"></p>\n<p>而且dblp整站的数据都可以下载为一个<a href=\"http://dblp.dagstuhl.de/xml/\" target=\"_blank\" rel=\"external\">xml文件</a>，以供进一步挖掘。</p>\n<h2 id=\"DOI\"><a href=\"#DOI\" class=\"headerlink\" title=\"DOI\"></a>DOI</h2><p>在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，<a href=\"https://zh.wikipedia.org/wiki/DOI\" target=\"_blank\" rel=\"external\">wikipedia介绍DOI</a>“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。</p>\n<ul>\n<li>Semantic Scholar [<a href=\"https://www.semanticscholar.org\" target=\"_blank\" rel=\"external\">https://www.semanticscholar.org</a>]</li>\n<li>CiteSeerX [<a href=\"http://citeseerx.ist.psu.edu/\" target=\"_blank\" rel=\"external\">http://citeseerx.ist.psu.edu/</a>]</li>\n<li>ResearchGate [<a href=\"https://www.researchgate.net/\" target=\"_blank\" rel=\"external\">https://www.researchgate.net/</a>] ，这是一个学术社交网络</li>\n</ul>\n<h1 id=\"CCF目录\"><a href=\"#CCF目录\" class=\"headerlink\" title=\"CCF目录\"></a>CCF目录</h1><p>EI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。<br>更 “<strong>不幸</strong>” 的是，对于CS的学生，还有一个<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">CCF目录</a>（<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。</p>\n<p>首先说<a href=\"http://www.ccf.org.cn/\" target=\"_blank\" rel=\"external\">中国计算机学会 CCF</a>是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">精简得多</a>。<br>考虑到对EI和SCI指标要求的实际情况，目录选取的 <strong>大多</strong> 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。<br>A，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。</p>\n<blockquote>\n<p>如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 <a href=\"http://dblp.org/db/journals/fgcs/\" target=\"_blank\" rel=\"external\">FGCS    Future Generation Computer Systems</a>上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。<br>随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。</p>\n</blockquote>\n<p>上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的<a href=\"http://dl.acm.org/ccs/ccs.cfm\" target=\"_blank\" rel=\"external\">分类系统CCS</a>，以及有重叠的<a href=\"https://www.acm.org/special-interest-groups/sigs-by-knowledge-area\" target=\"_blank\" rel=\"external\">SIGs大类划分</a>，还有<a href=\"https://en.wikipedia.org/wiki/Outline_of_computer_science\" target=\"_blank\" rel=\"external\">wikipedia上的一个划分</a>。</p>\n<h1 id=\"Google-Scholar（谷歌学术）\"><a href=\"#Google-Scholar（谷歌学术）\" class=\"headerlink\" title=\"Google Scholar（谷歌学术）\"></a>Google Scholar（谷歌学术）</h1><p><a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"external\">Google Scholar</a>非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 <strong>高级搜索</strong>，实在不行再去ACM DL、IEEE Xplore。<br><img src=\"/img/scholar_adv.png\" alt=\"谷歌学术高级搜索\"></p>\n<h2 id=\"创建快讯\"><a href=\"#创建快讯\" class=\"headerlink\" title=\"创建快讯\"></a>创建快讯</h2><p>与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；<br>此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 <strong>作者的个人资料页</strong> 可以创建关于他的新文章或新引用的快讯，及时获取动态。</p>\n<blockquote>\n<p>话说体验一下<a href=\"http://www.bing.com/academic\" target=\"_blank\" rel=\"external\">必应学术</a>、<a href=\"http://xueshu.baidu.com/\" target=\"_blank\" rel=\"external\">百度学术</a>和<a href=\"http://scholar.sogou.com/\" target=\"_blank\" rel=\"external\">搜狗学术</a>也未尝不可。</p>\n</blockquote>\n<p><a name=\"tldr\"></a></p>\n<h1 id=\"tl-dr：链接列表\"><a href=\"#tl-dr：链接列表\" class=\"headerlink\" title=\"tl,dr：链接列表\"></a>tl,dr：链接列表</h1><h2 id=\"体系结构，系统，存储，分布式系统\"><a href=\"#体系结构，系统，存储，分布式系统\" class=\"headerlink\" title=\"体系结构，系统，存储，分布式系统\"></a>体系结构，系统，存储，分布式系统</h2><ul>\n<li>ASPLOS@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE178&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/asplos/\" target=\"_blank\" rel=\"external\">DBLP</a> Architectural Support for Programming Languages and Operating Systems</li>\n<li>FAST@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE425&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/fast/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on File and Storage Technologies</li>\n<li>HPCA@<strong>A</strong>   <a href=\"http://ieeexplore.ieee.org/servlet/opac?punumber=1000335\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/hpca/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Computer Architecture</li>\n<li>ISCA@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE239&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/isca/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Computer Architecture</li>\n<li>MICRO@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE203&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/micro/\" target=\"_blank\" rel=\"external\">DBLP</a> Microarchitecture</li>\n<li>PPoPP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE241&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ppopp/\" target=\"_blank\" rel=\"external\">DBLP</a> Principles and Practice of Parallel Programming</li>\n<li>SC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE207&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sc/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. for High Performance Computing, Networking, Storage, and Analysis</li>\n<li>ATC@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/131\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/usenix/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Annul Technical Conf.</li>\n<li>CGO@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE256&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cgo/\" target=\"_blank\" rel=\"external\">DBLP</a> Code Generation and Optimization</li>\n<li>EuroSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE101&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/eurosys/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Computer Systems</li>\n<li>HotCHIPS@<strong>B</strong>   <a href=\"http://www.hotchips.org/\" target=\"_blank\" rel=\"external\">HotChips</a> Symposium on High Performance Chips</li>\n<li>HPDC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE300&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/hpdc/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Distributed Computing</li>\n<li>LISA@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/5\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/lisa/\" target=\"_blank\" rel=\"external\">DBLP</a> Large Installation system Administration Conf.</li>\n<li>PODC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE221&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/podc/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Principles of Distributed Computing</li>\n<li>SIGMETRICS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE187&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a>，<a href=\"http://dl.acm.org/citation.cfm?id=J618\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmetrics/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Measurement and Modeling of Computer Systems</li>\n<li>VEE@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE287&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vee/\" target=\"_blank\" rel=\"external\">DBLP</a> Virtual Execution Environments</li>\n<li>TC@<strong>A</strong>   <a href=\"https://www.computer.org/web/tc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tc/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computers</li>\n<li>TOCS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J774&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tocs/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computer Systems</li>\n<li>TOS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J960&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tos/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Storage</li>\n<li>TPDS@<strong>A</strong>   <a href=\"https://www.computer.org/web/tpds\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tpds/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Parallel and Distributed Systems</li>\n<li>ISMM   <a href=\"http://dl.acm.org/event.cfm?id=RE149&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ismm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Memory Management</li>\n</ul>\n<h2 id=\"软件工程（软件分析）\"><a href=\"#软件工程（软件分析）\" class=\"headerlink\" title=\"软件工程（软件分析）\"></a>软件工程（软件分析）</h2><ul>\n<li>Github上的<a href=\"https://github.com/tue-mdse/conferenceMetrics\" target=\"_blank\" rel=\"external\">软件工程方向会议的数据</a></li>\n<li>UIUC的<a href=\"http://taoxie.cs.illinois.edu/\" target=\"_blank\" rel=\"external\">谢涛老师</a>维护的<a href=\"http://taoxie.cs.illinois.edu/seconferences.htm\" target=\"_blank\" rel=\"external\">软件工程方向的会议统计列表</a></li>\n<li>ASE@<strong>A</strong>   <a href=\"http://dblp.org/db/conf/kbse/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Automated Software Engineering</li>\n<li>FSE/ESEC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE201&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigsoft/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.</li>\n<li>ICSE@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE228&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/icse/\" target=\"_blank\" rel=\"external\">DBLP</a> FOSE会议：七年一届的展望 Int. Conf. on Software Engineering</li>\n<li>OOPSLA/SPLASH@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE181&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/oopsla/\" target=\"_blank\" rel=\"external\">DBLP</a> Onward会议：创新（脑洞） Conf. on Object-Oriented Programming Systems, Languages, and Applications</li>\n<li>OSDI@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/179\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/osdi/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Symposium on Operating Systems Design and Implementations，<strong>双数</strong> 年份召开</li>\n<li>SOSP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE208&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sosp/\" target=\"_blank\" rel=\"external\">DBLP</a>，Symposium on Operating Systems Principles， <strong>单数</strong> 年份召开，另，<a href=\"http://sigops.org/sosp/sosp15/history/index.html\" target=\"_blank\" rel=\"external\">SOSP 2015 History Day</a></li>\n<li>PLDI@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE200&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pldi/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN Symposium on Programming Language Design and Implementation</li>\n<li>POPL@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE180&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/popl/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN&amp;SIGACT Symposium on Principles of Programming Languages</li>\n<li>ECOOP@<strong>B</strong>   <a href=\"http://www.ecoop.org/\" target=\"_blank\" rel=\"external\">ECOOP</a> , <a href=\"http://dblp.org/db/conf/ecoop/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Object-Oriented Programming</li>\n<li>HotOS@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/155\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotos/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Workshop on Hot Topics in Operating Systems</li>\n<li>ICSME@<strong>B</strong>   <a href=\"http://conferences.computer.org/icsm/\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/icsm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Software Maintenance</li>\n<li>ISSTA@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE222&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/issta/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Software Testing and Analysis</li>\n<li>TOPLAS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J783&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/toplas/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Programming Languages and Systems</li>\n<li>TOSEM@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J790&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tosem/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering Methodology</li>\n<li>TSE@<strong>A</strong>   <a href=\"https://www.computer.org/web/tse\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tse/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering</li>\n</ul>\n<h2 id=\"云计算，网络，大数据\"><a href=\"#云计算，网络，大数据\" class=\"headerlink\" title=\"云计算，网络，大数据\"></a>云计算，网络，大数据</h2><ul>\n<li>SIGMOD@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmod/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on Management of Data</li>\n<li>SoCC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Cloud Computing</li>\n<li>PODS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pods/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGMOD Conf. on Principles of DB Systems</li>\n<li>VLDB Endowment@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J1174&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Very Large Data Bases</li>\n<li>VLDB Journal@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J869&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Journal on Very Large Data Bases</li>\n<li>NSDI@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/178\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/nsdi/\" target=\"_blank\" rel=\"external\">DBLP</a> Network System Design and Implementation</li>\n<li>IEEE 云计算系列@<strong>B/C</strong>  <a href=\"http://cloudcomputing.ieee.org/conferences\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/IEEEcloud/\" target=\"_blank\" rel=\"external\">DBLP</a></li>\n<li>HotCloud   <a href=\"https://www.usenix.org/conferences/byname/1\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotcloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Hot Topics on Cloud Computing</li>\n<li>TCC   <a href=\"https://www.computer.org/web/tcc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tcc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Cloud Computing</li>\n<li>TSC@<strong>B</strong>   <a href=\"https://www.computer.org/web/tsc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tsc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Services Computing</li>\n<li>SigComm@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE258&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/conf/sigcomm/\" target=\"_blank\" rel=\"external\">DBLP</a><br>上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。</li>\n</ul>\n<h2 id=\"移动计算\"><a href=\"#移动计算\" class=\"headerlink\" title=\"移动计算\"></a>移动计算</h2><ul>\n<li>MobiCom@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE366&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobicom/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing and Networking</li>\n<li>MobiSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE191&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobisys/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Systems, Applications, and Services</li>\n<li>HotMobile   <a href=\"http://dl.acm.org/event.cfm?id=RE142&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/wmcsa/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing Systems and Applications</li>\n</ul>\n<h2 id=\"ACM-DL列表\"><a href=\"#ACM-DL列表\" class=\"headerlink\" title=\"ACM DL列表\"></a>ACM DL列表</h2><ul>\n<li><a href=\"http://dl.acm.org/contents_dl.cfm\" target=\"_blank\" rel=\"external\">收录会议和期刊的完整列表</a></li>\n<li><a href=\"http://dl.acm.org/events.cfm\" target=\"_blank\" rel=\"external\">会议</a></li>\n<li><a href=\"http://dl.acm.org/proceedings.cfm\" target=\"_blank\" rel=\"external\">会议历次论文集</a></li>\n<li><a href=\"http://dl.acm.org/pubs.cfm\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"http://dl.acm.org/mags.cfm\" target=\"_blank\" rel=\"external\">杂志</a></li>\n<li><a href=\"http://dl.acm.org/conferences.cfm\" target=\"_blank\" rel=\"external\">ACM Conferences - past 12 months</a></li>\n<li><a href=\"http://dl.acm.org/UpcomingConfLocations.xml\" target=\"_blank\" rel=\"external\">ACM Upcoming Conferences - RSS</a></li>\n</ul>\n<p>关于ACM的杂志，特别推荐</p>\n<ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM</a>， <a href=\"http://dblp.org/db/journals/cacm/\" target=\"_blank\" rel=\"external\">in dblp</a></li>\n<li><a href=\"http://dl.acm.org/toco_arch.cfm?id=J79&amp;lang=chinese\" target=\"_blank\" rel=\"external\">CACM中国版</a>，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去</li>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J882\" target=\"_blank\" rel=\"external\">Queue</a>也值得一看，不过它与CACM有很多重叠的文章</li>\n</ul>\n<p>期刊中，推荐<a href=\"http://dl.acm.org/citation.cfm?id=J204\" target=\"_blank\" rel=\"external\">ACM Computing Surveys, CSUR</a>， <a href=\"http://dblp.org/db/journals/csur/\" target=\"_blank\" rel=\"external\">in dblp</a></p>\n<blockquote>\n<p>看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。</p>\n</blockquote>\n<h2 id=\"IEEE-Computer列表\"><a href=\"#IEEE-Computer列表\" class=\"headerlink\" title=\"IEEE Computer列表\"></a>IEEE Computer列表</h2><ul>\n<li><a href=\"https://www.computer.org/web/conferences/calendar/\" target=\"_blank\" rel=\"external\">会议日历</a></li>\n<li><a href=\"https://www.computer.org/web/publications/transactions\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"https://www.computer.org/web/publications/magazines\" target=\"_blank\" rel=\"external\">杂志</a></li>\n</ul>\n<h2 id=\"USENIX组织的会议列表\"><a href=\"#USENIX组织的会议列表\" class=\"headerlink\" title=\"USENIX组织的会议列表\"></a><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></h2><p><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a>，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。</p>\n<h2 id=\"国内三个学报\"><a href=\"#国内三个学报\" class=\"headerlink\" title=\"国内三个学报\"></a>国内三个学报</h2><ul>\n<li><a href=\"http://www.jos.org.cn/ch/index.aspx\" target=\"_blank\" rel=\"external\">软件学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://cjc.ict.ac.cn/\" target=\"_blank\" rel=\"external\">计算机学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://crad.ict.ac.cn/CN/volumn/home.shtml\" target=\"_blank\" rel=\"external\">计算机研究与发展</a> ，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n</ul>\n<h2 id=\"国内论文数据库\"><a href=\"#国内论文数据库\" class=\"headerlink\" title=\"国内论文数据库\"></a>国内论文数据库</h2><ul>\n<li><a href=\"http://www.cnki.net/\" target=\"_blank\" rel=\"external\">知网CNKI</a></li>\n<li><a href=\"http://www.wanfangdata.com.cn/\" target=\"_blank\" rel=\"external\">万方数据</a></li>\n</ul>\n<h2 id=\"其它链接\"><a href=\"#其它链接\" class=\"headerlink\" title=\"其它链接\"></a>其它链接</h2><ul>\n<li><a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软研究院</a></li>\n<li><a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌研究院</a></li>\n<li><a href=\"https://blog.acolyer.org/\" target=\"_blank\" rel=\"external\">The morning paper</a>, an interesting-influential-important paper from the world of CS every weekday morning</li>\n<li><a href=\"http://sites.computer.org/debull/bull_issues.html\" target=\"_blank\" rel=\"external\">IEEE Technical Committee on Data Engineering</a></li>\n<li><a href=\"https://www.youtube.com\" target=\"_blank\" rel=\"external\">YouTube</a>，</li>\n<li><strong><a href=\"http://www1.cs.columbia.edu/~kaiser/relatedwork.htm\" target=\"_blank\" rel=\"external\">Suggested Guidelines for Finding Materials to include in the “Related Work” Sections of Conference Papers</a></strong></li>\n<li><a href=\"http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582\" target=\"_blank\" rel=\"external\">YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表</a>  </li>\n</ul>\n<h1 id=\"如何读论文\"><a href=\"#如何读论文\" class=\"headerlink\" title=\"如何读论文\"></a>如何读论文</h1><ul>\n<li><a href=\"http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf\" target=\"_blank\" rel=\"external\">Efficient Reading of Papers in Science and Technology(pdf)</a></li>\n<li><a href=\"http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf\" target=\"_blank\" rel=\"external\">How to Read a Paper(pdf)</a></li>\n<li><a href=\"https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html\" target=\"_blank\" rel=\"external\">How to Read a Technical Paper</a></li>\n<li><a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》第3章</a></li>\n</ul>\n<h1 id=\"Todo-辅助工具\"><a href=\"#Todo-辅助工具\" class=\"headerlink\" title=\"[Todo]辅助工具\"></a>[Todo]辅助工具</h1><ul>\n<li><a href=\"http://myhuiban.com\" target=\"_blank\" rel=\"external\">会伴</a></li>\n<li>Trans. on BigData的学术文献处理专刊 <a href=\"https://www.computer.org/csdl/trans/bd/2016/01/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 1</a>，<a href=\"https://www.computer.org/csdl/trans/bd/2016/02/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 2</a></li>\n<li><a href=\"http://www.sciplore.org/\" target=\"_blank\" rel=\"external\">Sciplore</a></li>\n<li><a href=\"https://www.scopus.com/\" target=\"_blank\" rel=\"external\">Scopus</a></li>\n<li><a href=\"http://www.docear.org/\" target=\"_blank\" rel=\"external\">Docear</a></li>\n<li><a href=\"https://www.mendeley.com/\" target=\"_blank\" rel=\"external\">Mendeley</a></li>\n<li><a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"external\">Zotero</a></li>\n<li><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></li>\n<li>Todo，如何整理文献，如何管理时间，<a href=\"https://www.zhihu.com/question/27956707\" target=\"_blank\" rel=\"external\">科研小组里有哪些有效的组会形式 - 知乎</a></li>\n</ul>\n<p>如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，<strong>总会觉得</strong> 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去<a href=\"https://en.wikipedia.org/\" target=\"_blank\" rel=\"external\">wikipedia</a>上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。<br>如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。</p>\n<blockquote>\n<p>PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)</p>\n</blockquote>\n<p>一些标题有<code>A systematic review on ...</code>综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。</p>\n<p>再列出知乎上的几个相关问题吧</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/26901116\" target=\"_blank\" rel=\"external\">如何总结和整理学术文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/26857521\" target=\"_blank\" rel=\"external\">如何高效管理文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/22790506\" target=\"_blank\" rel=\"external\">如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?</a></li>\n</ul>\n<p><a name=\"hosts\"></a></p>\n<h1 id=\"Bonus-如何访问Google-Scholar\"><a href=\"#Bonus-如何访问Google-Scholar\" class=\"headerlink\" title=\"[Bonus] 如何访问Google Scholar\"></a>[Bonus] 如何访问Google Scholar</h1><h2 id=\"改hosts\"><a href=\"#改hosts\" class=\"headerlink\" title=\"改hosts\"></a><strong>改hosts</strong></h2><ul>\n<li>IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N</li>\n<li>IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk</li>\n</ul>\n<h2 id=\"hosts文件的路径\"><a href=\"#hosts文件的路径\" class=\"headerlink\" title=\"hosts文件的路径\"></a><strong>hosts文件的路径</strong></h2><ul>\n<li>Windows：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux，Mac，Android（均需要root权限）：<code>/etc/hosts</code></li>\n</ul>\n<h1 id=\"PS-A-Survival-Guide-to-a-PhD\"><a href=\"#PS-A-Survival-Guide-to-a-PhD\" class=\"headerlink\" title=\"PS: A Survival Guide to a PhD\"></a>PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></h1><hr>\n<p>飞鸟集</p>\n<blockquote>\n<p>第83<br>那想做好人的，在门外敲着门，那爱人的，看见门敞开着。</p>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>论文（Paper）是每个研究生读研路上挥之不去的“阴云”。<br>无论是否已经有了一个好的课题或想法，都首先要收集某个研究方向一定数量的论文，来了解相关的工作和最新进展（State of the art &amp; practice）。<br>本文介绍了如何检索、收集计算机科学（CS）专业的论文，还介绍了相关的机构，学术会议和论文数据库。<br>文末有 <a href=\"#hosts\"><strong>Bonus</strong></a> 哦;-)</p>","more":"<hr>\n<h1 id=\"tl-dr\"><a href=\"#tl-dr\" class=\"headerlink\" title=\"tl;dr\"></a>tl;dr</h1><ul>\n<li>从<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">CCF推荐目录</a>中自己感兴趣的方向的 <strong>A类会议及期刊</strong> 中找论文即可。</li>\n<li>我关注的云计算，程序分析方向的<a href=\"#tldr\">会议和期刊列表</a></li>\n<li><a href=\"#hosts\"><strong>Bonus</strong></a> 修改Hosts</li>\n</ul>\n<h1 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h1><p>按理说，开篇应该先要强调一下Paper对于科研的重要性的，直接把前辈的经验拿来吧：</p>\n<ul>\n<li>周志华老师的一篇关于<a href=\"/doc/research_and_paper_zhou_zhihua_2007_ppt.pdf\">做研究与写论文的ppt</a></li>\n<li>凌晓峰和杨强的<a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》</a>，这本书的英文原版是<a href=\"http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6813064\" target=\"_blank\" rel=\"external\">Crafting Your Research Future - A Guide to Successful Master’s and Ph.D. Degrees in Science &amp; Engineering</a></li>\n</ul>\n<p>首先要从前辈的经验中端正对Paper的态度：Paper不是科研的原因，而是结果（的一部分）。结果肯定是必要的，自然也就少不了Paper或者总结报告；<br>再者要借鉴前辈的学习方法和技巧，所谓“工欲善其事，必先利其器”，除了科研课题本身，养成一套高效的科研方法和习惯也是重要的。<br>重要的是要 <strong>有意识地探索和总结适合自己的科研方法</strong>，既要低头苦干，又要抬头看路，还要回头总结。</p>\n<h2 id=\"论文发表的过程\"><a href=\"#论文发表的过程\" class=\"headerlink\" title=\"论文发表的过程\"></a>论文发表的过程</h2><pre>\n                                  / 期刊，特辑/专刊 → 多轮审稿 → 上线 \\\nIdea -> 编程、实验、写Paper、投稿 <                                    ->出版，检索\n                                  \\ 会议           → 审稿 → 赴会报告 /\n</pre>\n\n<p>简单介绍一下发表论文的过程：</p>\n<ul>\n<li>首先投稿的Paper作者，一般是高校的的研究生，也有教师，比如<a href=\"https://amplab.cs.berkeley.edu/\" target=\"_blank\" rel=\"external\">UC Berkeley 的AMPLab</a>；还有一些公司的研究院，比如<a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软</a>，<a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌</a>。显然，论文的出身对质量有很大影响。</li>\n<li>期刊是传统的研究成果发表方式，一般期刊是季度，少有月度出版的，每期称为一个Issue，一年的各期集结为一个Volume。一般可以随时投稿给期刊，没有截稿日期（Deadline，ddl）的压力。投稿后一般要经过同行评审（Peer Review），针对审稿人的建议做大修，小修（Major，Minor Revision）等两三轮修改才能被接收，期间跨度一年多是常有的情况。不过如果有的期刊安排了专刊（Special Issue）计划，会公布一个截稿日期，审稿的进度会稍快些。<br>期刊分为 <strong>Transaction, Journal 和 Magazine</strong> 。这三者的学术严肃性依次降低，这可以从它们的封面上直观地看出来。严格来说Magazine不算是学术期刊了，上面很少发表新的原创性的内容，而是对当前进展的简介和综述，也会转发一些已经发表过的重要的Paper。 <strong>不过对于新手来说，先浏览一下Magazine，建立一个基本的概念还是很有必要的，特别是 <a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM（CACM, ACM通讯）</a> 值得关注</strong>。</li>\n<li>对快速发展的CS专业来说，期刊的节奏有点慢了，而且期刊版面有限，每期只能发布几篇到十几篇不等（有的期刊则动辄一卷几千页，所以，文章质量嘛……），所以上面发表的一般是一些理论性比较强的论文，或者综述性的论文；很多新成果转而发表在学术会议上来，这跟传统学科不太一样。<br>很多会议每年举行一次，时间上也是比较固定的月份，会提前在会议网站上发布下一年的call for paper（cfp，征稿启事）和deadline（截稿日期）。投稿后，一般经过两三个月的审稿就会通知作者是否录用（Notifications）。被接收的Paper会要求按格式和Reviewers的意见稍修改后提交正式的最终版，称为Camera Ready。最后需要作者赴会做Presentation。<br>会议录用的所有Paper会结集出版，称为 <strong>Proceedings</strong> 。有的会议还会推荐一些优秀的Paper到合作的期刊，扩展后作为期刊论文出版。<br>会议分为 <strong>Symposium , Conference 和 Workshop</strong>。这三者的学术严肃性依次降低，大部分会议都称为 <strong>Conference</strong>。一般来说 <strong>Workshop</strong> 是随某个 <strong>Conference</strong> 一同举办，可能没有固定的主题，Paper质量与主会议有所差别。</li>\n</ul>\n<p>通过这个过程，我们还可以知道如何 <strong>尽快</strong> 找到一篇感兴趣的文章：</p>\n<ul>\n<li>对于期刊，一般投稿是很多的，编辑部会把已经接收但还没有排到出版期号的文章先放到网上在线出版，称为Early Access，即在线预出版；</li>\n<li>对于会议，在确定了接收的文章后，会在会议网站的Program/Accepted Papers/Schedule等类似链接下给出列表，同时会Email通知作者准备提交Camera Ready版。这时有的作者就会把Camera Ready版放到自己的主页上。之后会议组委将论文集结提供给所有作者，还会将论文集发布到ACM或IEEE（这两个机构直接参与了很多会议的组织）的论文数据库中。不同的会议组委效率不同，有的在开会前就上线出版了，有的在会议结束后还要等一段时间。</li>\n</ul>\n<h1 id=\"CS论文数据库\"><a href=\"#CS论文数据库\" class=\"headerlink\" title=\"CS论文数据库\"></a>CS论文数据库</h1><h2 id=\"ACM-IEEE-Computer等\"><a href=\"#ACM-IEEE-Computer等\" class=\"headerlink\" title=\"ACM, IEEE Computer等\"></a>ACM, IEEE Computer等</h2><p>一般会议和期刊都有自己的网站，但很少能在上面获取到论文全文。又因为来源分散，直接从它们那里检索Paper很不方便。有几个大型的论文数据库，它们与期刊或者会议主办方合作，或者自己组织会议或编辑出版期刊，比如下面的表格及<a href=\"#lib\">图书馆页面截图</a>。</p>\n<blockquote>\n<p>注意， DL和机构的网站有很多介绍性的内容是重复的，下载论文全文要去DL的页面。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>机构</th>\n<th>Digital Library （DL）</th>\n<th>机构首页</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Association for Computing Machinery, ACM</td>\n<td>ACM Digital Library  <a href=\"https://dl.acm.org/\" target=\"_blank\" rel=\"external\">https://dl.acm.org/</a></td>\n<td><a href=\"https://www.acm.org/\" target=\"_blank\" rel=\"external\">https://www.acm.org/</a></td>\n</tr>\n<tr>\n<td>IEEE Computer Society</td>\n<td>IEEE Xplore DL <a href=\"http://ieeexplore.ieee.org/\" target=\"_blank\" rel=\"external\">http://ieeexplore.ieee.org/</a></td>\n<td><a href=\"https://www.computer.org/\" target=\"_blank\" rel=\"external\">https://www.computer.org/</a></td>\n</tr>\n<tr>\n<td>Elsevier ScienceDirect</td>\n<td><a href=\"http://www.sciencedirect.com/\" target=\"_blank\" rel=\"external\">http://www.sciencedirect.com/</a></td>\n<td><a href=\"https://www.elsevier.com/\" target=\"_blank\" rel=\"external\">https://www.elsevier.com/</a></td>\n</tr>\n<tr>\n<td>Springer</td>\n<td>Springer Link <a href=\"http://link.springer.com/\" target=\"_blank\" rel=\"external\">http://link.springer.com/</a></td>\n<td><a href=\"http://www.springer.com/\" target=\"_blank\" rel=\"external\">http://www.springer.com/</a></td>\n</tr>\n<tr>\n<td>Wiley</td>\n<td>Wiley Online Lib <a href=\"http://onlinelibrary.wiley.com/\" target=\"_blank\" rel=\"external\">http://onlinelibrary.wiley.com/</a></td>\n<td><a href=\"http://www.wiley.com/\" target=\"_blank\" rel=\"external\">http://www.wiley.com/</a></td>\n</tr>\n</tbody>\n</table>\n<p>ACM 和 IEEE Computer Society（计算机学会，IEEE还有电气、电子、通信等其它多个学会） 的网址后缀是 <strong>.org</strong>，这两个是CS领域最重要的学术组织，很多的CS学术会议都是由它们组织的。<br>Elsevier，Springer，Wiley的网址后缀则是 <strong>.com</strong> ，这些是学术出版商，内容以期刊为主，涵盖了CS及其它多个学科。<br>上面这几个数据库是 <strong>主要的论文全文来源</strong>。它们各自收录的会议和期刊基本没有重叠，从它们的数据库下载的Paper也都有各自的排版样式。</p>\n<blockquote>\n<p>ACM作为最“正统”的计算机学术组织，它的DL除了收录ACM组织的会议和期刊全文之外，还会索引其它几家数据库的 <strong>元数据</strong>，但没有全文，不过可以通过DOI链接跳转到这几家数据库的全文页面。<br>IEEE出版的一些论文在 computer.org （实际是<a href=\"https://www.computer.org/csdl/\" target=\"_blank\" rel=\"external\">CSDL</a>）和 Xplore DL 都可能搜到，但这两个数据库是 <strong>分别</strong> 收费的，能在Xplore DL下载的不一定能在Computer.org下载。</p>\n</blockquote>\n<h3 id=\"ACM-SIGs\"><a href=\"#ACM-SIGs\" class=\"headerlink\" title=\"ACM SIGs\"></a>ACM SIGs</h3><p>ACM之下针对CS多个子方向的“分舵”，称为Special Interest Group，SIG，目前有三十多个<a href=\"http://www.acm.org/sigs/\" target=\"_blank\" rel=\"external\">ACM SIGs</a>（或参考DL的这个链接<a href=\"http://dl.acm.org/sigs.cfm\" target=\"_blank\" rel=\"external\">SIGs ACM DL</a>），比如</p>\n<ul>\n<li>体系结构方向的<a href=\"http://www.sigarch.org/\" target=\"_blank\" rel=\"external\">SIGARCH</a>、<a href=\"http://www.sighpc.org/\" target=\"_blank\" rel=\"external\">SIGHPC</a>、<a href=\"http://www.sigmetrics.org/\" target=\"_blank\" rel=\"external\">SIGMETRICS</a>、<a href=\"http://www.sigmicro.org/\" target=\"_blank\" rel=\"external\">SIGMICRO</a>、<a href=\"http://www.sigmobile.org/\" target=\"_blank\" rel=\"external\">SIGMOBILE</a>，</li>\n<li>网络方向的<a href=\"http://www.sigcomm.org/\" target=\"_blank\" rel=\"external\">SIGCOMM</a>，</li>\n<li>数据库方向的<a href=\"http://www.sigmod.org/\" target=\"_blank\" rel=\"external\">SIGMOD</a>，</li>\n<li>系统方向的<a href=\"http://www.sigops.org/\" target=\"_blank\" rel=\"external\">SIGOPS</a>，</li>\n<li>软件工程方向的<a href=\"http://www.sigplan.org/\" target=\"_blank\" rel=\"external\">SIGPLAN</a>、<a href=\"http://www.sigsoft.org/\" target=\"_blank\" rel=\"external\">SIGSOFT</a></li>\n</ul>\n<p>这些SIGs除了组织一系列的学术会议，还会评选本方向的一些奖项，包括 <strong>最佳论文</strong>，<strong>优秀博士论文</strong> 等（在DL中一般没有标明哪篇是Best Paper）。此外，</p>\n<ul>\n<li>有网站维护了一个<a href=\"http://jeffhuang.com/best_paper_awards.html\" target=\"_blank\" rel=\"external\">部分会议的最佳论文列表</a>，</li>\n<li>还有下面要介绍的USENIX的<a href=\"https://www.usenix.org/conferences/best-papers\" target=\"_blank\" rel=\"external\">各会议最佳论文</a>。</li>\n</ul>\n<p>有的SIG会选择一些高质量的文章，以Review，Newsletter 或 Notes 的形式重新发表，引用的时候最好引用最初的来源。</p>\n<h2 id=\"USENIX\"><a href=\"#USENIX\" class=\"headerlink\" title=\"USENIX\"></a><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></h2><p>要是学校的图书馆不差钱，把所有有价值的论文数据库都买买买来，那么下面截图中的电子资源列表应该很全了吧？然而还是少了一个重要的数据库：USENIX —— 它是免费的。<br>话说<strong><a href=\"https://www.usenix.org/\" target=\"_blank\" rel=\"external\">USENIX</a></strong> 实在是个良心组织。USENIX最初称为Unix User Group。它组织了OSDI 、ATC、FAST、NSDI、LISA等会议，不但学术水平很高，贴近工业界，而且免费提供全文下载，还提供一些论文作者在会议上的slides及演讲视频。slides是对文章的提炼，读论文时可以参考。拿slides和视频来学习做Presentation，练习英语听力和口语也不错。</p>\n<h2 id=\"arXiv\"><a href=\"#arXiv\" class=\"headerlink\" title=\"arXiv\"></a><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a></h2><p><a href=\"http://arxiv.org/\" target=\"_blank\" rel=\"external\">arXiv</a>， 是archive（归档）的意思，是一个由康乃尔大学维护的免费的多学科论文<strong>预</strong>出版（preprint）数据库。所谓<strong>预</strong>出版，就是说论文还没有经过同行评审，文责自负，文章质量参差不齐，所以一般不会作为正式的学术成果。不过有的学科习惯上先把文章公开到arXiv上，然后再提交到会议上。</p>\n<p><a name=\"lib\"><img src=\"/img/lib.png\" alt=\"图书馆电子资源\"></a></p>\n<h2 id=\"EI和SCI\"><a href=\"#EI和SCI\" class=\"headerlink\" title=\"EI和SCI\"></a>EI和SCI</h2><p>分别搜索上面的数据库还是有点麻烦，于是就有了一些聚合数据库，又称为索引。想必很多同学在读研之前早就听说EI和SCI，</p>\n<ul>\n<li>EI <strong>Engineering Index</strong> <a href=\"https://www.engineeringvillage.com/\" target=\"_blank\" rel=\"external\">https://www.engineeringvillage.com/</a></li>\n<li>SCI <strong>Science Citation Index</strong> <a href=\"http://apps.webofknowledge.com/\" target=\"_blank\" rel=\"external\">http://apps.webofknowledge.com/</a></li>\n</ul>\n<p><strong>只看 URL 还以为是 山寨网站</strong>，它们的Web界面体验也不太友好，而且它们不止有CS一个学科，直接通过关键词搜索经常会给出不相关的内容。其实这两个数据库通常是在 <strong>已知文章标题的情况下</strong> 检索是不是被它们收录了，而 <strong>不是</strong> 用来收集文章的。</p>\n<p>要确定某个会议论文集或者期刊<a href=\"http://www.philippe-fournier-viger.com/links.php\" target=\"_blank\" rel=\"external\">是否被EI或SCI收录</a>，</p>\n<ul>\n<li>在<a href=\"https://www.elsevier.com/solutions/engineering-village/content\" target=\"_blank\" rel=\"external\">EI收录列表</a> 页内搜索Compendex Source List，会找到一个Excel表格的链接，下载下来会发现这个表格是受保护的，但可以筛选标题（而且最后一个WorkSheet有中文翻译哦，满满的土洋结合，中国特色）。嘘~~ 也许你可以参考<a href=\"/doc/crack_xls_vb.txt\">这个脚本解除保护</a>，还要建议把title列中每个单元格开头的<code>=</code>替换掉。这个Excel的title是排好序的，方便顺序浏览，比如有个杂志名叫<code>Computing</code>，真是起的好名字，如果直接搜索是肯定搜出一堆结果，所以，即便找到名字一样的期刊，最好也要再确认一下ISSN号。<strong>但是！</strong>，这个Excel表格并不完整，如果没有在表中搜索到，还是需要在EI的网站上搜索文章标题才能最终确认。对了，EI的数据库叫 <strong>Compendex</strong>。</li>\n<li>在<code>webofknowledge</code>的网站查询之前，<strong>一定</strong> 要选择数据库为<code>检索 Web of Science 核心合集</code>，等自动刷新候，还要在页面下部展开“更多设置”，只选中<code>Science Citation Index Expanded (SCIEXPANDED) 1900年至今</code>这一项，然后才能查询出根正苗红的<code>SCI（E）</code>。请<strong>务必</strong>参考<a href=\"/doc/SCI_E_Web_of_Science.pdf\">这个截图</a>。可以在<a href=\"http://ip-science.thomsonreuters.com/cgi-bin/jrnlst/jlsearch.cgi?PC=K\" target=\"_blank\" rel=\"external\">SCI收录列表</a>直接输入期刊的名称来查询该期刊是否被SCI收录，但感觉这个查的也不全。还是要充分利用SCI的中国特色了，因为还有一个国内整理的SCI期刊列表：<a href=\"http://scit.nju.edu.cn/Item/1162.aspx\" target=\"_blank\" rel=\"external\">中国科学技术信息研究所SCI（E）论文期刊分区列表（2016年）</a>，这是一个有13.8k多行的Excel表格，简洁粗暴。</li>\n</ul>\n<hr>\n<p>上面的这些数据库可以免费检索标题和摘要，购买全文则价格不菲。如果学校的图书馆购买了这些数据库，一般会识别用户的IP地址，在学校网络范围内可以直接下载PDF全文。<br>校外就没有这么方便了，好在很多作者在Paper被录用后会在自己的主页上挂出PDF全文，从Google Scholar上可以搜索到这些PDF全文的链接，非常方便。<br>话说只要是能花钱买到的东西，去万能的 <strong>淘宝</strong> 肯定能找到，就看是买 <strong>VPN/代理，单篇文章，还是 整个数据库</strong> 了。</p>\n<h2 id=\"dblp\"><a href=\"#dblp\" class=\"headerlink\" title=\"dblp\"></a>dblp</h2><p>dblp [<a href=\"http://dblp.org\" target=\"_blank\" rel=\"external\">http://dblp.org</a>] ，或[<a href=\"http://dblp.uni-trier.de]，\" target=\"_blank\" rel=\"external\">http://dblp.uni-trier.de]，</a> 是专注于CS学科的文献 <strong>元数据索引</strong> 数据库，优势是收集得相当完整，链接也很有规律，比如特定会议的 FSE 2016 <a href=\"http://dblp.org/db/conf/sigsoft/fse2016.html\" target=\"_blank\" rel=\"external\">http://dblp.org/db/conf/sigsoft/fse2016.html</a> 或者某个作者的全部论文列（dblp对重名作者处理得很好），但只能搜索标题或作者等元数据，用来初步筛选论文非常方便，需要获取全文时还是要跳转到上面的几个数据库，数据更新也稍微滞后一点。<br>2015版CCF目录中的会议和期刊都是dblp的链接。</p>\n<p>dblp 列出了关于CS论文的一些统计数据，比如（2016年10月查询）</p>\n<ul>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/recordsindblp.html\" target=\"_blank\" rel=\"external\">累计论文记录数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/publicationsperyear.html\" target=\"_blank\" rel=\"external\">每年发表的论文数量</a>，</li>\n<li><a href=\"http://dblp.dagstuhl.de/statistics/distributionofpublicationtype.html\" target=\"_blank\" rel=\"external\">论文发表的类型</a>，其中会议论文占53%，</li>\n<li>论文总数 3,587,354 ， 作者人数 1,825,286，会议数4,912，期刊数 1,491。</li>\n</ul>\n<p>另外，ACM DL也有一个<a href=\"http://dl.acm.org/contents_guide.cfm\" target=\"_blank\" rel=\"external\">类似的统计</a>。<br><img src=\"/img/pubs.png\" alt=\"每年发表的CS论文数量\"></p>\n<p>而且dblp整站的数据都可以下载为一个<a href=\"http://dblp.dagstuhl.de/xml/\" target=\"_blank\" rel=\"external\">xml文件</a>，以供进一步挖掘。</p>\n<h2 id=\"DOI\"><a href=\"#DOI\" class=\"headerlink\" title=\"DOI\"></a>DOI</h2><p>在查找或引用论文时经常会遇到DOI(Digital Object Identifier)，<a href=\"https://zh.wikipedia.org/wiki/DOI\" target=\"_blank\" rel=\"external\">wikipedia介绍DOI</a>“是一套识别数字资源的机制，涵括的对象有视频、报告或书籍等等。它既有一套为资源命名的机制，也有一套将识别号解析为具体地址的协议”。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p>从Google Scholar搜索全文时可能会跳转到下面这几个网站，因为它们会保存一些别人分享的全文。</p>\n<ul>\n<li>Semantic Scholar [<a href=\"https://www.semanticscholar.org\" target=\"_blank\" rel=\"external\">https://www.semanticscholar.org</a>]</li>\n<li>CiteSeerX [<a href=\"http://citeseerx.ist.psu.edu/\" target=\"_blank\" rel=\"external\">http://citeseerx.ist.psu.edu/</a>]</li>\n<li>ResearchGate [<a href=\"https://www.researchgate.net/\" target=\"_blank\" rel=\"external\">https://www.researchgate.net/</a>] ，这是一个学术社交网络</li>\n</ul>\n<h1 id=\"CCF目录\"><a href=\"#CCF目录\" class=\"headerlink\" title=\"CCF目录\"></a>CCF目录</h1><p>EI和SCI只是两个论文数据库，但能够发表被EI和SCI收录的文章变成了能够毕业，能否获得奖学金，能否获得基金的指标。由于时代的限制，EI和SCI被赋予了不相称的地位和意义，而且短期看还是如此。<br>更 “<strong>不幸</strong>” 的是，对于CS的学生，还有一个<a href=\"http://history.ccf.org.cn/sites/ccf/paiming.jsp\" target=\"_blank\" rel=\"external\">CCF目录</a>（<a href=\"http://history.ccf.org.cn/sites/paiming/2015ccfmulu.pdf\" target=\"_blank\" rel=\"external\">2015版的PDF</a>）摆在面前。其实并非是不幸，而是十分幸运，因为CCF目录不像是一个紧箍咒，而更像是一个入门指南。</p>\n<p>首先说<a href=\"http://www.ccf.org.cn/\" target=\"_blank\" rel=\"external\">中国计算机学会 CCF</a>是国内的类似于ACM的计算机学术组织。也许某位同学的导师就是CCF会员。相比EI和SCI收录的成百上千的会议和期刊，CCF维护的目录显然<a href=\"https://ying-zhang.github.io/misc/2017/ccf-all-in-one/\">精简得多</a>。<br>考虑到对EI和SCI指标要求的实际情况，目录选取的 <strong>大多</strong> 是被EI或SCI收录的，具体划分为10个子方向，并区分出A，B，C三个等级。<br>A，B类的会议和期刊的文章学术质量较高。这个质量不是简单通过所谓影响因子等机械的数据来评价的，而是综合了多种因素，国际上也获得比较广泛认可的。比如，翻一下本科的《现代操作系统》这本经典教材的参考文献，会发现其中引用的有不少SOSP，OSDI，ASPLOS,TCS等A类会议和期刊。</p>\n<blockquote>\n<p>如果只看标题和摘要，有的期刊/会议文章看起来非常值得一读，比如 <a href=\"http://dblp.org/db/journals/fgcs/\" target=\"_blank\" rel=\"external\">FGCS    Future Generation Computer Systems</a>上的文章。但如果仔细读一下文章全文，经常是大失所望。好在CCF只给了FGCS C类的评级。<br>随着越来越多的研究生进入工业界，论文对码农来说也就不那么神秘了。看到别人写的文章末尾附上了一大堆英文论文，也不只是单纯地赞赏一番或浏览一下标题，还要看看这些文章发在哪些会议或者期刊上。其实经典的二八定律也符合学术界，对CS专业来说比例可能更甚。事实是大部分的文章不值得细读。这时就会发现CCF评级的价值了。仅从A类文章搜集资料就已经足够了，而且还能提高检索效率。</p>\n</blockquote>\n<p>上面提到ACM有三十多个SIGs，而CCF则只划分了10个子方向，不同的视角有不同的划分结果，这里有ACM的更详细的<a href=\"http://dl.acm.org/ccs/ccs.cfm\" target=\"_blank\" rel=\"external\">分类系统CCS</a>，以及有重叠的<a href=\"https://www.acm.org/special-interest-groups/sigs-by-knowledge-area\" target=\"_blank\" rel=\"external\">SIGs大类划分</a>，还有<a href=\"https://en.wikipedia.org/wiki/Outline_of_computer_science\" target=\"_blank\" rel=\"external\">wikipedia上的一个划分</a>。</p>\n<h1 id=\"Google-Scholar（谷歌学术）\"><a href=\"#Google-Scholar（谷歌学术）\" class=\"headerlink\" title=\"Google Scholar（谷歌学术）\"></a>Google Scholar（谷歌学术）</h1><p><a href=\"https://scholar.google.com/\" target=\"_blank\" rel=\"external\">Google Scholar</a>非常强大又简单易用。虽然它不只收录CS专业的文献，但很容易搜索到准确的结果。我习惯先在谷歌学术上搜索，如果搜不到就改用 <strong>高级搜索</strong>，实在不行再去ACM DL、IEEE Xplore。<br><img src=\"/img/scholar_adv.png\" alt=\"谷歌学术高级搜索\"></p>\n<h2 id=\"创建快讯\"><a href=\"#创建快讯\" class=\"headerlink\" title=\"创建快讯\"></a>创建快讯</h2><p>与Google网页搜索一样，可以在Google Scholar创建某个关键词或某篇文章的快讯（发送邮件通知最新的搜索结果）；<br>此外，注意搜索到的论文的作者是否有链接，打开即是Google Scholar创建的作者个人资料页，上面一般有作者的单位、联系方式，文章列表等，在 <strong>作者的个人资料页</strong> 可以创建关于他的新文章或新引用的快讯，及时获取动态。</p>\n<blockquote>\n<p>话说体验一下<a href=\"http://www.bing.com/academic\" target=\"_blank\" rel=\"external\">必应学术</a>、<a href=\"http://xueshu.baidu.com/\" target=\"_blank\" rel=\"external\">百度学术</a>和<a href=\"http://scholar.sogou.com/\" target=\"_blank\" rel=\"external\">搜狗学术</a>也未尝不可。</p>\n</blockquote>\n<p><a name=\"tldr\"></a></p>\n<h1 id=\"tl-dr：链接列表\"><a href=\"#tl-dr：链接列表\" class=\"headerlink\" title=\"tl,dr：链接列表\"></a>tl,dr：链接列表</h1><h2 id=\"体系结构，系统，存储，分布式系统\"><a href=\"#体系结构，系统，存储，分布式系统\" class=\"headerlink\" title=\"体系结构，系统，存储，分布式系统\"></a>体系结构，系统，存储，分布式系统</h2><ul>\n<li>ASPLOS@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE178&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/asplos/\" target=\"_blank\" rel=\"external\">DBLP</a> Architectural Support for Programming Languages and Operating Systems</li>\n<li>FAST@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE425&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/fast/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on File and Storage Technologies</li>\n<li>HPCA@<strong>A</strong>   <a href=\"http://ieeexplore.ieee.org/servlet/opac?punumber=1000335\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/hpca/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Computer Architecture</li>\n<li>ISCA@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE239&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/isca/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Computer Architecture</li>\n<li>MICRO@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE203&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/micro/\" target=\"_blank\" rel=\"external\">DBLP</a> Microarchitecture</li>\n<li>PPoPP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE241&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ppopp/\" target=\"_blank\" rel=\"external\">DBLP</a> Principles and Practice of Parallel Programming</li>\n<li>SC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE207&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sc/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. for High Performance Computing, Networking, Storage, and Analysis</li>\n<li>ATC@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/131\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/usenix/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Annul Technical Conf.</li>\n<li>CGO@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE256&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cgo/\" target=\"_blank\" rel=\"external\">DBLP</a> Code Generation and Optimization</li>\n<li>EuroSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE101&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/eurosys/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Computer Systems</li>\n<li>HotCHIPS@<strong>B</strong>   <a href=\"http://www.hotchips.org/\" target=\"_blank\" rel=\"external\">HotChips</a> Symposium on High Performance Chips</li>\n<li>HPDC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE300&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/hpdc/\" target=\"_blank\" rel=\"external\">DBLP</a> High-Performance Distributed Computing</li>\n<li>LISA@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/5\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/lisa/\" target=\"_blank\" rel=\"external\">DBLP</a> Large Installation system Administration Conf.</li>\n<li>PODC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE221&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/podc/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Principles of Distributed Computing</li>\n<li>SIGMETRICS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE187&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a>，<a href=\"http://dl.acm.org/citation.cfm?id=J618\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmetrics/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Measurement and Modeling of Computer Systems</li>\n<li>VEE@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE287&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vee/\" target=\"_blank\" rel=\"external\">DBLP</a> Virtual Execution Environments</li>\n<li>TC@<strong>A</strong>   <a href=\"https://www.computer.org/web/tc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tc/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computers</li>\n<li>TOCS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J774&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tocs/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Computer Systems</li>\n<li>TOS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J960&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tos/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Storage</li>\n<li>TPDS@<strong>A</strong>   <a href=\"https://www.computer.org/web/tpds\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tpds/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Parallel and Distributed Systems</li>\n<li>ISMM   <a href=\"http://dl.acm.org/event.cfm?id=RE149&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/ismm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Memory Management</li>\n</ul>\n<h2 id=\"软件工程（软件分析）\"><a href=\"#软件工程（软件分析）\" class=\"headerlink\" title=\"软件工程（软件分析）\"></a>软件工程（软件分析）</h2><ul>\n<li>Github上的<a href=\"https://github.com/tue-mdse/conferenceMetrics\" target=\"_blank\" rel=\"external\">软件工程方向会议的数据</a></li>\n<li>UIUC的<a href=\"http://taoxie.cs.illinois.edu/\" target=\"_blank\" rel=\"external\">谢涛老师</a>维护的<a href=\"http://taoxie.cs.illinois.edu/seconferences.htm\" target=\"_blank\" rel=\"external\">软件工程方向的会议统计列表</a></li>\n<li>ASE@<strong>A</strong>   <a href=\"http://dblp.org/db/conf/kbse/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Automated Software Engineering</li>\n<li>FSE/ESEC@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE201&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigsoft/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGSOFT Symposium on the Foundation of Software Engineering / European Software Engineering Conf.</li>\n<li>ICSE@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE228&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/icse/\" target=\"_blank\" rel=\"external\">DBLP</a> FOSE会议：七年一届的展望 Int. Conf. on Software Engineering</li>\n<li>OOPSLA/SPLASH@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE181&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/oopsla/\" target=\"_blank\" rel=\"external\">DBLP</a> Onward会议：创新（脑洞） Conf. on Object-Oriented Programming Systems, Languages, and Applications</li>\n<li>OSDI@<strong>A</strong>   <a href=\"https://www.usenix.org/conferences/byname/179\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/osdi/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Symposium on Operating Systems Design and Implementations，<strong>双数</strong> 年份召开</li>\n<li>SOSP@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE208&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sosp/\" target=\"_blank\" rel=\"external\">DBLP</a>，Symposium on Operating Systems Principles， <strong>单数</strong> 年份召开，另，<a href=\"http://sigops.org/sosp/sosp15/history/index.html\" target=\"_blank\" rel=\"external\">SOSP 2015 History Day</a></li>\n<li>PLDI@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE200&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pldi/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN Symposium on Programming Language Design and Implementation</li>\n<li>POPL@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE180&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/popl/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGPLAN&amp;SIGACT Symposium on Principles of Programming Languages</li>\n<li>ECOOP@<strong>B</strong>   <a href=\"http://www.ecoop.org/\" target=\"_blank\" rel=\"external\">ECOOP</a> , <a href=\"http://dblp.org/db/conf/ecoop/\" target=\"_blank\" rel=\"external\">DBLP</a> European Conf. on Object-Oriented Programming</li>\n<li>HotOS@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/155\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotos/\" target=\"_blank\" rel=\"external\">DBLP</a> USENIX Workshop on Hot Topics in Operating Systems</li>\n<li>ICSME@<strong>B</strong>   <a href=\"http://conferences.computer.org/icsm/\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/icsm/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Software Maintenance</li>\n<li>ISSTA@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE222&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/issta/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Symposium on Software Testing and Analysis</li>\n<li>TOPLAS@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J783&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/toplas/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Programming Languages and Systems</li>\n<li>TOSEM@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J790&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/tosem/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering Methodology</li>\n<li>TSE@<strong>A</strong>   <a href=\"https://www.computer.org/web/tse\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tse/\" target=\"_blank\" rel=\"external\">DBLP</a> Trans. on Software Engineering</li>\n</ul>\n<h2 id=\"云计算，网络，大数据\"><a href=\"#云计算，网络，大数据\" class=\"headerlink\" title=\"云计算，网络，大数据\"></a>云计算，网络，大数据</h2><ul>\n<li>SIGMOD@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/sigmod/\" target=\"_blank\" rel=\"external\">DBLP</a> Conf. on Management of Data</li>\n<li>SoCC@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/cloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Symposium on Cloud Computing</li>\n<li>PODS@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE227&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/pods/\" target=\"_blank\" rel=\"external\">DBLP</a> SIGMOD Conf. on Principles of DB Systems</li>\n<li>VLDB Endowment@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J1174&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Conf. on Very Large Data Bases</li>\n<li>VLDB Journal@<strong>A</strong>   <a href=\"http://dl.acm.org/pub.cfm?id=J869&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/journals/vldb/\" target=\"_blank\" rel=\"external\">DBLP</a> Int. Journal on Very Large Data Bases</li>\n<li>NSDI@<strong>B</strong>   <a href=\"https://www.usenix.org/conferences/byname/178\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/nsdi/\" target=\"_blank\" rel=\"external\">DBLP</a> Network System Design and Implementation</li>\n<li>IEEE 云计算系列@<strong>B/C</strong>  <a href=\"http://cloudcomputing.ieee.org/conferences\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/conf/IEEEcloud/\" target=\"_blank\" rel=\"external\">DBLP</a></li>\n<li>HotCloud   <a href=\"https://www.usenix.org/conferences/byname/1\" target=\"_blank\" rel=\"external\">USENIX</a> , <a href=\"http://dblp.org/db/conf/hotcloud/\" target=\"_blank\" rel=\"external\">DBLP</a> Hot Topics on Cloud Computing</li>\n<li>TCC   <a href=\"https://www.computer.org/web/tcc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tcc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Cloud Computing</li>\n<li>TSC@<strong>B</strong>   <a href=\"https://www.computer.org/web/tsc\" target=\"_blank\" rel=\"external\">IEEE</a> , <a href=\"http://dblp.org/db/journals/tsc/\" target=\"_blank\" rel=\"external\">DBLP</a> IEEE Trans. on Services Computing</li>\n<li>SigComm@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE258&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/conf/sigcomm/\" target=\"_blank\" rel=\"external\">DBLP</a><br>上面体系结构中的 ASPLOS、FAST、ISCA、Micro、ATC、EuroSys、HPDC、LISA、SIGMETRICS、TPDS等，及软工的OSDI、SOSP等也都有不少云计算相关的文章。</li>\n</ul>\n<h2 id=\"移动计算\"><a href=\"#移动计算\" class=\"headerlink\" title=\"移动计算\"></a>移动计算</h2><ul>\n<li>MobiCom@<strong>A</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE366&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobicom/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing and Networking</li>\n<li>MobiSys@<strong>B</strong>   <a href=\"http://dl.acm.org/event.cfm?id=RE191&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/mobisys/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Systems, Applications, and Services</li>\n<li>HotMobile   <a href=\"http://dl.acm.org/event.cfm?id=RE142&amp;tab=pubs\" target=\"_blank\" rel=\"external\">ACM</a> , <a href=\"http://dblp.org/db/conf/wmcsa/\" target=\"_blank\" rel=\"external\">DBLP</a> Mobile Computing Systems and Applications</li>\n</ul>\n<h2 id=\"ACM-DL列表\"><a href=\"#ACM-DL列表\" class=\"headerlink\" title=\"ACM DL列表\"></a>ACM DL列表</h2><ul>\n<li><a href=\"http://dl.acm.org/contents_dl.cfm\" target=\"_blank\" rel=\"external\">收录会议和期刊的完整列表</a></li>\n<li><a href=\"http://dl.acm.org/events.cfm\" target=\"_blank\" rel=\"external\">会议</a></li>\n<li><a href=\"http://dl.acm.org/proceedings.cfm\" target=\"_blank\" rel=\"external\">会议历次论文集</a></li>\n<li><a href=\"http://dl.acm.org/pubs.cfm\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"http://dl.acm.org/mags.cfm\" target=\"_blank\" rel=\"external\">杂志</a></li>\n<li><a href=\"http://dl.acm.org/conferences.cfm\" target=\"_blank\" rel=\"external\">ACM Conferences - past 12 months</a></li>\n<li><a href=\"http://dl.acm.org/UpcomingConfLocations.xml\" target=\"_blank\" rel=\"external\">ACM Upcoming Conferences - RSS</a></li>\n</ul>\n<p>关于ACM的杂志，特别推荐</p>\n<ul>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J79\" target=\"_blank\" rel=\"external\">Communications of the ACM, CACM</a>， <a href=\"http://dblp.org/db/journals/cacm/\" target=\"_blank\" rel=\"external\">in dblp</a></li>\n<li><a href=\"http://dl.acm.org/toco_arch.cfm?id=J79&amp;lang=chinese\" target=\"_blank\" rel=\"external\">CACM中国版</a>，CCF曾经 选译 一部分CACM文章为中文并出版，但2016年后没有继续下去</li>\n<li><a href=\"http://dl.acm.org/citation.cfm?id=J882\" target=\"_blank\" rel=\"external\">Queue</a>也值得一看，不过它与CACM有很多重叠的文章</li>\n</ul>\n<p>期刊中，推荐<a href=\"http://dl.acm.org/citation.cfm?id=J204\" target=\"_blank\" rel=\"external\">ACM Computing Surveys, CSUR</a>， <a href=\"http://dblp.org/db/journals/csur/\" target=\"_blank\" rel=\"external\">in dblp</a></p>\n<blockquote>\n<p>看了ACM DL的列表页面，应该能体会到：1000项以内的列表还是不要分页的好。</p>\n</blockquote>\n<h2 id=\"IEEE-Computer列表\"><a href=\"#IEEE-Computer列表\" class=\"headerlink\" title=\"IEEE Computer列表\"></a>IEEE Computer列表</h2><ul>\n<li><a href=\"https://www.computer.org/web/conferences/calendar/\" target=\"_blank\" rel=\"external\">会议日历</a></li>\n<li><a href=\"https://www.computer.org/web/publications/transactions\" target=\"_blank\" rel=\"external\">期刊和学报</a></li>\n<li><a href=\"https://www.computer.org/web/publications/magazines\" target=\"_blank\" rel=\"external\">杂志</a></li>\n</ul>\n<h2 id=\"USENIX组织的会议列表\"><a href=\"#USENIX组织的会议列表\" class=\"headerlink\" title=\"USENIX组织的会议列表\"></a><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a></h2><p><a href=\"https://www.usenix.org/conferences/byname\" target=\"_blank\" rel=\"external\">USENIX组织的会议列表</a>，其中包括ATC，FAST，LISA，MobiSys，NSDI，OSDI，VEE及HotCloud，HotOS等一系列 HotXXXX 的Workshop。</p>\n<h2 id=\"国内三个学报\"><a href=\"#国内三个学报\" class=\"headerlink\" title=\"国内三个学报\"></a>国内三个学报</h2><ul>\n<li><a href=\"http://www.jos.org.cn/ch/index.aspx\" target=\"_blank\" rel=\"external\">软件学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=RJXB&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://cjc.ict.ac.cn/\" target=\"_blank\" rel=\"external\">计算机学报</a>，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JSJX&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n<li><a href=\"http://crad.ict.ac.cn/CN/volumn/home.shtml\" target=\"_blank\" rel=\"external\">计算机研究与发展</a> ，<a href=\"http://rss.cnki.net/KNS/rss.aspx?journal=JFYZ&amp;Virtual=KNS\" target=\"_blank\" rel=\"external\">CNKI RSS</a></li>\n</ul>\n<h2 id=\"国内论文数据库\"><a href=\"#国内论文数据库\" class=\"headerlink\" title=\"国内论文数据库\"></a>国内论文数据库</h2><ul>\n<li><a href=\"http://www.cnki.net/\" target=\"_blank\" rel=\"external\">知网CNKI</a></li>\n<li><a href=\"http://www.wanfangdata.com.cn/\" target=\"_blank\" rel=\"external\">万方数据</a></li>\n</ul>\n<h2 id=\"其它链接\"><a href=\"#其它链接\" class=\"headerlink\" title=\"其它链接\"></a>其它链接</h2><ul>\n<li><a href=\"https://www.microsoft.com/en-us/research/\" target=\"_blank\" rel=\"external\">微软研究院</a></li>\n<li><a href=\"https://research.google.com/pubs/papers.html\" target=\"_blank\" rel=\"external\">谷歌研究院</a></li>\n<li><a href=\"https://blog.acolyer.org/\" target=\"_blank\" rel=\"external\">The morning paper</a>, an interesting-influential-important paper from the world of CS every weekday morning</li>\n<li><a href=\"http://sites.computer.org/debull/bull_issues.html\" target=\"_blank\" rel=\"external\">IEEE Technical Committee on Data Engineering</a></li>\n<li><a href=\"https://www.youtube.com\" target=\"_blank\" rel=\"external\">YouTube</a>，</li>\n<li><strong><a href=\"http://www1.cs.columbia.edu/~kaiser/relatedwork.htm\" target=\"_blank\" rel=\"external\">Suggested Guidelines for Finding Materials to include in the “Related Work” Sections of Conference Papers</a></strong></li>\n<li><a href=\"http://www.yocsef.org.cn/sites/yocweb/yocltzw.jsp?contentId=2658502145582\" target=\"_blank\" rel=\"external\">YOCSEF专题论坛：从LNCS事件反思中国学术论文的发表</a>  </li>\n</ul>\n<h1 id=\"如何读论文\"><a href=\"#如何读论文\" class=\"headerlink\" title=\"如何读论文\"></a>如何读论文</h1><ul>\n<li><a href=\"http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf\" target=\"_blank\" rel=\"external\">Efficient Reading of Papers in Science and Technology(pdf)</a></li>\n<li><a href=\"http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf\" target=\"_blank\" rel=\"external\">How to Read a Paper(pdf)</a></li>\n<li><a href=\"https://www.cs.jhu.edu/~jason/advice/how-to-read-a-paper.html\" target=\"_blank\" rel=\"external\">How to Read a Technical Paper</a></li>\n<li><a href=\"http://item.jd.com/11127141.html\" target=\"_blank\" rel=\"external\">《学术研究 - 你的成功之道》第3章</a></li>\n</ul>\n<h1 id=\"Todo-辅助工具\"><a href=\"#Todo-辅助工具\" class=\"headerlink\" title=\"[Todo]辅助工具\"></a>[Todo]辅助工具</h1><ul>\n<li><a href=\"http://myhuiban.com\" target=\"_blank\" rel=\"external\">会伴</a></li>\n<li>Trans. on BigData的学术文献处理专刊 <a href=\"https://www.computer.org/csdl/trans/bd/2016/01/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 1</a>，<a href=\"https://www.computer.org/csdl/trans/bd/2016/02/index.html\" target=\"_blank\" rel=\"external\">Vol. 2 Issue 2</a></li>\n<li><a href=\"http://www.sciplore.org/\" target=\"_blank\" rel=\"external\">Sciplore</a></li>\n<li><a href=\"https://www.scopus.com/\" target=\"_blank\" rel=\"external\">Scopus</a></li>\n<li><a href=\"http://www.docear.org/\" target=\"_blank\" rel=\"external\">Docear</a></li>\n<li><a href=\"https://www.mendeley.com/\" target=\"_blank\" rel=\"external\">Mendeley</a></li>\n<li><a href=\"https://www.zotero.org/\" target=\"_blank\" rel=\"external\">Zotero</a></li>\n<li><a href=\"https://www.teambition.com/\" target=\"_blank\" rel=\"external\">Teambition</a></li>\n<li>Todo，如何整理文献，如何管理时间，<a href=\"https://www.zhihu.com/question/27956707\" target=\"_blank\" rel=\"external\">科研小组里有哪些有效的组会形式 - 知乎</a></li>\n</ul>\n<p>如果所在的实验室没有什么积累，暂时没有好的idea/topic，不妨去浏览一下感兴趣的大方向的A类会议近三年或五年的文章列表，<strong>总会觉得</strong> 有几篇比其它文章更有意思，这就把范围缩小一些了；然后再从这几篇文章里提炼出关键词，去<a href=\"https://en.wikipedia.org/\" target=\"_blank\" rel=\"external\">wikipedia</a>上搜索一下这个关键词，再从Related Work再扩展出去，体验一下这个小领域涉及的问题。找出来这个小领域里发文章比较多的作者和研究小组（实验室），去作者和小组的主页看看。这个前期工作其实花不了一周的时间，然后就收集一些相关的论文，粗览一遍，筛选出值得仔细研读的。我们不妨通过相关论文的数量来定义一个小的领域，武断地说100篇或200篇，这个具体的大小不是关键，但一个领域能发的文章必定是有限的，太多的话说明问题太复杂，还要细分，太少的话，如果不是幸运地发现了新的方向，就是问题太Trivial了。而这其中，又只有几篇或十几篇是开创性的，非常值得仔细研读的。<br>如果读完核心的几篇文章后还是没有新的想法，那就只好重复上面的过程，重新寻找另外感兴趣的领域了。</p>\n<blockquote>\n<p>PS，相比上面列出来一堆链接，其实这几句话才是这篇文章的重点啊 ;-)</p>\n</blockquote>\n<p>一些标题有<code>A systematic review on ...</code>综述文章，其中会介绍收集相关论文的过程，方法都类似，可以找一篇当作论文搜集方法的教程来看。</p>\n<p>再列出知乎上的几个相关问题吧</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/26901116\" target=\"_blank\" rel=\"external\">如何总结和整理学术文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/26857521\" target=\"_blank\" rel=\"external\">如何高效管理文献？</a></li>\n<li><a href=\"https://www.zhihu.com/question/22790506\" target=\"_blank\" rel=\"external\">如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?</a></li>\n</ul>\n<p><a name=\"hosts\"></a></p>\n<h1 id=\"Bonus-如何访问Google-Scholar\"><a href=\"#Bonus-如何访问Google-Scholar\" class=\"headerlink\" title=\"[Bonus] 如何访问Google Scholar\"></a>[Bonus] 如何访问Google Scholar</h1><h2 id=\"改hosts\"><a href=\"#改hosts\" class=\"headerlink\" title=\"改hosts\"></a><strong>改hosts</strong></h2><ul>\n<li>IP v4， https://raw.githubusercontent.com/racaljk/hosts/master/hosts  或短网址 https://git.io/vWE1N</li>\n<li>IP v6， https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/host 或短网址 https://git.io/vMjCk</li>\n</ul>\n<h2 id=\"hosts文件的路径\"><a href=\"#hosts文件的路径\" class=\"headerlink\" title=\"hosts文件的路径\"></a><strong>hosts文件的路径</strong></h2><ul>\n<li>Windows：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux，Mac，Android（均需要root权限）：<code>/etc/hosts</code></li>\n</ul>\n<h1 id=\"PS-A-Survival-Guide-to-a-PhD\"><a href=\"#PS-A-Survival-Guide-to-a-PhD\" class=\"headerlink\" title=\"PS: A Survival Guide to a PhD\"></a>PS: <a href=\"http://karpathy.github.io/2016/09/07/phd/\" target=\"_blank\" rel=\"external\">A Survival Guide to a PhD</a></h1><hr>\n<p>飞鸟集</p>\n<blockquote>\n<p>第83<br>那想做好人的，在门外敲着门，那爱人的，看见门敞开着。</p>\n<p>第142<br>让我设想，在群星之中，有一颗星是指导着我的生命通过不可知的黑暗的。</p>\n</blockquote>"},{"title":"Windows从VHD启动实现极速快照和恢复","date":"2016-09-21T16:00:00.000Z","_content":"把之前发过的[虚拟机及docker的存储，快照和镜像](/cloud/2016/vm-disk/index.html#win-vhd-boot)相关部分单独拿出来。正文无内容。\n<!--more-->\n","source":"_posts/win-vhd-boot.md","raw":"title: Windows从VHD启动实现极速快照和恢复\ncategory: [cloud]\ntags: \ndate: 2016-09-22\n---\n把之前发过的[虚拟机及docker的存储，快照和镜像](/cloud/2016/vm-disk/index.html#win-vhd-boot)相关部分单独拿出来。正文无内容。\n<!--more-->\n","slug":"win-vhd-boot","published":1,"updated":"2017-10-30T03:43:20.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9s6hmhc000y9s4f4l6omn7q","content":"<p>把之前发过的<a href=\"/cloud/2016/vm-disk/index.html#win-vhd-boot\">虚拟机及docker的存储，快照和镜像</a>相关部分单独拿出来。正文无内容。<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>把之前发过的<a href=\"/cloud/2016/vm-disk/index.html#win-vhd-boot\">虚拟机及docker的存储，快照和镜像</a>相关部分单独拿出来。正文无内容。<br>","more":"</p>"},{"title":"【译文修订】使用Borg在Google管理大规模集群","date":"2017-10-30T16:00:00.000Z","_content":"\n发表于EuroSys 2015的 ***Large-scale cluster management at Google with Borg*** 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。\n\n<!--more-->\n\n---\n\n# Large-scale cl uster management at Google with Borg\n# 使用Borg在Google管理大规模集群\n\n作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes\n\nEuroSys'15, http://dx.doi.org/10.1145/2741948.2741964\n\nhttp://research.google.com/pubs/pub43438.html 或 [下载转存的英文全文PDF](https://ying-zhang.github.io/doc/EuroSys15_Borg.pdf)\n\n[**中文译文全文PDF**](https://ying-zhang.github.io/doc/EuroSys15_Borg_CN_Ying_201711.pdf)\n\n译者：难易 http://my.oschina.net/HardySimpson\n\n> **修订：Ying 2017-10-31 ~ 2017-11-09**\n\n# 摘要\n\nGoogle的Borg系统是一个集群管理器。它在多个万台机器规模的集群上运行着来自几千个不同的应用的几十万个作业。\n\nBorg通过准入控制、高效的任务装箱、超售、机器共享、以及进程级别的性能隔离，实现了高利用率。它为高可用应用提供了可以减少故障恢复时间的运行时特性，以及降低关联故障概率的调度策略。Borg提供了声明式的作业描述语言、名字服务集成、实时作业监控、分析和模拟系统行为的工具。这些简化了用户的使用。\n\n本文介绍了Borg系统架构和特性，重要的设计决策，对某些策略选择的定量分析，以及十年来的运营经验和教训。\n \n# 1. 简介\n\n我们内部称为Borg的集群管理系统，负责接收、调度、启动、重启和监控Google所有的应用。本文介绍它是如何实现的。\n\nBorg提供了三个主要的好处：（1）隐藏资源管理和故障处理细节，使用户可以专注于应用开发；（2）高可靠性和高可用性的运维，并支持应用程序也能够如此；（3）让我们可以在几万台机器上高效地运行负载。Borg不是第一个涉及这些问题的系统，但它是少有的运行在如此大规模、具有弹性、完善的系统之一。\n\n本文围绕这些主题来编写，总结了十多年来我们在生产环境运行Borg的一些定性观察。\n\n<img width=\"600\"  src=\"/img/borg-fig-01.png\" alt=\"图1. Borg的架构。图中只画出了数千个工作节点的很小一部分\"/>\n\n# 2. 用户视角\n\nBorg的用户是Google的开发人员以及运行Google应用和服务的系统管理员（站点可靠性工程师，SRE）。用户以作业（Job）的方式将他们的工作提交给Borg。作业由一个或多个任务（Task）组成，每个任务执行相同的二进制程序。每个作业只运行在一个Borg单元（Cell）里。Cell是一组机器的管理单元。下面的小节将介绍用户视角看到的Borg系统的主要特性。\n\n>SRE的职责比系统管理员多得多：他们是负责Google生产服务的工程师。他们也设计和实现包括自动化系统等软件，管理应用、服务基础设施和平台，以保证在Google如此大的规模下的高性能和高可靠性。\n\n## 2.1 工作负载\n\nBorg Cell主要运行两种异构的工作负载。第一种是应该“永不”停止的长期运行的服务，处理持续时间较短但对延迟敏感的请求（从几微秒到几百毫秒）。这些服务用于面向最终用户的产品，如Gmail、Google Docs、网页搜索，以及内部基础设施服务（例如Bigtable）。第二种是批处理作业，执行时间从几秒到几天，对短期性能波动不敏感。不同Cell中这两种负载的混合程度不同，取决于其主要租户（例如，有些Cell就以批处理作业为主）。工作负载也随时间变化：批处理作业不断提交或结束，而很多面向终端用户的服务表现出昼夜周期性的使用模式。Borg需要都处理好这些情况。\n\nBorg的代表性负载是一个公开的2011年5月整月的记录数据集[80]。这个数据集已经获得了广泛的分析[1, 26, 27, 57, 68]。\n\n最近几年，以Borg为基础构建了很多应用框架，包括我们内部的MapReduce系统[23]、FlumeJava[18]、Millwheel[3]和Pregel[59]。这些框架大多有一个控制器来提交Master Job，还有多个Worker Job。前两个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和它的后继者CFS、Bigtable[19]、以及Megastore[8]，都是运行在Borg上的。\n\n本文中，我们把高优先级的Borg作业称为为生产作业（prod），其它的则是非生产的（non-prod）。大多数长期服务是prod的，大部分批处理作业是non-prod的。一个典型Cell里，prod作业分配了约70%的总CPU资源，占总CPU使用量约60%；分配了约55%的总内存资源，占总内存使用量约85%。§5.5节表明分配量和使用量的差异是值得注意的。\n\n## 2.2 集群（Cluster）和单元（Cell）\n\n一个Cell里的机器属于同一个集群。集群由数据中心级的高性能光纤的组网来定义。一个集群位于数据中心的一栋建筑内，而一个数据中心有多栋建筑（注：这些关系会有少数例外情况）。一个集群通常包括一个大的Cell，还可能有一些小规模的测试用或其它特殊用途的Cell。我们尽力避免任何单点故障。\n\n排除测试用的Cell，中等规模的Cell约有一万台机器；有些Cell还要大得多。Cell中的机器从多个维度看都是异构的：大小（CPU、内存，硬盘，网络）、处理器类型、性能、以及是否有外网IP地址或SSD等。Borg负责决定任务在Cell中的哪些机器上执行、为其分配资源、安装程序及依赖、监控健康状态并在失败后重启，从而使用户几乎不必关心机器异构性。\n\n## 2.3 作业（Job）和任务（Task）\n\n一个Borg 作业的属性有：名字、拥有者和任务个数。作业可以有一些约束来强制其任务运行在有特定属性的机器上，比如处理器架构、操作系统版本、是否有外网IP地址等。约束可以是硬性的或者柔性的，柔性约束表示偏好，而非需求。一个作业可以推迟到前一个作业结束后再开始（ying：即依赖顺序）。一个作业只在一个Cell中运行。\n\n每个任务对应着一组Linux进程，运行在一台机器上的一个容器内[62]。绝大部分Borg的工作负载没有运行在虚拟机里，因为我们不想付出虚拟化的开销。而且，在Borg设计的那个时期，我们有很多处理器还不支持硬件虚拟化呢。\n\n任务也有一些属性，如资源需求量，在作业中的序号等。一个作业中的任务大多有相同的属性，但也可以被覆盖 —— 例如特定任务的命令行参数。各维度的资源（CPU核、内存、硬盘空间、硬盘访问速度、TCP端口（注：Borg负责管理一台机器上的可用端口并将其分配给任务）等。可以互相独立的以细粒度指定。我们不强制使用固定大小的资源桶或槽（见§5.4）。Borg运行的程序都是静态链接的，以减少对运行环境的依赖，这些程序组织成由二进制文件和数据文件构成的包，由Borg负责安装。\n\n用户通过向Borg发送RPC来控制作业。RPC大多是从命令行工具、其它作业、或我们的监控系统（§2.6）发出的。大多作业描述文件使用一种声明式配置语言BCL。BCL是GCL[12]的一个变种，即增加了一些Borg专有的关键字，而GCL会生成若干protobuf文件[67]。GCL还提供了匿名函数以支持计算，这样就能让应用根据环境调整自己的配置。有上万个超过一千行的BCL配置文件，系统中累计运行了千万行BCL。Borg的作业配置与Aurora的配置文件[6]相似。\n\n图2展示了作业和任务整个生命周期的状态变化。\n\n<img width=\"600\"  src=\"/img/borg-fig-02.png\" alt=\"图2. 作业和任务的状态图。用户可以触发提交，杀死和更新动作\"/>\n\n要想在运行时改变一个作业中若干或全部任务的属性，用户可以向Borg提交一个新的作业配置，并命令Borg将任务更新到新的配置。更新是轻量级的，非原子性的事务，在事务结束（提交）之前可以很容易地撤销。更新通常是滚动执行的，而且可以限制由更新导致的任务中断（被重新调度或抢占）的数量；超过限值的变更会被跳过。\n\n一些任务更新（如更新二进制程序）需要重启任务；另外一些更新（如增加资源需求或修改约束）可能使该任务不适合运行在当前机器上，导致停止并重新调度该任务；还有一些更新（如修改优先级）总是可以执行的，不需要重启或者移动任务。\n\n任务可以要求被Unix的`SIGKILL`立即杀死之前获得`SIGTERM`信号通知，这样它们还有时间清理资源、保存状态、结束当前请求、拒绝新请求。但如果抢占者设置了延迟限值，就可能来不及发通知。实践中，80%的情况下能发出通知信号。\n\n## 2.4 分配（Allocs）\n\nBorg的alloc（allocation的缩写）是一台机器上的预留资源，可以用来执行一个或多个任务；不管有没有被使用，这些资源都算分配出去了。Allocs可以给将来的任务预留资源，或在任务停止和重启的间隔保持资源，以及将不同作业的多个任务绑定在同一台机器上 —— 例如一个Web服务器实例和附加的将其URL日志从本机硬盘拷贝到分布式文件系统的保存日志任务。Alloc的资源像一台机器上的那样来管理；运行在同一个Alloc内的多个任务共享其资源。如果一个Alloc需要迁移到其它机器上，那么它的任务也要跟着重新调度。\n\n一个Alloc集，即一组在多台机器上预留了资源的Alloc，类似于一个作业。一旦创建了一个Alloc集，就可以向其提交若干作业。简便起见，我们用**任务**表示一个Alloc或者一个顶层任务（即运行在Alloc之外的任务），用**作业**表示一个普通作业或者Alloc集。\n\n## 2.5 优先级、配额和准入控制\n\n当出现超过系统容量的工作负载会产生什么情况？我们对此的解决方案是优先级和配额。\n\n每个作业都有一个小的正整数表示的优先级。高优先级的任务可以优先获取资源，甚至抢占（杀死）低优先级的任务。Borg为不同用途定义了不重叠的优先级区间，包括（优先级降序）：**监控、生产、批处理、尽力（即测试的或免费的）**。本文中，prod作业的优先级是监控和生产两个区间。\n\n虽然一个被抢占的任务通常会被重新调度到Cell的其它机器上，但级联抢占也可能发生：如果某个任务抢占了一个优先级稍低的任务，而后者又抢占了另一个优先级稍低的，如此往复。为避免这种情况，我们禁止`生产`区间的任务互相抢占。细粒度（ying：相比于区间的粗粒度）的优先级在其它场景下也很有用 —— 如MapReduce的Master 任务的优先级比其管理的Worker高一点，以提高其可靠性。\n\n优先级表示了Cell中运行或等待的作业之间的相对重要性。配额则用来决定准许哪个作业可以被调度。配额是指定优先级和时间段（典型是几个月）的一个资源向量（CPU，内存，硬盘等）。配额限制了用户的作业一次可以申请资源的最大数量（如：20TB内存，以prod优先级，从现在到7月末，在xx Cell内）。配额检查是准入控制的一部分，不是调度的：配额不足的作业提交时当即就会被拒绝。\n\n高优先级的配额比低优先级的成本要高。生产级的配额限于一个Cell的实际可用资源量，因此用户提交了不超过配额的生产级作业时，不考虑资源碎片和约束，可以预期这个作业一定会运行。尽管我们鼓励用户不要购买超过其需求的配额，但很多用户仍然超买了，这样他们就不用担心将来应用的用户量增长可能导致的配额短缺。我们的应对方案是对低优先级资源配额的超售：所有用户的0优先级配额是无限的，尽管这无法实现。低优先级的作业虽然被接收了，但可能由于资源不足而一直等待。\n\n配额分配是Borg之外的系统处理的，与我们的物理容量规划紧密相关。容量规划的结果反映在各数据中心的价格和可用配额上。只有在其要求的优先级有足够的配额，用户的作业才能被接收。采用配额使得主导资源公平性（DRF）[29, 35, 36, 66]这样的策略不是那么必要了。\n\nBorg的容量系统可以给某些用户一些特殊权限。例如，允许管理员删除或修改Cell里的任意作业，或者允许某个用户操作特定的内核特性或Borg行为（如对其作业禁用资源估计。§5.5）。\n\n## 2.6 命名和监控\n\n仅仅创建和放置任务是不够的：一个服务的客户端和其它系统需要能找到它们，即使该服务被重新放置到另一台机器之后。为实现该需求，Borg为每个任务创建了一个固定的BNS名字（BNS，Borg name Service），这个名字包括了Cell名，作业名和任务序号。Borg把任务的主机名和端口写入Chubby[14]的一个持久化高可用文件里，以BNS名字为文件名。这个文件被RPC用来发现任务的实际地址。BNS名字也是任务的DNS名字的基础部分，例如，cc Cell的ubar用户的jfoo 作业的第50个任务可以通过`50.jfoo.ubar.cc.borg.google.com`来访问。每当状态改变时，Borg还会把作业的大小和任务的健康信息写入到Chubby，这样负载均衡器就知道如何路由请求了。\n\n几乎每个任务都有一个内置的HTTP服务器，用来发布任务的健康信息和几千个性能指标（如RPC延时）。Borg监控这些健康检查的URL，重启那些没有立刻响应或返回HTTP错误码的任务。监控工具跟踪其它数据并显示在仪表盘上，当违反服务水平目标（SLO）时报警。\n\n用户可以使用一个称为Sigma的Web界面来检查他的所有作业的状态，针对某个Cell，或者深入某个作业及任务，检查其资源行为、详细日志、执行历史和最终结果。我们的应用产生大量的日志，它们都会被自动的滚动以避免耗尽硬盘空间。任务退出后，日志会保留一小段时间以帮助调试。如果一个作业没有运行起来，Borg会提供一个挂起原因的标注，以及建议如何修改作业的资源请求，以使其更适合Cell。我们发布了如何使资源请求更容易被调度的指南。\n\nBorg将所有的作业提交、任务事件、以及每个任务的详细资源使用都记录在Infrastore里。Infrastore是一个可扩展的只读数据存储，通过Dremel[61]提供了类似SQL的交互式接口。这些数据用以支持基于使用量的收费，调试作业和系统故障，以及长期容量规划。公开的Google集群负载数据集[80]也来自于这些数据。\n\n所有这些特性帮助用户理解和调试Borg及其作业的行为，并帮助我们的SRE实现每人管理超过上万台机器。\n\n# 3. Borg架构\n\n一个Borg的Cell包括一组机器，一个逻辑上集中的控制器，称为Borgmaster，以及运行在每台机器上的称为Borglet的代理进程（见图1）。Borg的组件都是用C++实现的。\n\n## 3.1 Borgmaster\n\nCell的Borgmaster由两个进程组成：Borgmaster主进程和一个单独的调度进程（§3.2）。Borgmaster主进程处理客户端的RPC，包括修改状态（如创建作业），或提供只读数据（如查找作业）。它还管理着系统中所有对象（机器、任务、Allocs等）的状态，与Borglet通信，并提供一个Web UI（作为Sigma的备份）。\n\nBorgmaster在逻辑上是单个进程，但实际上有5个副本。每个副本在内存维护着Cell状态的拷贝，该状态同时保存在由这些副本的本地硬盘组成的一个基于Paxos[55]的高可用、分布式存储上。每个Cell中仅有一个选举出来的Master，它同时作为Paxos的Leader和状态修改者，处理所有变更Cell状态的请求，例如提交作业或者结束某台机器上的一个任务。当Cell启动或者上一个Master故障时，新的Master会通过Paxos算法选举出来；新Master会获取一个Chubby锁，这样其它的系统就可以找到它。选举并转移到新的Master通常需要10秒，但在大的Cell里可能需要长达1分钟，因为需要重构一些内存状态。当一个副本从宕机恢复后，它会动态地从其它最新的Paxos副本中重新同步自己的状态。\n\n某个时刻的Borgmaster状态被称为检查点（Checkpoint），以定期快照加变更日志的形式保存在Paxos存储里。检查点有很多用途：如重建过去任意时刻的Borgmaster状态（例如，在接收一个触发了Borg故障的请求之前，这样就可以用来调试）；极端情况下可以手工修复检查点；构建一个持久的事件日志供日后查询；或用于离线仿真。\n\n一个高保真的Borgmaster模拟器，称为Fauxmaster，可以读取检查点文件。Fauxmaster的代码拷贝自线上的Borgmaster，还有对Borglet的存根接口。它接收RPC来改变状态，执行操作，例如“调度所有等待的任务”。我们用它来调试故障，像跟在线的Borgmaster那样与模拟器交互，用模拟的Borglet重放检查点文件里的真实交互。用户可以单步执行并观察系统过去确实发生了的状态变化。Fauxmaster也用于容量规划（可以接收多少个此类型的作业？），以及在实际更改Cell配置前做可行性检查（这个变更会导致关键作业异常退出吗？）\n\n## 3.2 调度\n\n当提交一个作业后，Borgmaster会把它保存在持久的Paxos存储上，并将这个作业的所有任务加入等待队列中。调度器异步地扫描等待队列，将任务分配到满足作业约束且有足够资源的机器上（调度是针对任务的，而非作业）。队列扫描从高优先级到低优先级，同优先级则以轮转的方式处理，以保证用户间的公平，并避免队首的大型作业阻塞队列。调度算法有两个部分：**可行性检查**，找到一组可以运行任务的机器；**评分**，从中选择一个合适的机器。\n\n在可行性检查阶段，调度器会找到一组满足任务约束且有足够可用资源的机器 —— 可用资源包括已经分配给低优先级任务但可以抢占的资源。在评分阶段，调度器确定每台可行机器的适宜性。评分考虑了用户特定的偏好，但主要取决于内置的标准：例如最小化被抢占任务的个数和优先级，选择已经有该任务安装包的机器，尽可能使任务分散在不同的供电和故障域，以及装箱（Packing）质量（在单台机器上混合高、低优先级的任务，以允许高优先级任务在负载尖峰扩容）等。\n\nBorg早期使用修改过的E-PVM[4]算法来评分。这个算法对异构的资源生成等效的成本值，放置任务的目标是使成本的变化量最小。在实践中，E-PVM会把负载分散到所有机器，为负载尖峰预留出资源 —— 这样的代价是增加了碎片，特别是对需要大部分机器的大型任务而言；我们有时称其为“最差匹配”。\n\n与之相反的是“最佳匹配”，把机器上的任务塞的越满越好。这就“空”出一些没有用户作业的机器（它们仍运行存储服务），这样放置大型任务就比较直接了。但是，如果用户或Borg错误估计了资源需求，紧实的装箱会对此造成（性能上的）惩罚。这种策略不利于有突发负载的应用，而且对申请少量CPU的批处理作业特别不友好，这些作业申请少量CPU本来是为了更容易被调度执行，并抓住机会使用空闲资源：20%的non-prod 任务申请少于0.1个CPU核。\n\n我们目前的评分模型是混合的，试图减少搁浅（Stranded）的资源（指一台机器因某些类型资源全部分配了，导致未能分配的其它类型资源）。对我们的负载而言，这个模型比“最佳匹配”提升了3%-5%的装箱效率（以[78]定义的方式评价）。\n\n如果评分后选中的一台机器仍没有足够的资源来运行新任务，Borg会抢占低优先级的任务，从最低优先级向上逐级抢占，直到资源足够运行该任务。被抢占的任务放回到调度器的等待队列里，而不是被迁移或休眠（注：例外情况是，为Google Compute Engine提供虚拟机的任务会被迁移）。\n\n任务的启动延迟（从提交作业到任务开始运行之间的时间段）是我们持续重点关注的。这个时间差别很大，中位数约25秒。安装软件包耗费了其中80%的时间：一个已知的瓶颈就是软件包写入时对本地硬盘的竞争。为了减少任务启动时间，调度器偏好将任务分配到已经有必需的软件包（程序及数据）的机器：大部分包是只读的，所以可以被共享和缓存（这是Borg调度器唯一的一种数据局部性支持）。另外，Borg通过树形和类似BT的协议并发地将软件包分发到多个机器上。\n\n此外，调度器采用多种技术使其能够扩展到数万台机器的Cell（§3.4）。\n\n## 3.3 Borglet\n\nBorglet是部署在Cell每台机器上的本机Borg代理。它负责启动和停止任务；重启失败的任务；通过OS内核设置来管理本地资源；滚动调试日志；把本机的状态上报给Borgmaster和其它监控系统。\n\nBorgmaster每过几秒就会轮询每个Borglet来获取机器的当前状态，并向其发送请求。这让Borgmaster能控制通信频率，省去了显式的流量控制机制，而且防止了恢复风暴[9]。\n\n选举出来的Master负责准备发送给Borglet的消息，并根据Borglet的响应更新Cell的状态。为了性能扩展性，每个Borgmaster副本会运行一个无状态的链接分片（Link Shard）来处理部分Borglet的通信；Borgmaster选举后重新计算链接的分片。为了保证容错（Resiliency），Borglet总是汇报全部状态，但是Link Shard只汇报变化值，从而聚合、压缩这些信息，减少Master更新的负担。\n\n如果某个Borglet几次没有响应轮询请求，该机器会被标记为宕机，其上运行的所有任务会被重新调度到其它机器。如果通讯恢复了，Borgmaster会让这个Borglet杀掉已经被重新调度出去的任务，以避免重复。即便无法与Borgmaster通信，Borglet仍会继续正常运行。所以即使所有的Borgmaster都出故障了，正在运行的任务和服务还会保持运行。\n\n## 3.4 扩展性\n\n\n我们还没有遇到Borg这种集中式架构的终极扩展上限。我们顺利突破了遇到的每个限制。一个单独的Borgmaster可以管理有数千台机器的Cell，有若干Cell每分钟有10000多个到达的任务。一个繁忙的Borgmaster使用10~14个CPU核以及50GB内存。我们用了几项技术来实现这种扩展性。\n\n早期版本的Borgmaster使用一个简单的，同步的循环来处理请求、调度任务，并与Borglet通信。为了处理更大的Cell，我们把调度器分离为一个单独的进程，这样它就可以与其它的Borgmaster功能并行执行，而这些其它的功能有多副本以容错。一个调度器副本使用一份缓存的Cell状态拷贝，重复执行下面的操作：从选举出来的Master获取状态改变（包括已分配的和等待中的工作）；更新自己的本地拷贝；执行一遍调度来分配任务；将分配信息发送给Master。Master会接受并应用这些分配，但如果分配不适合（例如，是基于过时的状态做出的），就会等待调度器的下一遍调度。这与Omega[69]使用的乐观并发控制思路很相似，而且我们最近还给Borg添加了对不同负载类型使用不同调度器的功能。\n\n为了改进响应时间，Borglet使用独立的线程分别进行通信和响应只读RPC。为了更好的性能，我们将这些请求划分给5个Borgmaster副本（§3.3）。总的效果是，UI响应时间的99%分位数小于1秒，而Borglet轮询间隔的95%分位数小于10秒。\n\n一些提高Borg调度器扩展性的方法如下：\n\n**缓存评分**：计算一台机器的可行性和评分是比较昂贵的，所以Borg会一直缓存评分，直到这台机器或者任务的属性发生了变化 —— 例如，这台机器上的某个任务结束了，一些属性修改了，或者任务的需求改变了。忽略小额的资源变化可以减少缓存失效。\n\n**任务等价类（Equivalence classes）**：一般来说，同一个Borg 作业的任务有相同的请求和约束。任务等价类即一组有相同需求的任务。Borg只对等价类中的一个任务进行可行性检查和评分，而不是对等待的每个任务去检查一遍所有机器的可行性并对可行的机器评分。\n\n**适度随机**：在一个大的Cell中，对所有机器都去计算一遍可行性和评分是很浪费的。调度器会随机地检查机器，直到找到足够多的可用机器来评分，然后从中挑选出最好的一个。这减少了任务启动和退出所需的评分次数及导致的缓存失效，加快了任务分配过程。适度随机有点类似Sparrow[65]的批量采样技术（ying：Sparrow的批量采样考虑的是机器上的任务队列长度），但Borg还处理了优先级、抢占、异构性和安装软件包的成本。\n\n在我们的实验中（§5），从零开始调度整个Cell的工作负载只要几百秒，但禁用上面几项技术的话，3天都不够。正常情况下，半秒之内就能完成一遍等待队列的在线调度。\n\n# 4. 可用性\n\n<img width=\"600\"  src=\"/img/borg-fig-03.png\" alt=\"图3. 不同类型任务的异常退出率及原因（包括抢占、资源不足、机器故障、机器关机、其它）。数据从2013-08-01开始。\" />\n\n大型系统里故障是很常见的[10, 11, 12]。图3展示了在15个样本Cell里任务异常退出的原因分类。在Borg上运行的应用需要能处理这种事件，可采用的技术有多副本、保存持久状态到分布式存储，或定期快照（如果可行的话）等。当然，我们也尽可能的缓解异常事件的影响。例如，Borg提供了：\n\n+ 自动重新调度异常退出的任务，如果必要，可以放置到另一台机器上去运行\n+ 把一个作业的任务分散到不同的可用域，例如机器、机架、供电域层次，以减少关联失效\n+ 在机器/OS升级等维护活动期间，限制任务受影响的速率，以及同一作业中同时中止的任务的个数\n+ 使用声明式的预期状态表示和幂等的变更操作，这样故障的客户端可以无损地重复提交故障期间漏掉的请求\n+ 对于失联的机器上的任务，限制重新调度的速率，因为大规模的机器故障和网络分区是很难区分的\n+ 回避造成崩溃的 <任务：机器> 组合\n+ 通过不断重新执行日志保存任务（§2.4），恢复已写入本地硬盘的关键中间数据，就算这个日志关联的Alloc已经终止或调度到其它机器上了。用户可以设置系统保持重复尝试多久，通常是几天时间。\n\nBorg的一个关键设计特性是：就算Borgmaster或者Borglet挂掉了，已经运行的任务还会继续运行下去。不过，保持Master正常运行仍然重要，因为在它退出后就无法提交新的作业，无法更新运行作业的状态，也不能重新调度故障机器上的任务。\n\nBorgmaster使用多项的技术支持其获得99.99%的实际可用性：多副本应对机器故障；准入控制应对超载；使用简单、底层的工具部署实例，以减少外部依赖。Cell彼此是独立的，减少了关联误操作和故障传播的机会。同时这也是我们不扩大Cell规模的主要考虑，而并非是扩展性的限制。\n\n# 5. 利用率\n\n\nBorg的一个主要目标就是有效地利用Google的大量机器（这是一大笔财务投资）：让效率提升几个百分点就能省下几百万美元。这一节讨论和评估了一些Borg使用的策略和技术。\n\n## 5.1 评估方法\n\n作业有部署约束，而且需要处理负载尖峰（尽管比较少见）；机器是异构的；我们回收服务型作业的资源来运行批处理作业。因此，我们需要一个比“平均利用率”更高级的指标来评估我们的策略选择。大量实验后，我们选择了Cell压缩量（Compaction）：给定一个负载，我们不断地移除机器，直到无法容纳该负载，从而得知所需最小的Cell规模。从空集群开始部署该负载并重复多次，以减少特殊情况的影响。终止条件是明确的，对比可以自动化，避免了生成和建模合成负载的陷阱[31]。[78]提供了评估技术的定量比较，其中的细节非常微妙。\n\n我们不可能在线上Cell进行实验，但是我们用了Fauxmaster来获得高保真的模拟效果，它使用了真实生产Cell和负载的数据，包括所有约束、实际限制、预留和使用量数据（§5.5）。实验数据提取自2014-10-01 14:00 PDT的Borg快照（其它快照也有类似的结论）。我们首先排除了特殊用途的、测试用的、小型的（少于5000台机器）的Cell，然后从剩下的Cell中选取了15个样本，抽样尽量关于Cell的大小均匀分布。\n\n为了保持机器异构性，在Cell压缩实验中，我们随机地移除机器。为了保持工作负载的异构性，我们保留了所有负载（除了那些绑定到特定机器的服务和存储任务，如Borglet）。我们把那些需要超过原Cell大小一半的作业的硬性限制改成柔性的，允许不超过0.2%的任务一直等待，这是针对一些特别“挑剔”的，只能放置在很少的特定机器上的任务；充分的实验表明结果是可复现的，波动很小。如果需要一个大型的Cell，就把原Cell复制几倍；如果需要更多的Cell，也是复制原Cell。\n\n每个实验都用不同的随机数种子对每个Cell重复了11次。图中，我们用误差线线来表示所需机器数量的最大和最小值，选择90%分位数作为结果 —— 平均值或中位数不能反映系统管理员所期望的充分把握。我们认为Cell压缩率是一个公平一致的比较调度策略的方法，而且可以直接转化为成本/收益的结果：更好的策略只需要更少的机器来运行相同的负载。\n\n我们的实验关注于即时的调度（装箱），而不是重放一段长时间的负载记录。部分原因是避免处理开放或闭合的队列模型[71, 79]的困难；部分是传统的完成时间不适用于长时间运行的服务；部分是这样可以提供明确的比较结果；部分是因为我们认为不会对结果产生显著影响；还有部分现实原因，我们发现一次实验使用了20万个Borg CPU核 —— 即便对Google而言，这个成本也不是个小数目。\n\n<img width=\"600\"  src=\"/img/borg-fig-04.png\" alt=\"图4. 压缩的效果。15个Cell在压缩后相比原规模的百分比累积分布（CDF）\"/>\n\n生产环境中，我们特意保留了一些裕度（Headroom），以应对负载增长、偶然的“黑天鹅”事件、负载尖峰、机器故障、硬件升级、以及大范围的局部故障（如供电母线短路）。图4显示了如果应用Cell压缩，实际的Cell可以压缩到多小。下文的图使用这些压缩后的大小作为基准值。\n\n## 5.2 Cell共享\n\n几乎所有的机器都同时运行prod和non-prod的任务：在共享的Cell里是98%的机器，在所有Borg管理的机器里是83%（有一些是Cell专用的）。\n\n![图5. 将prod和non-prod工作划分到不同的集群将需要更多的机器。两幅图中的百分比都是相对于单个集群所需机器的最少数量而言的](/img/borg-fig-05.png)\n\n鉴于很多外部组织将面向用户的作业和批处理作业分别运行在不同的集群上，我们检查一下如果我们也这么做会怎样。图5表明，在一个中等大小的Cell上，分开运行prod和non-prod的工作负载将需要增加20-30%的机器。这是因为prod的作业通常会保留一些资源来应对极少发生的负载尖峰，但大多情况下用不到这些资源。Borg回收了这些用不到的资源（§5.5），来运行non-prod的工作，所以总体我们只需要更少的机器。\n\n<img width=\"600\"  src=\"/img/borg-fig-06.png\" alt=\"图6. 将用户分开到不同的集群也会需要更多的机器\"/>\n\n大部分Borg Cell被数千个用户共享使用。图6展示了为什么要共享。测试中，如果一个用户消费了超过10TiB（或100TiB）的内存，我们就把这个用户的工作负载分离到另一个Cell中。我们目前的共享策略是有效的：即使100TiB的阈值，也需要2-16倍的Cell，增加20-150%的机器。将资源池化再次显著地节省了成本。\n\n但是，把很多不相关的用户和作业类型放置到同一台机器上可能会造成CPU冲突，我们是否需要更多的机器来补偿？为评估这一点，我们看一下固定机器类型和时钟频率，任务的CPI（Cycles per Instruction，执行每条指令平均所需时钟数，越大则程序执行越慢）在其它环境条件不同的影响下是如何变化的。在这种实验条件下，CPI是一个可比较的指标，而且可以表征性能冲突，因为2倍的CPI意味着一个CPU密集型程序需要2倍的执行时间。数据是在一周内从约12000个随机选择的prod任务获取的，使用了[83]中介绍的硬件剖析工具记录5分钟内的时钟数和指令数，并调整了采样的权重，使CPU时间的每秒都均等处理。结果并非直截了当的：\n\n（1）我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及这个机器上同时运行的任务个数（基本上独立）；每向一台机器上增加一个任务，就会使其它任务的CPI增加0.3%（从数据拟合的线性模型给出的预测值）；将一台机器的CPU使用量增加10%，就会增加2%弱的CPI。尽管相关性在统计意义上是显著的，也只是解释了CPI变化的5%。还有其它的因素，支配着CPI的变化，例如，应用程序固有的差别，以及特殊的干扰模式[24, 83]。\n\n（2）比较从共享Cell和只运行几种应用的少数专用Cell获取的CPI采样，我们看到共享Cell里的CPI平均值为1.58（σ=0.35，标准差），专用Cell的CPI平均值是1.53（σ=0.32） —— 也就是说，共享Cell的性能差3%。\n\n（3）为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差（或许对冲突更敏感的程序会被挪到专用Cell里面去），我们观察了Borglet的CPI。所有Cell的所有机器上都运行着Borglet。我们发现专用Cell里Borlet的CPI平均值是1.20（σ=0.29），而共享Cell里的CPI平均值为1.43（σ=0.45），表明在专用Cell上比在共享Cell上快1.19倍，不过这个结果忽略了专用Cell中的机器负载较轻的因素，即稍偏向专用Cell。\n\n这些实验表明了仓库级别的性能比较是复杂的，强化了[51]中的观察，但也说明共享并没有显著增加运行程序的开销。\n\n不过，就算从结果中最差的数据来看，共享还是有益的：比起CPU的降速，共享比各个划分方案都减少了机器，这一点更重要，而且共享的收益适用于包括内存和硬盘等各种资源，不仅仅是CPU。\n\n## 5.3 大型Cell\n\n![图7. 将Cell分成更小的规模将需要更多的机器](/img/borg-fig-07.png)\n\nGoogle建立了大型Cell，一是为了允许运行大型任务，二是为了减少资源碎片。为测试减少碎片的效果，我们把负载从一个Cell分散多个较小的Cell中 —— 首先将作业随机排列，然后轮流分配到各小的Cell中。图7确认了使用小型Cell需要增加相当多的机器。\n\n## 5.4 细粒度资源请求\n\nBorg用户请求的CPU单位是0.001个核，内存和硬盘的单位是字节。（一个核实际上是一个CPU的超线程，对不同机器类型的性能进行了标准化）。图8表明用户充分利用了细粒度：请求的CPU核和内存数量的“特别偏好值”是很少的，这些资源也没有明显的相关性。这与[68]里的分布非常相似，除了我们在90%分位数及以上的内存请求多一点之外。\n\n尽管IaaS普遍只提供一组固定尺寸的容器或虚拟机[7, 33]，但不符合我们的需求。为说明这一点，我们对prod的作业和Alloc（§2.4）申请的CPU核和内存分别向上取整到最接近的2的幂，形成固定大小的“桶”，最小的桶有0.5个核和1GiB内存。图9显示一般情况下这样需要增加30-50%的资源。上限的情形是，有的大型任务即便将Cell扩大为未压缩尺寸的四倍也无法容纳，只好为其分配一整台机器。下限是允许这些任务一直等待。（这比[37]给出的将近100%的额外开销要小一些，因为我们支持不止4种尺寸的桶，而且允许CPU和内存分别改变）。\n\n## 5.5 资源回收\n\n作业可以声明一个资源**限额（Limit）**，是每个任务能获得的资源上限。Borg会用它来检查用户是否有足够的配额来接受该作业，并检查某个机器是否有足够的可用资源来运行任务。因为Borg通常会杀死那些试图使用超出内存和硬盘申请值的任务，或者限制其CPU使用量不超过申请值，所以有的用户会为任务申请超过实际需要的资源，就像有的用户会购买超过实际需要的配额一样。另外，一些任务只是偶尔需要使用它们申请的所有资源（例如，在一天中的高峰期或者受到了拒绝服务攻击），但大多时候用不了。\n\n与其把那些分配出来但暂时没有被用到的资源浪费掉，我们估计了一个任务会用多少资源，然后把剩余的资源回收给那些可以忍受低质量资源的任务，例如批处理作业。这整个过程称为**资源再利用**。这个估值称为任务的资源**预留（Reservation）**。Borgmaster每隔几秒就会根据Borglet获取的细粒度资源使用量信息来计算一次预留值。最初的预留资源被设置为资源限额；在300秒之后，也就过了启动阶段，预留资源会缓慢的下降到实际使用量加上一个安全值。在实际使用量超过它时，预留值会迅速增加。\n\nBorg调度器使用资源限额来计算prod级任务（注：准确的说，是高优先级的、延迟敏感的任务，见§6.2）是否可以执行（§3.2），所以这些任务不依赖于回收的资源，也与资源超售无关；对于non-prod的任务，运行任务使用的资源在预留值之内，这样新任务就可以使用回收的资源。\n\n一台机器有可能因为预留（预测）错误而导致运行时资源不足 —— 即使所有的任务都在资源限额之内。如果这种情况发生了，我们会杀掉或者限制non-prod任务，但从来不对prod任务下手。\n\n图10表明，如果没有资源回收，将需要更多的机器。在一个中等规模的Cell中大概有20%的工作负载（§6.2）使用了回收的资源。\n\n图11可以看到更多的细节，其中有预留值、使用量与限额的比例。当资源紧张时，超出内存限额的任务首先会被抢占，不论优先级有多高，所以很少有任务超过内存限额。另一方面，CPU使用量是可以被轻易限制住的，所以短时的毛刺虽然会导致使用量超过预留值，但这没什么损害。\n\n图11表明了资源回收可能还过于保守：在预留值和实际使用量中间还有一大段差距。为了测试这一点，我们选择了一个线上Cell，（第一周作为参照基准，）第二周将其估计算法的参数调整为比较**激进**的设置，即把安全裕度留小一点；第三周采取的是介于激进和基准之间的**适度**策略，最后一周恢复到基准策略。\n\n![](/img/borg-fig-08-09-10-11.png)\n\n图12展示了结果。第二周的预留值明显更接近实际使用量，第三周稍大一点，最大的是第一周和第四周。和预期的一样，第二周和第三周的OOM比率轻微地增加了（注：第3周后期的异常情况与本次实验无关）。在评估了这个结果后，我们认为利大于弊，于是在其它Cell上也采用了**适度**策略的资源回收参数。\n\n![图12. 更激进的资源估计可以回收更多资源，但会稍增加OOM事件](/img/borg-fig-12.png)\n\n# 6. 隔离\n\n50%的机器运行了9个以上的任务；处于90%分位数的机器则有大约25个任务，4500个线程[83]。虽然在应用之间共享机器会增加利用率，但也需要一个比较好的机制来保证任务之间不产生干扰。这同时适用于安全和性能两个方面。\n\n## 6.1 安全隔离\n\n我们使用Linux的chroot作为同一台机器上不同任务之间的主要安全隔离机制。仅当某台机器有用户运行的任务时，为了允许远程调试，我们以前会自动分发（或废除）SSH秘钥，使用户可以访问这台机器。对大多数用户来说，现在被替换为`borgssh`命令，这个程序和Borglet协同构建一个SSH通道，连接到与任务运行在同一个chroot和cgroup下的Shell，这样限制就更加严格了。\n\nGoogle的AppEngine（GAE）[38]和Google Compute Engine（GCE）使用VM和安全沙箱技术运行外部的软件。我们把每个运行在KVM进程中的VM作为一个Borg任务来运行。\n\n## 6.2 性能隔离\n\n\n早期的Borglet使用了一种相对原始的资源隔离措施：事后检查内存、硬盘和CPU使用量，终止使用过多内存和硬盘的任务，或者降低使用过多CPU的任务的Linux CPU优先级。不过，一些粗暴的任务还是能很容易地影响到同台机器上其它任务的性能，于是有的用户就会多申请资源来让Borg减少与其共存的任务数量，降低了资源利用率。资源回收可以弥补一些损失，但不是全部，因为涉及到安全裕度。在极端情况下，用户会要求使用专属的机器或者Cell。\n\n目前，所有Borg任务都运行在基于Linux cgroup的资源容器[17, 58, 62]里。Borglet控制着这些容器的设置。有了OS内核的帮助，控制能力得到了改善。即使这样，偶尔还是有低级别的资源冲突发生（例如内存带宽或L3缓存污染），见[60, 83]。\n\n为了应对超载和超售，Borg任务有一个应用类别（appclass）。最重要的区分是延迟敏感（LS）的应用和本文中称为批处理（batch）的其它类别。LS任务包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS任务得到最高优待，可以暂时让批处理任务等待几秒种。\n\n第二个区分是：**可压缩**资源（例如CPU，硬盘I/O带宽），都是基于速率的，可以通过降低一个任务的服务质量而不是杀死它来回收；**不可压缩**资源（例如内存、硬盘空间），这些一般来说不杀掉任务是没办法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会开始杀死任务，从低优先级开始，直到能满足剩下的资源预留。如果机器用完了可压缩资源，Borglet会限制使用量（偏好LS任务），这样不用杀死任何任务也能处理短期负载尖峰。如果情况没有改善，Borgmaster会从这个机器上移除一个或多个任务。\n\nBorglet有一个用户态的控制循环，负责以下操作：为容器确定内存量，prod任务基于预测值，而non-prod任务则基于内存压力；处理来自内核的OOM事件；当任务试图分配超过其自身限额的内存时，或者超售的机器上确实耗尽内存时，都会杀死任务。Linux激进的文件缓存让我们的实现复杂得多，因为需要精确计算内存使用量。\n\n为了增强性能隔离，LS任务可以预留整个物理CPU核，以阻止别的LS任务来使用它们。批处理任务被允许运行在任何核上，但是相比LS任务，批处理任务只分配了很少的调度份额。Borglet动态地调整贪婪的LS任务的资源上限，以保证它们不会把批处理任务饿上几分钟，必要时有选择的使用CFS带宽控制[75]；仅用份额来表示是不够的，因为我们有多个优先级。\n\n<img width=\"600\"  src=\"/img/borg-fig-13.png\" alt=\"图13. 调度延迟与负载的关系。即一个就绪线程需要等待超过1 ms才能运行的比率，与机器繁忙程度的关系。每组数据条中，左侧是延迟敏感的任务，右侧是批处理任务。只有很少的比率需要等5 ms以上，超过10 ms就极少了。这是2013年12月从一个代表性的Cell中获取的一个月的数据；误差线是每天的波动\"/>\n\n同Leverich[56]一样，我们发现标准的Linux CPU调度器（CFS）需要大幅调整才能同时支持低延迟和高利用率。为了减少调度延迟：我们内部版本的CFS对每个`cgroup`都有单独的负载历史[16]；允许LS任务抢占批处理任务；当一个CPU有多个就绪的LS任务时，减少其调度数量。幸运的是，我们的大多应用使用每个线程处理一个请求的模型，这样就缓解了长期的负载不均衡。我们节俭地使用`cpusets`给有特别严格的延迟需求的应用分配CPU核。这些努力的一些效果展示在图13中。我们持续在这方面投入，增加感知NUMA、超线程、能耗（如[81]）的线程放置和CPU管理，改进Borglet的控制精确度。\n\n任务被允许在其上限之内消费资源。大部分任务还允许去使用超出上限的可压缩资源，例如CPU，以利用空闲资源。只有5%的LS任务禁止这么做，主要是为了改善可预测性；小于1%的批处理任务也禁止了。使用超量内存默认是被禁止的，因为这会增加任务被杀掉的概率，不过即使这样，10%的LS任务解除了这个限制，79%的批处理任务也解除了，因为这是MapReduce框架的默认设置。这补偿了资源回收（§5.5）的后果。批处理任务很乐意使用空闲的或回收的内存：大多情况下这样运作得很好，即使偶尔批处理任务会被急需资源的LS任务杀掉。\n\n# 7. 相关工作\n\n数十年来，资源调度已经在多种场景得到了研究，如广域高性能计算网格、工作站网络、和大规模服务器集群等。我们这里只关注最相关的大规模服务器集群这个场景。\n\n最近的一些研究分析了来自于Yahoo!、Google和Facebook的集群记录数据[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载固有的异构性和大规模带来的挑战。[69]包含了对集群管理器架构的分类。\n\nApache Mesos[45]将资源管理和任务放置功能拆分到一个集中资源管理器（类似于去掉调度器的Bormaster）和多种“框架”（比如Hadoop[41]和Spark[73]）之间，两者基于供应（Offer）机制交互。Borg则把这些功能集中在一起，使用基于请求的机制，而且扩展性相当好。DRF[29, 35, 36, 66]最初是为Mesos开发的；Borg则使用优先级和准入配额来替代。Mesos开发者已经宣布了他们扩展Mesos的雄心壮志：预测性资源分配和回收，以及解决[69]中发现的一些问题。\n\nYARN[76]是一个针对Hadoop的集群管理器。每个应用都有一个另外的管理器，与中央资源管理器谈判所需资源；这跟大约2008年开始Google的MapReduce作业已经使用的向Borg获取资源的模式如出一辙。YARN的资源管理器最近才支持容错。一个相关的开源项目是Hadoop Capacity Scheduler（基于容量的调度器）[42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近扩展支持了多种资源类型、优先级、抢占和高级准入控制[21]。Tetris（俄罗斯方块）研究原型[40]支持完成时间感知的作业装箱。\n\nFacebook的Tupperware[64]，是一个在集群中调度`cgroup`容器的类Borg系统；只有少量细节披露出来了，看起来它也提供了某种形式的资源回收功能。Twitter开源的Aurora[5]是一个类似Borg的，用于长期运行服务的调度器，运行与Mesos之上，其配置语言和状态迁移与Borg类似。\n\n微软的Autopilot[48]为其集群提供了“自动化的软件供应和部署；系统监控；以及采取修复行为处理软硬件故障”的功能。Borg生态系统提供了相似的特性，不过篇幅所限，不再深入讨论；作者Isaard概括了很多我们也赞成的最佳实践。\n\nQuincy[49]使用了一个网络流模型来提供公平性和数据局部性感知的调度，应用在几百个节点的集群的数据处理DAG上。Borg使用配额和优先级在用户间共享数据，可以扩展到上万台机器。Quincy可以直接处理执行图，而Borg需要在其上层另外构建。\n\nCosmos[44]聚焦在批处理上，强调了用户可以公平获取他们已经捐献给集群的资源。每个作业分别有一个管理器来获取资源；只有很少公开的细节。\n\n微软的Apollo系统[13]为每个短期批处理作业分别使用单独的调度器，以获得高吞吐量，其集群规模看起来与Borg的Cell相当。Apollo投机地执行低优先级后台任务来提升资源利用率，代价是有时有长达多日的队列延迟。Apollo的各节点都一个关于开始时间的预测矩阵，其行列分别为CPU和内存两个资源维度。调度器会综合开始时间、估计的启动开销、获取远程数据的开销来决定部署位置，并用一个随机延时来减少冲突。Borg使用的是中央调度器，基于之前的分配来决定部署位置，可以处理更多的资源维度，而且更关注高可用、长期运行的应用；Apollo也许能处理比Borg更高的任务到达率。\n\n阿里巴巴的伏羲（Fuxi）[84]支持数据分析的负载，从2009年就开始运行了。类似Borgmaster，一个集中的FuxiMaster（也做了容错多副本）从节点上获取可用资源的信息、接受应用的资源请求，然后匹配两者。伏羲的增量调度策略与Borg的任务等价类是相反的：伏羲用最新的可用资源匹配等待队列里的任务（ying：Borg是用任务匹配资源）。类似Mesos，伏羲允许定义“虚拟资源”类型。只有对合成工作负载的实验结果是公开的。\n\nOmega[69]支持多个并发的调度器，粗略相当于没有持久存储和链接分片的Borgmaster。Omega调度器使用乐观并发控制的方式去操作一个共享的集群预期的和观察的状态表示。集群状态存储在一个集中持久存储中，用单独的连接组件与Borglet同步。Omage架构设计为支持多种不同的工作负载，它们有自己特定的RPC接口、状态迁移和调度策略（例如长期运行的服务、多个框架批处理作业、如集群存储这样的基础服务、Google云平台上的虚拟机）。相反，Borg提供了一种通用方案，同样的RPC接口、状态迁移、调度策略，为支持多种不同的负载，其规模和复杂度逐渐增加，但目前来说可扩展性还不算一个问题（§3.4）。\n\nGoogle的开源项目Kubernetes系统[53]把应用放在Docker容器内[28]，再分发到多个机器上。它即可以运行在物理机上（像Borg那样），也可以运行在多个云供应商（比如Google Compute Engine，GCE）的主机上。Kubernetes正在快速开发中，它的很多开发者也参与开发了Borg。Google提供了一个托管的版本，称为Google Container Engine（GKE）[39]。我们会在下一节里面讨论Kubernetes从Borg中学到了哪些东西。\n\n在高性能计算社区对这个领域有长期的研究传统（如Maui, Moab, Platform LSF[2, 47, 50]）；但是这和Google Cell所面对的规模、工作负载、容错性是不同的。总体而言，为达到高用率，这些系统需要让任务在一个很长的队列中等待。\n\n虚拟化供应商，例如VMware[77]，和数据中心方案供应商，例如HP和IBM[46]提供了典型情况下可以扩展到一千台机器规模的集群管理解决方案。另外，一些研究小组的原型系统以多种方式提升了调度质量（如[25, 40, 72, 74]）。\n\n最后，正如我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]指出，失效预案、多租户、健康检查、准入控制，以及可重启性对实现单个运维人员管理更多的机器的目标是必要的。Borg的设计哲学也是这样的，而且支撑了我们的每个SRE管理数万台机器。\n\n>Borg从它的前任继承了很多东西，即我们内部的全局工作队列（Global Work Queue）系统，它最初是由Jeff Dean，Olcan Sercinoglu, 和Percy Liang开发的。\n>Conder[85]曾被广泛应用于收集空闲资源，其ClassAds机制[86]支持声明式的语句和自动属性匹配。\n\n# 8. 经验教训和未来工作\n\n在这一节中我们介绍了十多年来我们在生产环境运行Borg得到的定性的经验教训，然后介绍设计Kubernetes[53]是如何吸收这些经验的。\n\n## 8.1 教训\n\n我们从一些Borg作为反面警示的特性开始，然后介绍Kubernetes的替代方案。\n\n**将作业作为唯一的任务分组机制比较受限**\n\nBorg没有内置的方法将多个作业组成单个实体来管理，或将相关的服务实例关联起来（例如，测试通道和生产通道）。作为一个技巧，用户把他们的服务拓扑编码到作业的名字中，然后构建了更高层的管理工具来解析这些名字。这个问题的另外一面是，没办法指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级或改变作业的实例数。\n\n为了避免这些困难，Kubernetes不再使用作业这个概念，而是用标签（Label）来组织它的调度单元（Pod）。标签是任意的键值对，用户可以对系统的任何对象打上标签。Borg作业可以等效地通过对一组Pod打上 <作业：作业名> 这样的标签来实现。其它有用的分组方式也可以用标签来表示，例如服务、层级、发布类型（如，生产、就绪、测试）。Kubernetes用标签查询的方式来选取待操作的目标对象。这样就比固定的作业分组更加灵活。\n\n**同一台机器的任务共享一个IP太复杂了**\n\nBorg中，同一台机器上的所有任务都使用主机的同一个IP地址，共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；任务必须先声明它需要多少端口，而且需要支持启动时传入可用端口号；Borglet必须强制端口隔离；命名和RPC系统必须像IP一样处理端口（ying：最后这一点我认为是必要的）。\n\n多亏了Linux的namespace、虚拟机、IPv6和软件定义网络SDN的出现，Kubernetes可以用一种更用户友好的方式来消解这些复杂性：每个Pod和Service都自己的IP地址，允许开发者选择端口而不是让他们的软件支持基础设施的分配，这也消除了基础设施管理端口的复杂性。\n\n**给资深用户优化而忽略了初级用户**\n \n Borg提供了一大堆针对“资深用户”的特性，这样他们就可以仔细地调节他们程序的运行方式（BCL规范约有230个参数）：开始的目的是为了支持Google的大型资源用户，提升他们的效率会带来显著的效益。但不幸的是，这么复杂的API让初级用户用起来很复杂，而且限制了API的演化。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中决定合理的配置。由于应用支持容错，实验可以自由进行：即使自动化出了问题，也只是小麻烦，不会导致灾难。\n\n## 8.2 经验\n\n另一方面，有不少Borg的设计特性是非常有益的，而且经历了时间考验。\n\n**Alloc是有用的**\n\nBorg的Alloc抽象适用于广泛使用的保存日志模式（§2.4），另一个流行的模式是：一个简单的数据加载任务定期更新Web服务器使用的数据。Alloc和软件包机制允许这些辅助服务由不同的小组开发。Kubernetes对应于Alloc的概念是Pod，它是对一个或多个容器的资源封装，其中的容器共享Pod的资源，而且总是被调度到同一台机器上。Kubernetes使用Pod里的辅助容器来替代Alloc里面的任务，不过思路是一样的。\n\n**集群管理不只是任务管理**\n \n虽然Borg的主要角色是管理任务和机器的生命周期，但Borg上的应用还从其它的集群服务中收益良多，例如名字服务和负载均衡。Kubernetes用Service这个抽象概念来支持名字服务和负载均衡：Service有一个名字和用标签选出的多个Pod的动态集合。集群中的任何容器都可以通过Service名连接到该服务。幕后，Kubernetes自动将连接到该Service的负载分散到与其标签匹配的Pod之间，由于Pod挂掉后会被重新调度到其它机器上，Kubernetes还会跟踪这些Pod的位置。\n\n**自省是至关重要的**\n\n虽然Borg总体上是工作良好的，但出了问题后，定位根本原因是非常有挑战性的。Borg的一个关键设计选择是把所有的调试信息暴露给用户而不是隐藏起来：Borg有几千个用户，所以“自助”是调试的第一步。虽然一些用户的依赖项让我们难以废弃一些特性或修改内部策略，但这还是成功的，我们还没找到其它实际的替代方式。为管理大量的数据，我们提供了多个层次的UI和调试工具，这样用户就可以快速定位与其作业相关的异常事件，深入挖掘来自其应用和基础设施本身的详细事件和错误日志。\n\nKubernetes也计划引入Borg的大部分自省技术。和Kubernetes一起发布了很多工具，比如用于资源监控的cAdvisor[15]，它基于Elasticsearch/Kibana[30]和Fluentd[32]聚合日志。Master可以用来查询某个对象的状态快照。Kubernetes提供了一致机制，所有可以记录事件的组件（例如，被调度的Pod、出错的容器）都可以被客户端访问。\n\n**Master是分布式系统的核心**\n \nBorgmaster最初设计为一个单体的系统，随着时间发展，它演变成了一组服务生态系统的核心。用户作业管理的管理是由这些服务协同完成的。比如，我们把调度器和主要的UI（Sigma）分离成单独的进程，增加了一组服务，包括准入控制、纵向和横向扩展、任务重新装箱、周期性作业提交（cron）、工作流管理，用于离线查询的系统活动归档等。总体而言，这让我们能扩展工作负载和特性集合，但无需牺牲性能和可维护性。\n\nKubernetes的架构走的更远一些：它的核心是一个仅处理请求和操作底层状态目标的API服务。集群管理逻辑构建为一个小型的、可组合的微服务，作为API服务的客户端，如故障后仍维持Pod副本个数在期望值的副本管理器，以及管理机器生命周期的节点管理器。\n\n## 8.3 总结\n\n在过去十年间，所有几乎所有的Google集群负载都迁移到了Borg上。我们仍在持续改进它，并把经验应用到了Kubernetes上。\n\n# 致谢\n\n这篇文章的作者负责撰写文章，并完成了评估实验。几十位设计、实现和维护Borg组件和生态系统的工程师才是它成功的关键。我们在这里列出直接参与设计、实现和维护Borgmaster及Borglet的人员。如果有遗漏，我们深表歉意。\n\n早期版本的Borgmaster设计和实现人员有：Jeremy Dion和Mark Vandevoorde，以及Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu 和 Monika Henzinger。早期版本的Borglet主要是由Paul Menage设计和实现的（ying：见[62]）。\n\n后续的参与者包括：Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, Onufry Wojtaszczyk, Patrick Johnson, Pedro Valenzuela, Piotr Witusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, Tomasz Wozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.\n\nBorg SRE团队也是非常重要的，包括：Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, 和 Viraj Alankar。Borg配置语言（BCL）和`borgcfg`工具最初是Marcel van Lohuizen 和 Robert Griesemer开发的。\n\n>我们不小心漏掉了 Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, 和 Pavanish Nirula。\n\n谢谢我们的审稿人（尤其是Eric Brewer, Malte Schwarzkopf 和 Tom Rodeheffer），以及我们的导师Christos Kozyrakis，对这篇论文的反馈。\n\n# 勘误\n\n2015-04-23\n\n定稿后，我们发现了若干无意的疏漏和歧义。（ying：译文已将勘误内容放置到对应章节。补充的两条参考文献序号有冲突，放在了列表之后，并继续编号为85，86）\n\n# 参考文献\n[1] O. A. Abdul-Rahman and K. Aida. **Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon.**In Proc. IEEE Int'l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.\n[2] Adaptive Computing Enterprises Inc., Provo, UT. **Maui Scheduler Administrator's Guide**, 3.2 edition, 2011.\n[3] T. Akidau, A. Balikov, K. Bekiroğlu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. **MillWheel: fault-tolerant stream processing at internet scale** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.\n[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. **An opportunity cost approach for job assignment in a scalable computing cluster** IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.\n[5] **Apache Aurora**. http://aurora.incubator.apache.org/, 2014.\n[6] **Aurora Configuration Tutorial**. https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/, 2014.\n[7] AWS. **Amazon Web Services VM Instances**. http://aws.amazon.com/ec2/instance-types/, 2014.\n[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. **Megastore: Providing scalable, highly available storage for interactive services** In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.\n[9] M. Baker and J. Ousterhout. **Availability in the Sprite distributed file system** Operating Systems Review,25(2):95–98, Apr. 1991.\n[10] L. A. Barroso, J. Clidaras, and U. Hölzle. **The datacenter as a computer: an introduction to the design of warehouse-scale machines** Morgan Claypool Publishers, 2nd edition, 2013.\n[11] L. A. Barroso, J. Dean, and U. Holzle. **Web search for a planet: the Google cluster architecture** In IEEE Micro, pages 22–28, 2003.\n[12] I. Bokharouss. **GCL Viewer: a study in improving the understanding of GCL programs** Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.\n[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. **Apollo: scalable and coordinated scheduling for cloud-scale computing** In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.\n[14] M. Burrows. **The Chubby lock service for loosely-coupled distributed systems** In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.\n[15] **cAdvisor**. https://github.com/google/cadvisor, 2014\n[16] **CFS per-entity load patches**. http://lwn.net/Articles/531853, 2013.\n[17] **cgroups**. http://en.wikipedia.org/wiki/Cgroups, 2014.\n[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. **FlumeJava: easy, efficient data-parallel pipelines** In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.\n[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. **Bigtable: a distributed storage system for structured data** ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.\n[20] Y. Chen, S. Alspaugh, and R. H. Katz. **Design insights for MapReduce from diverse production workloads** Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.\n[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. **Reservation-based scheduling: if you're late don't blame us!**In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.\n[22] J. Dean and L. A. Barroso. **The tail at scale** Communications of the ACM, 56(2):74–80, Feb. 2012.\n[23] J. Dean and S. Ghemawat. **MapReduce: simplified data processing on large clusters** Communications of the ACM, 51(1):107–113, 2008.\n[24] C. Delimitrou and C. Kozyrakis. **Paragon: QoS-aware scheduling for heterogeneous datacenters** In Proc. Int'l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.\n[25] C. Delimitrou and C. Kozyrakis. **Quasar: resource-efficient and QoS-aware cluster management** In Proc. Int'l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.\n[26] S. Di, D. Kondo, and W. Cirne. **Characterization and comparison of cloud versus Grid workloads** In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.\n[27] S. Di, D. Kondo, and C. Franck. **Characterizing cloud applications on a Google data center** In Proc. Int'l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.\n[28] **Docker Project**. https://www.docker.io/, 2014.\n[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. **No justified complaints: on fair sharing of multiple resources** In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.\n[30] **ElasticSearch**. http://www.elasticsearch.org, 2014.\n[31] D. G. Feitelson. **Workload Modeling for Computer Systems Performance Evaluation** Cambridge University Press, 2014.\n[32] **Fluentd**. http://www.fluentd.org/, 2014.\n[33] **GCE. Google Compute Engine**. http://cloud.google.com/products/compute-engine/, 2014.\n[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. **The Google File System** In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.\n[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. **Dominant Resource Fairness: fair allocation of multiple resource types** In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.\n[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. **Choosy: max-min fair sharing for datacenter jobs with constraints** In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.\n[37] D. Gmach, J. Rolia, and L. Cherkasova. **Selling T-shirts and time shares in the cloud** In Proc. IEEE/ACM Int'l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.\n[38] **Google App Engine**. http://cloud.google.com/AppEngine, 2014.\n[39] **Google Container Engine (GKE)**. https://cloud.google.com/container-engine/, 2015.\n[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. **Multi-resource packing for cluster schedulers** In Proc. ACM SIGCOMM, Aug. 2014.\n[41] **Apache Hadoop Project**. http://hadoop.apache.org/, 2009.\n[42] **Hadoop MapReduce Next Generation – Capacity Scheduler**. [http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html](http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html), 2013.\n[43] J. Hamilton. **On designing and deploying internet-scale services**. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.\n[44] P. Helland. **Cosmos: big data and big challenges**. [http://research.microsoft.com/en-us/events/fs2011/ helland_cosmos_big_data_and_big_challenges.pdf](http://research.microsoft.com/en-us/events/fs2011/helland_cosmos_big_data_and_big_challenges.pdf), 2011.\n[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. **Mesos: a platform for fine-grained resource sharing in the data center**. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.\n[46] **IBM Platform Computing**. [http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/ index.html](http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/index.html).\n[47] S. Iqbal, R. Gupta, and Y.-C. Fang. **Planning considerations for job scheduling in HPC clusters** Dell Power Solutions, Feb. 2005.\n[48] M. Isaard. **Autopilot: Automatic data center management** ACM SIGOPS Operating Systems Review, 41(2), 2007.\n[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. **Quincy: fair scheduling for distributed computing clusters** In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.\n[50] D. B. Jackson, Q. Snell, and M. J. **Clement. Core algorithms of the Maui scheduler** In Proc. Int'l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.\n[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. **Measuring interference between live datacenter applications** In Proc. Int'l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.\n[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. **An analysis of traces from a production MapReduce cluster** In Proc. IEEE/ACM Int'l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.\n[53] **Kubernetes**. http://kubernetes.io, Aug. 2014.\n[54] **Kernel Based Virtual Machine**. http://www.linux-kvm.org.\n[55] L. Lamport. **The part-time parliament** ACM Trans. on Computer Systems, 16(2):133–169, May 1998.\n[56] J. Leverich and C. Kozyrakis. **Reconciling high server utilization and sub-millisecond quality-of-service** In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.\n[57] Z. Liu and S. Cho. **Characterizing machines and workloads on a Google cluster** In Proc. Int'l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.\n[58] **Google LMCTFY project (let me contain that for you)**. http://github.com/google/lmctfy, 2014.\n[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. **Pregel: a system for large-scale graph processing** In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.\n[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. **Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations** In Proc. Int'l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.\n[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. **Dremel: interactive analysis of web-scale datasets** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.\n[62] P. Menage. **Linux control groups**. http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.\n[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. **Towards characterizing cloud backend workloads: insights from Google compute clusters** ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.\n[64] A. Narayanan. **Tupperware: containerized deployment at Facebook**. http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook, June 2014.\n[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. **Sparrow: distributed, low latency scheduling** In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.\n[66] D. C. Parkes, A. D. Procaccia, and N. Shah. **Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities** In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.\n[67] **Protocol buffers**. https://developers.google.com/protocol-buffers/, and https://github.com/google/protobuf/, 2014.\n[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. **Heterogeneity and dynamicity of clouds at scale: Google trace analysis** In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. **Omega: flexible, scalable schedulers for large compute clusters** In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. **Modeling and synthesizing task placement constraints in Google compute clusters** In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.\n[71] E. Shmueli and D. G. Feitelson. **On simulation and design of parallel-systems schedulers: are we doing the right thing?** IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.\n[72] A. Singh, M. Korupolu, and D. Mohapatra. **Server-storage virtualization: integration and load balancing in data centers** In Proc. Int'l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.\n[73] **Apache Spark Project**. http://spark.apache.org/, 2014.\n[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. **Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds** In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n[75] P. Turner, B. Rao, and N. Rao. **CPU bandwidth control for CFS** In Proc. Linux Symposium, pages 245–254, July 2010.\n[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O'Malley, S. Radia, B. Reed, and E. Baldeschwieler. **Apache Hadoop YARN: Yet Another Resource Negotiator** In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.\n[77] **VMware VCloud Suite**. http://www.vmware.com/products/vcloud-suite/.\n[78] A. Verma, M. Korupolu, and J. Wilkes. **Evaluating job packing in warehouse-scale computing** In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.\n[79] W. Whitt. **Open and closed models for networks of queues** AT&T Bell Labs Technical Journal, 63(9), Nov. 1984.\n[80] J. Wilkes. **More Google cluster data**. http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html, Nov. 2011.\n[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. **HaPPy: Hyperthread-aware power profiling dynamically** In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.\n[82] Q. Zhang, J. Hellerstein, and R. Boutaba. **Characterizing task usage shapes in Google's compute clusters** In Proc. Int'l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.\n[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. **CPI2: CPU performance isolation for shared compute clusters** In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. **Fuxi: a fault-tolerant resource management and job scheduling system at internet scale** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.\n[85] Michael Litzkow, Miron Livny, and Matt Mutka. **Condor - A Hunter of Idle Workstations** In Proc. Int'l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.\n[86] Rajesh Raman, Miron Livny, and Marvin Solomon. **Matchmaking: Distributed Resource Management for High Throughput Computing** In Proc. Int'l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.\t\n ","source":"_posts/eurosys15-borg-cn.md","raw":"title: 【译文修订】使用Borg在Google管理大规模集群\ncategory: cloud\ndate: 2017-10-31\ntags:\n\n---\n\n发表于EuroSys 2015的 ***Large-scale cluster management at Google with Borg*** 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。\n\n<!--more-->\n\n---\n\n# Large-scale cl uster management at Google with Borg\n# 使用Borg在Google管理大规模集群\n\n作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes\n\nEuroSys'15, http://dx.doi.org/10.1145/2741948.2741964\n\nhttp://research.google.com/pubs/pub43438.html 或 [下载转存的英文全文PDF](https://ying-zhang.github.io/doc/EuroSys15_Borg.pdf)\n\n[**中文译文全文PDF**](https://ying-zhang.github.io/doc/EuroSys15_Borg_CN_Ying_201711.pdf)\n\n译者：难易 http://my.oschina.net/HardySimpson\n\n> **修订：Ying 2017-10-31 ~ 2017-11-09**\n\n# 摘要\n\nGoogle的Borg系统是一个集群管理器。它在多个万台机器规模的集群上运行着来自几千个不同的应用的几十万个作业。\n\nBorg通过准入控制、高效的任务装箱、超售、机器共享、以及进程级别的性能隔离，实现了高利用率。它为高可用应用提供了可以减少故障恢复时间的运行时特性，以及降低关联故障概率的调度策略。Borg提供了声明式的作业描述语言、名字服务集成、实时作业监控、分析和模拟系统行为的工具。这些简化了用户的使用。\n\n本文介绍了Borg系统架构和特性，重要的设计决策，对某些策略选择的定量分析，以及十年来的运营经验和教训。\n \n# 1. 简介\n\n我们内部称为Borg的集群管理系统，负责接收、调度、启动、重启和监控Google所有的应用。本文介绍它是如何实现的。\n\nBorg提供了三个主要的好处：（1）隐藏资源管理和故障处理细节，使用户可以专注于应用开发；（2）高可靠性和高可用性的运维，并支持应用程序也能够如此；（3）让我们可以在几万台机器上高效地运行负载。Borg不是第一个涉及这些问题的系统，但它是少有的运行在如此大规模、具有弹性、完善的系统之一。\n\n本文围绕这些主题来编写，总结了十多年来我们在生产环境运行Borg的一些定性观察。\n\n<img width=\"600\"  src=\"/img/borg-fig-01.png\" alt=\"图1. Borg的架构。图中只画出了数千个工作节点的很小一部分\"/>\n\n# 2. 用户视角\n\nBorg的用户是Google的开发人员以及运行Google应用和服务的系统管理员（站点可靠性工程师，SRE）。用户以作业（Job）的方式将他们的工作提交给Borg。作业由一个或多个任务（Task）组成，每个任务执行相同的二进制程序。每个作业只运行在一个Borg单元（Cell）里。Cell是一组机器的管理单元。下面的小节将介绍用户视角看到的Borg系统的主要特性。\n\n>SRE的职责比系统管理员多得多：他们是负责Google生产服务的工程师。他们也设计和实现包括自动化系统等软件，管理应用、服务基础设施和平台，以保证在Google如此大的规模下的高性能和高可靠性。\n\n## 2.1 工作负载\n\nBorg Cell主要运行两种异构的工作负载。第一种是应该“永不”停止的长期运行的服务，处理持续时间较短但对延迟敏感的请求（从几微秒到几百毫秒）。这些服务用于面向最终用户的产品，如Gmail、Google Docs、网页搜索，以及内部基础设施服务（例如Bigtable）。第二种是批处理作业，执行时间从几秒到几天，对短期性能波动不敏感。不同Cell中这两种负载的混合程度不同，取决于其主要租户（例如，有些Cell就以批处理作业为主）。工作负载也随时间变化：批处理作业不断提交或结束，而很多面向终端用户的服务表现出昼夜周期性的使用模式。Borg需要都处理好这些情况。\n\nBorg的代表性负载是一个公开的2011年5月整月的记录数据集[80]。这个数据集已经获得了广泛的分析[1, 26, 27, 57, 68]。\n\n最近几年，以Borg为基础构建了很多应用框架，包括我们内部的MapReduce系统[23]、FlumeJava[18]、Millwheel[3]和Pregel[59]。这些框架大多有一个控制器来提交Master Job，还有多个Worker Job。前两个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和它的后继者CFS、Bigtable[19]、以及Megastore[8]，都是运行在Borg上的。\n\n本文中，我们把高优先级的Borg作业称为为生产作业（prod），其它的则是非生产的（non-prod）。大多数长期服务是prod的，大部分批处理作业是non-prod的。一个典型Cell里，prod作业分配了约70%的总CPU资源，占总CPU使用量约60%；分配了约55%的总内存资源，占总内存使用量约85%。§5.5节表明分配量和使用量的差异是值得注意的。\n\n## 2.2 集群（Cluster）和单元（Cell）\n\n一个Cell里的机器属于同一个集群。集群由数据中心级的高性能光纤的组网来定义。一个集群位于数据中心的一栋建筑内，而一个数据中心有多栋建筑（注：这些关系会有少数例外情况）。一个集群通常包括一个大的Cell，还可能有一些小规模的测试用或其它特殊用途的Cell。我们尽力避免任何单点故障。\n\n排除测试用的Cell，中等规模的Cell约有一万台机器；有些Cell还要大得多。Cell中的机器从多个维度看都是异构的：大小（CPU、内存，硬盘，网络）、处理器类型、性能、以及是否有外网IP地址或SSD等。Borg负责决定任务在Cell中的哪些机器上执行、为其分配资源、安装程序及依赖、监控健康状态并在失败后重启，从而使用户几乎不必关心机器异构性。\n\n## 2.3 作业（Job）和任务（Task）\n\n一个Borg 作业的属性有：名字、拥有者和任务个数。作业可以有一些约束来强制其任务运行在有特定属性的机器上，比如处理器架构、操作系统版本、是否有外网IP地址等。约束可以是硬性的或者柔性的，柔性约束表示偏好，而非需求。一个作业可以推迟到前一个作业结束后再开始（ying：即依赖顺序）。一个作业只在一个Cell中运行。\n\n每个任务对应着一组Linux进程，运行在一台机器上的一个容器内[62]。绝大部分Borg的工作负载没有运行在虚拟机里，因为我们不想付出虚拟化的开销。而且，在Borg设计的那个时期，我们有很多处理器还不支持硬件虚拟化呢。\n\n任务也有一些属性，如资源需求量，在作业中的序号等。一个作业中的任务大多有相同的属性，但也可以被覆盖 —— 例如特定任务的命令行参数。各维度的资源（CPU核、内存、硬盘空间、硬盘访问速度、TCP端口（注：Borg负责管理一台机器上的可用端口并将其分配给任务）等。可以互相独立的以细粒度指定。我们不强制使用固定大小的资源桶或槽（见§5.4）。Borg运行的程序都是静态链接的，以减少对运行环境的依赖，这些程序组织成由二进制文件和数据文件构成的包，由Borg负责安装。\n\n用户通过向Borg发送RPC来控制作业。RPC大多是从命令行工具、其它作业、或我们的监控系统（§2.6）发出的。大多作业描述文件使用一种声明式配置语言BCL。BCL是GCL[12]的一个变种，即增加了一些Borg专有的关键字，而GCL会生成若干protobuf文件[67]。GCL还提供了匿名函数以支持计算，这样就能让应用根据环境调整自己的配置。有上万个超过一千行的BCL配置文件，系统中累计运行了千万行BCL。Borg的作业配置与Aurora的配置文件[6]相似。\n\n图2展示了作业和任务整个生命周期的状态变化。\n\n<img width=\"600\"  src=\"/img/borg-fig-02.png\" alt=\"图2. 作业和任务的状态图。用户可以触发提交，杀死和更新动作\"/>\n\n要想在运行时改变一个作业中若干或全部任务的属性，用户可以向Borg提交一个新的作业配置，并命令Borg将任务更新到新的配置。更新是轻量级的，非原子性的事务，在事务结束（提交）之前可以很容易地撤销。更新通常是滚动执行的，而且可以限制由更新导致的任务中断（被重新调度或抢占）的数量；超过限值的变更会被跳过。\n\n一些任务更新（如更新二进制程序）需要重启任务；另外一些更新（如增加资源需求或修改约束）可能使该任务不适合运行在当前机器上，导致停止并重新调度该任务；还有一些更新（如修改优先级）总是可以执行的，不需要重启或者移动任务。\n\n任务可以要求被Unix的`SIGKILL`立即杀死之前获得`SIGTERM`信号通知，这样它们还有时间清理资源、保存状态、结束当前请求、拒绝新请求。但如果抢占者设置了延迟限值，就可能来不及发通知。实践中，80%的情况下能发出通知信号。\n\n## 2.4 分配（Allocs）\n\nBorg的alloc（allocation的缩写）是一台机器上的预留资源，可以用来执行一个或多个任务；不管有没有被使用，这些资源都算分配出去了。Allocs可以给将来的任务预留资源，或在任务停止和重启的间隔保持资源，以及将不同作业的多个任务绑定在同一台机器上 —— 例如一个Web服务器实例和附加的将其URL日志从本机硬盘拷贝到分布式文件系统的保存日志任务。Alloc的资源像一台机器上的那样来管理；运行在同一个Alloc内的多个任务共享其资源。如果一个Alloc需要迁移到其它机器上，那么它的任务也要跟着重新调度。\n\n一个Alloc集，即一组在多台机器上预留了资源的Alloc，类似于一个作业。一旦创建了一个Alloc集，就可以向其提交若干作业。简便起见，我们用**任务**表示一个Alloc或者一个顶层任务（即运行在Alloc之外的任务），用**作业**表示一个普通作业或者Alloc集。\n\n## 2.5 优先级、配额和准入控制\n\n当出现超过系统容量的工作负载会产生什么情况？我们对此的解决方案是优先级和配额。\n\n每个作业都有一个小的正整数表示的优先级。高优先级的任务可以优先获取资源，甚至抢占（杀死）低优先级的任务。Borg为不同用途定义了不重叠的优先级区间，包括（优先级降序）：**监控、生产、批处理、尽力（即测试的或免费的）**。本文中，prod作业的优先级是监控和生产两个区间。\n\n虽然一个被抢占的任务通常会被重新调度到Cell的其它机器上，但级联抢占也可能发生：如果某个任务抢占了一个优先级稍低的任务，而后者又抢占了另一个优先级稍低的，如此往复。为避免这种情况，我们禁止`生产`区间的任务互相抢占。细粒度（ying：相比于区间的粗粒度）的优先级在其它场景下也很有用 —— 如MapReduce的Master 任务的优先级比其管理的Worker高一点，以提高其可靠性。\n\n优先级表示了Cell中运行或等待的作业之间的相对重要性。配额则用来决定准许哪个作业可以被调度。配额是指定优先级和时间段（典型是几个月）的一个资源向量（CPU，内存，硬盘等）。配额限制了用户的作业一次可以申请资源的最大数量（如：20TB内存，以prod优先级，从现在到7月末，在xx Cell内）。配额检查是准入控制的一部分，不是调度的：配额不足的作业提交时当即就会被拒绝。\n\n高优先级的配额比低优先级的成本要高。生产级的配额限于一个Cell的实际可用资源量，因此用户提交了不超过配额的生产级作业时，不考虑资源碎片和约束，可以预期这个作业一定会运行。尽管我们鼓励用户不要购买超过其需求的配额，但很多用户仍然超买了，这样他们就不用担心将来应用的用户量增长可能导致的配额短缺。我们的应对方案是对低优先级资源配额的超售：所有用户的0优先级配额是无限的，尽管这无法实现。低优先级的作业虽然被接收了，但可能由于资源不足而一直等待。\n\n配额分配是Borg之外的系统处理的，与我们的物理容量规划紧密相关。容量规划的结果反映在各数据中心的价格和可用配额上。只有在其要求的优先级有足够的配额，用户的作业才能被接收。采用配额使得主导资源公平性（DRF）[29, 35, 36, 66]这样的策略不是那么必要了。\n\nBorg的容量系统可以给某些用户一些特殊权限。例如，允许管理员删除或修改Cell里的任意作业，或者允许某个用户操作特定的内核特性或Borg行为（如对其作业禁用资源估计。§5.5）。\n\n## 2.6 命名和监控\n\n仅仅创建和放置任务是不够的：一个服务的客户端和其它系统需要能找到它们，即使该服务被重新放置到另一台机器之后。为实现该需求，Borg为每个任务创建了一个固定的BNS名字（BNS，Borg name Service），这个名字包括了Cell名，作业名和任务序号。Borg把任务的主机名和端口写入Chubby[14]的一个持久化高可用文件里，以BNS名字为文件名。这个文件被RPC用来发现任务的实际地址。BNS名字也是任务的DNS名字的基础部分，例如，cc Cell的ubar用户的jfoo 作业的第50个任务可以通过`50.jfoo.ubar.cc.borg.google.com`来访问。每当状态改变时，Borg还会把作业的大小和任务的健康信息写入到Chubby，这样负载均衡器就知道如何路由请求了。\n\n几乎每个任务都有一个内置的HTTP服务器，用来发布任务的健康信息和几千个性能指标（如RPC延时）。Borg监控这些健康检查的URL，重启那些没有立刻响应或返回HTTP错误码的任务。监控工具跟踪其它数据并显示在仪表盘上，当违反服务水平目标（SLO）时报警。\n\n用户可以使用一个称为Sigma的Web界面来检查他的所有作业的状态，针对某个Cell，或者深入某个作业及任务，检查其资源行为、详细日志、执行历史和最终结果。我们的应用产生大量的日志，它们都会被自动的滚动以避免耗尽硬盘空间。任务退出后，日志会保留一小段时间以帮助调试。如果一个作业没有运行起来，Borg会提供一个挂起原因的标注，以及建议如何修改作业的资源请求，以使其更适合Cell。我们发布了如何使资源请求更容易被调度的指南。\n\nBorg将所有的作业提交、任务事件、以及每个任务的详细资源使用都记录在Infrastore里。Infrastore是一个可扩展的只读数据存储，通过Dremel[61]提供了类似SQL的交互式接口。这些数据用以支持基于使用量的收费，调试作业和系统故障，以及长期容量规划。公开的Google集群负载数据集[80]也来自于这些数据。\n\n所有这些特性帮助用户理解和调试Borg及其作业的行为，并帮助我们的SRE实现每人管理超过上万台机器。\n\n# 3. Borg架构\n\n一个Borg的Cell包括一组机器，一个逻辑上集中的控制器，称为Borgmaster，以及运行在每台机器上的称为Borglet的代理进程（见图1）。Borg的组件都是用C++实现的。\n\n## 3.1 Borgmaster\n\nCell的Borgmaster由两个进程组成：Borgmaster主进程和一个单独的调度进程（§3.2）。Borgmaster主进程处理客户端的RPC，包括修改状态（如创建作业），或提供只读数据（如查找作业）。它还管理着系统中所有对象（机器、任务、Allocs等）的状态，与Borglet通信，并提供一个Web UI（作为Sigma的备份）。\n\nBorgmaster在逻辑上是单个进程，但实际上有5个副本。每个副本在内存维护着Cell状态的拷贝，该状态同时保存在由这些副本的本地硬盘组成的一个基于Paxos[55]的高可用、分布式存储上。每个Cell中仅有一个选举出来的Master，它同时作为Paxos的Leader和状态修改者，处理所有变更Cell状态的请求，例如提交作业或者结束某台机器上的一个任务。当Cell启动或者上一个Master故障时，新的Master会通过Paxos算法选举出来；新Master会获取一个Chubby锁，这样其它的系统就可以找到它。选举并转移到新的Master通常需要10秒，但在大的Cell里可能需要长达1分钟，因为需要重构一些内存状态。当一个副本从宕机恢复后，它会动态地从其它最新的Paxos副本中重新同步自己的状态。\n\n某个时刻的Borgmaster状态被称为检查点（Checkpoint），以定期快照加变更日志的形式保存在Paxos存储里。检查点有很多用途：如重建过去任意时刻的Borgmaster状态（例如，在接收一个触发了Borg故障的请求之前，这样就可以用来调试）；极端情况下可以手工修复检查点；构建一个持久的事件日志供日后查询；或用于离线仿真。\n\n一个高保真的Borgmaster模拟器，称为Fauxmaster，可以读取检查点文件。Fauxmaster的代码拷贝自线上的Borgmaster，还有对Borglet的存根接口。它接收RPC来改变状态，执行操作，例如“调度所有等待的任务”。我们用它来调试故障，像跟在线的Borgmaster那样与模拟器交互，用模拟的Borglet重放检查点文件里的真实交互。用户可以单步执行并观察系统过去确实发生了的状态变化。Fauxmaster也用于容量规划（可以接收多少个此类型的作业？），以及在实际更改Cell配置前做可行性检查（这个变更会导致关键作业异常退出吗？）\n\n## 3.2 调度\n\n当提交一个作业后，Borgmaster会把它保存在持久的Paxos存储上，并将这个作业的所有任务加入等待队列中。调度器异步地扫描等待队列，将任务分配到满足作业约束且有足够资源的机器上（调度是针对任务的，而非作业）。队列扫描从高优先级到低优先级，同优先级则以轮转的方式处理，以保证用户间的公平，并避免队首的大型作业阻塞队列。调度算法有两个部分：**可行性检查**，找到一组可以运行任务的机器；**评分**，从中选择一个合适的机器。\n\n在可行性检查阶段，调度器会找到一组满足任务约束且有足够可用资源的机器 —— 可用资源包括已经分配给低优先级任务但可以抢占的资源。在评分阶段，调度器确定每台可行机器的适宜性。评分考虑了用户特定的偏好，但主要取决于内置的标准：例如最小化被抢占任务的个数和优先级，选择已经有该任务安装包的机器，尽可能使任务分散在不同的供电和故障域，以及装箱（Packing）质量（在单台机器上混合高、低优先级的任务，以允许高优先级任务在负载尖峰扩容）等。\n\nBorg早期使用修改过的E-PVM[4]算法来评分。这个算法对异构的资源生成等效的成本值，放置任务的目标是使成本的变化量最小。在实践中，E-PVM会把负载分散到所有机器，为负载尖峰预留出资源 —— 这样的代价是增加了碎片，特别是对需要大部分机器的大型任务而言；我们有时称其为“最差匹配”。\n\n与之相反的是“最佳匹配”，把机器上的任务塞的越满越好。这就“空”出一些没有用户作业的机器（它们仍运行存储服务），这样放置大型任务就比较直接了。但是，如果用户或Borg错误估计了资源需求，紧实的装箱会对此造成（性能上的）惩罚。这种策略不利于有突发负载的应用，而且对申请少量CPU的批处理作业特别不友好，这些作业申请少量CPU本来是为了更容易被调度执行，并抓住机会使用空闲资源：20%的non-prod 任务申请少于0.1个CPU核。\n\n我们目前的评分模型是混合的，试图减少搁浅（Stranded）的资源（指一台机器因某些类型资源全部分配了，导致未能分配的其它类型资源）。对我们的负载而言，这个模型比“最佳匹配”提升了3%-5%的装箱效率（以[78]定义的方式评价）。\n\n如果评分后选中的一台机器仍没有足够的资源来运行新任务，Borg会抢占低优先级的任务，从最低优先级向上逐级抢占，直到资源足够运行该任务。被抢占的任务放回到调度器的等待队列里，而不是被迁移或休眠（注：例外情况是，为Google Compute Engine提供虚拟机的任务会被迁移）。\n\n任务的启动延迟（从提交作业到任务开始运行之间的时间段）是我们持续重点关注的。这个时间差别很大，中位数约25秒。安装软件包耗费了其中80%的时间：一个已知的瓶颈就是软件包写入时对本地硬盘的竞争。为了减少任务启动时间，调度器偏好将任务分配到已经有必需的软件包（程序及数据）的机器：大部分包是只读的，所以可以被共享和缓存（这是Borg调度器唯一的一种数据局部性支持）。另外，Borg通过树形和类似BT的协议并发地将软件包分发到多个机器上。\n\n此外，调度器采用多种技术使其能够扩展到数万台机器的Cell（§3.4）。\n\n## 3.3 Borglet\n\nBorglet是部署在Cell每台机器上的本机Borg代理。它负责启动和停止任务；重启失败的任务；通过OS内核设置来管理本地资源；滚动调试日志；把本机的状态上报给Borgmaster和其它监控系统。\n\nBorgmaster每过几秒就会轮询每个Borglet来获取机器的当前状态，并向其发送请求。这让Borgmaster能控制通信频率，省去了显式的流量控制机制，而且防止了恢复风暴[9]。\n\n选举出来的Master负责准备发送给Borglet的消息，并根据Borglet的响应更新Cell的状态。为了性能扩展性，每个Borgmaster副本会运行一个无状态的链接分片（Link Shard）来处理部分Borglet的通信；Borgmaster选举后重新计算链接的分片。为了保证容错（Resiliency），Borglet总是汇报全部状态，但是Link Shard只汇报变化值，从而聚合、压缩这些信息，减少Master更新的负担。\n\n如果某个Borglet几次没有响应轮询请求，该机器会被标记为宕机，其上运行的所有任务会被重新调度到其它机器。如果通讯恢复了，Borgmaster会让这个Borglet杀掉已经被重新调度出去的任务，以避免重复。即便无法与Borgmaster通信，Borglet仍会继续正常运行。所以即使所有的Borgmaster都出故障了，正在运行的任务和服务还会保持运行。\n\n## 3.4 扩展性\n\n\n我们还没有遇到Borg这种集中式架构的终极扩展上限。我们顺利突破了遇到的每个限制。一个单独的Borgmaster可以管理有数千台机器的Cell，有若干Cell每分钟有10000多个到达的任务。一个繁忙的Borgmaster使用10~14个CPU核以及50GB内存。我们用了几项技术来实现这种扩展性。\n\n早期版本的Borgmaster使用一个简单的，同步的循环来处理请求、调度任务，并与Borglet通信。为了处理更大的Cell，我们把调度器分离为一个单独的进程，这样它就可以与其它的Borgmaster功能并行执行，而这些其它的功能有多副本以容错。一个调度器副本使用一份缓存的Cell状态拷贝，重复执行下面的操作：从选举出来的Master获取状态改变（包括已分配的和等待中的工作）；更新自己的本地拷贝；执行一遍调度来分配任务；将分配信息发送给Master。Master会接受并应用这些分配，但如果分配不适合（例如，是基于过时的状态做出的），就会等待调度器的下一遍调度。这与Omega[69]使用的乐观并发控制思路很相似，而且我们最近还给Borg添加了对不同负载类型使用不同调度器的功能。\n\n为了改进响应时间，Borglet使用独立的线程分别进行通信和响应只读RPC。为了更好的性能，我们将这些请求划分给5个Borgmaster副本（§3.3）。总的效果是，UI响应时间的99%分位数小于1秒，而Borglet轮询间隔的95%分位数小于10秒。\n\n一些提高Borg调度器扩展性的方法如下：\n\n**缓存评分**：计算一台机器的可行性和评分是比较昂贵的，所以Borg会一直缓存评分，直到这台机器或者任务的属性发生了变化 —— 例如，这台机器上的某个任务结束了，一些属性修改了，或者任务的需求改变了。忽略小额的资源变化可以减少缓存失效。\n\n**任务等价类（Equivalence classes）**：一般来说，同一个Borg 作业的任务有相同的请求和约束。任务等价类即一组有相同需求的任务。Borg只对等价类中的一个任务进行可行性检查和评分，而不是对等待的每个任务去检查一遍所有机器的可行性并对可行的机器评分。\n\n**适度随机**：在一个大的Cell中，对所有机器都去计算一遍可行性和评分是很浪费的。调度器会随机地检查机器，直到找到足够多的可用机器来评分，然后从中挑选出最好的一个。这减少了任务启动和退出所需的评分次数及导致的缓存失效，加快了任务分配过程。适度随机有点类似Sparrow[65]的批量采样技术（ying：Sparrow的批量采样考虑的是机器上的任务队列长度），但Borg还处理了优先级、抢占、异构性和安装软件包的成本。\n\n在我们的实验中（§5），从零开始调度整个Cell的工作负载只要几百秒，但禁用上面几项技术的话，3天都不够。正常情况下，半秒之内就能完成一遍等待队列的在线调度。\n\n# 4. 可用性\n\n<img width=\"600\"  src=\"/img/borg-fig-03.png\" alt=\"图3. 不同类型任务的异常退出率及原因（包括抢占、资源不足、机器故障、机器关机、其它）。数据从2013-08-01开始。\" />\n\n大型系统里故障是很常见的[10, 11, 12]。图3展示了在15个样本Cell里任务异常退出的原因分类。在Borg上运行的应用需要能处理这种事件，可采用的技术有多副本、保存持久状态到分布式存储，或定期快照（如果可行的话）等。当然，我们也尽可能的缓解异常事件的影响。例如，Borg提供了：\n\n+ 自动重新调度异常退出的任务，如果必要，可以放置到另一台机器上去运行\n+ 把一个作业的任务分散到不同的可用域，例如机器、机架、供电域层次，以减少关联失效\n+ 在机器/OS升级等维护活动期间，限制任务受影响的速率，以及同一作业中同时中止的任务的个数\n+ 使用声明式的预期状态表示和幂等的变更操作，这样故障的客户端可以无损地重复提交故障期间漏掉的请求\n+ 对于失联的机器上的任务，限制重新调度的速率，因为大规模的机器故障和网络分区是很难区分的\n+ 回避造成崩溃的 <任务：机器> 组合\n+ 通过不断重新执行日志保存任务（§2.4），恢复已写入本地硬盘的关键中间数据，就算这个日志关联的Alloc已经终止或调度到其它机器上了。用户可以设置系统保持重复尝试多久，通常是几天时间。\n\nBorg的一个关键设计特性是：就算Borgmaster或者Borglet挂掉了，已经运行的任务还会继续运行下去。不过，保持Master正常运行仍然重要，因为在它退出后就无法提交新的作业，无法更新运行作业的状态，也不能重新调度故障机器上的任务。\n\nBorgmaster使用多项的技术支持其获得99.99%的实际可用性：多副本应对机器故障；准入控制应对超载；使用简单、底层的工具部署实例，以减少外部依赖。Cell彼此是独立的，减少了关联误操作和故障传播的机会。同时这也是我们不扩大Cell规模的主要考虑，而并非是扩展性的限制。\n\n# 5. 利用率\n\n\nBorg的一个主要目标就是有效地利用Google的大量机器（这是一大笔财务投资）：让效率提升几个百分点就能省下几百万美元。这一节讨论和评估了一些Borg使用的策略和技术。\n\n## 5.1 评估方法\n\n作业有部署约束，而且需要处理负载尖峰（尽管比较少见）；机器是异构的；我们回收服务型作业的资源来运行批处理作业。因此，我们需要一个比“平均利用率”更高级的指标来评估我们的策略选择。大量实验后，我们选择了Cell压缩量（Compaction）：给定一个负载，我们不断地移除机器，直到无法容纳该负载，从而得知所需最小的Cell规模。从空集群开始部署该负载并重复多次，以减少特殊情况的影响。终止条件是明确的，对比可以自动化，避免了生成和建模合成负载的陷阱[31]。[78]提供了评估技术的定量比较，其中的细节非常微妙。\n\n我们不可能在线上Cell进行实验，但是我们用了Fauxmaster来获得高保真的模拟效果，它使用了真实生产Cell和负载的数据，包括所有约束、实际限制、预留和使用量数据（§5.5）。实验数据提取自2014-10-01 14:00 PDT的Borg快照（其它快照也有类似的结论）。我们首先排除了特殊用途的、测试用的、小型的（少于5000台机器）的Cell，然后从剩下的Cell中选取了15个样本，抽样尽量关于Cell的大小均匀分布。\n\n为了保持机器异构性，在Cell压缩实验中，我们随机地移除机器。为了保持工作负载的异构性，我们保留了所有负载（除了那些绑定到特定机器的服务和存储任务，如Borglet）。我们把那些需要超过原Cell大小一半的作业的硬性限制改成柔性的，允许不超过0.2%的任务一直等待，这是针对一些特别“挑剔”的，只能放置在很少的特定机器上的任务；充分的实验表明结果是可复现的，波动很小。如果需要一个大型的Cell，就把原Cell复制几倍；如果需要更多的Cell，也是复制原Cell。\n\n每个实验都用不同的随机数种子对每个Cell重复了11次。图中，我们用误差线线来表示所需机器数量的最大和最小值，选择90%分位数作为结果 —— 平均值或中位数不能反映系统管理员所期望的充分把握。我们认为Cell压缩率是一个公平一致的比较调度策略的方法，而且可以直接转化为成本/收益的结果：更好的策略只需要更少的机器来运行相同的负载。\n\n我们的实验关注于即时的调度（装箱），而不是重放一段长时间的负载记录。部分原因是避免处理开放或闭合的队列模型[71, 79]的困难；部分是传统的完成时间不适用于长时间运行的服务；部分是这样可以提供明确的比较结果；部分是因为我们认为不会对结果产生显著影响；还有部分现实原因，我们发现一次实验使用了20万个Borg CPU核 —— 即便对Google而言，这个成本也不是个小数目。\n\n<img width=\"600\"  src=\"/img/borg-fig-04.png\" alt=\"图4. 压缩的效果。15个Cell在压缩后相比原规模的百分比累积分布（CDF）\"/>\n\n生产环境中，我们特意保留了一些裕度（Headroom），以应对负载增长、偶然的“黑天鹅”事件、负载尖峰、机器故障、硬件升级、以及大范围的局部故障（如供电母线短路）。图4显示了如果应用Cell压缩，实际的Cell可以压缩到多小。下文的图使用这些压缩后的大小作为基准值。\n\n## 5.2 Cell共享\n\n几乎所有的机器都同时运行prod和non-prod的任务：在共享的Cell里是98%的机器，在所有Borg管理的机器里是83%（有一些是Cell专用的）。\n\n![图5. 将prod和non-prod工作划分到不同的集群将需要更多的机器。两幅图中的百分比都是相对于单个集群所需机器的最少数量而言的](/img/borg-fig-05.png)\n\n鉴于很多外部组织将面向用户的作业和批处理作业分别运行在不同的集群上，我们检查一下如果我们也这么做会怎样。图5表明，在一个中等大小的Cell上，分开运行prod和non-prod的工作负载将需要增加20-30%的机器。这是因为prod的作业通常会保留一些资源来应对极少发生的负载尖峰，但大多情况下用不到这些资源。Borg回收了这些用不到的资源（§5.5），来运行non-prod的工作，所以总体我们只需要更少的机器。\n\n<img width=\"600\"  src=\"/img/borg-fig-06.png\" alt=\"图6. 将用户分开到不同的集群也会需要更多的机器\"/>\n\n大部分Borg Cell被数千个用户共享使用。图6展示了为什么要共享。测试中，如果一个用户消费了超过10TiB（或100TiB）的内存，我们就把这个用户的工作负载分离到另一个Cell中。我们目前的共享策略是有效的：即使100TiB的阈值，也需要2-16倍的Cell，增加20-150%的机器。将资源池化再次显著地节省了成本。\n\n但是，把很多不相关的用户和作业类型放置到同一台机器上可能会造成CPU冲突，我们是否需要更多的机器来补偿？为评估这一点，我们看一下固定机器类型和时钟频率，任务的CPI（Cycles per Instruction，执行每条指令平均所需时钟数，越大则程序执行越慢）在其它环境条件不同的影响下是如何变化的。在这种实验条件下，CPI是一个可比较的指标，而且可以表征性能冲突，因为2倍的CPI意味着一个CPU密集型程序需要2倍的执行时间。数据是在一周内从约12000个随机选择的prod任务获取的，使用了[83]中介绍的硬件剖析工具记录5分钟内的时钟数和指令数，并调整了采样的权重，使CPU时间的每秒都均等处理。结果并非直截了当的：\n\n（1）我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及这个机器上同时运行的任务个数（基本上独立）；每向一台机器上增加一个任务，就会使其它任务的CPI增加0.3%（从数据拟合的线性模型给出的预测值）；将一台机器的CPU使用量增加10%，就会增加2%弱的CPI。尽管相关性在统计意义上是显著的，也只是解释了CPI变化的5%。还有其它的因素，支配着CPI的变化，例如，应用程序固有的差别，以及特殊的干扰模式[24, 83]。\n\n（2）比较从共享Cell和只运行几种应用的少数专用Cell获取的CPI采样，我们看到共享Cell里的CPI平均值为1.58（σ=0.35，标准差），专用Cell的CPI平均值是1.53（σ=0.32） —— 也就是说，共享Cell的性能差3%。\n\n（3）为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差（或许对冲突更敏感的程序会被挪到专用Cell里面去），我们观察了Borglet的CPI。所有Cell的所有机器上都运行着Borglet。我们发现专用Cell里Borlet的CPI平均值是1.20（σ=0.29），而共享Cell里的CPI平均值为1.43（σ=0.45），表明在专用Cell上比在共享Cell上快1.19倍，不过这个结果忽略了专用Cell中的机器负载较轻的因素，即稍偏向专用Cell。\n\n这些实验表明了仓库级别的性能比较是复杂的，强化了[51]中的观察，但也说明共享并没有显著增加运行程序的开销。\n\n不过，就算从结果中最差的数据来看，共享还是有益的：比起CPU的降速，共享比各个划分方案都减少了机器，这一点更重要，而且共享的收益适用于包括内存和硬盘等各种资源，不仅仅是CPU。\n\n## 5.3 大型Cell\n\n![图7. 将Cell分成更小的规模将需要更多的机器](/img/borg-fig-07.png)\n\nGoogle建立了大型Cell，一是为了允许运行大型任务，二是为了减少资源碎片。为测试减少碎片的效果，我们把负载从一个Cell分散多个较小的Cell中 —— 首先将作业随机排列，然后轮流分配到各小的Cell中。图7确认了使用小型Cell需要增加相当多的机器。\n\n## 5.4 细粒度资源请求\n\nBorg用户请求的CPU单位是0.001个核，内存和硬盘的单位是字节。（一个核实际上是一个CPU的超线程，对不同机器类型的性能进行了标准化）。图8表明用户充分利用了细粒度：请求的CPU核和内存数量的“特别偏好值”是很少的，这些资源也没有明显的相关性。这与[68]里的分布非常相似，除了我们在90%分位数及以上的内存请求多一点之外。\n\n尽管IaaS普遍只提供一组固定尺寸的容器或虚拟机[7, 33]，但不符合我们的需求。为说明这一点，我们对prod的作业和Alloc（§2.4）申请的CPU核和内存分别向上取整到最接近的2的幂，形成固定大小的“桶”，最小的桶有0.5个核和1GiB内存。图9显示一般情况下这样需要增加30-50%的资源。上限的情形是，有的大型任务即便将Cell扩大为未压缩尺寸的四倍也无法容纳，只好为其分配一整台机器。下限是允许这些任务一直等待。（这比[37]给出的将近100%的额外开销要小一些，因为我们支持不止4种尺寸的桶，而且允许CPU和内存分别改变）。\n\n## 5.5 资源回收\n\n作业可以声明一个资源**限额（Limit）**，是每个任务能获得的资源上限。Borg会用它来检查用户是否有足够的配额来接受该作业，并检查某个机器是否有足够的可用资源来运行任务。因为Borg通常会杀死那些试图使用超出内存和硬盘申请值的任务，或者限制其CPU使用量不超过申请值，所以有的用户会为任务申请超过实际需要的资源，就像有的用户会购买超过实际需要的配额一样。另外，一些任务只是偶尔需要使用它们申请的所有资源（例如，在一天中的高峰期或者受到了拒绝服务攻击），但大多时候用不了。\n\n与其把那些分配出来但暂时没有被用到的资源浪费掉，我们估计了一个任务会用多少资源，然后把剩余的资源回收给那些可以忍受低质量资源的任务，例如批处理作业。这整个过程称为**资源再利用**。这个估值称为任务的资源**预留（Reservation）**。Borgmaster每隔几秒就会根据Borglet获取的细粒度资源使用量信息来计算一次预留值。最初的预留资源被设置为资源限额；在300秒之后，也就过了启动阶段，预留资源会缓慢的下降到实际使用量加上一个安全值。在实际使用量超过它时，预留值会迅速增加。\n\nBorg调度器使用资源限额来计算prod级任务（注：准确的说，是高优先级的、延迟敏感的任务，见§6.2）是否可以执行（§3.2），所以这些任务不依赖于回收的资源，也与资源超售无关；对于non-prod的任务，运行任务使用的资源在预留值之内，这样新任务就可以使用回收的资源。\n\n一台机器有可能因为预留（预测）错误而导致运行时资源不足 —— 即使所有的任务都在资源限额之内。如果这种情况发生了，我们会杀掉或者限制non-prod任务，但从来不对prod任务下手。\n\n图10表明，如果没有资源回收，将需要更多的机器。在一个中等规模的Cell中大概有20%的工作负载（§6.2）使用了回收的资源。\n\n图11可以看到更多的细节，其中有预留值、使用量与限额的比例。当资源紧张时，超出内存限额的任务首先会被抢占，不论优先级有多高，所以很少有任务超过内存限额。另一方面，CPU使用量是可以被轻易限制住的，所以短时的毛刺虽然会导致使用量超过预留值，但这没什么损害。\n\n图11表明了资源回收可能还过于保守：在预留值和实际使用量中间还有一大段差距。为了测试这一点，我们选择了一个线上Cell，（第一周作为参照基准，）第二周将其估计算法的参数调整为比较**激进**的设置，即把安全裕度留小一点；第三周采取的是介于激进和基准之间的**适度**策略，最后一周恢复到基准策略。\n\n![](/img/borg-fig-08-09-10-11.png)\n\n图12展示了结果。第二周的预留值明显更接近实际使用量，第三周稍大一点，最大的是第一周和第四周。和预期的一样，第二周和第三周的OOM比率轻微地增加了（注：第3周后期的异常情况与本次实验无关）。在评估了这个结果后，我们认为利大于弊，于是在其它Cell上也采用了**适度**策略的资源回收参数。\n\n![图12. 更激进的资源估计可以回收更多资源，但会稍增加OOM事件](/img/borg-fig-12.png)\n\n# 6. 隔离\n\n50%的机器运行了9个以上的任务；处于90%分位数的机器则有大约25个任务，4500个线程[83]。虽然在应用之间共享机器会增加利用率，但也需要一个比较好的机制来保证任务之间不产生干扰。这同时适用于安全和性能两个方面。\n\n## 6.1 安全隔离\n\n我们使用Linux的chroot作为同一台机器上不同任务之间的主要安全隔离机制。仅当某台机器有用户运行的任务时，为了允许远程调试，我们以前会自动分发（或废除）SSH秘钥，使用户可以访问这台机器。对大多数用户来说，现在被替换为`borgssh`命令，这个程序和Borglet协同构建一个SSH通道，连接到与任务运行在同一个chroot和cgroup下的Shell，这样限制就更加严格了。\n\nGoogle的AppEngine（GAE）[38]和Google Compute Engine（GCE）使用VM和安全沙箱技术运行外部的软件。我们把每个运行在KVM进程中的VM作为一个Borg任务来运行。\n\n## 6.2 性能隔离\n\n\n早期的Borglet使用了一种相对原始的资源隔离措施：事后检查内存、硬盘和CPU使用量，终止使用过多内存和硬盘的任务，或者降低使用过多CPU的任务的Linux CPU优先级。不过，一些粗暴的任务还是能很容易地影响到同台机器上其它任务的性能，于是有的用户就会多申请资源来让Borg减少与其共存的任务数量，降低了资源利用率。资源回收可以弥补一些损失，但不是全部，因为涉及到安全裕度。在极端情况下，用户会要求使用专属的机器或者Cell。\n\n目前，所有Borg任务都运行在基于Linux cgroup的资源容器[17, 58, 62]里。Borglet控制着这些容器的设置。有了OS内核的帮助，控制能力得到了改善。即使这样，偶尔还是有低级别的资源冲突发生（例如内存带宽或L3缓存污染），见[60, 83]。\n\n为了应对超载和超售，Borg任务有一个应用类别（appclass）。最重要的区分是延迟敏感（LS）的应用和本文中称为批处理（batch）的其它类别。LS任务包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS任务得到最高优待，可以暂时让批处理任务等待几秒种。\n\n第二个区分是：**可压缩**资源（例如CPU，硬盘I/O带宽），都是基于速率的，可以通过降低一个任务的服务质量而不是杀死它来回收；**不可压缩**资源（例如内存、硬盘空间），这些一般来说不杀掉任务是没办法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会开始杀死任务，从低优先级开始，直到能满足剩下的资源预留。如果机器用完了可压缩资源，Borglet会限制使用量（偏好LS任务），这样不用杀死任何任务也能处理短期负载尖峰。如果情况没有改善，Borgmaster会从这个机器上移除一个或多个任务。\n\nBorglet有一个用户态的控制循环，负责以下操作：为容器确定内存量，prod任务基于预测值，而non-prod任务则基于内存压力；处理来自内核的OOM事件；当任务试图分配超过其自身限额的内存时，或者超售的机器上确实耗尽内存时，都会杀死任务。Linux激进的文件缓存让我们的实现复杂得多，因为需要精确计算内存使用量。\n\n为了增强性能隔离，LS任务可以预留整个物理CPU核，以阻止别的LS任务来使用它们。批处理任务被允许运行在任何核上，但是相比LS任务，批处理任务只分配了很少的调度份额。Borglet动态地调整贪婪的LS任务的资源上限，以保证它们不会把批处理任务饿上几分钟，必要时有选择的使用CFS带宽控制[75]；仅用份额来表示是不够的，因为我们有多个优先级。\n\n<img width=\"600\"  src=\"/img/borg-fig-13.png\" alt=\"图13. 调度延迟与负载的关系。即一个就绪线程需要等待超过1 ms才能运行的比率，与机器繁忙程度的关系。每组数据条中，左侧是延迟敏感的任务，右侧是批处理任务。只有很少的比率需要等5 ms以上，超过10 ms就极少了。这是2013年12月从一个代表性的Cell中获取的一个月的数据；误差线是每天的波动\"/>\n\n同Leverich[56]一样，我们发现标准的Linux CPU调度器（CFS）需要大幅调整才能同时支持低延迟和高利用率。为了减少调度延迟：我们内部版本的CFS对每个`cgroup`都有单独的负载历史[16]；允许LS任务抢占批处理任务；当一个CPU有多个就绪的LS任务时，减少其调度数量。幸运的是，我们的大多应用使用每个线程处理一个请求的模型，这样就缓解了长期的负载不均衡。我们节俭地使用`cpusets`给有特别严格的延迟需求的应用分配CPU核。这些努力的一些效果展示在图13中。我们持续在这方面投入，增加感知NUMA、超线程、能耗（如[81]）的线程放置和CPU管理，改进Borglet的控制精确度。\n\n任务被允许在其上限之内消费资源。大部分任务还允许去使用超出上限的可压缩资源，例如CPU，以利用空闲资源。只有5%的LS任务禁止这么做，主要是为了改善可预测性；小于1%的批处理任务也禁止了。使用超量内存默认是被禁止的，因为这会增加任务被杀掉的概率，不过即使这样，10%的LS任务解除了这个限制，79%的批处理任务也解除了，因为这是MapReduce框架的默认设置。这补偿了资源回收（§5.5）的后果。批处理任务很乐意使用空闲的或回收的内存：大多情况下这样运作得很好，即使偶尔批处理任务会被急需资源的LS任务杀掉。\n\n# 7. 相关工作\n\n数十年来，资源调度已经在多种场景得到了研究，如广域高性能计算网格、工作站网络、和大规模服务器集群等。我们这里只关注最相关的大规模服务器集群这个场景。\n\n最近的一些研究分析了来自于Yahoo!、Google和Facebook的集群记录数据[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载固有的异构性和大规模带来的挑战。[69]包含了对集群管理器架构的分类。\n\nApache Mesos[45]将资源管理和任务放置功能拆分到一个集中资源管理器（类似于去掉调度器的Bormaster）和多种“框架”（比如Hadoop[41]和Spark[73]）之间，两者基于供应（Offer）机制交互。Borg则把这些功能集中在一起，使用基于请求的机制，而且扩展性相当好。DRF[29, 35, 36, 66]最初是为Mesos开发的；Borg则使用优先级和准入配额来替代。Mesos开发者已经宣布了他们扩展Mesos的雄心壮志：预测性资源分配和回收，以及解决[69]中发现的一些问题。\n\nYARN[76]是一个针对Hadoop的集群管理器。每个应用都有一个另外的管理器，与中央资源管理器谈判所需资源；这跟大约2008年开始Google的MapReduce作业已经使用的向Borg获取资源的模式如出一辙。YARN的资源管理器最近才支持容错。一个相关的开源项目是Hadoop Capacity Scheduler（基于容量的调度器）[42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近扩展支持了多种资源类型、优先级、抢占和高级准入控制[21]。Tetris（俄罗斯方块）研究原型[40]支持完成时间感知的作业装箱。\n\nFacebook的Tupperware[64]，是一个在集群中调度`cgroup`容器的类Borg系统；只有少量细节披露出来了，看起来它也提供了某种形式的资源回收功能。Twitter开源的Aurora[5]是一个类似Borg的，用于长期运行服务的调度器，运行与Mesos之上，其配置语言和状态迁移与Borg类似。\n\n微软的Autopilot[48]为其集群提供了“自动化的软件供应和部署；系统监控；以及采取修复行为处理软硬件故障”的功能。Borg生态系统提供了相似的特性，不过篇幅所限，不再深入讨论；作者Isaard概括了很多我们也赞成的最佳实践。\n\nQuincy[49]使用了一个网络流模型来提供公平性和数据局部性感知的调度，应用在几百个节点的集群的数据处理DAG上。Borg使用配额和优先级在用户间共享数据，可以扩展到上万台机器。Quincy可以直接处理执行图，而Borg需要在其上层另外构建。\n\nCosmos[44]聚焦在批处理上，强调了用户可以公平获取他们已经捐献给集群的资源。每个作业分别有一个管理器来获取资源；只有很少公开的细节。\n\n微软的Apollo系统[13]为每个短期批处理作业分别使用单独的调度器，以获得高吞吐量，其集群规模看起来与Borg的Cell相当。Apollo投机地执行低优先级后台任务来提升资源利用率，代价是有时有长达多日的队列延迟。Apollo的各节点都一个关于开始时间的预测矩阵，其行列分别为CPU和内存两个资源维度。调度器会综合开始时间、估计的启动开销、获取远程数据的开销来决定部署位置，并用一个随机延时来减少冲突。Borg使用的是中央调度器，基于之前的分配来决定部署位置，可以处理更多的资源维度，而且更关注高可用、长期运行的应用；Apollo也许能处理比Borg更高的任务到达率。\n\n阿里巴巴的伏羲（Fuxi）[84]支持数据分析的负载，从2009年就开始运行了。类似Borgmaster，一个集中的FuxiMaster（也做了容错多副本）从节点上获取可用资源的信息、接受应用的资源请求，然后匹配两者。伏羲的增量调度策略与Borg的任务等价类是相反的：伏羲用最新的可用资源匹配等待队列里的任务（ying：Borg是用任务匹配资源）。类似Mesos，伏羲允许定义“虚拟资源”类型。只有对合成工作负载的实验结果是公开的。\n\nOmega[69]支持多个并发的调度器，粗略相当于没有持久存储和链接分片的Borgmaster。Omega调度器使用乐观并发控制的方式去操作一个共享的集群预期的和观察的状态表示。集群状态存储在一个集中持久存储中，用单独的连接组件与Borglet同步。Omage架构设计为支持多种不同的工作负载，它们有自己特定的RPC接口、状态迁移和调度策略（例如长期运行的服务、多个框架批处理作业、如集群存储这样的基础服务、Google云平台上的虚拟机）。相反，Borg提供了一种通用方案，同样的RPC接口、状态迁移、调度策略，为支持多种不同的负载，其规模和复杂度逐渐增加，但目前来说可扩展性还不算一个问题（§3.4）。\n\nGoogle的开源项目Kubernetes系统[53]把应用放在Docker容器内[28]，再分发到多个机器上。它即可以运行在物理机上（像Borg那样），也可以运行在多个云供应商（比如Google Compute Engine，GCE）的主机上。Kubernetes正在快速开发中，它的很多开发者也参与开发了Borg。Google提供了一个托管的版本，称为Google Container Engine（GKE）[39]。我们会在下一节里面讨论Kubernetes从Borg中学到了哪些东西。\n\n在高性能计算社区对这个领域有长期的研究传统（如Maui, Moab, Platform LSF[2, 47, 50]）；但是这和Google Cell所面对的规模、工作负载、容错性是不同的。总体而言，为达到高用率，这些系统需要让任务在一个很长的队列中等待。\n\n虚拟化供应商，例如VMware[77]，和数据中心方案供应商，例如HP和IBM[46]提供了典型情况下可以扩展到一千台机器规模的集群管理解决方案。另外，一些研究小组的原型系统以多种方式提升了调度质量（如[25, 40, 72, 74]）。\n\n最后，正如我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]指出，失效预案、多租户、健康检查、准入控制，以及可重启性对实现单个运维人员管理更多的机器的目标是必要的。Borg的设计哲学也是这样的，而且支撑了我们的每个SRE管理数万台机器。\n\n>Borg从它的前任继承了很多东西，即我们内部的全局工作队列（Global Work Queue）系统，它最初是由Jeff Dean，Olcan Sercinoglu, 和Percy Liang开发的。\n>Conder[85]曾被广泛应用于收集空闲资源，其ClassAds机制[86]支持声明式的语句和自动属性匹配。\n\n# 8. 经验教训和未来工作\n\n在这一节中我们介绍了十多年来我们在生产环境运行Borg得到的定性的经验教训，然后介绍设计Kubernetes[53]是如何吸收这些经验的。\n\n## 8.1 教训\n\n我们从一些Borg作为反面警示的特性开始，然后介绍Kubernetes的替代方案。\n\n**将作业作为唯一的任务分组机制比较受限**\n\nBorg没有内置的方法将多个作业组成单个实体来管理，或将相关的服务实例关联起来（例如，测试通道和生产通道）。作为一个技巧，用户把他们的服务拓扑编码到作业的名字中，然后构建了更高层的管理工具来解析这些名字。这个问题的另外一面是，没办法指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级或改变作业的实例数。\n\n为了避免这些困难，Kubernetes不再使用作业这个概念，而是用标签（Label）来组织它的调度单元（Pod）。标签是任意的键值对，用户可以对系统的任何对象打上标签。Borg作业可以等效地通过对一组Pod打上 <作业：作业名> 这样的标签来实现。其它有用的分组方式也可以用标签来表示，例如服务、层级、发布类型（如，生产、就绪、测试）。Kubernetes用标签查询的方式来选取待操作的目标对象。这样就比固定的作业分组更加灵活。\n\n**同一台机器的任务共享一个IP太复杂了**\n\nBorg中，同一台机器上的所有任务都使用主机的同一个IP地址，共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；任务必须先声明它需要多少端口，而且需要支持启动时传入可用端口号；Borglet必须强制端口隔离；命名和RPC系统必须像IP一样处理端口（ying：最后这一点我认为是必要的）。\n\n多亏了Linux的namespace、虚拟机、IPv6和软件定义网络SDN的出现，Kubernetes可以用一种更用户友好的方式来消解这些复杂性：每个Pod和Service都自己的IP地址，允许开发者选择端口而不是让他们的软件支持基础设施的分配，这也消除了基础设施管理端口的复杂性。\n\n**给资深用户优化而忽略了初级用户**\n \n Borg提供了一大堆针对“资深用户”的特性，这样他们就可以仔细地调节他们程序的运行方式（BCL规范约有230个参数）：开始的目的是为了支持Google的大型资源用户，提升他们的效率会带来显著的效益。但不幸的是，这么复杂的API让初级用户用起来很复杂，而且限制了API的演化。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中决定合理的配置。由于应用支持容错，实验可以自由进行：即使自动化出了问题，也只是小麻烦，不会导致灾难。\n\n## 8.2 经验\n\n另一方面，有不少Borg的设计特性是非常有益的，而且经历了时间考验。\n\n**Alloc是有用的**\n\nBorg的Alloc抽象适用于广泛使用的保存日志模式（§2.4），另一个流行的模式是：一个简单的数据加载任务定期更新Web服务器使用的数据。Alloc和软件包机制允许这些辅助服务由不同的小组开发。Kubernetes对应于Alloc的概念是Pod，它是对一个或多个容器的资源封装，其中的容器共享Pod的资源，而且总是被调度到同一台机器上。Kubernetes使用Pod里的辅助容器来替代Alloc里面的任务，不过思路是一样的。\n\n**集群管理不只是任务管理**\n \n虽然Borg的主要角色是管理任务和机器的生命周期，但Borg上的应用还从其它的集群服务中收益良多，例如名字服务和负载均衡。Kubernetes用Service这个抽象概念来支持名字服务和负载均衡：Service有一个名字和用标签选出的多个Pod的动态集合。集群中的任何容器都可以通过Service名连接到该服务。幕后，Kubernetes自动将连接到该Service的负载分散到与其标签匹配的Pod之间，由于Pod挂掉后会被重新调度到其它机器上，Kubernetes还会跟踪这些Pod的位置。\n\n**自省是至关重要的**\n\n虽然Borg总体上是工作良好的，但出了问题后，定位根本原因是非常有挑战性的。Borg的一个关键设计选择是把所有的调试信息暴露给用户而不是隐藏起来：Borg有几千个用户，所以“自助”是调试的第一步。虽然一些用户的依赖项让我们难以废弃一些特性或修改内部策略，但这还是成功的，我们还没找到其它实际的替代方式。为管理大量的数据，我们提供了多个层次的UI和调试工具，这样用户就可以快速定位与其作业相关的异常事件，深入挖掘来自其应用和基础设施本身的详细事件和错误日志。\n\nKubernetes也计划引入Borg的大部分自省技术。和Kubernetes一起发布了很多工具，比如用于资源监控的cAdvisor[15]，它基于Elasticsearch/Kibana[30]和Fluentd[32]聚合日志。Master可以用来查询某个对象的状态快照。Kubernetes提供了一致机制，所有可以记录事件的组件（例如，被调度的Pod、出错的容器）都可以被客户端访问。\n\n**Master是分布式系统的核心**\n \nBorgmaster最初设计为一个单体的系统，随着时间发展，它演变成了一组服务生态系统的核心。用户作业管理的管理是由这些服务协同完成的。比如，我们把调度器和主要的UI（Sigma）分离成单独的进程，增加了一组服务，包括准入控制、纵向和横向扩展、任务重新装箱、周期性作业提交（cron）、工作流管理，用于离线查询的系统活动归档等。总体而言，这让我们能扩展工作负载和特性集合，但无需牺牲性能和可维护性。\n\nKubernetes的架构走的更远一些：它的核心是一个仅处理请求和操作底层状态目标的API服务。集群管理逻辑构建为一个小型的、可组合的微服务，作为API服务的客户端，如故障后仍维持Pod副本个数在期望值的副本管理器，以及管理机器生命周期的节点管理器。\n\n## 8.3 总结\n\n在过去十年间，所有几乎所有的Google集群负载都迁移到了Borg上。我们仍在持续改进它，并把经验应用到了Kubernetes上。\n\n# 致谢\n\n这篇文章的作者负责撰写文章，并完成了评估实验。几十位设计、实现和维护Borg组件和生态系统的工程师才是它成功的关键。我们在这里列出直接参与设计、实现和维护Borgmaster及Borglet的人员。如果有遗漏，我们深表歉意。\n\n早期版本的Borgmaster设计和实现人员有：Jeremy Dion和Mark Vandevoorde，以及Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu 和 Monika Henzinger。早期版本的Borglet主要是由Paul Menage设计和实现的（ying：见[62]）。\n\n后续的参与者包括：Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, Onufry Wojtaszczyk, Patrick Johnson, Pedro Valenzuela, Piotr Witusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, Tomasz Wozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.\n\nBorg SRE团队也是非常重要的，包括：Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, 和 Viraj Alankar。Borg配置语言（BCL）和`borgcfg`工具最初是Marcel van Lohuizen 和 Robert Griesemer开发的。\n\n>我们不小心漏掉了 Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, 和 Pavanish Nirula。\n\n谢谢我们的审稿人（尤其是Eric Brewer, Malte Schwarzkopf 和 Tom Rodeheffer），以及我们的导师Christos Kozyrakis，对这篇论文的反馈。\n\n# 勘误\n\n2015-04-23\n\n定稿后，我们发现了若干无意的疏漏和歧义。（ying：译文已将勘误内容放置到对应章节。补充的两条参考文献序号有冲突，放在了列表之后，并继续编号为85，86）\n\n# 参考文献\n[1] O. A. Abdul-Rahman and K. Aida. **Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon.**In Proc. IEEE Int'l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.\n[2] Adaptive Computing Enterprises Inc., Provo, UT. **Maui Scheduler Administrator's Guide**, 3.2 edition, 2011.\n[3] T. Akidau, A. Balikov, K. Bekiroğlu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. **MillWheel: fault-tolerant stream processing at internet scale** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.\n[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. **An opportunity cost approach for job assignment in a scalable computing cluster** IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.\n[5] **Apache Aurora**. http://aurora.incubator.apache.org/, 2014.\n[6] **Aurora Configuration Tutorial**. https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/, 2014.\n[7] AWS. **Amazon Web Services VM Instances**. http://aws.amazon.com/ec2/instance-types/, 2014.\n[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. **Megastore: Providing scalable, highly available storage for interactive services** In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.\n[9] M. Baker and J. Ousterhout. **Availability in the Sprite distributed file system** Operating Systems Review,25(2):95–98, Apr. 1991.\n[10] L. A. Barroso, J. Clidaras, and U. Hölzle. **The datacenter as a computer: an introduction to the design of warehouse-scale machines** Morgan Claypool Publishers, 2nd edition, 2013.\n[11] L. A. Barroso, J. Dean, and U. Holzle. **Web search for a planet: the Google cluster architecture** In IEEE Micro, pages 22–28, 2003.\n[12] I. Bokharouss. **GCL Viewer: a study in improving the understanding of GCL programs** Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.\n[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. **Apollo: scalable and coordinated scheduling for cloud-scale computing** In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.\n[14] M. Burrows. **The Chubby lock service for loosely-coupled distributed systems** In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.\n[15] **cAdvisor**. https://github.com/google/cadvisor, 2014\n[16] **CFS per-entity load patches**. http://lwn.net/Articles/531853, 2013.\n[17] **cgroups**. http://en.wikipedia.org/wiki/Cgroups, 2014.\n[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. **FlumeJava: easy, efficient data-parallel pipelines** In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.\n[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. **Bigtable: a distributed storage system for structured data** ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.\n[20] Y. Chen, S. Alspaugh, and R. H. Katz. **Design insights for MapReduce from diverse production workloads** Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.\n[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. **Reservation-based scheduling: if you're late don't blame us!**In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.\n[22] J. Dean and L. A. Barroso. **The tail at scale** Communications of the ACM, 56(2):74–80, Feb. 2012.\n[23] J. Dean and S. Ghemawat. **MapReduce: simplified data processing on large clusters** Communications of the ACM, 51(1):107–113, 2008.\n[24] C. Delimitrou and C. Kozyrakis. **Paragon: QoS-aware scheduling for heterogeneous datacenters** In Proc. Int'l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.\n[25] C. Delimitrou and C. Kozyrakis. **Quasar: resource-efficient and QoS-aware cluster management** In Proc. Int'l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.\n[26] S. Di, D. Kondo, and W. Cirne. **Characterization and comparison of cloud versus Grid workloads** In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.\n[27] S. Di, D. Kondo, and C. Franck. **Characterizing cloud applications on a Google data center** In Proc. Int'l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.\n[28] **Docker Project**. https://www.docker.io/, 2014.\n[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. **No justified complaints: on fair sharing of multiple resources** In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.\n[30] **ElasticSearch**. http://www.elasticsearch.org, 2014.\n[31] D. G. Feitelson. **Workload Modeling for Computer Systems Performance Evaluation** Cambridge University Press, 2014.\n[32] **Fluentd**. http://www.fluentd.org/, 2014.\n[33] **GCE. Google Compute Engine**. http://cloud.google.com/products/compute-engine/, 2014.\n[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. **The Google File System** In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.\n[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. **Dominant Resource Fairness: fair allocation of multiple resource types** In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.\n[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. **Choosy: max-min fair sharing for datacenter jobs with constraints** In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.\n[37] D. Gmach, J. Rolia, and L. Cherkasova. **Selling T-shirts and time shares in the cloud** In Proc. IEEE/ACM Int'l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.\n[38] **Google App Engine**. http://cloud.google.com/AppEngine, 2014.\n[39] **Google Container Engine (GKE)**. https://cloud.google.com/container-engine/, 2015.\n[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. **Multi-resource packing for cluster schedulers** In Proc. ACM SIGCOMM, Aug. 2014.\n[41] **Apache Hadoop Project**. http://hadoop.apache.org/, 2009.\n[42] **Hadoop MapReduce Next Generation – Capacity Scheduler**. [http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html](http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html), 2013.\n[43] J. Hamilton. **On designing and deploying internet-scale services**. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.\n[44] P. Helland. **Cosmos: big data and big challenges**. [http://research.microsoft.com/en-us/events/fs2011/ helland_cosmos_big_data_and_big_challenges.pdf](http://research.microsoft.com/en-us/events/fs2011/helland_cosmos_big_data_and_big_challenges.pdf), 2011.\n[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. **Mesos: a platform for fine-grained resource sharing in the data center**. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.\n[46] **IBM Platform Computing**. [http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/ index.html](http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/index.html).\n[47] S. Iqbal, R. Gupta, and Y.-C. Fang. **Planning considerations for job scheduling in HPC clusters** Dell Power Solutions, Feb. 2005.\n[48] M. Isaard. **Autopilot: Automatic data center management** ACM SIGOPS Operating Systems Review, 41(2), 2007.\n[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. **Quincy: fair scheduling for distributed computing clusters** In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.\n[50] D. B. Jackson, Q. Snell, and M. J. **Clement. Core algorithms of the Maui scheduler** In Proc. Int'l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.\n[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. **Measuring interference between live datacenter applications** In Proc. Int'l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.\n[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. **An analysis of traces from a production MapReduce cluster** In Proc. IEEE/ACM Int'l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.\n[53] **Kubernetes**. http://kubernetes.io, Aug. 2014.\n[54] **Kernel Based Virtual Machine**. http://www.linux-kvm.org.\n[55] L. Lamport. **The part-time parliament** ACM Trans. on Computer Systems, 16(2):133–169, May 1998.\n[56] J. Leverich and C. Kozyrakis. **Reconciling high server utilization and sub-millisecond quality-of-service** In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.\n[57] Z. Liu and S. Cho. **Characterizing machines and workloads on a Google cluster** In Proc. Int'l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.\n[58] **Google LMCTFY project (let me contain that for you)**. http://github.com/google/lmctfy, 2014.\n[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. **Pregel: a system for large-scale graph processing** In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.\n[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. **Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations** In Proc. Int'l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.\n[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. **Dremel: interactive analysis of web-scale datasets** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.\n[62] P. Menage. **Linux control groups**. http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt, 2007–2014.\n[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. **Towards characterizing cloud backend workloads: insights from Google compute clusters** ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.\n[64] A. Narayanan. **Tupperware: containerized deployment at Facebook**. http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook, June 2014.\n[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. **Sparrow: distributed, low latency scheduling** In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.\n[66] D. C. Parkes, A. D. Procaccia, and N. Shah. **Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities** In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.\n[67] **Protocol buffers**. https://developers.google.com/protocol-buffers/, and https://github.com/google/protobuf/, 2014.\n[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. **Heterogeneity and dynamicity of clouds at scale: Google trace analysis** In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. **Omega: flexible, scalable schedulers for large compute clusters** In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. **Modeling and synthesizing task placement constraints in Google compute clusters** In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.\n[71] E. Shmueli and D. G. Feitelson. **On simulation and design of parallel-systems schedulers: are we doing the right thing?** IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.\n[72] A. Singh, M. Korupolu, and D. Mohapatra. **Server-storage virtualization: integration and load balancing in data centers** In Proc. Int'l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.\n[73] **Apache Spark Project**. http://spark.apache.org/, 2014.\n[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. **Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds** In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.\n[75] P. Turner, B. Rao, and N. Rao. **CPU bandwidth control for CFS** In Proc. Linux Symposium, pages 245–254, July 2010.\n[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O'Malley, S. Radia, B. Reed, and E. Baldeschwieler. **Apache Hadoop YARN: Yet Another Resource Negotiator** In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.\n[77] **VMware VCloud Suite**. http://www.vmware.com/products/vcloud-suite/.\n[78] A. Verma, M. Korupolu, and J. Wilkes. **Evaluating job packing in warehouse-scale computing** In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.\n[79] W. Whitt. **Open and closed models for networks of queues** AT&T Bell Labs Technical Journal, 63(9), Nov. 1984.\n[80] J. Wilkes. **More Google cluster data**. http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html, Nov. 2011.\n[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. **HaPPy: Hyperthread-aware power profiling dynamically** In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.\n[82] Q. Zhang, J. Hellerstein, and R. Boutaba. **Characterizing task usage shapes in Google's compute clusters** In Proc. Int'l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.\n[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. **CPI2: CPU performance isolation for shared compute clusters** In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.\n[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. **Fuxi: a fault-tolerant resource management and job scheduling system at internet scale** In Proc. Int'l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.\n[85] Michael Litzkow, Miron Livny, and Matt Mutka. **Condor - A Hunter of Idle Workstations** In Proc. Int'l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.\n[86] Rajesh Raman, Miron Livny, and Marvin Solomon. **Matchmaking: Distributed Resource Management for High Throughput Computing** In Proc. Int'l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.\t\n ","slug":"eurosys15-borg-cn","published":1,"updated":"2017-12-03T14:59:36.639Z","_id":"cj9s6hmhj00169s4fle8xnvvp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>发表于EuroSys 2015的 <strong><em>Large-scale cluster management at Google with Borg</em></strong> 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。</p>\n<a id=\"more\"></a>\n<hr>\n<h1 id=\"Large-scale-cl-uster-management-at-Google-with-Borg\"><a href=\"#Large-scale-cl-uster-management-at-Google-with-Borg\" class=\"headerlink\" title=\"Large-scale cl uster management at Google with Borg\"></a>Large-scale cl uster management at Google with Borg</h1><h1 id=\"使用Borg在Google管理大规模集群\"><a href=\"#使用Borg在Google管理大规模集群\" class=\"headerlink\" title=\"使用Borg在Google管理大规模集群\"></a>使用Borg在Google管理大规模集群</h1><p>作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes</p>\n<p>EuroSys’15, <a href=\"http://dx.doi.org/10.1145/2741948.2741964\" target=\"_blank\" rel=\"external\">http://dx.doi.org/10.1145/2741948.2741964</a></p>\n<p><a href=\"http://research.google.com/pubs/pub43438.html\" target=\"_blank\" rel=\"external\">http://research.google.com/pubs/pub43438.html</a> 或 <a href=\"https://ying-zhang.github.io/doc/EuroSys15_Borg.pdf\">下载转存的英文全文PDF</a></p>\n<p><a href=\"https://ying-zhang.github.io/doc/EuroSys15_Borg_CN_Ying_201711.pdf\"><strong>中文译文全文PDF</strong></a></p>\n<p>译者：难易 <a href=\"http://my.oschina.net/HardySimpson\" target=\"_blank\" rel=\"external\">http://my.oschina.net/HardySimpson</a></p>\n<blockquote>\n<p><strong>修订：Ying 2017-10-31 ~ 2017-11-09</strong></p>\n</blockquote>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>Google的Borg系统是一个集群管理器。它在多个万台机器规模的集群上运行着来自几千个不同的应用的几十万个作业。</p>\n<p>Borg通过准入控制、高效的任务装箱、超售、机器共享、以及进程级别的性能隔离，实现了高利用率。它为高可用应用提供了可以减少故障恢复时间的运行时特性，以及降低关联故障概率的调度策略。Borg提供了声明式的作业描述语言、名字服务集成、实时作业监控、分析和模拟系统行为的工具。这些简化了用户的使用。</p>\n<p>本文介绍了Borg系统架构和特性，重要的设计决策，对某些策略选择的定量分析，以及十年来的运营经验和教训。</p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>我们内部称为Borg的集群管理系统，负责接收、调度、启动、重启和监控Google所有的应用。本文介绍它是如何实现的。</p>\n<p>Borg提供了三个主要的好处：（1）隐藏资源管理和故障处理细节，使用户可以专注于应用开发；（2）高可靠性和高可用性的运维，并支持应用程序也能够如此；（3）让我们可以在几万台机器上高效地运行负载。Borg不是第一个涉及这些问题的系统，但它是少有的运行在如此大规模、具有弹性、完善的系统之一。</p>\n<p>本文围绕这些主题来编写，总结了十多年来我们在生产环境运行Borg的一些定性观察。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-01.png\" alt=\"图1. Borg的架构。图中只画出了数千个工作节点的很小一部分\"></p>\n<h1 id=\"2-用户视角\"><a href=\"#2-用户视角\" class=\"headerlink\" title=\"2. 用户视角\"></a>2. 用户视角</h1><p>Borg的用户是Google的开发人员以及运行Google应用和服务的系统管理员（站点可靠性工程师，SRE）。用户以作业（Job）的方式将他们的工作提交给Borg。作业由一个或多个任务（Task）组成，每个任务执行相同的二进制程序。每个作业只运行在一个Borg单元（Cell）里。Cell是一组机器的管理单元。下面的小节将介绍用户视角看到的Borg系统的主要特性。</p>\n<blockquote>\n<p>SRE的职责比系统管理员多得多：他们是负责Google生产服务的工程师。他们也设计和实现包括自动化系统等软件，管理应用、服务基础设施和平台，以保证在Google如此大的规模下的高性能和高可靠性。</p>\n</blockquote>\n<h2 id=\"2-1-工作负载\"><a href=\"#2-1-工作负载\" class=\"headerlink\" title=\"2.1 工作负载\"></a>2.1 工作负载</h2><p>Borg Cell主要运行两种异构的工作负载。第一种是应该“永不”停止的长期运行的服务，处理持续时间较短但对延迟敏感的请求（从几微秒到几百毫秒）。这些服务用于面向最终用户的产品，如Gmail、Google Docs、网页搜索，以及内部基础设施服务（例如Bigtable）。第二种是批处理作业，执行时间从几秒到几天，对短期性能波动不敏感。不同Cell中这两种负载的混合程度不同，取决于其主要租户（例如，有些Cell就以批处理作业为主）。工作负载也随时间变化：批处理作业不断提交或结束，而很多面向终端用户的服务表现出昼夜周期性的使用模式。Borg需要都处理好这些情况。</p>\n<p>Borg的代表性负载是一个公开的2011年5月整月的记录数据集[80]。这个数据集已经获得了广泛的分析[1, 26, 27, 57, 68]。</p>\n<p>最近几年，以Borg为基础构建了很多应用框架，包括我们内部的MapReduce系统[23]、FlumeJava[18]、Millwheel[3]和Pregel[59]。这些框架大多有一个控制器来提交Master Job，还有多个Worker Job。前两个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和它的后继者CFS、Bigtable[19]、以及Megastore[8]，都是运行在Borg上的。</p>\n<p>本文中，我们把高优先级的Borg作业称为为生产作业（prod），其它的则是非生产的（non-prod）。大多数长期服务是prod的，大部分批处理作业是non-prod的。一个典型Cell里，prod作业分配了约70%的总CPU资源，占总CPU使用量约60%；分配了约55%的总内存资源，占总内存使用量约85%。§5.5节表明分配量和使用量的差异是值得注意的。</p>\n<h2 id=\"2-2-集群（Cluster）和单元（Cell）\"><a href=\"#2-2-集群（Cluster）和单元（Cell）\" class=\"headerlink\" title=\"2.2 集群（Cluster）和单元（Cell）\"></a>2.2 集群（Cluster）和单元（Cell）</h2><p>一个Cell里的机器属于同一个集群。集群由数据中心级的高性能光纤的组网来定义。一个集群位于数据中心的一栋建筑内，而一个数据中心有多栋建筑（注：这些关系会有少数例外情况）。一个集群通常包括一个大的Cell，还可能有一些小规模的测试用或其它特殊用途的Cell。我们尽力避免任何单点故障。</p>\n<p>排除测试用的Cell，中等规模的Cell约有一万台机器；有些Cell还要大得多。Cell中的机器从多个维度看都是异构的：大小（CPU、内存，硬盘，网络）、处理器类型、性能、以及是否有外网IP地址或SSD等。Borg负责决定任务在Cell中的哪些机器上执行、为其分配资源、安装程序及依赖、监控健康状态并在失败后重启，从而使用户几乎不必关心机器异构性。</p>\n<h2 id=\"2-3-作业（Job）和任务（Task）\"><a href=\"#2-3-作业（Job）和任务（Task）\" class=\"headerlink\" title=\"2.3 作业（Job）和任务（Task）\"></a>2.3 作业（Job）和任务（Task）</h2><p>一个Borg 作业的属性有：名字、拥有者和任务个数。作业可以有一些约束来强制其任务运行在有特定属性的机器上，比如处理器架构、操作系统版本、是否有外网IP地址等。约束可以是硬性的或者柔性的，柔性约束表示偏好，而非需求。一个作业可以推迟到前一个作业结束后再开始（ying：即依赖顺序）。一个作业只在一个Cell中运行。</p>\n<p>每个任务对应着一组Linux进程，运行在一台机器上的一个容器内[62]。绝大部分Borg的工作负载没有运行在虚拟机里，因为我们不想付出虚拟化的开销。而且，在Borg设计的那个时期，我们有很多处理器还不支持硬件虚拟化呢。</p>\n<p>任务也有一些属性，如资源需求量，在作业中的序号等。一个作业中的任务大多有相同的属性，但也可以被覆盖 —— 例如特定任务的命令行参数。各维度的资源（CPU核、内存、硬盘空间、硬盘访问速度、TCP端口（注：Borg负责管理一台机器上的可用端口并将其分配给任务）等。可以互相独立的以细粒度指定。我们不强制使用固定大小的资源桶或槽（见§5.4）。Borg运行的程序都是静态链接的，以减少对运行环境的依赖，这些程序组织成由二进制文件和数据文件构成的包，由Borg负责安装。</p>\n<p>用户通过向Borg发送RPC来控制作业。RPC大多是从命令行工具、其它作业、或我们的监控系统（§2.6）发出的。大多作业描述文件使用一种声明式配置语言BCL。BCL是GCL[12]的一个变种，即增加了一些Borg专有的关键字，而GCL会生成若干protobuf文件[67]。GCL还提供了匿名函数以支持计算，这样就能让应用根据环境调整自己的配置。有上万个超过一千行的BCL配置文件，系统中累计运行了千万行BCL。Borg的作业配置与Aurora的配置文件[6]相似。</p>\n<p>图2展示了作业和任务整个生命周期的状态变化。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-02.png\" alt=\"图2. 作业和任务的状态图。用户可以触发提交，杀死和更新动作\"></p>\n<p>要想在运行时改变一个作业中若干或全部任务的属性，用户可以向Borg提交一个新的作业配置，并命令Borg将任务更新到新的配置。更新是轻量级的，非原子性的事务，在事务结束（提交）之前可以很容易地撤销。更新通常是滚动执行的，而且可以限制由更新导致的任务中断（被重新调度或抢占）的数量；超过限值的变更会被跳过。</p>\n<p>一些任务更新（如更新二进制程序）需要重启任务；另外一些更新（如增加资源需求或修改约束）可能使该任务不适合运行在当前机器上，导致停止并重新调度该任务；还有一些更新（如修改优先级）总是可以执行的，不需要重启或者移动任务。</p>\n<p>任务可以要求被Unix的<code>SIGKILL</code>立即杀死之前获得<code>SIGTERM</code>信号通知，这样它们还有时间清理资源、保存状态、结束当前请求、拒绝新请求。但如果抢占者设置了延迟限值，就可能来不及发通知。实践中，80%的情况下能发出通知信号。</p>\n<h2 id=\"2-4-分配（Allocs）\"><a href=\"#2-4-分配（Allocs）\" class=\"headerlink\" title=\"2.4 分配（Allocs）\"></a>2.4 分配（Allocs）</h2><p>Borg的alloc（allocation的缩写）是一台机器上的预留资源，可以用来执行一个或多个任务；不管有没有被使用，这些资源都算分配出去了。Allocs可以给将来的任务预留资源，或在任务停止和重启的间隔保持资源，以及将不同作业的多个任务绑定在同一台机器上 —— 例如一个Web服务器实例和附加的将其URL日志从本机硬盘拷贝到分布式文件系统的保存日志任务。Alloc的资源像一台机器上的那样来管理；运行在同一个Alloc内的多个任务共享其资源。如果一个Alloc需要迁移到其它机器上，那么它的任务也要跟着重新调度。</p>\n<p>一个Alloc集，即一组在多台机器上预留了资源的Alloc，类似于一个作业。一旦创建了一个Alloc集，就可以向其提交若干作业。简便起见，我们用<strong>任务</strong>表示一个Alloc或者一个顶层任务（即运行在Alloc之外的任务），用<strong>作业</strong>表示一个普通作业或者Alloc集。</p>\n<h2 id=\"2-5-优先级、配额和准入控制\"><a href=\"#2-5-优先级、配额和准入控制\" class=\"headerlink\" title=\"2.5 优先级、配额和准入控制\"></a>2.5 优先级、配额和准入控制</h2><p>当出现超过系统容量的工作负载会产生什么情况？我们对此的解决方案是优先级和配额。</p>\n<p>每个作业都有一个小的正整数表示的优先级。高优先级的任务可以优先获取资源，甚至抢占（杀死）低优先级的任务。Borg为不同用途定义了不重叠的优先级区间，包括（优先级降序）：<strong>监控、生产、批处理、尽力（即测试的或免费的）</strong>。本文中，prod作业的优先级是监控和生产两个区间。</p>\n<p>虽然一个被抢占的任务通常会被重新调度到Cell的其它机器上，但级联抢占也可能发生：如果某个任务抢占了一个优先级稍低的任务，而后者又抢占了另一个优先级稍低的，如此往复。为避免这种情况，我们禁止<code>生产</code>区间的任务互相抢占。细粒度（ying：相比于区间的粗粒度）的优先级在其它场景下也很有用 —— 如MapReduce的Master 任务的优先级比其管理的Worker高一点，以提高其可靠性。</p>\n<p>优先级表示了Cell中运行或等待的作业之间的相对重要性。配额则用来决定准许哪个作业可以被调度。配额是指定优先级和时间段（典型是几个月）的一个资源向量（CPU，内存，硬盘等）。配额限制了用户的作业一次可以申请资源的最大数量（如：20TB内存，以prod优先级，从现在到7月末，在xx Cell内）。配额检查是准入控制的一部分，不是调度的：配额不足的作业提交时当即就会被拒绝。</p>\n<p>高优先级的配额比低优先级的成本要高。生产级的配额限于一个Cell的实际可用资源量，因此用户提交了不超过配额的生产级作业时，不考虑资源碎片和约束，可以预期这个作业一定会运行。尽管我们鼓励用户不要购买超过其需求的配额，但很多用户仍然超买了，这样他们就不用担心将来应用的用户量增长可能导致的配额短缺。我们的应对方案是对低优先级资源配额的超售：所有用户的0优先级配额是无限的，尽管这无法实现。低优先级的作业虽然被接收了，但可能由于资源不足而一直等待。</p>\n<p>配额分配是Borg之外的系统处理的，与我们的物理容量规划紧密相关。容量规划的结果反映在各数据中心的价格和可用配额上。只有在其要求的优先级有足够的配额，用户的作业才能被接收。采用配额使得主导资源公平性（DRF）[29, 35, 36, 66]这样的策略不是那么必要了。</p>\n<p>Borg的容量系统可以给某些用户一些特殊权限。例如，允许管理员删除或修改Cell里的任意作业，或者允许某个用户操作特定的内核特性或Borg行为（如对其作业禁用资源估计。§5.5）。</p>\n<h2 id=\"2-6-命名和监控\"><a href=\"#2-6-命名和监控\" class=\"headerlink\" title=\"2.6 命名和监控\"></a>2.6 命名和监控</h2><p>仅仅创建和放置任务是不够的：一个服务的客户端和其它系统需要能找到它们，即使该服务被重新放置到另一台机器之后。为实现该需求，Borg为每个任务创建了一个固定的BNS名字（BNS，Borg name Service），这个名字包括了Cell名，作业名和任务序号。Borg把任务的主机名和端口写入Chubby[14]的一个持久化高可用文件里，以BNS名字为文件名。这个文件被RPC用来发现任务的实际地址。BNS名字也是任务的DNS名字的基础部分，例如，cc Cell的ubar用户的jfoo 作业的第50个任务可以通过<code>50.jfoo.ubar.cc.borg.google.com</code>来访问。每当状态改变时，Borg还会把作业的大小和任务的健康信息写入到Chubby，这样负载均衡器就知道如何路由请求了。</p>\n<p>几乎每个任务都有一个内置的HTTP服务器，用来发布任务的健康信息和几千个性能指标（如RPC延时）。Borg监控这些健康检查的URL，重启那些没有立刻响应或返回HTTP错误码的任务。监控工具跟踪其它数据并显示在仪表盘上，当违反服务水平目标（SLO）时报警。</p>\n<p>用户可以使用一个称为Sigma的Web界面来检查他的所有作业的状态，针对某个Cell，或者深入某个作业及任务，检查其资源行为、详细日志、执行历史和最终结果。我们的应用产生大量的日志，它们都会被自动的滚动以避免耗尽硬盘空间。任务退出后，日志会保留一小段时间以帮助调试。如果一个作业没有运行起来，Borg会提供一个挂起原因的标注，以及建议如何修改作业的资源请求，以使其更适合Cell。我们发布了如何使资源请求更容易被调度的指南。</p>\n<p>Borg将所有的作业提交、任务事件、以及每个任务的详细资源使用都记录在Infrastore里。Infrastore是一个可扩展的只读数据存储，通过Dremel[61]提供了类似SQL的交互式接口。这些数据用以支持基于使用量的收费，调试作业和系统故障，以及长期容量规划。公开的Google集群负载数据集[80]也来自于这些数据。</p>\n<p>所有这些特性帮助用户理解和调试Borg及其作业的行为，并帮助我们的SRE实现每人管理超过上万台机器。</p>\n<h1 id=\"3-Borg架构\"><a href=\"#3-Borg架构\" class=\"headerlink\" title=\"3. Borg架构\"></a>3. Borg架构</h1><p>一个Borg的Cell包括一组机器，一个逻辑上集中的控制器，称为Borgmaster，以及运行在每台机器上的称为Borglet的代理进程（见图1）。Borg的组件都是用C++实现的。</p>\n<h2 id=\"3-1-Borgmaster\"><a href=\"#3-1-Borgmaster\" class=\"headerlink\" title=\"3.1 Borgmaster\"></a>3.1 Borgmaster</h2><p>Cell的Borgmaster由两个进程组成：Borgmaster主进程和一个单独的调度进程（§3.2）。Borgmaster主进程处理客户端的RPC，包括修改状态（如创建作业），或提供只读数据（如查找作业）。它还管理着系统中所有对象（机器、任务、Allocs等）的状态，与Borglet通信，并提供一个Web UI（作为Sigma的备份）。</p>\n<p>Borgmaster在逻辑上是单个进程，但实际上有5个副本。每个副本在内存维护着Cell状态的拷贝，该状态同时保存在由这些副本的本地硬盘组成的一个基于Paxos[55]的高可用、分布式存储上。每个Cell中仅有一个选举出来的Master，它同时作为Paxos的Leader和状态修改者，处理所有变更Cell状态的请求，例如提交作业或者结束某台机器上的一个任务。当Cell启动或者上一个Master故障时，新的Master会通过Paxos算法选举出来；新Master会获取一个Chubby锁，这样其它的系统就可以找到它。选举并转移到新的Master通常需要10秒，但在大的Cell里可能需要长达1分钟，因为需要重构一些内存状态。当一个副本从宕机恢复后，它会动态地从其它最新的Paxos副本中重新同步自己的状态。</p>\n<p>某个时刻的Borgmaster状态被称为检查点（Checkpoint），以定期快照加变更日志的形式保存在Paxos存储里。检查点有很多用途：如重建过去任意时刻的Borgmaster状态（例如，在接收一个触发了Borg故障的请求之前，这样就可以用来调试）；极端情况下可以手工修复检查点；构建一个持久的事件日志供日后查询；或用于离线仿真。</p>\n<p>一个高保真的Borgmaster模拟器，称为Fauxmaster，可以读取检查点文件。Fauxmaster的代码拷贝自线上的Borgmaster，还有对Borglet的存根接口。它接收RPC来改变状态，执行操作，例如“调度所有等待的任务”。我们用它来调试故障，像跟在线的Borgmaster那样与模拟器交互，用模拟的Borglet重放检查点文件里的真实交互。用户可以单步执行并观察系统过去确实发生了的状态变化。Fauxmaster也用于容量规划（可以接收多少个此类型的作业？），以及在实际更改Cell配置前做可行性检查（这个变更会导致关键作业异常退出吗？）</p>\n<h2 id=\"3-2-调度\"><a href=\"#3-2-调度\" class=\"headerlink\" title=\"3.2 调度\"></a>3.2 调度</h2><p>当提交一个作业后，Borgmaster会把它保存在持久的Paxos存储上，并将这个作业的所有任务加入等待队列中。调度器异步地扫描等待队列，将任务分配到满足作业约束且有足够资源的机器上（调度是针对任务的，而非作业）。队列扫描从高优先级到低优先级，同优先级则以轮转的方式处理，以保证用户间的公平，并避免队首的大型作业阻塞队列。调度算法有两个部分：<strong>可行性检查</strong>，找到一组可以运行任务的机器；<strong>评分</strong>，从中选择一个合适的机器。</p>\n<p>在可行性检查阶段，调度器会找到一组满足任务约束且有足够可用资源的机器 —— 可用资源包括已经分配给低优先级任务但可以抢占的资源。在评分阶段，调度器确定每台可行机器的适宜性。评分考虑了用户特定的偏好，但主要取决于内置的标准：例如最小化被抢占任务的个数和优先级，选择已经有该任务安装包的机器，尽可能使任务分散在不同的供电和故障域，以及装箱（Packing）质量（在单台机器上混合高、低优先级的任务，以允许高优先级任务在负载尖峰扩容）等。</p>\n<p>Borg早期使用修改过的E-PVM[4]算法来评分。这个算法对异构的资源生成等效的成本值，放置任务的目标是使成本的变化量最小。在实践中，E-PVM会把负载分散到所有机器，为负载尖峰预留出资源 —— 这样的代价是增加了碎片，特别是对需要大部分机器的大型任务而言；我们有时称其为“最差匹配”。</p>\n<p>与之相反的是“最佳匹配”，把机器上的任务塞的越满越好。这就“空”出一些没有用户作业的机器（它们仍运行存储服务），这样放置大型任务就比较直接了。但是，如果用户或Borg错误估计了资源需求，紧实的装箱会对此造成（性能上的）惩罚。这种策略不利于有突发负载的应用，而且对申请少量CPU的批处理作业特别不友好，这些作业申请少量CPU本来是为了更容易被调度执行，并抓住机会使用空闲资源：20%的non-prod 任务申请少于0.1个CPU核。</p>\n<p>我们目前的评分模型是混合的，试图减少搁浅（Stranded）的资源（指一台机器因某些类型资源全部分配了，导致未能分配的其它类型资源）。对我们的负载而言，这个模型比“最佳匹配”提升了3%-5%的装箱效率（以[78]定义的方式评价）。</p>\n<p>如果评分后选中的一台机器仍没有足够的资源来运行新任务，Borg会抢占低优先级的任务，从最低优先级向上逐级抢占，直到资源足够运行该任务。被抢占的任务放回到调度器的等待队列里，而不是被迁移或休眠（注：例外情况是，为Google Compute Engine提供虚拟机的任务会被迁移）。</p>\n<p>任务的启动延迟（从提交作业到任务开始运行之间的时间段）是我们持续重点关注的。这个时间差别很大，中位数约25秒。安装软件包耗费了其中80%的时间：一个已知的瓶颈就是软件包写入时对本地硬盘的竞争。为了减少任务启动时间，调度器偏好将任务分配到已经有必需的软件包（程序及数据）的机器：大部分包是只读的，所以可以被共享和缓存（这是Borg调度器唯一的一种数据局部性支持）。另外，Borg通过树形和类似BT的协议并发地将软件包分发到多个机器上。</p>\n<p>此外，调度器采用多种技术使其能够扩展到数万台机器的Cell（§3.4）。</p>\n<h2 id=\"3-3-Borglet\"><a href=\"#3-3-Borglet\" class=\"headerlink\" title=\"3.3 Borglet\"></a>3.3 Borglet</h2><p>Borglet是部署在Cell每台机器上的本机Borg代理。它负责启动和停止任务；重启失败的任务；通过OS内核设置来管理本地资源；滚动调试日志；把本机的状态上报给Borgmaster和其它监控系统。</p>\n<p>Borgmaster每过几秒就会轮询每个Borglet来获取机器的当前状态，并向其发送请求。这让Borgmaster能控制通信频率，省去了显式的流量控制机制，而且防止了恢复风暴[9]。</p>\n<p>选举出来的Master负责准备发送给Borglet的消息，并根据Borglet的响应更新Cell的状态。为了性能扩展性，每个Borgmaster副本会运行一个无状态的链接分片（Link Shard）来处理部分Borglet的通信；Borgmaster选举后重新计算链接的分片。为了保证容错（Resiliency），Borglet总是汇报全部状态，但是Link Shard只汇报变化值，从而聚合、压缩这些信息，减少Master更新的负担。</p>\n<p>如果某个Borglet几次没有响应轮询请求，该机器会被标记为宕机，其上运行的所有任务会被重新调度到其它机器。如果通讯恢复了，Borgmaster会让这个Borglet杀掉已经被重新调度出去的任务，以避免重复。即便无法与Borgmaster通信，Borglet仍会继续正常运行。所以即使所有的Borgmaster都出故障了，正在运行的任务和服务还会保持运行。</p>\n<h2 id=\"3-4-扩展性\"><a href=\"#3-4-扩展性\" class=\"headerlink\" title=\"3.4 扩展性\"></a>3.4 扩展性</h2><p>我们还没有遇到Borg这种集中式架构的终极扩展上限。我们顺利突破了遇到的每个限制。一个单独的Borgmaster可以管理有数千台机器的Cell，有若干Cell每分钟有10000多个到达的任务。一个繁忙的Borgmaster使用10~14个CPU核以及50GB内存。我们用了几项技术来实现这种扩展性。</p>\n<p>早期版本的Borgmaster使用一个简单的，同步的循环来处理请求、调度任务，并与Borglet通信。为了处理更大的Cell，我们把调度器分离为一个单独的进程，这样它就可以与其它的Borgmaster功能并行执行，而这些其它的功能有多副本以容错。一个调度器副本使用一份缓存的Cell状态拷贝，重复执行下面的操作：从选举出来的Master获取状态改变（包括已分配的和等待中的工作）；更新自己的本地拷贝；执行一遍调度来分配任务；将分配信息发送给Master。Master会接受并应用这些分配，但如果分配不适合（例如，是基于过时的状态做出的），就会等待调度器的下一遍调度。这与Omega[69]使用的乐观并发控制思路很相似，而且我们最近还给Borg添加了对不同负载类型使用不同调度器的功能。</p>\n<p>为了改进响应时间，Borglet使用独立的线程分别进行通信和响应只读RPC。为了更好的性能，我们将这些请求划分给5个Borgmaster副本（§3.3）。总的效果是，UI响应时间的99%分位数小于1秒，而Borglet轮询间隔的95%分位数小于10秒。</p>\n<p>一些提高Borg调度器扩展性的方法如下：</p>\n<p><strong>缓存评分</strong>：计算一台机器的可行性和评分是比较昂贵的，所以Borg会一直缓存评分，直到这台机器或者任务的属性发生了变化 —— 例如，这台机器上的某个任务结束了，一些属性修改了，或者任务的需求改变了。忽略小额的资源变化可以减少缓存失效。</p>\n<p><strong>任务等价类（Equivalence classes）</strong>：一般来说，同一个Borg 作业的任务有相同的请求和约束。任务等价类即一组有相同需求的任务。Borg只对等价类中的一个任务进行可行性检查和评分，而不是对等待的每个任务去检查一遍所有机器的可行性并对可行的机器评分。</p>\n<p><strong>适度随机</strong>：在一个大的Cell中，对所有机器都去计算一遍可行性和评分是很浪费的。调度器会随机地检查机器，直到找到足够多的可用机器来评分，然后从中挑选出最好的一个。这减少了任务启动和退出所需的评分次数及导致的缓存失效，加快了任务分配过程。适度随机有点类似Sparrow[65]的批量采样技术（ying：Sparrow的批量采样考虑的是机器上的任务队列长度），但Borg还处理了优先级、抢占、异构性和安装软件包的成本。</p>\n<p>在我们的实验中（§5），从零开始调度整个Cell的工作负载只要几百秒，但禁用上面几项技术的话，3天都不够。正常情况下，半秒之内就能完成一遍等待队列的在线调度。</p>\n<h1 id=\"4-可用性\"><a href=\"#4-可用性\" class=\"headerlink\" title=\"4. 可用性\"></a>4. 可用性</h1><p><img width=\"600\" src=\"/img/borg-fig-03.png\" alt=\"图3. 不同类型任务的异常退出率及原因（包括抢占、资源不足、机器故障、机器关机、其它）。数据从2013-08-01开始。\"></p>\n<p>大型系统里故障是很常见的[10, 11, 12]。图3展示了在15个样本Cell里任务异常退出的原因分类。在Borg上运行的应用需要能处理这种事件，可采用的技术有多副本、保存持久状态到分布式存储，或定期快照（如果可行的话）等。当然，我们也尽可能的缓解异常事件的影响。例如，Borg提供了：</p>\n<ul>\n<li>自动重新调度异常退出的任务，如果必要，可以放置到另一台机器上去运行</li>\n<li>把一个作业的任务分散到不同的可用域，例如机器、机架、供电域层次，以减少关联失效</li>\n<li>在机器/OS升级等维护活动期间，限制任务受影响的速率，以及同一作业中同时中止的任务的个数</li>\n<li>使用声明式的预期状态表示和幂等的变更操作，这样故障的客户端可以无损地重复提交故障期间漏掉的请求</li>\n<li>对于失联的机器上的任务，限制重新调度的速率，因为大规模的机器故障和网络分区是很难区分的</li>\n<li>回避造成崩溃的 &lt;任务：机器&gt; 组合</li>\n<li>通过不断重新执行日志保存任务（§2.4），恢复已写入本地硬盘的关键中间数据，就算这个日志关联的Alloc已经终止或调度到其它机器上了。用户可以设置系统保持重复尝试多久，通常是几天时间。</li>\n</ul>\n<p>Borg的一个关键设计特性是：就算Borgmaster或者Borglet挂掉了，已经运行的任务还会继续运行下去。不过，保持Master正常运行仍然重要，因为在它退出后就无法提交新的作业，无法更新运行作业的状态，也不能重新调度故障机器上的任务。</p>\n<p>Borgmaster使用多项的技术支持其获得99.99%的实际可用性：多副本应对机器故障；准入控制应对超载；使用简单、底层的工具部署实例，以减少外部依赖。Cell彼此是独立的，减少了关联误操作和故障传播的机会。同时这也是我们不扩大Cell规模的主要考虑，而并非是扩展性的限制。</p>\n<h1 id=\"5-利用率\"><a href=\"#5-利用率\" class=\"headerlink\" title=\"5. 利用率\"></a>5. 利用率</h1><p>Borg的一个主要目标就是有效地利用Google的大量机器（这是一大笔财务投资）：让效率提升几个百分点就能省下几百万美元。这一节讨论和评估了一些Borg使用的策略和技术。</p>\n<h2 id=\"5-1-评估方法\"><a href=\"#5-1-评估方法\" class=\"headerlink\" title=\"5.1 评估方法\"></a>5.1 评估方法</h2><p>作业有部署约束，而且需要处理负载尖峰（尽管比较少见）；机器是异构的；我们回收服务型作业的资源来运行批处理作业。因此，我们需要一个比“平均利用率”更高级的指标来评估我们的策略选择。大量实验后，我们选择了Cell压缩量（Compaction）：给定一个负载，我们不断地移除机器，直到无法容纳该负载，从而得知所需最小的Cell规模。从空集群开始部署该负载并重复多次，以减少特殊情况的影响。终止条件是明确的，对比可以自动化，避免了生成和建模合成负载的陷阱[31]。[78]提供了评估技术的定量比较，其中的细节非常微妙。</p>\n<p>我们不可能在线上Cell进行实验，但是我们用了Fauxmaster来获得高保真的模拟效果，它使用了真实生产Cell和负载的数据，包括所有约束、实际限制、预留和使用量数据（§5.5）。实验数据提取自2014-10-01 14:00 PDT的Borg快照（其它快照也有类似的结论）。我们首先排除了特殊用途的、测试用的、小型的（少于5000台机器）的Cell，然后从剩下的Cell中选取了15个样本，抽样尽量关于Cell的大小均匀分布。</p>\n<p>为了保持机器异构性，在Cell压缩实验中，我们随机地移除机器。为了保持工作负载的异构性，我们保留了所有负载（除了那些绑定到特定机器的服务和存储任务，如Borglet）。我们把那些需要超过原Cell大小一半的作业的硬性限制改成柔性的，允许不超过0.2%的任务一直等待，这是针对一些特别“挑剔”的，只能放置在很少的特定机器上的任务；充分的实验表明结果是可复现的，波动很小。如果需要一个大型的Cell，就把原Cell复制几倍；如果需要更多的Cell，也是复制原Cell。</p>\n<p>每个实验都用不同的随机数种子对每个Cell重复了11次。图中，我们用误差线线来表示所需机器数量的最大和最小值，选择90%分位数作为结果 —— 平均值或中位数不能反映系统管理员所期望的充分把握。我们认为Cell压缩率是一个公平一致的比较调度策略的方法，而且可以直接转化为成本/收益的结果：更好的策略只需要更少的机器来运行相同的负载。</p>\n<p>我们的实验关注于即时的调度（装箱），而不是重放一段长时间的负载记录。部分原因是避免处理开放或闭合的队列模型[71, 79]的困难；部分是传统的完成时间不适用于长时间运行的服务；部分是这样可以提供明确的比较结果；部分是因为我们认为不会对结果产生显著影响；还有部分现实原因，我们发现一次实验使用了20万个Borg CPU核 —— 即便对Google而言，这个成本也不是个小数目。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-04.png\" alt=\"图4. 压缩的效果。15个Cell在压缩后相比原规模的百分比累积分布（CDF）\"></p>\n<p>生产环境中，我们特意保留了一些裕度（Headroom），以应对负载增长、偶然的“黑天鹅”事件、负载尖峰、机器故障、硬件升级、以及大范围的局部故障（如供电母线短路）。图4显示了如果应用Cell压缩，实际的Cell可以压缩到多小。下文的图使用这些压缩后的大小作为基准值。</p>\n<h2 id=\"5-2-Cell共享\"><a href=\"#5-2-Cell共享\" class=\"headerlink\" title=\"5.2 Cell共享\"></a>5.2 Cell共享</h2><p>几乎所有的机器都同时运行prod和non-prod的任务：在共享的Cell里是98%的机器，在所有Borg管理的机器里是83%（有一些是Cell专用的）。</p>\n<p><img src=\"/img/borg-fig-05.png\" alt=\"图5. 将prod和non-prod工作划分到不同的集群将需要更多的机器。两幅图中的百分比都是相对于单个集群所需机器的最少数量而言的\"></p>\n<p>鉴于很多外部组织将面向用户的作业和批处理作业分别运行在不同的集群上，我们检查一下如果我们也这么做会怎样。图5表明，在一个中等大小的Cell上，分开运行prod和non-prod的工作负载将需要增加20-30%的机器。这是因为prod的作业通常会保留一些资源来应对极少发生的负载尖峰，但大多情况下用不到这些资源。Borg回收了这些用不到的资源（§5.5），来运行non-prod的工作，所以总体我们只需要更少的机器。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-06.png\" alt=\"图6. 将用户分开到不同的集群也会需要更多的机器\"></p>\n<p>大部分Borg Cell被数千个用户共享使用。图6展示了为什么要共享。测试中，如果一个用户消费了超过10TiB（或100TiB）的内存，我们就把这个用户的工作负载分离到另一个Cell中。我们目前的共享策略是有效的：即使100TiB的阈值，也需要2-16倍的Cell，增加20-150%的机器。将资源池化再次显著地节省了成本。</p>\n<p>但是，把很多不相关的用户和作业类型放置到同一台机器上可能会造成CPU冲突，我们是否需要更多的机器来补偿？为评估这一点，我们看一下固定机器类型和时钟频率，任务的CPI（Cycles per Instruction，执行每条指令平均所需时钟数，越大则程序执行越慢）在其它环境条件不同的影响下是如何变化的。在这种实验条件下，CPI是一个可比较的指标，而且可以表征性能冲突，因为2倍的CPI意味着一个CPU密集型程序需要2倍的执行时间。数据是在一周内从约12000个随机选择的prod任务获取的，使用了[83]中介绍的硬件剖析工具记录5分钟内的时钟数和指令数，并调整了采样的权重，使CPU时间的每秒都均等处理。结果并非直截了当的：</p>\n<p>（1）我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及这个机器上同时运行的任务个数（基本上独立）；每向一台机器上增加一个任务，就会使其它任务的CPI增加0.3%（从数据拟合的线性模型给出的预测值）；将一台机器的CPU使用量增加10%，就会增加2%弱的CPI。尽管相关性在统计意义上是显著的，也只是解释了CPI变化的5%。还有其它的因素，支配着CPI的变化，例如，应用程序固有的差别，以及特殊的干扰模式[24, 83]。</p>\n<p>（2）比较从共享Cell和只运行几种应用的少数专用Cell获取的CPI采样，我们看到共享Cell里的CPI平均值为1.58（σ=0.35，标准差），专用Cell的CPI平均值是1.53（σ=0.32） —— 也就是说，共享Cell的性能差3%。</p>\n<p>（3）为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差（或许对冲突更敏感的程序会被挪到专用Cell里面去），我们观察了Borglet的CPI。所有Cell的所有机器上都运行着Borglet。我们发现专用Cell里Borlet的CPI平均值是1.20（σ=0.29），而共享Cell里的CPI平均值为1.43（σ=0.45），表明在专用Cell上比在共享Cell上快1.19倍，不过这个结果忽略了专用Cell中的机器负载较轻的因素，即稍偏向专用Cell。</p>\n<p>这些实验表明了仓库级别的性能比较是复杂的，强化了[51]中的观察，但也说明共享并没有显著增加运行程序的开销。</p>\n<p>不过，就算从结果中最差的数据来看，共享还是有益的：比起CPU的降速，共享比各个划分方案都减少了机器，这一点更重要，而且共享的收益适用于包括内存和硬盘等各种资源，不仅仅是CPU。</p>\n<h2 id=\"5-3-大型Cell\"><a href=\"#5-3-大型Cell\" class=\"headerlink\" title=\"5.3 大型Cell\"></a>5.3 大型Cell</h2><p><img src=\"/img/borg-fig-07.png\" alt=\"图7. 将Cell分成更小的规模将需要更多的机器\"></p>\n<p>Google建立了大型Cell，一是为了允许运行大型任务，二是为了减少资源碎片。为测试减少碎片的效果，我们把负载从一个Cell分散多个较小的Cell中 —— 首先将作业随机排列，然后轮流分配到各小的Cell中。图7确认了使用小型Cell需要增加相当多的机器。</p>\n<h2 id=\"5-4-细粒度资源请求\"><a href=\"#5-4-细粒度资源请求\" class=\"headerlink\" title=\"5.4 细粒度资源请求\"></a>5.4 细粒度资源请求</h2><p>Borg用户请求的CPU单位是0.001个核，内存和硬盘的单位是字节。（一个核实际上是一个CPU的超线程，对不同机器类型的性能进行了标准化）。图8表明用户充分利用了细粒度：请求的CPU核和内存数量的“特别偏好值”是很少的，这些资源也没有明显的相关性。这与[68]里的分布非常相似，除了我们在90%分位数及以上的内存请求多一点之外。</p>\n<p>尽管IaaS普遍只提供一组固定尺寸的容器或虚拟机[7, 33]，但不符合我们的需求。为说明这一点，我们对prod的作业和Alloc（§2.4）申请的CPU核和内存分别向上取整到最接近的2的幂，形成固定大小的“桶”，最小的桶有0.5个核和1GiB内存。图9显示一般情况下这样需要增加30-50%的资源。上限的情形是，有的大型任务即便将Cell扩大为未压缩尺寸的四倍也无法容纳，只好为其分配一整台机器。下限是允许这些任务一直等待。（这比[37]给出的将近100%的额外开销要小一些，因为我们支持不止4种尺寸的桶，而且允许CPU和内存分别改变）。</p>\n<h2 id=\"5-5-资源回收\"><a href=\"#5-5-资源回收\" class=\"headerlink\" title=\"5.5 资源回收\"></a>5.5 资源回收</h2><p>作业可以声明一个资源<strong>限额（Limit）</strong>，是每个任务能获得的资源上限。Borg会用它来检查用户是否有足够的配额来接受该作业，并检查某个机器是否有足够的可用资源来运行任务。因为Borg通常会杀死那些试图使用超出内存和硬盘申请值的任务，或者限制其CPU使用量不超过申请值，所以有的用户会为任务申请超过实际需要的资源，就像有的用户会购买超过实际需要的配额一样。另外，一些任务只是偶尔需要使用它们申请的所有资源（例如，在一天中的高峰期或者受到了拒绝服务攻击），但大多时候用不了。</p>\n<p>与其把那些分配出来但暂时没有被用到的资源浪费掉，我们估计了一个任务会用多少资源，然后把剩余的资源回收给那些可以忍受低质量资源的任务，例如批处理作业。这整个过程称为<strong>资源再利用</strong>。这个估值称为任务的资源<strong>预留（Reservation）</strong>。Borgmaster每隔几秒就会根据Borglet获取的细粒度资源使用量信息来计算一次预留值。最初的预留资源被设置为资源限额；在300秒之后，也就过了启动阶段，预留资源会缓慢的下降到实际使用量加上一个安全值。在实际使用量超过它时，预留值会迅速增加。</p>\n<p>Borg调度器使用资源限额来计算prod级任务（注：准确的说，是高优先级的、延迟敏感的任务，见§6.2）是否可以执行（§3.2），所以这些任务不依赖于回收的资源，也与资源超售无关；对于non-prod的任务，运行任务使用的资源在预留值之内，这样新任务就可以使用回收的资源。</p>\n<p>一台机器有可能因为预留（预测）错误而导致运行时资源不足 —— 即使所有的任务都在资源限额之内。如果这种情况发生了，我们会杀掉或者限制non-prod任务，但从来不对prod任务下手。</p>\n<p>图10表明，如果没有资源回收，将需要更多的机器。在一个中等规模的Cell中大概有20%的工作负载（§6.2）使用了回收的资源。</p>\n<p>图11可以看到更多的细节，其中有预留值、使用量与限额的比例。当资源紧张时，超出内存限额的任务首先会被抢占，不论优先级有多高，所以很少有任务超过内存限额。另一方面，CPU使用量是可以被轻易限制住的，所以短时的毛刺虽然会导致使用量超过预留值，但这没什么损害。</p>\n<p>图11表明了资源回收可能还过于保守：在预留值和实际使用量中间还有一大段差距。为了测试这一点，我们选择了一个线上Cell，（第一周作为参照基准，）第二周将其估计算法的参数调整为比较<strong>激进</strong>的设置，即把安全裕度留小一点；第三周采取的是介于激进和基准之间的<strong>适度</strong>策略，最后一周恢复到基准策略。</p>\n<p><img src=\"/img/borg-fig-08-09-10-11.png\" alt=\"\"></p>\n<p>图12展示了结果。第二周的预留值明显更接近实际使用量，第三周稍大一点，最大的是第一周和第四周。和预期的一样，第二周和第三周的OOM比率轻微地增加了（注：第3周后期的异常情况与本次实验无关）。在评估了这个结果后，我们认为利大于弊，于是在其它Cell上也采用了<strong>适度</strong>策略的资源回收参数。</p>\n<p><img src=\"/img/borg-fig-12.png\" alt=\"图12. 更激进的资源估计可以回收更多资源，但会稍增加OOM事件\"></p>\n<h1 id=\"6-隔离\"><a href=\"#6-隔离\" class=\"headerlink\" title=\"6. 隔离\"></a>6. 隔离</h1><p>50%的机器运行了9个以上的任务；处于90%分位数的机器则有大约25个任务，4500个线程[83]。虽然在应用之间共享机器会增加利用率，但也需要一个比较好的机制来保证任务之间不产生干扰。这同时适用于安全和性能两个方面。</p>\n<h2 id=\"6-1-安全隔离\"><a href=\"#6-1-安全隔离\" class=\"headerlink\" title=\"6.1 安全隔离\"></a>6.1 安全隔离</h2><p>我们使用Linux的chroot作为同一台机器上不同任务之间的主要安全隔离机制。仅当某台机器有用户运行的任务时，为了允许远程调试，我们以前会自动分发（或废除）SSH秘钥，使用户可以访问这台机器。对大多数用户来说，现在被替换为<code>borgssh</code>命令，这个程序和Borglet协同构建一个SSH通道，连接到与任务运行在同一个chroot和cgroup下的Shell，这样限制就更加严格了。</p>\n<p>Google的AppEngine（GAE）[38]和Google Compute Engine（GCE）使用VM和安全沙箱技术运行外部的软件。我们把每个运行在KVM进程中的VM作为一个Borg任务来运行。</p>\n<h2 id=\"6-2-性能隔离\"><a href=\"#6-2-性能隔离\" class=\"headerlink\" title=\"6.2 性能隔离\"></a>6.2 性能隔离</h2><p>早期的Borglet使用了一种相对原始的资源隔离措施：事后检查内存、硬盘和CPU使用量，终止使用过多内存和硬盘的任务，或者降低使用过多CPU的任务的Linux CPU优先级。不过，一些粗暴的任务还是能很容易地影响到同台机器上其它任务的性能，于是有的用户就会多申请资源来让Borg减少与其共存的任务数量，降低了资源利用率。资源回收可以弥补一些损失，但不是全部，因为涉及到安全裕度。在极端情况下，用户会要求使用专属的机器或者Cell。</p>\n<p>目前，所有Borg任务都运行在基于Linux cgroup的资源容器[17, 58, 62]里。Borglet控制着这些容器的设置。有了OS内核的帮助，控制能力得到了改善。即使这样，偶尔还是有低级别的资源冲突发生（例如内存带宽或L3缓存污染），见[60, 83]。</p>\n<p>为了应对超载和超售，Borg任务有一个应用类别（appclass）。最重要的区分是延迟敏感（LS）的应用和本文中称为批处理（batch）的其它类别。LS任务包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS任务得到最高优待，可以暂时让批处理任务等待几秒种。</p>\n<p>第二个区分是：<strong>可压缩</strong>资源（例如CPU，硬盘I/O带宽），都是基于速率的，可以通过降低一个任务的服务质量而不是杀死它来回收；<strong>不可压缩</strong>资源（例如内存、硬盘空间），这些一般来说不杀掉任务是没办法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会开始杀死任务，从低优先级开始，直到能满足剩下的资源预留。如果机器用完了可压缩资源，Borglet会限制使用量（偏好LS任务），这样不用杀死任何任务也能处理短期负载尖峰。如果情况没有改善，Borgmaster会从这个机器上移除一个或多个任务。</p>\n<p>Borglet有一个用户态的控制循环，负责以下操作：为容器确定内存量，prod任务基于预测值，而non-prod任务则基于内存压力；处理来自内核的OOM事件；当任务试图分配超过其自身限额的内存时，或者超售的机器上确实耗尽内存时，都会杀死任务。Linux激进的文件缓存让我们的实现复杂得多，因为需要精确计算内存使用量。</p>\n<p>为了增强性能隔离，LS任务可以预留整个物理CPU核，以阻止别的LS任务来使用它们。批处理任务被允许运行在任何核上，但是相比LS任务，批处理任务只分配了很少的调度份额。Borglet动态地调整贪婪的LS任务的资源上限，以保证它们不会把批处理任务饿上几分钟，必要时有选择的使用CFS带宽控制[75]；仅用份额来表示是不够的，因为我们有多个优先级。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-13.png\" alt=\"图13. 调度延迟与负载的关系。即一个就绪线程需要等待超过1 ms才能运行的比率，与机器繁忙程度的关系。每组数据条中，左侧是延迟敏感的任务，右侧是批处理任务。只有很少的比率需要等5 ms以上，超过10 ms就极少了。这是2013年12月从一个代表性的Cell中获取的一个月的数据；误差线是每天的波动\"></p>\n<p>同Leverich[56]一样，我们发现标准的Linux CPU调度器（CFS）需要大幅调整才能同时支持低延迟和高利用率。为了减少调度延迟：我们内部版本的CFS对每个<code>cgroup</code>都有单独的负载历史[16]；允许LS任务抢占批处理任务；当一个CPU有多个就绪的LS任务时，减少其调度数量。幸运的是，我们的大多应用使用每个线程处理一个请求的模型，这样就缓解了长期的负载不均衡。我们节俭地使用<code>cpusets</code>给有特别严格的延迟需求的应用分配CPU核。这些努力的一些效果展示在图13中。我们持续在这方面投入，增加感知NUMA、超线程、能耗（如[81]）的线程放置和CPU管理，改进Borglet的控制精确度。</p>\n<p>任务被允许在其上限之内消费资源。大部分任务还允许去使用超出上限的可压缩资源，例如CPU，以利用空闲资源。只有5%的LS任务禁止这么做，主要是为了改善可预测性；小于1%的批处理任务也禁止了。使用超量内存默认是被禁止的，因为这会增加任务被杀掉的概率，不过即使这样，10%的LS任务解除了这个限制，79%的批处理任务也解除了，因为这是MapReduce框架的默认设置。这补偿了资源回收（§5.5）的后果。批处理任务很乐意使用空闲的或回收的内存：大多情况下这样运作得很好，即使偶尔批处理任务会被急需资源的LS任务杀掉。</p>\n<h1 id=\"7-相关工作\"><a href=\"#7-相关工作\" class=\"headerlink\" title=\"7. 相关工作\"></a>7. 相关工作</h1><p>数十年来，资源调度已经在多种场景得到了研究，如广域高性能计算网格、工作站网络、和大规模服务器集群等。我们这里只关注最相关的大规模服务器集群这个场景。</p>\n<p>最近的一些研究分析了来自于Yahoo!、Google和Facebook的集群记录数据[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载固有的异构性和大规模带来的挑战。[69]包含了对集群管理器架构的分类。</p>\n<p>Apache Mesos[45]将资源管理和任务放置功能拆分到一个集中资源管理器（类似于去掉调度器的Bormaster）和多种“框架”（比如Hadoop[41]和Spark[73]）之间，两者基于供应（Offer）机制交互。Borg则把这些功能集中在一起，使用基于请求的机制，而且扩展性相当好。DRF[29, 35, 36, 66]最初是为Mesos开发的；Borg则使用优先级和准入配额来替代。Mesos开发者已经宣布了他们扩展Mesos的雄心壮志：预测性资源分配和回收，以及解决[69]中发现的一些问题。</p>\n<p>YARN[76]是一个针对Hadoop的集群管理器。每个应用都有一个另外的管理器，与中央资源管理器谈判所需资源；这跟大约2008年开始Google的MapReduce作业已经使用的向Borg获取资源的模式如出一辙。YARN的资源管理器最近才支持容错。一个相关的开源项目是Hadoop Capacity Scheduler（基于容量的调度器）[42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近扩展支持了多种资源类型、优先级、抢占和高级准入控制[21]。Tetris（俄罗斯方块）研究原型[40]支持完成时间感知的作业装箱。</p>\n<p>Facebook的Tupperware[64]，是一个在集群中调度<code>cgroup</code>容器的类Borg系统；只有少量细节披露出来了，看起来它也提供了某种形式的资源回收功能。Twitter开源的Aurora[5]是一个类似Borg的，用于长期运行服务的调度器，运行与Mesos之上，其配置语言和状态迁移与Borg类似。</p>\n<p>微软的Autopilot[48]为其集群提供了“自动化的软件供应和部署；系统监控；以及采取修复行为处理软硬件故障”的功能。Borg生态系统提供了相似的特性，不过篇幅所限，不再深入讨论；作者Isaard概括了很多我们也赞成的最佳实践。</p>\n<p>Quincy[49]使用了一个网络流模型来提供公平性和数据局部性感知的调度，应用在几百个节点的集群的数据处理DAG上。Borg使用配额和优先级在用户间共享数据，可以扩展到上万台机器。Quincy可以直接处理执行图，而Borg需要在其上层另外构建。</p>\n<p>Cosmos[44]聚焦在批处理上，强调了用户可以公平获取他们已经捐献给集群的资源。每个作业分别有一个管理器来获取资源；只有很少公开的细节。</p>\n<p>微软的Apollo系统[13]为每个短期批处理作业分别使用单独的调度器，以获得高吞吐量，其集群规模看起来与Borg的Cell相当。Apollo投机地执行低优先级后台任务来提升资源利用率，代价是有时有长达多日的队列延迟。Apollo的各节点都一个关于开始时间的预测矩阵，其行列分别为CPU和内存两个资源维度。调度器会综合开始时间、估计的启动开销、获取远程数据的开销来决定部署位置，并用一个随机延时来减少冲突。Borg使用的是中央调度器，基于之前的分配来决定部署位置，可以处理更多的资源维度，而且更关注高可用、长期运行的应用；Apollo也许能处理比Borg更高的任务到达率。</p>\n<p>阿里巴巴的伏羲（Fuxi）[84]支持数据分析的负载，从2009年就开始运行了。类似Borgmaster，一个集中的FuxiMaster（也做了容错多副本）从节点上获取可用资源的信息、接受应用的资源请求，然后匹配两者。伏羲的增量调度策略与Borg的任务等价类是相反的：伏羲用最新的可用资源匹配等待队列里的任务（ying：Borg是用任务匹配资源）。类似Mesos，伏羲允许定义“虚拟资源”类型。只有对合成工作负载的实验结果是公开的。</p>\n<p>Omega[69]支持多个并发的调度器，粗略相当于没有持久存储和链接分片的Borgmaster。Omega调度器使用乐观并发控制的方式去操作一个共享的集群预期的和观察的状态表示。集群状态存储在一个集中持久存储中，用单独的连接组件与Borglet同步。Omage架构设计为支持多种不同的工作负载，它们有自己特定的RPC接口、状态迁移和调度策略（例如长期运行的服务、多个框架批处理作业、如集群存储这样的基础服务、Google云平台上的虚拟机）。相反，Borg提供了一种通用方案，同样的RPC接口、状态迁移、调度策略，为支持多种不同的负载，其规模和复杂度逐渐增加，但目前来说可扩展性还不算一个问题（§3.4）。</p>\n<p>Google的开源项目Kubernetes系统[53]把应用放在Docker容器内[28]，再分发到多个机器上。它即可以运行在物理机上（像Borg那样），也可以运行在多个云供应商（比如Google Compute Engine，GCE）的主机上。Kubernetes正在快速开发中，它的很多开发者也参与开发了Borg。Google提供了一个托管的版本，称为Google Container Engine（GKE）[39]。我们会在下一节里面讨论Kubernetes从Borg中学到了哪些东西。</p>\n<p>在高性能计算社区对这个领域有长期的研究传统（如Maui, Moab, Platform LSF[2, 47, 50]）；但是这和Google Cell所面对的规模、工作负载、容错性是不同的。总体而言，为达到高用率，这些系统需要让任务在一个很长的队列中等待。</p>\n<p>虚拟化供应商，例如VMware[77]，和数据中心方案供应商，例如HP和IBM[46]提供了典型情况下可以扩展到一千台机器规模的集群管理解决方案。另外，一些研究小组的原型系统以多种方式提升了调度质量（如[25, 40, 72, 74]）。</p>\n<p>最后，正如我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]指出，失效预案、多租户、健康检查、准入控制，以及可重启性对实现单个运维人员管理更多的机器的目标是必要的。Borg的设计哲学也是这样的，而且支撑了我们的每个SRE管理数万台机器。</p>\n<blockquote>\n<p>Borg从它的前任继承了很多东西，即我们内部的全局工作队列（Global Work Queue）系统，它最初是由Jeff Dean，Olcan Sercinoglu, 和Percy Liang开发的。<br>Conder[85]曾被广泛应用于收集空闲资源，其ClassAds机制[86]支持声明式的语句和自动属性匹配。</p>\n</blockquote>\n<h1 id=\"8-经验教训和未来工作\"><a href=\"#8-经验教训和未来工作\" class=\"headerlink\" title=\"8. 经验教训和未来工作\"></a>8. 经验教训和未来工作</h1><p>在这一节中我们介绍了十多年来我们在生产环境运行Borg得到的定性的经验教训，然后介绍设计Kubernetes[53]是如何吸收这些经验的。</p>\n<h2 id=\"8-1-教训\"><a href=\"#8-1-教训\" class=\"headerlink\" title=\"8.1 教训\"></a>8.1 教训</h2><p>我们从一些Borg作为反面警示的特性开始，然后介绍Kubernetes的替代方案。</p>\n<p><strong>将作业作为唯一的任务分组机制比较受限</strong></p>\n<p>Borg没有内置的方法将多个作业组成单个实体来管理，或将相关的服务实例关联起来（例如，测试通道和生产通道）。作为一个技巧，用户把他们的服务拓扑编码到作业的名字中，然后构建了更高层的管理工具来解析这些名字。这个问题的另外一面是，没办法指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级或改变作业的实例数。</p>\n<p>为了避免这些困难，Kubernetes不再使用作业这个概念，而是用标签（Label）来组织它的调度单元（Pod）。标签是任意的键值对，用户可以对系统的任何对象打上标签。Borg作业可以等效地通过对一组Pod打上 &lt;作业：作业名&gt; 这样的标签来实现。其它有用的分组方式也可以用标签来表示，例如服务、层级、发布类型（如，生产、就绪、测试）。Kubernetes用标签查询的方式来选取待操作的目标对象。这样就比固定的作业分组更加灵活。</p>\n<p><strong>同一台机器的任务共享一个IP太复杂了</strong></p>\n<p>Borg中，同一台机器上的所有任务都使用主机的同一个IP地址，共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；任务必须先声明它需要多少端口，而且需要支持启动时传入可用端口号；Borglet必须强制端口隔离；命名和RPC系统必须像IP一样处理端口（ying：最后这一点我认为是必要的）。</p>\n<p>多亏了Linux的namespace、虚拟机、IPv6和软件定义网络SDN的出现，Kubernetes可以用一种更用户友好的方式来消解这些复杂性：每个Pod和Service都自己的IP地址，允许开发者选择端口而不是让他们的软件支持基础设施的分配，这也消除了基础设施管理端口的复杂性。</p>\n<p><strong>给资深用户优化而忽略了初级用户</strong></p>\n<p> Borg提供了一大堆针对“资深用户”的特性，这样他们就可以仔细地调节他们程序的运行方式（BCL规范约有230个参数）：开始的目的是为了支持Google的大型资源用户，提升他们的效率会带来显著的效益。但不幸的是，这么复杂的API让初级用户用起来很复杂，而且限制了API的演化。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中决定合理的配置。由于应用支持容错，实验可以自由进行：即使自动化出了问题，也只是小麻烦，不会导致灾难。</p>\n<h2 id=\"8-2-经验\"><a href=\"#8-2-经验\" class=\"headerlink\" title=\"8.2 经验\"></a>8.2 经验</h2><p>另一方面，有不少Borg的设计特性是非常有益的，而且经历了时间考验。</p>\n<p><strong>Alloc是有用的</strong></p>\n<p>Borg的Alloc抽象适用于广泛使用的保存日志模式（§2.4），另一个流行的模式是：一个简单的数据加载任务定期更新Web服务器使用的数据。Alloc和软件包机制允许这些辅助服务由不同的小组开发。Kubernetes对应于Alloc的概念是Pod，它是对一个或多个容器的资源封装，其中的容器共享Pod的资源，而且总是被调度到同一台机器上。Kubernetes使用Pod里的辅助容器来替代Alloc里面的任务，不过思路是一样的。</p>\n<p><strong>集群管理不只是任务管理</strong></p>\n<p>虽然Borg的主要角色是管理任务和机器的生命周期，但Borg上的应用还从其它的集群服务中收益良多，例如名字服务和负载均衡。Kubernetes用Service这个抽象概念来支持名字服务和负载均衡：Service有一个名字和用标签选出的多个Pod的动态集合。集群中的任何容器都可以通过Service名连接到该服务。幕后，Kubernetes自动将连接到该Service的负载分散到与其标签匹配的Pod之间，由于Pod挂掉后会被重新调度到其它机器上，Kubernetes还会跟踪这些Pod的位置。</p>\n<p><strong>自省是至关重要的</strong></p>\n<p>虽然Borg总体上是工作良好的，但出了问题后，定位根本原因是非常有挑战性的。Borg的一个关键设计选择是把所有的调试信息暴露给用户而不是隐藏起来：Borg有几千个用户，所以“自助”是调试的第一步。虽然一些用户的依赖项让我们难以废弃一些特性或修改内部策略，但这还是成功的，我们还没找到其它实际的替代方式。为管理大量的数据，我们提供了多个层次的UI和调试工具，这样用户就可以快速定位与其作业相关的异常事件，深入挖掘来自其应用和基础设施本身的详细事件和错误日志。</p>\n<p>Kubernetes也计划引入Borg的大部分自省技术。和Kubernetes一起发布了很多工具，比如用于资源监控的cAdvisor[15]，它基于Elasticsearch/Kibana[30]和Fluentd[32]聚合日志。Master可以用来查询某个对象的状态快照。Kubernetes提供了一致机制，所有可以记录事件的组件（例如，被调度的Pod、出错的容器）都可以被客户端访问。</p>\n<p><strong>Master是分布式系统的核心</strong></p>\n<p>Borgmaster最初设计为一个单体的系统，随着时间发展，它演变成了一组服务生态系统的核心。用户作业管理的管理是由这些服务协同完成的。比如，我们把调度器和主要的UI（Sigma）分离成单独的进程，增加了一组服务，包括准入控制、纵向和横向扩展、任务重新装箱、周期性作业提交（cron）、工作流管理，用于离线查询的系统活动归档等。总体而言，这让我们能扩展工作负载和特性集合，但无需牺牲性能和可维护性。</p>\n<p>Kubernetes的架构走的更远一些：它的核心是一个仅处理请求和操作底层状态目标的API服务。集群管理逻辑构建为一个小型的、可组合的微服务，作为API服务的客户端，如故障后仍维持Pod副本个数在期望值的副本管理器，以及管理机器生命周期的节点管理器。</p>\n<h2 id=\"8-3-总结\"><a href=\"#8-3-总结\" class=\"headerlink\" title=\"8.3 总结\"></a>8.3 总结</h2><p>在过去十年间，所有几乎所有的Google集群负载都迁移到了Borg上。我们仍在持续改进它，并把经验应用到了Kubernetes上。</p>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>这篇文章的作者负责撰写文章，并完成了评估实验。几十位设计、实现和维护Borg组件和生态系统的工程师才是它成功的关键。我们在这里列出直接参与设计、实现和维护Borgmaster及Borglet的人员。如果有遗漏，我们深表歉意。</p>\n<p>早期版本的Borgmaster设计和实现人员有：Jeremy Dion和Mark Vandevoorde，以及Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu 和 Monika Henzinger。早期版本的Borglet主要是由Paul Menage设计和实现的（ying：见[62]）。</p>\n<p>后续的参与者包括：Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, Onufry Wojtaszczyk, Patrick Johnson, Pedro Valenzuela, Piotr Witusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, Tomasz Wozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.</p>\n<p>Borg SRE团队也是非常重要的，包括：Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, 和 Viraj Alankar。Borg配置语言（BCL）和<code>borgcfg</code>工具最初是Marcel van Lohuizen 和 Robert Griesemer开发的。</p>\n<blockquote>\n<p>我们不小心漏掉了 Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, 和 Pavanish Nirula。</p>\n</blockquote>\n<p>谢谢我们的审稿人（尤其是Eric Brewer, Malte Schwarzkopf 和 Tom Rodeheffer），以及我们的导师Christos Kozyrakis，对这篇论文的反馈。</p>\n<h1 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h1><p>2015-04-23</p>\n<p>定稿后，我们发现了若干无意的疏漏和歧义。（ying：译文已将勘误内容放置到对应章节。补充的两条参考文献序号有冲突，放在了列表之后，并继续编号为85，86）</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] O. A. Abdul-Rahman and K. Aida. <strong>Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon.</strong>In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.<br>[2] Adaptive Computing Enterprises Inc., Provo, UT. <strong>Maui Scheduler Administrator’s Guide</strong>, 3.2 edition, 2011.<br>[3] T. Akidau, A. Balikov, K. Bekiroğlu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. <strong>MillWheel: fault-tolerant stream processing at internet scale</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.<br>[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. <strong>An opportunity cost approach for job assignment in a scalable computing cluster</strong> IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.<br>[5] <strong>Apache Aurora</strong>. <a href=\"http://aurora.incubator.apache.org/\" target=\"_blank\" rel=\"external\">http://aurora.incubator.apache.org/</a>, 2014.<br>[6] <strong>Aurora Configuration Tutorial</strong>. <a href=\"https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/\" target=\"_blank\" rel=\"external\">https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/</a>, 2014.<br>[7] AWS. <strong>Amazon Web Services VM Instances</strong>. <a href=\"http://aws.amazon.com/ec2/instance-types/\" target=\"_blank\" rel=\"external\">http://aws.amazon.com/ec2/instance-types/</a>, 2014.<br>[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. <strong>Megastore: Providing scalable, highly available storage for interactive services</strong> In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.<br>[9] M. Baker and J. Ousterhout. <strong>Availability in the Sprite distributed file system</strong> Operating Systems Review,25(2):95–98, Apr. 1991.<br>[10] L. A. Barroso, J. Clidaras, and U. Hölzle. <strong>The datacenter as a computer: an introduction to the design of warehouse-scale machines</strong> Morgan Claypool Publishers, 2nd edition, 2013.<br>[11] L. A. Barroso, J. Dean, and U. Holzle. <strong>Web search for a planet: the Google cluster architecture</strong> In IEEE Micro, pages 22–28, 2003.<br>[12] I. Bokharouss. <strong>GCL Viewer: a study in improving the understanding of GCL programs</strong> Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.<br>[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. <strong>Apollo: scalable and coordinated scheduling for cloud-scale computing</strong> In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.<br>[14] M. Burrows. <strong>The Chubby lock service for loosely-coupled distributed systems</strong> In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.<br>[15] <strong>cAdvisor</strong>. <a href=\"https://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">https://github.com/google/cadvisor</a>, 2014<br>[16] <strong>CFS per-entity load patches</strong>. <a href=\"http://lwn.net/Articles/531853\" target=\"_blank\" rel=\"external\">http://lwn.net/Articles/531853</a>, 2013.<br>[17] <strong>cgroups</strong>. <a href=\"http://en.wikipedia.org/wiki/Cgroups\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Cgroups</a>, 2014.<br>[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. <strong>FlumeJava: easy, efficient data-parallel pipelines</strong> In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.<br>[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. <strong>Bigtable: a distributed storage system for structured data</strong> ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.<br>[20] Y. Chen, S. Alspaugh, and R. H. Katz. <strong>Design insights for MapReduce from diverse production workloads</strong> Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.<br>[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. <strong>Reservation-based scheduling: if you’re late don’t blame us!</strong>In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.<br>[22] J. Dean and L. A. Barroso. <strong>The tail at scale</strong> Communications of the ACM, 56(2):74–80, Feb. 2012.<br>[23] J. Dean and S. Ghemawat. <strong>MapReduce: simplified data processing on large clusters</strong> Communications of the ACM, 51(1):107–113, 2008.<br>[24] C. Delimitrou and C. Kozyrakis. <strong>Paragon: QoS-aware scheduling for heterogeneous datacenters</strong> In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.<br>[25] C. Delimitrou and C. Kozyrakis. <strong>Quasar: resource-efficient and QoS-aware cluster management</strong> In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.<br>[26] S. Di, D. Kondo, and W. Cirne. <strong>Characterization and comparison of cloud versus Grid workloads</strong> In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.<br>[27] S. Di, D. Kondo, and C. Franck. <strong>Characterizing cloud applications on a Google data center</strong> In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.<br>[28] <strong>Docker Project</strong>. <a href=\"https://www.docker.io/\" target=\"_blank\" rel=\"external\">https://www.docker.io/</a>, 2014.<br>[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. <strong>No justified complaints: on fair sharing of multiple resources</strong> In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.<br>[30] <strong>ElasticSearch</strong>. <a href=\"http://www.elasticsearch.org\" target=\"_blank\" rel=\"external\">http://www.elasticsearch.org</a>, 2014.<br>[31] D. G. Feitelson. <strong>Workload Modeling for Computer Systems Performance Evaluation</strong> Cambridge University Press, 2014.<br>[32] <strong>Fluentd</strong>. <a href=\"http://www.fluentd.org/\" target=\"_blank\" rel=\"external\">http://www.fluentd.org/</a>, 2014.<br>[33] <strong>GCE. Google Compute Engine</strong>. <a href=\"http://cloud.google.com/products/compute-engine/\" target=\"_blank\" rel=\"external\">http://cloud.google.com/products/compute-engine/</a>, 2014.<br>[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. <strong>The Google File System</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.<br>[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. <strong>Dominant Resource Fairness: fair allocation of multiple resource types</strong> In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.<br>[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. <strong>Choosy: max-min fair sharing for datacenter jobs with constraints</strong> In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.<br>[37] D. Gmach, J. Rolia, and L. Cherkasova. <strong>Selling T-shirts and time shares in the cloud</strong> In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.<br>[38] <strong>Google App Engine</strong>. <a href=\"http://cloud.google.com/AppEngine\" target=\"_blank\" rel=\"external\">http://cloud.google.com/AppEngine</a>, 2014.<br>[39] <strong>Google Container Engine (GKE)</strong>. <a href=\"https://cloud.google.com/container-engine/\" target=\"_blank\" rel=\"external\">https://cloud.google.com/container-engine/</a>, 2015.<br>[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. <strong>Multi-resource packing for cluster schedulers</strong> In Proc. ACM SIGCOMM, Aug. 2014.<br>[41] <strong>Apache Hadoop Project</strong>. <a href=\"http://hadoop.apache.org/\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/</a>, 2009.<br>[42] <strong>Hadoop MapReduce Next Generation – Capacity Scheduler</strong>. <a href=\"http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html</a>, 2013.<br>[43] J. Hamilton. <strong>On designing and deploying internet-scale services</strong>. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.<br>[44] P. Helland. <strong>Cosmos: big data and big challenges</strong>. <a href=\"http://research.microsoft.com/en-us/events/fs2011/helland_cosmos_big_data_and_big_challenges.pdf\" target=\"_blank\" rel=\"external\">http://research.microsoft.com/en-us/events/fs2011/ helland_cosmos_big_data_and_big_challenges.pdf</a>, 2011.<br>[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. <strong>Mesos: a platform for fine-grained resource sharing in the data center</strong>. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.<br>[46] <strong>IBM Platform Computing</strong>. <a href=\"http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/index.html\" target=\"_blank\" rel=\"external\">http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/ index.html</a>.<br>[47] S. Iqbal, R. Gupta, and Y.-C. Fang. <strong>Planning considerations for job scheduling in HPC clusters</strong> Dell Power Solutions, Feb. 2005.<br>[48] M. Isaard. <strong>Autopilot: Automatic data center management</strong> ACM SIGOPS Operating Systems Review, 41(2), 2007.<br>[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. <strong>Quincy: fair scheduling for distributed computing clusters</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.<br>[50] D. B. Jackson, Q. Snell, and M. J. <strong>Clement. Core algorithms of the Maui scheduler</strong> In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.<br>[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. <strong>Measuring interference between live datacenter applications</strong> In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.<br>[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. <strong>An analysis of traces from a production MapReduce cluster</strong> In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.<br>[53] <strong>Kubernetes</strong>. <a href=\"http://kubernetes.io\" target=\"_blank\" rel=\"external\">http://kubernetes.io</a>, Aug. 2014.<br>[54] <strong>Kernel Based Virtual Machine</strong>. <a href=\"http://www.linux-kvm.org\" target=\"_blank\" rel=\"external\">http://www.linux-kvm.org</a>.<br>[55] L. Lamport. <strong>The part-time parliament</strong> ACM Trans. on Computer Systems, 16(2):133–169, May 1998.<br>[56] J. Leverich and C. Kozyrakis. <strong>Reconciling high server utilization and sub-millisecond quality-of-service</strong> In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.<br>[57] Z. Liu and S. Cho. <strong>Characterizing machines and workloads on a Google cluster</strong> In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.<br>[58] <strong>Google LMCTFY project (let me contain that for you)</strong>. <a href=\"http://github.com/google/lmctfy\" target=\"_blank\" rel=\"external\">http://github.com/google/lmctfy</a>, 2014.<br>[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. <strong>Pregel: a system for large-scale graph processing</strong> In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.<br>[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. <strong>Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations</strong> In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.<br>[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. <strong>Dremel: interactive analysis of web-scale datasets</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.<br>[62] P. Menage. <strong>Linux control groups</strong>. <a href=\"http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt\" target=\"_blank\" rel=\"external\">http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt</a>, 2007–2014.<br>[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. <strong>Towards characterizing cloud backend workloads: insights from Google compute clusters</strong> ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.<br>[64] A. Narayanan. <strong>Tupperware: containerized deployment at Facebook</strong>. <a href=\"http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook\" target=\"_blank\" rel=\"external\">http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook</a>, June 2014.<br>[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. <strong>Sparrow: distributed, low latency scheduling</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.<br>[66] D. C. Parkes, A. D. Procaccia, and N. Shah. <strong>Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities</strong> In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.<br>[67] <strong>Protocol buffers</strong>. <a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\" rel=\"external\">https://developers.google.com/protocol-buffers/</a>, and <a href=\"https://github.com/google/protobuf/\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/</a>, 2014.<br>[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. <strong>Heterogeneity and dynamicity of clouds at scale: Google trace analysis</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.<br>[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. <strong>Omega: flexible, scalable schedulers for large compute clusters</strong> In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.<br>[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. <strong>Modeling and synthesizing task placement constraints in Google compute clusters</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.<br>[71] E. Shmueli and D. G. Feitelson. <strong>On simulation and design of parallel-systems schedulers: are we doing the right thing?</strong> IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.<br>[72] A. Singh, M. Korupolu, and D. Mohapatra. <strong>Server-storage virtualization: integration and load balancing in data centers</strong> In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.<br>[73] <strong>Apache Spark Project</strong>. <a href=\"http://spark.apache.org/\" target=\"_blank\" rel=\"external\">http://spark.apache.org/</a>, 2014.<br>[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. <strong>Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.<br>[75] P. Turner, B. Rao, and N. Rao. <strong>CPU bandwidth control for CFS</strong> In Proc. Linux Symposium, pages 245–254, July 2010.<br>[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. <strong>Apache Hadoop YARN: Yet Another Resource Negotiator</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.<br>[77] <strong>VMware VCloud Suite</strong>. <a href=\"http://www.vmware.com/products/vcloud-suite/\" target=\"_blank\" rel=\"external\">http://www.vmware.com/products/vcloud-suite/</a>.<br>[78] A. Verma, M. Korupolu, and J. Wilkes. <strong>Evaluating job packing in warehouse-scale computing</strong> In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.<br>[79] W. Whitt. <strong>Open and closed models for networks of queues</strong> AT&amp;T Bell Labs Technical Journal, 63(9), Nov. 1984.<br>[80] J. Wilkes. <strong>More Google cluster data</strong>. <a href=\"http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html\" target=\"_blank\" rel=\"external\">http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html</a>, Nov. 2011.<br>[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. <strong>HaPPy: Hyperthread-aware power profiling dynamically</strong> In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.<br>[82] Q. Zhang, J. Hellerstein, and R. Boutaba. <strong>Characterizing task usage shapes in Google’s compute clusters</strong> In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.<br>[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. <strong>CPI2: CPU performance isolation for shared compute clusters</strong> In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.<br>[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. <strong>Fuxi: a fault-tolerant resource management and job scheduling system at internet scale</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.<br>[85] Michael Litzkow, Miron Livny, and Matt Mutka. <strong>Condor - A Hunter of Idle Workstations</strong> In Proc. Int’l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.<br>[86] Rajesh Raman, Miron Livny, and Marvin Solomon. <strong>Matchmaking: Distributed Resource Management for High Throughput Computing</strong> In Proc. Int’l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.    </p>\n","site":{"data":{}},"excerpt":"<p>发表于EuroSys 2015的 <strong><em>Large-scale cluster management at Google with Borg</em></strong> 详细介绍了Google的Borg资源管理器。已经有网友“难易（HardySimpson）” 翻译了此文，这里对其稍作修订。之前读过两三遍此文，每遍都感觉有新的体会，这次修订就是为了更仔细地读一遍。</p>","more":"<hr>\n<h1 id=\"Large-scale-cl-uster-management-at-Google-with-Borg\"><a href=\"#Large-scale-cl-uster-management-at-Google-with-Borg\" class=\"headerlink\" title=\"Large-scale cl uster management at Google with Borg\"></a>Large-scale cl uster management at Google with Borg</h1><h1 id=\"使用Borg在Google管理大规模集群\"><a href=\"#使用Borg在Google管理大规模集群\" class=\"headerlink\" title=\"使用Borg在Google管理大规模集群\"></a>使用Borg在Google管理大规模集群</h1><p>作者：Abhishek Vermay, Luis Pedrosaz, Madhukar Korupolu, David Oppenheimer, Eric Tune, John Wilkes</p>\n<p>EuroSys’15, <a href=\"http://dx.doi.org/10.1145/2741948.2741964\" target=\"_blank\" rel=\"external\">http://dx.doi.org/10.1145/2741948.2741964</a></p>\n<p><a href=\"http://research.google.com/pubs/pub43438.html\" target=\"_blank\" rel=\"external\">http://research.google.com/pubs/pub43438.html</a> 或 <a href=\"https://ying-zhang.github.io/doc/EuroSys15_Borg.pdf\">下载转存的英文全文PDF</a></p>\n<p><a href=\"https://ying-zhang.github.io/doc/EuroSys15_Borg_CN_Ying_201711.pdf\"><strong>中文译文全文PDF</strong></a></p>\n<p>译者：难易 <a href=\"http://my.oschina.net/HardySimpson\" target=\"_blank\" rel=\"external\">http://my.oschina.net/HardySimpson</a></p>\n<blockquote>\n<p><strong>修订：Ying 2017-10-31 ~ 2017-11-09</strong></p>\n</blockquote>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><p>Google的Borg系统是一个集群管理器。它在多个万台机器规模的集群上运行着来自几千个不同的应用的几十万个作业。</p>\n<p>Borg通过准入控制、高效的任务装箱、超售、机器共享、以及进程级别的性能隔离，实现了高利用率。它为高可用应用提供了可以减少故障恢复时间的运行时特性，以及降低关联故障概率的调度策略。Borg提供了声明式的作业描述语言、名字服务集成、实时作业监控、分析和模拟系统行为的工具。这些简化了用户的使用。</p>\n<p>本文介绍了Borg系统架构和特性，重要的设计决策，对某些策略选择的定量分析，以及十年来的运营经验和教训。</p>\n<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>我们内部称为Borg的集群管理系统，负责接收、调度、启动、重启和监控Google所有的应用。本文介绍它是如何实现的。</p>\n<p>Borg提供了三个主要的好处：（1）隐藏资源管理和故障处理细节，使用户可以专注于应用开发；（2）高可靠性和高可用性的运维，并支持应用程序也能够如此；（3）让我们可以在几万台机器上高效地运行负载。Borg不是第一个涉及这些问题的系统，但它是少有的运行在如此大规模、具有弹性、完善的系统之一。</p>\n<p>本文围绕这些主题来编写，总结了十多年来我们在生产环境运行Borg的一些定性观察。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-01.png\" alt=\"图1. Borg的架构。图中只画出了数千个工作节点的很小一部分\"></p>\n<h1 id=\"2-用户视角\"><a href=\"#2-用户视角\" class=\"headerlink\" title=\"2. 用户视角\"></a>2. 用户视角</h1><p>Borg的用户是Google的开发人员以及运行Google应用和服务的系统管理员（站点可靠性工程师，SRE）。用户以作业（Job）的方式将他们的工作提交给Borg。作业由一个或多个任务（Task）组成，每个任务执行相同的二进制程序。每个作业只运行在一个Borg单元（Cell）里。Cell是一组机器的管理单元。下面的小节将介绍用户视角看到的Borg系统的主要特性。</p>\n<blockquote>\n<p>SRE的职责比系统管理员多得多：他们是负责Google生产服务的工程师。他们也设计和实现包括自动化系统等软件，管理应用、服务基础设施和平台，以保证在Google如此大的规模下的高性能和高可靠性。</p>\n</blockquote>\n<h2 id=\"2-1-工作负载\"><a href=\"#2-1-工作负载\" class=\"headerlink\" title=\"2.1 工作负载\"></a>2.1 工作负载</h2><p>Borg Cell主要运行两种异构的工作负载。第一种是应该“永不”停止的长期运行的服务，处理持续时间较短但对延迟敏感的请求（从几微秒到几百毫秒）。这些服务用于面向最终用户的产品，如Gmail、Google Docs、网页搜索，以及内部基础设施服务（例如Bigtable）。第二种是批处理作业，执行时间从几秒到几天，对短期性能波动不敏感。不同Cell中这两种负载的混合程度不同，取决于其主要租户（例如，有些Cell就以批处理作业为主）。工作负载也随时间变化：批处理作业不断提交或结束，而很多面向终端用户的服务表现出昼夜周期性的使用模式。Borg需要都处理好这些情况。</p>\n<p>Borg的代表性负载是一个公开的2011年5月整月的记录数据集[80]。这个数据集已经获得了广泛的分析[1, 26, 27, 57, 68]。</p>\n<p>最近几年，以Borg为基础构建了很多应用框架，包括我们内部的MapReduce系统[23]、FlumeJava[18]、Millwheel[3]和Pregel[59]。这些框架大多有一个控制器来提交Master Job，还有多个Worker Job。前两个框架类似于YARN的应用管理器[76]。我们的分布式存储系统，例如GFS[34]和它的后继者CFS、Bigtable[19]、以及Megastore[8]，都是运行在Borg上的。</p>\n<p>本文中，我们把高优先级的Borg作业称为为生产作业（prod），其它的则是非生产的（non-prod）。大多数长期服务是prod的，大部分批处理作业是non-prod的。一个典型Cell里，prod作业分配了约70%的总CPU资源，占总CPU使用量约60%；分配了约55%的总内存资源，占总内存使用量约85%。§5.5节表明分配量和使用量的差异是值得注意的。</p>\n<h2 id=\"2-2-集群（Cluster）和单元（Cell）\"><a href=\"#2-2-集群（Cluster）和单元（Cell）\" class=\"headerlink\" title=\"2.2 集群（Cluster）和单元（Cell）\"></a>2.2 集群（Cluster）和单元（Cell）</h2><p>一个Cell里的机器属于同一个集群。集群由数据中心级的高性能光纤的组网来定义。一个集群位于数据中心的一栋建筑内，而一个数据中心有多栋建筑（注：这些关系会有少数例外情况）。一个集群通常包括一个大的Cell，还可能有一些小规模的测试用或其它特殊用途的Cell。我们尽力避免任何单点故障。</p>\n<p>排除测试用的Cell，中等规模的Cell约有一万台机器；有些Cell还要大得多。Cell中的机器从多个维度看都是异构的：大小（CPU、内存，硬盘，网络）、处理器类型、性能、以及是否有外网IP地址或SSD等。Borg负责决定任务在Cell中的哪些机器上执行、为其分配资源、安装程序及依赖、监控健康状态并在失败后重启，从而使用户几乎不必关心机器异构性。</p>\n<h2 id=\"2-3-作业（Job）和任务（Task）\"><a href=\"#2-3-作业（Job）和任务（Task）\" class=\"headerlink\" title=\"2.3 作业（Job）和任务（Task）\"></a>2.3 作业（Job）和任务（Task）</h2><p>一个Borg 作业的属性有：名字、拥有者和任务个数。作业可以有一些约束来强制其任务运行在有特定属性的机器上，比如处理器架构、操作系统版本、是否有外网IP地址等。约束可以是硬性的或者柔性的，柔性约束表示偏好，而非需求。一个作业可以推迟到前一个作业结束后再开始（ying：即依赖顺序）。一个作业只在一个Cell中运行。</p>\n<p>每个任务对应着一组Linux进程，运行在一台机器上的一个容器内[62]。绝大部分Borg的工作负载没有运行在虚拟机里，因为我们不想付出虚拟化的开销。而且，在Borg设计的那个时期，我们有很多处理器还不支持硬件虚拟化呢。</p>\n<p>任务也有一些属性，如资源需求量，在作业中的序号等。一个作业中的任务大多有相同的属性，但也可以被覆盖 —— 例如特定任务的命令行参数。各维度的资源（CPU核、内存、硬盘空间、硬盘访问速度、TCP端口（注：Borg负责管理一台机器上的可用端口并将其分配给任务）等。可以互相独立的以细粒度指定。我们不强制使用固定大小的资源桶或槽（见§5.4）。Borg运行的程序都是静态链接的，以减少对运行环境的依赖，这些程序组织成由二进制文件和数据文件构成的包，由Borg负责安装。</p>\n<p>用户通过向Borg发送RPC来控制作业。RPC大多是从命令行工具、其它作业、或我们的监控系统（§2.6）发出的。大多作业描述文件使用一种声明式配置语言BCL。BCL是GCL[12]的一个变种，即增加了一些Borg专有的关键字，而GCL会生成若干protobuf文件[67]。GCL还提供了匿名函数以支持计算，这样就能让应用根据环境调整自己的配置。有上万个超过一千行的BCL配置文件，系统中累计运行了千万行BCL。Borg的作业配置与Aurora的配置文件[6]相似。</p>\n<p>图2展示了作业和任务整个生命周期的状态变化。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-02.png\" alt=\"图2. 作业和任务的状态图。用户可以触发提交，杀死和更新动作\"></p>\n<p>要想在运行时改变一个作业中若干或全部任务的属性，用户可以向Borg提交一个新的作业配置，并命令Borg将任务更新到新的配置。更新是轻量级的，非原子性的事务，在事务结束（提交）之前可以很容易地撤销。更新通常是滚动执行的，而且可以限制由更新导致的任务中断（被重新调度或抢占）的数量；超过限值的变更会被跳过。</p>\n<p>一些任务更新（如更新二进制程序）需要重启任务；另外一些更新（如增加资源需求或修改约束）可能使该任务不适合运行在当前机器上，导致停止并重新调度该任务；还有一些更新（如修改优先级）总是可以执行的，不需要重启或者移动任务。</p>\n<p>任务可以要求被Unix的<code>SIGKILL</code>立即杀死之前获得<code>SIGTERM</code>信号通知，这样它们还有时间清理资源、保存状态、结束当前请求、拒绝新请求。但如果抢占者设置了延迟限值，就可能来不及发通知。实践中，80%的情况下能发出通知信号。</p>\n<h2 id=\"2-4-分配（Allocs）\"><a href=\"#2-4-分配（Allocs）\" class=\"headerlink\" title=\"2.4 分配（Allocs）\"></a>2.4 分配（Allocs）</h2><p>Borg的alloc（allocation的缩写）是一台机器上的预留资源，可以用来执行一个或多个任务；不管有没有被使用，这些资源都算分配出去了。Allocs可以给将来的任务预留资源，或在任务停止和重启的间隔保持资源，以及将不同作业的多个任务绑定在同一台机器上 —— 例如一个Web服务器实例和附加的将其URL日志从本机硬盘拷贝到分布式文件系统的保存日志任务。Alloc的资源像一台机器上的那样来管理；运行在同一个Alloc内的多个任务共享其资源。如果一个Alloc需要迁移到其它机器上，那么它的任务也要跟着重新调度。</p>\n<p>一个Alloc集，即一组在多台机器上预留了资源的Alloc，类似于一个作业。一旦创建了一个Alloc集，就可以向其提交若干作业。简便起见，我们用<strong>任务</strong>表示一个Alloc或者一个顶层任务（即运行在Alloc之外的任务），用<strong>作业</strong>表示一个普通作业或者Alloc集。</p>\n<h2 id=\"2-5-优先级、配额和准入控制\"><a href=\"#2-5-优先级、配额和准入控制\" class=\"headerlink\" title=\"2.5 优先级、配额和准入控制\"></a>2.5 优先级、配额和准入控制</h2><p>当出现超过系统容量的工作负载会产生什么情况？我们对此的解决方案是优先级和配额。</p>\n<p>每个作业都有一个小的正整数表示的优先级。高优先级的任务可以优先获取资源，甚至抢占（杀死）低优先级的任务。Borg为不同用途定义了不重叠的优先级区间，包括（优先级降序）：<strong>监控、生产、批处理、尽力（即测试的或免费的）</strong>。本文中，prod作业的优先级是监控和生产两个区间。</p>\n<p>虽然一个被抢占的任务通常会被重新调度到Cell的其它机器上，但级联抢占也可能发生：如果某个任务抢占了一个优先级稍低的任务，而后者又抢占了另一个优先级稍低的，如此往复。为避免这种情况，我们禁止<code>生产</code>区间的任务互相抢占。细粒度（ying：相比于区间的粗粒度）的优先级在其它场景下也很有用 —— 如MapReduce的Master 任务的优先级比其管理的Worker高一点，以提高其可靠性。</p>\n<p>优先级表示了Cell中运行或等待的作业之间的相对重要性。配额则用来决定准许哪个作业可以被调度。配额是指定优先级和时间段（典型是几个月）的一个资源向量（CPU，内存，硬盘等）。配额限制了用户的作业一次可以申请资源的最大数量（如：20TB内存，以prod优先级，从现在到7月末，在xx Cell内）。配额检查是准入控制的一部分，不是调度的：配额不足的作业提交时当即就会被拒绝。</p>\n<p>高优先级的配额比低优先级的成本要高。生产级的配额限于一个Cell的实际可用资源量，因此用户提交了不超过配额的生产级作业时，不考虑资源碎片和约束，可以预期这个作业一定会运行。尽管我们鼓励用户不要购买超过其需求的配额，但很多用户仍然超买了，这样他们就不用担心将来应用的用户量增长可能导致的配额短缺。我们的应对方案是对低优先级资源配额的超售：所有用户的0优先级配额是无限的，尽管这无法实现。低优先级的作业虽然被接收了，但可能由于资源不足而一直等待。</p>\n<p>配额分配是Borg之外的系统处理的，与我们的物理容量规划紧密相关。容量规划的结果反映在各数据中心的价格和可用配额上。只有在其要求的优先级有足够的配额，用户的作业才能被接收。采用配额使得主导资源公平性（DRF）[29, 35, 36, 66]这样的策略不是那么必要了。</p>\n<p>Borg的容量系统可以给某些用户一些特殊权限。例如，允许管理员删除或修改Cell里的任意作业，或者允许某个用户操作特定的内核特性或Borg行为（如对其作业禁用资源估计。§5.5）。</p>\n<h2 id=\"2-6-命名和监控\"><a href=\"#2-6-命名和监控\" class=\"headerlink\" title=\"2.6 命名和监控\"></a>2.6 命名和监控</h2><p>仅仅创建和放置任务是不够的：一个服务的客户端和其它系统需要能找到它们，即使该服务被重新放置到另一台机器之后。为实现该需求，Borg为每个任务创建了一个固定的BNS名字（BNS，Borg name Service），这个名字包括了Cell名，作业名和任务序号。Borg把任务的主机名和端口写入Chubby[14]的一个持久化高可用文件里，以BNS名字为文件名。这个文件被RPC用来发现任务的实际地址。BNS名字也是任务的DNS名字的基础部分，例如，cc Cell的ubar用户的jfoo 作业的第50个任务可以通过<code>50.jfoo.ubar.cc.borg.google.com</code>来访问。每当状态改变时，Borg还会把作业的大小和任务的健康信息写入到Chubby，这样负载均衡器就知道如何路由请求了。</p>\n<p>几乎每个任务都有一个内置的HTTP服务器，用来发布任务的健康信息和几千个性能指标（如RPC延时）。Borg监控这些健康检查的URL，重启那些没有立刻响应或返回HTTP错误码的任务。监控工具跟踪其它数据并显示在仪表盘上，当违反服务水平目标（SLO）时报警。</p>\n<p>用户可以使用一个称为Sigma的Web界面来检查他的所有作业的状态，针对某个Cell，或者深入某个作业及任务，检查其资源行为、详细日志、执行历史和最终结果。我们的应用产生大量的日志，它们都会被自动的滚动以避免耗尽硬盘空间。任务退出后，日志会保留一小段时间以帮助调试。如果一个作业没有运行起来，Borg会提供一个挂起原因的标注，以及建议如何修改作业的资源请求，以使其更适合Cell。我们发布了如何使资源请求更容易被调度的指南。</p>\n<p>Borg将所有的作业提交、任务事件、以及每个任务的详细资源使用都记录在Infrastore里。Infrastore是一个可扩展的只读数据存储，通过Dremel[61]提供了类似SQL的交互式接口。这些数据用以支持基于使用量的收费，调试作业和系统故障，以及长期容量规划。公开的Google集群负载数据集[80]也来自于这些数据。</p>\n<p>所有这些特性帮助用户理解和调试Borg及其作业的行为，并帮助我们的SRE实现每人管理超过上万台机器。</p>\n<h1 id=\"3-Borg架构\"><a href=\"#3-Borg架构\" class=\"headerlink\" title=\"3. Borg架构\"></a>3. Borg架构</h1><p>一个Borg的Cell包括一组机器，一个逻辑上集中的控制器，称为Borgmaster，以及运行在每台机器上的称为Borglet的代理进程（见图1）。Borg的组件都是用C++实现的。</p>\n<h2 id=\"3-1-Borgmaster\"><a href=\"#3-1-Borgmaster\" class=\"headerlink\" title=\"3.1 Borgmaster\"></a>3.1 Borgmaster</h2><p>Cell的Borgmaster由两个进程组成：Borgmaster主进程和一个单独的调度进程（§3.2）。Borgmaster主进程处理客户端的RPC，包括修改状态（如创建作业），或提供只读数据（如查找作业）。它还管理着系统中所有对象（机器、任务、Allocs等）的状态，与Borglet通信，并提供一个Web UI（作为Sigma的备份）。</p>\n<p>Borgmaster在逻辑上是单个进程，但实际上有5个副本。每个副本在内存维护着Cell状态的拷贝，该状态同时保存在由这些副本的本地硬盘组成的一个基于Paxos[55]的高可用、分布式存储上。每个Cell中仅有一个选举出来的Master，它同时作为Paxos的Leader和状态修改者，处理所有变更Cell状态的请求，例如提交作业或者结束某台机器上的一个任务。当Cell启动或者上一个Master故障时，新的Master会通过Paxos算法选举出来；新Master会获取一个Chubby锁，这样其它的系统就可以找到它。选举并转移到新的Master通常需要10秒，但在大的Cell里可能需要长达1分钟，因为需要重构一些内存状态。当一个副本从宕机恢复后，它会动态地从其它最新的Paxos副本中重新同步自己的状态。</p>\n<p>某个时刻的Borgmaster状态被称为检查点（Checkpoint），以定期快照加变更日志的形式保存在Paxos存储里。检查点有很多用途：如重建过去任意时刻的Borgmaster状态（例如，在接收一个触发了Borg故障的请求之前，这样就可以用来调试）；极端情况下可以手工修复检查点；构建一个持久的事件日志供日后查询；或用于离线仿真。</p>\n<p>一个高保真的Borgmaster模拟器，称为Fauxmaster，可以读取检查点文件。Fauxmaster的代码拷贝自线上的Borgmaster，还有对Borglet的存根接口。它接收RPC来改变状态，执行操作，例如“调度所有等待的任务”。我们用它来调试故障，像跟在线的Borgmaster那样与模拟器交互，用模拟的Borglet重放检查点文件里的真实交互。用户可以单步执行并观察系统过去确实发生了的状态变化。Fauxmaster也用于容量规划（可以接收多少个此类型的作业？），以及在实际更改Cell配置前做可行性检查（这个变更会导致关键作业异常退出吗？）</p>\n<h2 id=\"3-2-调度\"><a href=\"#3-2-调度\" class=\"headerlink\" title=\"3.2 调度\"></a>3.2 调度</h2><p>当提交一个作业后，Borgmaster会把它保存在持久的Paxos存储上，并将这个作业的所有任务加入等待队列中。调度器异步地扫描等待队列，将任务分配到满足作业约束且有足够资源的机器上（调度是针对任务的，而非作业）。队列扫描从高优先级到低优先级，同优先级则以轮转的方式处理，以保证用户间的公平，并避免队首的大型作业阻塞队列。调度算法有两个部分：<strong>可行性检查</strong>，找到一组可以运行任务的机器；<strong>评分</strong>，从中选择一个合适的机器。</p>\n<p>在可行性检查阶段，调度器会找到一组满足任务约束且有足够可用资源的机器 —— 可用资源包括已经分配给低优先级任务但可以抢占的资源。在评分阶段，调度器确定每台可行机器的适宜性。评分考虑了用户特定的偏好，但主要取决于内置的标准：例如最小化被抢占任务的个数和优先级，选择已经有该任务安装包的机器，尽可能使任务分散在不同的供电和故障域，以及装箱（Packing）质量（在单台机器上混合高、低优先级的任务，以允许高优先级任务在负载尖峰扩容）等。</p>\n<p>Borg早期使用修改过的E-PVM[4]算法来评分。这个算法对异构的资源生成等效的成本值，放置任务的目标是使成本的变化量最小。在实践中，E-PVM会把负载分散到所有机器，为负载尖峰预留出资源 —— 这样的代价是增加了碎片，特别是对需要大部分机器的大型任务而言；我们有时称其为“最差匹配”。</p>\n<p>与之相反的是“最佳匹配”，把机器上的任务塞的越满越好。这就“空”出一些没有用户作业的机器（它们仍运行存储服务），这样放置大型任务就比较直接了。但是，如果用户或Borg错误估计了资源需求，紧实的装箱会对此造成（性能上的）惩罚。这种策略不利于有突发负载的应用，而且对申请少量CPU的批处理作业特别不友好，这些作业申请少量CPU本来是为了更容易被调度执行，并抓住机会使用空闲资源：20%的non-prod 任务申请少于0.1个CPU核。</p>\n<p>我们目前的评分模型是混合的，试图减少搁浅（Stranded）的资源（指一台机器因某些类型资源全部分配了，导致未能分配的其它类型资源）。对我们的负载而言，这个模型比“最佳匹配”提升了3%-5%的装箱效率（以[78]定义的方式评价）。</p>\n<p>如果评分后选中的一台机器仍没有足够的资源来运行新任务，Borg会抢占低优先级的任务，从最低优先级向上逐级抢占，直到资源足够运行该任务。被抢占的任务放回到调度器的等待队列里，而不是被迁移或休眠（注：例外情况是，为Google Compute Engine提供虚拟机的任务会被迁移）。</p>\n<p>任务的启动延迟（从提交作业到任务开始运行之间的时间段）是我们持续重点关注的。这个时间差别很大，中位数约25秒。安装软件包耗费了其中80%的时间：一个已知的瓶颈就是软件包写入时对本地硬盘的竞争。为了减少任务启动时间，调度器偏好将任务分配到已经有必需的软件包（程序及数据）的机器：大部分包是只读的，所以可以被共享和缓存（这是Borg调度器唯一的一种数据局部性支持）。另外，Borg通过树形和类似BT的协议并发地将软件包分发到多个机器上。</p>\n<p>此外，调度器采用多种技术使其能够扩展到数万台机器的Cell（§3.4）。</p>\n<h2 id=\"3-3-Borglet\"><a href=\"#3-3-Borglet\" class=\"headerlink\" title=\"3.3 Borglet\"></a>3.3 Borglet</h2><p>Borglet是部署在Cell每台机器上的本机Borg代理。它负责启动和停止任务；重启失败的任务；通过OS内核设置来管理本地资源；滚动调试日志；把本机的状态上报给Borgmaster和其它监控系统。</p>\n<p>Borgmaster每过几秒就会轮询每个Borglet来获取机器的当前状态，并向其发送请求。这让Borgmaster能控制通信频率，省去了显式的流量控制机制，而且防止了恢复风暴[9]。</p>\n<p>选举出来的Master负责准备发送给Borglet的消息，并根据Borglet的响应更新Cell的状态。为了性能扩展性，每个Borgmaster副本会运行一个无状态的链接分片（Link Shard）来处理部分Borglet的通信；Borgmaster选举后重新计算链接的分片。为了保证容错（Resiliency），Borglet总是汇报全部状态，但是Link Shard只汇报变化值，从而聚合、压缩这些信息，减少Master更新的负担。</p>\n<p>如果某个Borglet几次没有响应轮询请求，该机器会被标记为宕机，其上运行的所有任务会被重新调度到其它机器。如果通讯恢复了，Borgmaster会让这个Borglet杀掉已经被重新调度出去的任务，以避免重复。即便无法与Borgmaster通信，Borglet仍会继续正常运行。所以即使所有的Borgmaster都出故障了，正在运行的任务和服务还会保持运行。</p>\n<h2 id=\"3-4-扩展性\"><a href=\"#3-4-扩展性\" class=\"headerlink\" title=\"3.4 扩展性\"></a>3.4 扩展性</h2><p>我们还没有遇到Borg这种集中式架构的终极扩展上限。我们顺利突破了遇到的每个限制。一个单独的Borgmaster可以管理有数千台机器的Cell，有若干Cell每分钟有10000多个到达的任务。一个繁忙的Borgmaster使用10~14个CPU核以及50GB内存。我们用了几项技术来实现这种扩展性。</p>\n<p>早期版本的Borgmaster使用一个简单的，同步的循环来处理请求、调度任务，并与Borglet通信。为了处理更大的Cell，我们把调度器分离为一个单独的进程，这样它就可以与其它的Borgmaster功能并行执行，而这些其它的功能有多副本以容错。一个调度器副本使用一份缓存的Cell状态拷贝，重复执行下面的操作：从选举出来的Master获取状态改变（包括已分配的和等待中的工作）；更新自己的本地拷贝；执行一遍调度来分配任务；将分配信息发送给Master。Master会接受并应用这些分配，但如果分配不适合（例如，是基于过时的状态做出的），就会等待调度器的下一遍调度。这与Omega[69]使用的乐观并发控制思路很相似，而且我们最近还给Borg添加了对不同负载类型使用不同调度器的功能。</p>\n<p>为了改进响应时间，Borglet使用独立的线程分别进行通信和响应只读RPC。为了更好的性能，我们将这些请求划分给5个Borgmaster副本（§3.3）。总的效果是，UI响应时间的99%分位数小于1秒，而Borglet轮询间隔的95%分位数小于10秒。</p>\n<p>一些提高Borg调度器扩展性的方法如下：</p>\n<p><strong>缓存评分</strong>：计算一台机器的可行性和评分是比较昂贵的，所以Borg会一直缓存评分，直到这台机器或者任务的属性发生了变化 —— 例如，这台机器上的某个任务结束了，一些属性修改了，或者任务的需求改变了。忽略小额的资源变化可以减少缓存失效。</p>\n<p><strong>任务等价类（Equivalence classes）</strong>：一般来说，同一个Borg 作业的任务有相同的请求和约束。任务等价类即一组有相同需求的任务。Borg只对等价类中的一个任务进行可行性检查和评分，而不是对等待的每个任务去检查一遍所有机器的可行性并对可行的机器评分。</p>\n<p><strong>适度随机</strong>：在一个大的Cell中，对所有机器都去计算一遍可行性和评分是很浪费的。调度器会随机地检查机器，直到找到足够多的可用机器来评分，然后从中挑选出最好的一个。这减少了任务启动和退出所需的评分次数及导致的缓存失效，加快了任务分配过程。适度随机有点类似Sparrow[65]的批量采样技术（ying：Sparrow的批量采样考虑的是机器上的任务队列长度），但Borg还处理了优先级、抢占、异构性和安装软件包的成本。</p>\n<p>在我们的实验中（§5），从零开始调度整个Cell的工作负载只要几百秒，但禁用上面几项技术的话，3天都不够。正常情况下，半秒之内就能完成一遍等待队列的在线调度。</p>\n<h1 id=\"4-可用性\"><a href=\"#4-可用性\" class=\"headerlink\" title=\"4. 可用性\"></a>4. 可用性</h1><p><img width=\"600\" src=\"/img/borg-fig-03.png\" alt=\"图3. 不同类型任务的异常退出率及原因（包括抢占、资源不足、机器故障、机器关机、其它）。数据从2013-08-01开始。\"></p>\n<p>大型系统里故障是很常见的[10, 11, 12]。图3展示了在15个样本Cell里任务异常退出的原因分类。在Borg上运行的应用需要能处理这种事件，可采用的技术有多副本、保存持久状态到分布式存储，或定期快照（如果可行的话）等。当然，我们也尽可能的缓解异常事件的影响。例如，Borg提供了：</p>\n<ul>\n<li>自动重新调度异常退出的任务，如果必要，可以放置到另一台机器上去运行</li>\n<li>把一个作业的任务分散到不同的可用域，例如机器、机架、供电域层次，以减少关联失效</li>\n<li>在机器/OS升级等维护活动期间，限制任务受影响的速率，以及同一作业中同时中止的任务的个数</li>\n<li>使用声明式的预期状态表示和幂等的变更操作，这样故障的客户端可以无损地重复提交故障期间漏掉的请求</li>\n<li>对于失联的机器上的任务，限制重新调度的速率，因为大规模的机器故障和网络分区是很难区分的</li>\n<li>回避造成崩溃的 &lt;任务：机器&gt; 组合</li>\n<li>通过不断重新执行日志保存任务（§2.4），恢复已写入本地硬盘的关键中间数据，就算这个日志关联的Alloc已经终止或调度到其它机器上了。用户可以设置系统保持重复尝试多久，通常是几天时间。</li>\n</ul>\n<p>Borg的一个关键设计特性是：就算Borgmaster或者Borglet挂掉了，已经运行的任务还会继续运行下去。不过，保持Master正常运行仍然重要，因为在它退出后就无法提交新的作业，无法更新运行作业的状态，也不能重新调度故障机器上的任务。</p>\n<p>Borgmaster使用多项的技术支持其获得99.99%的实际可用性：多副本应对机器故障；准入控制应对超载；使用简单、底层的工具部署实例，以减少外部依赖。Cell彼此是独立的，减少了关联误操作和故障传播的机会。同时这也是我们不扩大Cell规模的主要考虑，而并非是扩展性的限制。</p>\n<h1 id=\"5-利用率\"><a href=\"#5-利用率\" class=\"headerlink\" title=\"5. 利用率\"></a>5. 利用率</h1><p>Borg的一个主要目标就是有效地利用Google的大量机器（这是一大笔财务投资）：让效率提升几个百分点就能省下几百万美元。这一节讨论和评估了一些Borg使用的策略和技术。</p>\n<h2 id=\"5-1-评估方法\"><a href=\"#5-1-评估方法\" class=\"headerlink\" title=\"5.1 评估方法\"></a>5.1 评估方法</h2><p>作业有部署约束，而且需要处理负载尖峰（尽管比较少见）；机器是异构的；我们回收服务型作业的资源来运行批处理作业。因此，我们需要一个比“平均利用率”更高级的指标来评估我们的策略选择。大量实验后，我们选择了Cell压缩量（Compaction）：给定一个负载，我们不断地移除机器，直到无法容纳该负载，从而得知所需最小的Cell规模。从空集群开始部署该负载并重复多次，以减少特殊情况的影响。终止条件是明确的，对比可以自动化，避免了生成和建模合成负载的陷阱[31]。[78]提供了评估技术的定量比较，其中的细节非常微妙。</p>\n<p>我们不可能在线上Cell进行实验，但是我们用了Fauxmaster来获得高保真的模拟效果，它使用了真实生产Cell和负载的数据，包括所有约束、实际限制、预留和使用量数据（§5.5）。实验数据提取自2014-10-01 14:00 PDT的Borg快照（其它快照也有类似的结论）。我们首先排除了特殊用途的、测试用的、小型的（少于5000台机器）的Cell，然后从剩下的Cell中选取了15个样本，抽样尽量关于Cell的大小均匀分布。</p>\n<p>为了保持机器异构性，在Cell压缩实验中，我们随机地移除机器。为了保持工作负载的异构性，我们保留了所有负载（除了那些绑定到特定机器的服务和存储任务，如Borglet）。我们把那些需要超过原Cell大小一半的作业的硬性限制改成柔性的，允许不超过0.2%的任务一直等待，这是针对一些特别“挑剔”的，只能放置在很少的特定机器上的任务；充分的实验表明结果是可复现的，波动很小。如果需要一个大型的Cell，就把原Cell复制几倍；如果需要更多的Cell，也是复制原Cell。</p>\n<p>每个实验都用不同的随机数种子对每个Cell重复了11次。图中，我们用误差线线来表示所需机器数量的最大和最小值，选择90%分位数作为结果 —— 平均值或中位数不能反映系统管理员所期望的充分把握。我们认为Cell压缩率是一个公平一致的比较调度策略的方法，而且可以直接转化为成本/收益的结果：更好的策略只需要更少的机器来运行相同的负载。</p>\n<p>我们的实验关注于即时的调度（装箱），而不是重放一段长时间的负载记录。部分原因是避免处理开放或闭合的队列模型[71, 79]的困难；部分是传统的完成时间不适用于长时间运行的服务；部分是这样可以提供明确的比较结果；部分是因为我们认为不会对结果产生显著影响；还有部分现实原因，我们发现一次实验使用了20万个Borg CPU核 —— 即便对Google而言，这个成本也不是个小数目。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-04.png\" alt=\"图4. 压缩的效果。15个Cell在压缩后相比原规模的百分比累积分布（CDF）\"></p>\n<p>生产环境中，我们特意保留了一些裕度（Headroom），以应对负载增长、偶然的“黑天鹅”事件、负载尖峰、机器故障、硬件升级、以及大范围的局部故障（如供电母线短路）。图4显示了如果应用Cell压缩，实际的Cell可以压缩到多小。下文的图使用这些压缩后的大小作为基准值。</p>\n<h2 id=\"5-2-Cell共享\"><a href=\"#5-2-Cell共享\" class=\"headerlink\" title=\"5.2 Cell共享\"></a>5.2 Cell共享</h2><p>几乎所有的机器都同时运行prod和non-prod的任务：在共享的Cell里是98%的机器，在所有Borg管理的机器里是83%（有一些是Cell专用的）。</p>\n<p><img src=\"/img/borg-fig-05.png\" alt=\"图5. 将prod和non-prod工作划分到不同的集群将需要更多的机器。两幅图中的百分比都是相对于单个集群所需机器的最少数量而言的\"></p>\n<p>鉴于很多外部组织将面向用户的作业和批处理作业分别运行在不同的集群上，我们检查一下如果我们也这么做会怎样。图5表明，在一个中等大小的Cell上，分开运行prod和non-prod的工作负载将需要增加20-30%的机器。这是因为prod的作业通常会保留一些资源来应对极少发生的负载尖峰，但大多情况下用不到这些资源。Borg回收了这些用不到的资源（§5.5），来运行non-prod的工作，所以总体我们只需要更少的机器。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-06.png\" alt=\"图6. 将用户分开到不同的集群也会需要更多的机器\"></p>\n<p>大部分Borg Cell被数千个用户共享使用。图6展示了为什么要共享。测试中，如果一个用户消费了超过10TiB（或100TiB）的内存，我们就把这个用户的工作负载分离到另一个Cell中。我们目前的共享策略是有效的：即使100TiB的阈值，也需要2-16倍的Cell，增加20-150%的机器。将资源池化再次显著地节省了成本。</p>\n<p>但是，把很多不相关的用户和作业类型放置到同一台机器上可能会造成CPU冲突，我们是否需要更多的机器来补偿？为评估这一点，我们看一下固定机器类型和时钟频率，任务的CPI（Cycles per Instruction，执行每条指令平均所需时钟数，越大则程序执行越慢）在其它环境条件不同的影响下是如何变化的。在这种实验条件下，CPI是一个可比较的指标，而且可以表征性能冲突，因为2倍的CPI意味着一个CPU密集型程序需要2倍的执行时间。数据是在一周内从约12000个随机选择的prod任务获取的，使用了[83]中介绍的硬件剖析工具记录5分钟内的时钟数和指令数，并调整了采样的权重，使CPU时间的每秒都均等处理。结果并非直截了当的：</p>\n<p>（1）我们发现CPI在同一个时间段内和下面两个量正相关：这台机器上总的CPU使用量，以及这个机器上同时运行的任务个数（基本上独立）；每向一台机器上增加一个任务，就会使其它任务的CPI增加0.3%（从数据拟合的线性模型给出的预测值）；将一台机器的CPU使用量增加10%，就会增加2%弱的CPI。尽管相关性在统计意义上是显著的，也只是解释了CPI变化的5%。还有其它的因素，支配着CPI的变化，例如，应用程序固有的差别，以及特殊的干扰模式[24, 83]。</p>\n<p>（2）比较从共享Cell和只运行几种应用的少数专用Cell获取的CPI采样，我们看到共享Cell里的CPI平均值为1.58（σ=0.35，标准差），专用Cell的CPI平均值是1.53（σ=0.32） —— 也就是说，共享Cell的性能差3%。</p>\n<p>（3）为了搞定不同Cell的应用会有不同的工作负载，或者会有幸存者偏差（或许对冲突更敏感的程序会被挪到专用Cell里面去），我们观察了Borglet的CPI。所有Cell的所有机器上都运行着Borglet。我们发现专用Cell里Borlet的CPI平均值是1.20（σ=0.29），而共享Cell里的CPI平均值为1.43（σ=0.45），表明在专用Cell上比在共享Cell上快1.19倍，不过这个结果忽略了专用Cell中的机器负载较轻的因素，即稍偏向专用Cell。</p>\n<p>这些实验表明了仓库级别的性能比较是复杂的，强化了[51]中的观察，但也说明共享并没有显著增加运行程序的开销。</p>\n<p>不过，就算从结果中最差的数据来看，共享还是有益的：比起CPU的降速，共享比各个划分方案都减少了机器，这一点更重要，而且共享的收益适用于包括内存和硬盘等各种资源，不仅仅是CPU。</p>\n<h2 id=\"5-3-大型Cell\"><a href=\"#5-3-大型Cell\" class=\"headerlink\" title=\"5.3 大型Cell\"></a>5.3 大型Cell</h2><p><img src=\"/img/borg-fig-07.png\" alt=\"图7. 将Cell分成更小的规模将需要更多的机器\"></p>\n<p>Google建立了大型Cell，一是为了允许运行大型任务，二是为了减少资源碎片。为测试减少碎片的效果，我们把负载从一个Cell分散多个较小的Cell中 —— 首先将作业随机排列，然后轮流分配到各小的Cell中。图7确认了使用小型Cell需要增加相当多的机器。</p>\n<h2 id=\"5-4-细粒度资源请求\"><a href=\"#5-4-细粒度资源请求\" class=\"headerlink\" title=\"5.4 细粒度资源请求\"></a>5.4 细粒度资源请求</h2><p>Borg用户请求的CPU单位是0.001个核，内存和硬盘的单位是字节。（一个核实际上是一个CPU的超线程，对不同机器类型的性能进行了标准化）。图8表明用户充分利用了细粒度：请求的CPU核和内存数量的“特别偏好值”是很少的，这些资源也没有明显的相关性。这与[68]里的分布非常相似，除了我们在90%分位数及以上的内存请求多一点之外。</p>\n<p>尽管IaaS普遍只提供一组固定尺寸的容器或虚拟机[7, 33]，但不符合我们的需求。为说明这一点，我们对prod的作业和Alloc（§2.4）申请的CPU核和内存分别向上取整到最接近的2的幂，形成固定大小的“桶”，最小的桶有0.5个核和1GiB内存。图9显示一般情况下这样需要增加30-50%的资源。上限的情形是，有的大型任务即便将Cell扩大为未压缩尺寸的四倍也无法容纳，只好为其分配一整台机器。下限是允许这些任务一直等待。（这比[37]给出的将近100%的额外开销要小一些，因为我们支持不止4种尺寸的桶，而且允许CPU和内存分别改变）。</p>\n<h2 id=\"5-5-资源回收\"><a href=\"#5-5-资源回收\" class=\"headerlink\" title=\"5.5 资源回收\"></a>5.5 资源回收</h2><p>作业可以声明一个资源<strong>限额（Limit）</strong>，是每个任务能获得的资源上限。Borg会用它来检查用户是否有足够的配额来接受该作业，并检查某个机器是否有足够的可用资源来运行任务。因为Borg通常会杀死那些试图使用超出内存和硬盘申请值的任务，或者限制其CPU使用量不超过申请值，所以有的用户会为任务申请超过实际需要的资源，就像有的用户会购买超过实际需要的配额一样。另外，一些任务只是偶尔需要使用它们申请的所有资源（例如，在一天中的高峰期或者受到了拒绝服务攻击），但大多时候用不了。</p>\n<p>与其把那些分配出来但暂时没有被用到的资源浪费掉，我们估计了一个任务会用多少资源，然后把剩余的资源回收给那些可以忍受低质量资源的任务，例如批处理作业。这整个过程称为<strong>资源再利用</strong>。这个估值称为任务的资源<strong>预留（Reservation）</strong>。Borgmaster每隔几秒就会根据Borglet获取的细粒度资源使用量信息来计算一次预留值。最初的预留资源被设置为资源限额；在300秒之后，也就过了启动阶段，预留资源会缓慢的下降到实际使用量加上一个安全值。在实际使用量超过它时，预留值会迅速增加。</p>\n<p>Borg调度器使用资源限额来计算prod级任务（注：准确的说，是高优先级的、延迟敏感的任务，见§6.2）是否可以执行（§3.2），所以这些任务不依赖于回收的资源，也与资源超售无关；对于non-prod的任务，运行任务使用的资源在预留值之内，这样新任务就可以使用回收的资源。</p>\n<p>一台机器有可能因为预留（预测）错误而导致运行时资源不足 —— 即使所有的任务都在资源限额之内。如果这种情况发生了，我们会杀掉或者限制non-prod任务，但从来不对prod任务下手。</p>\n<p>图10表明，如果没有资源回收，将需要更多的机器。在一个中等规模的Cell中大概有20%的工作负载（§6.2）使用了回收的资源。</p>\n<p>图11可以看到更多的细节，其中有预留值、使用量与限额的比例。当资源紧张时，超出内存限额的任务首先会被抢占，不论优先级有多高，所以很少有任务超过内存限额。另一方面，CPU使用量是可以被轻易限制住的，所以短时的毛刺虽然会导致使用量超过预留值，但这没什么损害。</p>\n<p>图11表明了资源回收可能还过于保守：在预留值和实际使用量中间还有一大段差距。为了测试这一点，我们选择了一个线上Cell，（第一周作为参照基准，）第二周将其估计算法的参数调整为比较<strong>激进</strong>的设置，即把安全裕度留小一点；第三周采取的是介于激进和基准之间的<strong>适度</strong>策略，最后一周恢复到基准策略。</p>\n<p><img src=\"/img/borg-fig-08-09-10-11.png\" alt=\"\"></p>\n<p>图12展示了结果。第二周的预留值明显更接近实际使用量，第三周稍大一点，最大的是第一周和第四周。和预期的一样，第二周和第三周的OOM比率轻微地增加了（注：第3周后期的异常情况与本次实验无关）。在评估了这个结果后，我们认为利大于弊，于是在其它Cell上也采用了<strong>适度</strong>策略的资源回收参数。</p>\n<p><img src=\"/img/borg-fig-12.png\" alt=\"图12. 更激进的资源估计可以回收更多资源，但会稍增加OOM事件\"></p>\n<h1 id=\"6-隔离\"><a href=\"#6-隔离\" class=\"headerlink\" title=\"6. 隔离\"></a>6. 隔离</h1><p>50%的机器运行了9个以上的任务；处于90%分位数的机器则有大约25个任务，4500个线程[83]。虽然在应用之间共享机器会增加利用率，但也需要一个比较好的机制来保证任务之间不产生干扰。这同时适用于安全和性能两个方面。</p>\n<h2 id=\"6-1-安全隔离\"><a href=\"#6-1-安全隔离\" class=\"headerlink\" title=\"6.1 安全隔离\"></a>6.1 安全隔离</h2><p>我们使用Linux的chroot作为同一台机器上不同任务之间的主要安全隔离机制。仅当某台机器有用户运行的任务时，为了允许远程调试，我们以前会自动分发（或废除）SSH秘钥，使用户可以访问这台机器。对大多数用户来说，现在被替换为<code>borgssh</code>命令，这个程序和Borglet协同构建一个SSH通道，连接到与任务运行在同一个chroot和cgroup下的Shell，这样限制就更加严格了。</p>\n<p>Google的AppEngine（GAE）[38]和Google Compute Engine（GCE）使用VM和安全沙箱技术运行外部的软件。我们把每个运行在KVM进程中的VM作为一个Borg任务来运行。</p>\n<h2 id=\"6-2-性能隔离\"><a href=\"#6-2-性能隔离\" class=\"headerlink\" title=\"6.2 性能隔离\"></a>6.2 性能隔离</h2><p>早期的Borglet使用了一种相对原始的资源隔离措施：事后检查内存、硬盘和CPU使用量，终止使用过多内存和硬盘的任务，或者降低使用过多CPU的任务的Linux CPU优先级。不过，一些粗暴的任务还是能很容易地影响到同台机器上其它任务的性能，于是有的用户就会多申请资源来让Borg减少与其共存的任务数量，降低了资源利用率。资源回收可以弥补一些损失，但不是全部，因为涉及到安全裕度。在极端情况下，用户会要求使用专属的机器或者Cell。</p>\n<p>目前，所有Borg任务都运行在基于Linux cgroup的资源容器[17, 58, 62]里。Borglet控制着这些容器的设置。有了OS内核的帮助，控制能力得到了改善。即使这样，偶尔还是有低级别的资源冲突发生（例如内存带宽或L3缓存污染），见[60, 83]。</p>\n<p>为了应对超载和超售，Borg任务有一个应用类别（appclass）。最重要的区分是延迟敏感（LS）的应用和本文中称为批处理（batch）的其它类别。LS任务包括面向用户的应用和需要快速响应的共享基础设施。高优先级的LS任务得到最高优待，可以暂时让批处理任务等待几秒种。</p>\n<p>第二个区分是：<strong>可压缩</strong>资源（例如CPU，硬盘I/O带宽），都是基于速率的，可以通过降低一个任务的服务质量而不是杀死它来回收；<strong>不可压缩</strong>资源（例如内存、硬盘空间），这些一般来说不杀掉任务是没办法回收的。如果一个机器用光了不可压缩资源，Borglet马上就会开始杀死任务，从低优先级开始，直到能满足剩下的资源预留。如果机器用完了可压缩资源，Borglet会限制使用量（偏好LS任务），这样不用杀死任何任务也能处理短期负载尖峰。如果情况没有改善，Borgmaster会从这个机器上移除一个或多个任务。</p>\n<p>Borglet有一个用户态的控制循环，负责以下操作：为容器确定内存量，prod任务基于预测值，而non-prod任务则基于内存压力；处理来自内核的OOM事件；当任务试图分配超过其自身限额的内存时，或者超售的机器上确实耗尽内存时，都会杀死任务。Linux激进的文件缓存让我们的实现复杂得多，因为需要精确计算内存使用量。</p>\n<p>为了增强性能隔离，LS任务可以预留整个物理CPU核，以阻止别的LS任务来使用它们。批处理任务被允许运行在任何核上，但是相比LS任务，批处理任务只分配了很少的调度份额。Borglet动态地调整贪婪的LS任务的资源上限，以保证它们不会把批处理任务饿上几分钟，必要时有选择的使用CFS带宽控制[75]；仅用份额来表示是不够的，因为我们有多个优先级。</p>\n<p><img width=\"600\" src=\"/img/borg-fig-13.png\" alt=\"图13. 调度延迟与负载的关系。即一个就绪线程需要等待超过1 ms才能运行的比率，与机器繁忙程度的关系。每组数据条中，左侧是延迟敏感的任务，右侧是批处理任务。只有很少的比率需要等5 ms以上，超过10 ms就极少了。这是2013年12月从一个代表性的Cell中获取的一个月的数据；误差线是每天的波动\"></p>\n<p>同Leverich[56]一样，我们发现标准的Linux CPU调度器（CFS）需要大幅调整才能同时支持低延迟和高利用率。为了减少调度延迟：我们内部版本的CFS对每个<code>cgroup</code>都有单独的负载历史[16]；允许LS任务抢占批处理任务；当一个CPU有多个就绪的LS任务时，减少其调度数量。幸运的是，我们的大多应用使用每个线程处理一个请求的模型，这样就缓解了长期的负载不均衡。我们节俭地使用<code>cpusets</code>给有特别严格的延迟需求的应用分配CPU核。这些努力的一些效果展示在图13中。我们持续在这方面投入，增加感知NUMA、超线程、能耗（如[81]）的线程放置和CPU管理，改进Borglet的控制精确度。</p>\n<p>任务被允许在其上限之内消费资源。大部分任务还允许去使用超出上限的可压缩资源，例如CPU，以利用空闲资源。只有5%的LS任务禁止这么做，主要是为了改善可预测性；小于1%的批处理任务也禁止了。使用超量内存默认是被禁止的，因为这会增加任务被杀掉的概率，不过即使这样，10%的LS任务解除了这个限制，79%的批处理任务也解除了，因为这是MapReduce框架的默认设置。这补偿了资源回收（§5.5）的后果。批处理任务很乐意使用空闲的或回收的内存：大多情况下这样运作得很好，即使偶尔批处理任务会被急需资源的LS任务杀掉。</p>\n<h1 id=\"7-相关工作\"><a href=\"#7-相关工作\" class=\"headerlink\" title=\"7. 相关工作\"></a>7. 相关工作</h1><p>数十年来，资源调度已经在多种场景得到了研究，如广域高性能计算网格、工作站网络、和大规模服务器集群等。我们这里只关注最相关的大规模服务器集群这个场景。</p>\n<p>最近的一些研究分析了来自于Yahoo!、Google和Facebook的集群记录数据[20, 52, 63, 68, 70, 80, 82]，展现了这些现代的数据中心和工作负载固有的异构性和大规模带来的挑战。[69]包含了对集群管理器架构的分类。</p>\n<p>Apache Mesos[45]将资源管理和任务放置功能拆分到一个集中资源管理器（类似于去掉调度器的Bormaster）和多种“框架”（比如Hadoop[41]和Spark[73]）之间，两者基于供应（Offer）机制交互。Borg则把这些功能集中在一起，使用基于请求的机制，而且扩展性相当好。DRF[29, 35, 36, 66]最初是为Mesos开发的；Borg则使用优先级和准入配额来替代。Mesos开发者已经宣布了他们扩展Mesos的雄心壮志：预测性资源分配和回收，以及解决[69]中发现的一些问题。</p>\n<p>YARN[76]是一个针对Hadoop的集群管理器。每个应用都有一个另外的管理器，与中央资源管理器谈判所需资源；这跟大约2008年开始Google的MapReduce作业已经使用的向Borg获取资源的模式如出一辙。YARN的资源管理器最近才支持容错。一个相关的开源项目是Hadoop Capacity Scheduler（基于容量的调度器）[42]，提供了多租户下的容量保证、多层队列、弹性共享和公平调度。YARN最近扩展支持了多种资源类型、优先级、抢占和高级准入控制[21]。Tetris（俄罗斯方块）研究原型[40]支持完成时间感知的作业装箱。</p>\n<p>Facebook的Tupperware[64]，是一个在集群中调度<code>cgroup</code>容器的类Borg系统；只有少量细节披露出来了，看起来它也提供了某种形式的资源回收功能。Twitter开源的Aurora[5]是一个类似Borg的，用于长期运行服务的调度器，运行与Mesos之上，其配置语言和状态迁移与Borg类似。</p>\n<p>微软的Autopilot[48]为其集群提供了“自动化的软件供应和部署；系统监控；以及采取修复行为处理软硬件故障”的功能。Borg生态系统提供了相似的特性，不过篇幅所限，不再深入讨论；作者Isaard概括了很多我们也赞成的最佳实践。</p>\n<p>Quincy[49]使用了一个网络流模型来提供公平性和数据局部性感知的调度，应用在几百个节点的集群的数据处理DAG上。Borg使用配额和优先级在用户间共享数据，可以扩展到上万台机器。Quincy可以直接处理执行图，而Borg需要在其上层另外构建。</p>\n<p>Cosmos[44]聚焦在批处理上，强调了用户可以公平获取他们已经捐献给集群的资源。每个作业分别有一个管理器来获取资源；只有很少公开的细节。</p>\n<p>微软的Apollo系统[13]为每个短期批处理作业分别使用单独的调度器，以获得高吞吐量，其集群规模看起来与Borg的Cell相当。Apollo投机地执行低优先级后台任务来提升资源利用率，代价是有时有长达多日的队列延迟。Apollo的各节点都一个关于开始时间的预测矩阵，其行列分别为CPU和内存两个资源维度。调度器会综合开始时间、估计的启动开销、获取远程数据的开销来决定部署位置，并用一个随机延时来减少冲突。Borg使用的是中央调度器，基于之前的分配来决定部署位置，可以处理更多的资源维度，而且更关注高可用、长期运行的应用；Apollo也许能处理比Borg更高的任务到达率。</p>\n<p>阿里巴巴的伏羲（Fuxi）[84]支持数据分析的负载，从2009年就开始运行了。类似Borgmaster，一个集中的FuxiMaster（也做了容错多副本）从节点上获取可用资源的信息、接受应用的资源请求，然后匹配两者。伏羲的增量调度策略与Borg的任务等价类是相反的：伏羲用最新的可用资源匹配等待队列里的任务（ying：Borg是用任务匹配资源）。类似Mesos，伏羲允许定义“虚拟资源”类型。只有对合成工作负载的实验结果是公开的。</p>\n<p>Omega[69]支持多个并发的调度器，粗略相当于没有持久存储和链接分片的Borgmaster。Omega调度器使用乐观并发控制的方式去操作一个共享的集群预期的和观察的状态表示。集群状态存储在一个集中持久存储中，用单独的连接组件与Borglet同步。Omage架构设计为支持多种不同的工作负载，它们有自己特定的RPC接口、状态迁移和调度策略（例如长期运行的服务、多个框架批处理作业、如集群存储这样的基础服务、Google云平台上的虚拟机）。相反，Borg提供了一种通用方案，同样的RPC接口、状态迁移、调度策略，为支持多种不同的负载，其规模和复杂度逐渐增加，但目前来说可扩展性还不算一个问题（§3.4）。</p>\n<p>Google的开源项目Kubernetes系统[53]把应用放在Docker容器内[28]，再分发到多个机器上。它即可以运行在物理机上（像Borg那样），也可以运行在多个云供应商（比如Google Compute Engine，GCE）的主机上。Kubernetes正在快速开发中，它的很多开发者也参与开发了Borg。Google提供了一个托管的版本，称为Google Container Engine（GKE）[39]。我们会在下一节里面讨论Kubernetes从Borg中学到了哪些东西。</p>\n<p>在高性能计算社区对这个领域有长期的研究传统（如Maui, Moab, Platform LSF[2, 47, 50]）；但是这和Google Cell所面对的规模、工作负载、容错性是不同的。总体而言，为达到高用率，这些系统需要让任务在一个很长的队列中等待。</p>\n<p>虚拟化供应商，例如VMware[77]，和数据中心方案供应商，例如HP和IBM[46]提供了典型情况下可以扩展到一千台机器规模的集群管理解决方案。另外，一些研究小组的原型系统以多种方式提升了调度质量（如[25, 40, 72, 74]）。</p>\n<p>最后，正如我们所指出的，大规模集群管理的另外一个重要部分是自动化和无人化。[43]指出，失效预案、多租户、健康检查、准入控制，以及可重启性对实现单个运维人员管理更多的机器的目标是必要的。Borg的设计哲学也是这样的，而且支撑了我们的每个SRE管理数万台机器。</p>\n<blockquote>\n<p>Borg从它的前任继承了很多东西，即我们内部的全局工作队列（Global Work Queue）系统，它最初是由Jeff Dean，Olcan Sercinoglu, 和Percy Liang开发的。<br>Conder[85]曾被广泛应用于收集空闲资源，其ClassAds机制[86]支持声明式的语句和自动属性匹配。</p>\n</blockquote>\n<h1 id=\"8-经验教训和未来工作\"><a href=\"#8-经验教训和未来工作\" class=\"headerlink\" title=\"8. 经验教训和未来工作\"></a>8. 经验教训和未来工作</h1><p>在这一节中我们介绍了十多年来我们在生产环境运行Borg得到的定性的经验教训，然后介绍设计Kubernetes[53]是如何吸收这些经验的。</p>\n<h2 id=\"8-1-教训\"><a href=\"#8-1-教训\" class=\"headerlink\" title=\"8.1 教训\"></a>8.1 教训</h2><p>我们从一些Borg作为反面警示的特性开始，然后介绍Kubernetes的替代方案。</p>\n<p><strong>将作业作为唯一的任务分组机制比较受限</strong></p>\n<p>Borg没有内置的方法将多个作业组成单个实体来管理，或将相关的服务实例关联起来（例如，测试通道和生产通道）。作为一个技巧，用户把他们的服务拓扑编码到作业的名字中，然后构建了更高层的管理工具来解析这些名字。这个问题的另外一面是，没办法指向服务的任意子集，这就导致了僵硬的语义，以至于无法滚动升级或改变作业的实例数。</p>\n<p>为了避免这些困难，Kubernetes不再使用作业这个概念，而是用标签（Label）来组织它的调度单元（Pod）。标签是任意的键值对，用户可以对系统的任何对象打上标签。Borg作业可以等效地通过对一组Pod打上 &lt;作业：作业名&gt; 这样的标签来实现。其它有用的分组方式也可以用标签来表示，例如服务、层级、发布类型（如，生产、就绪、测试）。Kubernetes用标签查询的方式来选取待操作的目标对象。这样就比固定的作业分组更加灵活。</p>\n<p><strong>同一台机器的任务共享一个IP太复杂了</strong></p>\n<p>Borg中，同一台机器上的所有任务都使用主机的同一个IP地址，共享端口空间。这就带来几个麻烦：Borg必须把端口当做资源来调度；任务必须先声明它需要多少端口，而且需要支持启动时传入可用端口号；Borglet必须强制端口隔离；命名和RPC系统必须像IP一样处理端口（ying：最后这一点我认为是必要的）。</p>\n<p>多亏了Linux的namespace、虚拟机、IPv6和软件定义网络SDN的出现，Kubernetes可以用一种更用户友好的方式来消解这些复杂性：每个Pod和Service都自己的IP地址，允许开发者选择端口而不是让他们的软件支持基础设施的分配，这也消除了基础设施管理端口的复杂性。</p>\n<p><strong>给资深用户优化而忽略了初级用户</strong></p>\n<p> Borg提供了一大堆针对“资深用户”的特性，这样他们就可以仔细地调节他们程序的运行方式（BCL规范约有230个参数）：开始的目的是为了支持Google的大型资源用户，提升他们的效率会带来显著的效益。但不幸的是，这么复杂的API让初级用户用起来很复杂，而且限制了API的演化。我们的解决方案是在Borg上又做了一些自动化的工具和服务，从实验中决定合理的配置。由于应用支持容错，实验可以自由进行：即使自动化出了问题，也只是小麻烦，不会导致灾难。</p>\n<h2 id=\"8-2-经验\"><a href=\"#8-2-经验\" class=\"headerlink\" title=\"8.2 经验\"></a>8.2 经验</h2><p>另一方面，有不少Borg的设计特性是非常有益的，而且经历了时间考验。</p>\n<p><strong>Alloc是有用的</strong></p>\n<p>Borg的Alloc抽象适用于广泛使用的保存日志模式（§2.4），另一个流行的模式是：一个简单的数据加载任务定期更新Web服务器使用的数据。Alloc和软件包机制允许这些辅助服务由不同的小组开发。Kubernetes对应于Alloc的概念是Pod，它是对一个或多个容器的资源封装，其中的容器共享Pod的资源，而且总是被调度到同一台机器上。Kubernetes使用Pod里的辅助容器来替代Alloc里面的任务，不过思路是一样的。</p>\n<p><strong>集群管理不只是任务管理</strong></p>\n<p>虽然Borg的主要角色是管理任务和机器的生命周期，但Borg上的应用还从其它的集群服务中收益良多，例如名字服务和负载均衡。Kubernetes用Service这个抽象概念来支持名字服务和负载均衡：Service有一个名字和用标签选出的多个Pod的动态集合。集群中的任何容器都可以通过Service名连接到该服务。幕后，Kubernetes自动将连接到该Service的负载分散到与其标签匹配的Pod之间，由于Pod挂掉后会被重新调度到其它机器上，Kubernetes还会跟踪这些Pod的位置。</p>\n<p><strong>自省是至关重要的</strong></p>\n<p>虽然Borg总体上是工作良好的，但出了问题后，定位根本原因是非常有挑战性的。Borg的一个关键设计选择是把所有的调试信息暴露给用户而不是隐藏起来：Borg有几千个用户，所以“自助”是调试的第一步。虽然一些用户的依赖项让我们难以废弃一些特性或修改内部策略，但这还是成功的，我们还没找到其它实际的替代方式。为管理大量的数据，我们提供了多个层次的UI和调试工具，这样用户就可以快速定位与其作业相关的异常事件，深入挖掘来自其应用和基础设施本身的详细事件和错误日志。</p>\n<p>Kubernetes也计划引入Borg的大部分自省技术。和Kubernetes一起发布了很多工具，比如用于资源监控的cAdvisor[15]，它基于Elasticsearch/Kibana[30]和Fluentd[32]聚合日志。Master可以用来查询某个对象的状态快照。Kubernetes提供了一致机制，所有可以记录事件的组件（例如，被调度的Pod、出错的容器）都可以被客户端访问。</p>\n<p><strong>Master是分布式系统的核心</strong></p>\n<p>Borgmaster最初设计为一个单体的系统，随着时间发展，它演变成了一组服务生态系统的核心。用户作业管理的管理是由这些服务协同完成的。比如，我们把调度器和主要的UI（Sigma）分离成单独的进程，增加了一组服务，包括准入控制、纵向和横向扩展、任务重新装箱、周期性作业提交（cron）、工作流管理，用于离线查询的系统活动归档等。总体而言，这让我们能扩展工作负载和特性集合，但无需牺牲性能和可维护性。</p>\n<p>Kubernetes的架构走的更远一些：它的核心是一个仅处理请求和操作底层状态目标的API服务。集群管理逻辑构建为一个小型的、可组合的微服务，作为API服务的客户端，如故障后仍维持Pod副本个数在期望值的副本管理器，以及管理机器生命周期的节点管理器。</p>\n<h2 id=\"8-3-总结\"><a href=\"#8-3-总结\" class=\"headerlink\" title=\"8.3 总结\"></a>8.3 总结</h2><p>在过去十年间，所有几乎所有的Google集群负载都迁移到了Borg上。我们仍在持续改进它，并把经验应用到了Kubernetes上。</p>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>这篇文章的作者负责撰写文章，并完成了评估实验。几十位设计、实现和维护Borg组件和生态系统的工程师才是它成功的关键。我们在这里列出直接参与设计、实现和维护Borgmaster及Borglet的人员。如果有遗漏，我们深表歉意。</p>\n<p>早期版本的Borgmaster设计和实现人员有：Jeremy Dion和Mark Vandevoorde，以及Ben Smith, Ken Ashcraft, Maricia Scott, Ming-Yee Iu 和 Monika Henzinger。早期版本的Borglet主要是由Paul Menage设计和实现的（ying：见[62]）。</p>\n<p>后续的参与者包括：Abhishek Rai, Abhishek Verma, Andy Zheng, Ashwin Kumar, Beng-Hong Lim, Bin Zhang, Bolu Szewczyk, Brian Budge, Brian Grant, Brian Wickman, Chengdu Huang, Cynthia Wong, Daniel Smith, Dave Bort, David Oppenheimer, David Wall, Dawn Chen, Eric Haugen, Eric Tune, Ethan Solomita, Gaurav Dhiman, Geeta Chaudhry, Greg Roelofs, Grzegorz Czajkowski, James Eady, Jarek Kusmierek, Jaroslaw Przybylowicz, Jason Hickey, Javier Kohen, Jeremy Lau, Jerzy Szczepkowski, John Wilkes, Jonathan Wilson, Joso Eterovic, Jutta Degener, Kai Backman, Kamil Yurtsever, Kenji Kaneda, Kevan Miller, Kurt Steinkraus, Leo Landa, Liza Fireman, Madhukar Korupolu, Mark Logan, Markus Gutschke, Matt Sparks, Maya Haridasan, Michael Abd-El-Malek, Michael Kenniston, Mukesh Kumar, Nate Calvin, Onufry Wojtaszczyk, Patrick Johnson, Pedro Valenzuela, Piotr Witusowski, Praveen Kallakuri, Rafal Sokolowski, Richard Gooch, Rishi Gosalia, Rob Radez, Robert Hagmann, Robert Jardine, Robert Kennedy, Rohit Jnagal, Roy Bryant, Rune Dahl, Scott Garriss, Scott Johnson, Sean Howarth, Sheena Madan, Smeeta Jalan, Stan Chesnutt, Temo Arobelidze, Tim Hockin, Todd Wang, Tomasz Blaszczyk, Tomasz Wozniak, Tomek Zielonka, Victor Marmol, Vish Kannan, Vrigo Gokhale, Walfredo Cirne, Walt Drummond, Weiran Liu, Xiaopan Zhang, Xiao Zhang, Ye Zhao, Zohaib Maya.</p>\n<p>Borg SRE团队也是非常重要的，包括：Adam Rogoyski, Alex Milivojevic, Anil Das, Cody Smith, Cooper Bethea, Folke Behrens, Matt Liggett, James Sanford, John Millikin, Matt Brown, Miki Habryn, Peter Dahl, Robert van Gent, Seppi Wilhelmi, Seth Hettich, Torsten Marek, 和 Viraj Alankar。Borg配置语言（BCL）和<code>borgcfg</code>工具最初是Marcel van Lohuizen 和 Robert Griesemer开发的。</p>\n<blockquote>\n<p>我们不小心漏掉了 Brad Strand, Chris Colohan, Divyesh Shah, Eric Wilcox, 和 Pavanish Nirula。</p>\n</blockquote>\n<p>谢谢我们的审稿人（尤其是Eric Brewer, Malte Schwarzkopf 和 Tom Rodeheffer），以及我们的导师Christos Kozyrakis，对这篇论文的反馈。</p>\n<h1 id=\"勘误\"><a href=\"#勘误\" class=\"headerlink\" title=\"勘误\"></a>勘误</h1><p>2015-04-23</p>\n<p>定稿后，我们发现了若干无意的疏漏和歧义。（ying：译文已将勘误内容放置到对应章节。补充的两条参考文献序号有冲突，放在了列表之后，并继续编号为85，86）</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] O. A. Abdul-Rahman and K. Aida. <strong>Towards understanding the usage behavior of Google cloud users: the mice and elephants phenomenon.</strong>In Proc. IEEE Int’l Conf. on Cloud Computing Technology and Science (CloudCom), pages 272–277, Singapore, Dec. 2014.<br>[2] Adaptive Computing Enterprises Inc., Provo, UT. <strong>Maui Scheduler Administrator’s Guide</strong>, 3.2 edition, 2011.<br>[3] T. Akidau, A. Balikov, K. Bekiroğlu, S. Chernyak, J. Haberman, R. Lax, S. McVeety, D. Mills, P. Nordstrom,and S. Whittle. <strong>MillWheel: fault-tolerant stream processing at internet scale</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 734–746, Riva del Garda, Italy, Aug.2013.<br>[4] Y. Amir, B. Awerbuch, A. Barak, R. S. Borgstrom, and A. Keren. <strong>An opportunity cost approach for job assignment in a scalable computing cluster</strong> IEEE Trans. Parallel Distrib.Syst., 11(7):760–768, July 2000.<br>[5] <strong>Apache Aurora</strong>. <a href=\"http://aurora.incubator.apache.org/\" target=\"_blank\" rel=\"external\">http://aurora.incubator.apache.org/</a>, 2014.<br>[6] <strong>Aurora Configuration Tutorial</strong>. <a href=\"https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/\" target=\"_blank\" rel=\"external\">https://aurora.incubator.apache.org/documentation/latest/configuration-tutorial/</a>, 2014.<br>[7] AWS. <strong>Amazon Web Services VM Instances</strong>. <a href=\"http://aws.amazon.com/ec2/instance-types/\" target=\"_blank\" rel=\"external\">http://aws.amazon.com/ec2/instance-types/</a>, 2014.<br>[8] J. Baker, C. Bond, J. Corbett, J. Furman, A. Khorlin, J. Larson, J.-M. Leon, Y. Li, A. Lloyd, and V. Yushprakh. <strong>Megastore: Providing scalable, highly available storage for interactive services</strong> In Proc. Conference on Innovative Data Systems Research (CIDR), pages 223–234, Asilomar, CA, USA, Jan. 2011.<br>[9] M. Baker and J. Ousterhout. <strong>Availability in the Sprite distributed file system</strong> Operating Systems Review,25(2):95–98, Apr. 1991.<br>[10] L. A. Barroso, J. Clidaras, and U. Hölzle. <strong>The datacenter as a computer: an introduction to the design of warehouse-scale machines</strong> Morgan Claypool Publishers, 2nd edition, 2013.<br>[11] L. A. Barroso, J. Dean, and U. Holzle. <strong>Web search for a planet: the Google cluster architecture</strong> In IEEE Micro, pages 22–28, 2003.<br>[12] I. Bokharouss. <strong>GCL Viewer: a study in improving the understanding of GCL programs</strong> Technical report, Eindhoven Univ. of Technology, 2008. MS thesis.<br>[13] E. Boutin, J. Ekanayake, W. Lin, B. Shi, J. Zhou, Z. Qian, M. Wu, and L. Zhou. <strong>Apollo: scalable and coordinated scheduling for cloud-scale computing</strong> In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), Oct. 2014.<br>[14] M. Burrows. <strong>The Chubby lock service for loosely-coupled distributed systems</strong> In Proc. USENIX Symp. on Operating Systems Design and Implementation (OSDI), pages 335–350,Seattle, WA, USA, 2006.<br>[15] <strong>cAdvisor</strong>. <a href=\"https://github.com/google/cadvisor\" target=\"_blank\" rel=\"external\">https://github.com/google/cadvisor</a>, 2014<br>[16] <strong>CFS per-entity load patches</strong>. <a href=\"http://lwn.net/Articles/531853\" target=\"_blank\" rel=\"external\">http://lwn.net/Articles/531853</a>, 2013.<br>[17] <strong>cgroups</strong>. <a href=\"http://en.wikipedia.org/wiki/Cgroups\" target=\"_blank\" rel=\"external\">http://en.wikipedia.org/wiki/Cgroups</a>, 2014.<br>[18] C. Chambers, A. Raniwala, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, and N. Weizenbaum. <strong>FlumeJava: easy, efficient data-parallel pipelines</strong> In Proc. ACM SIGPLAN Conf. on Programming Language Design and Implementation (PLDI), pages 363–375, Toronto, Ontario, Canada, 2010.<br>[19] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. E. Gruber. <strong>Bigtable: a distributed storage system for structured data</strong> ACM Trans. on Computer Systems, 26(2):4:1–4:26, June 2008.<br>[20] Y. Chen, S. Alspaugh, and R. H. Katz. <strong>Design insights for MapReduce from diverse production workloads</strong> Technical Report UCB/EECS–2012–17, UC Berkeley, Jan. 2012.<br>[21] C. Curino, D. E. Difallah, C. Douglas, S. Krishnan, R. Ramakrishnan, and S. Rao. <strong>Reservation-based scheduling: if you’re late don’t blame us!</strong>In Proc. ACM Symp. on Cloud Computing (SoCC), pages 2:1–2:14, Seattle, WA, USA, 2014.<br>[22] J. Dean and L. A. Barroso. <strong>The tail at scale</strong> Communications of the ACM, 56(2):74–80, Feb. 2012.<br>[23] J. Dean and S. Ghemawat. <strong>MapReduce: simplified data processing on large clusters</strong> Communications of the ACM, 51(1):107–113, 2008.<br>[24] C. Delimitrou and C. Kozyrakis. <strong>Paragon: QoS-aware scheduling for heterogeneous datacenters</strong> In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), Mar. 201.<br>[25] C. Delimitrou and C. Kozyrakis. <strong>Quasar: resource-efficient and QoS-aware cluster management</strong> In Proc. Int’l Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS), pages 127–144, Salt Lake City, UT, USA, 2014.<br>[26] S. Di, D. Kondo, and W. Cirne. <strong>Characterization and comparison of cloud versus Grid workloads</strong> In International Conference on Cluster Computing (IEEE CLUSTER), pages 230–238, Beijing, China, Sept. 2012.<br>[27] S. Di, D. Kondo, and C. Franck. <strong>Characterizing cloud applications on a Google data center</strong> In Proc. Int’l Conf. on Parallel Processing (ICPP), Lyon, France, Oct. 2013.<br>[28] <strong>Docker Project</strong>. <a href=\"https://www.docker.io/\" target=\"_blank\" rel=\"external\">https://www.docker.io/</a>, 2014.<br>[29] D. Dolev, D. G. Feitelson, J. Y. Halpern, R. Kupferman, and N. Linial. <strong>No justified complaints: on fair sharing of multiple resources</strong> In Proc. Innovations in Theoretical Computer Science (ITCS), pages 68–75, Cambridge, MA, USA, 2012.<br>[30] <strong>ElasticSearch</strong>. <a href=\"http://www.elasticsearch.org\" target=\"_blank\" rel=\"external\">http://www.elasticsearch.org</a>, 2014.<br>[31] D. G. Feitelson. <strong>Workload Modeling for Computer Systems Performance Evaluation</strong> Cambridge University Press, 2014.<br>[32] <strong>Fluentd</strong>. <a href=\"http://www.fluentd.org/\" target=\"_blank\" rel=\"external\">http://www.fluentd.org/</a>, 2014.<br>[33] <strong>GCE. Google Compute Engine</strong>. <a href=\"http://cloud.google.com/products/compute-engine/\" target=\"_blank\" rel=\"external\">http://cloud.google.com/products/compute-engine/</a>, 2014.<br>[34] S. Ghemawat, H. Gobioff, and S.-T. Leung. <strong>The Google File System</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 29–43, Bolton Landing, NY, USA, 2003. ACM.<br>[35] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, and I. Stoica. <strong>Dominant Resource Fairness: fair allocation of multiple resource types</strong> In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), pages 323–326, 2011.<br>[36] A. Ghodsi, M. Zaharia, S. Shenker, and I. Stoica. <strong>Choosy: max-min fair sharing for datacenter jobs with constraints</strong> In Proc. European Conf. on Computer Systems (EuroSys), pages 365–378, Prague, Czech Republic, 2013.<br>[37] D. Gmach, J. Rolia, and L. Cherkasova. <strong>Selling T-shirts and time shares in the cloud</strong> In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 539–546, Ottawa, Canada, 2012.<br>[38] <strong>Google App Engine</strong>. <a href=\"http://cloud.google.com/AppEngine\" target=\"_blank\" rel=\"external\">http://cloud.google.com/AppEngine</a>, 2014.<br>[39] <strong>Google Container Engine (GKE)</strong>. <a href=\"https://cloud.google.com/container-engine/\" target=\"_blank\" rel=\"external\">https://cloud.google.com/container-engine/</a>, 2015.<br>[40] R. Grandl, G. Ananthanarayanan, S. Kandula, S. Rao, and A. Akella. <strong>Multi-resource packing for cluster schedulers</strong> In Proc. ACM SIGCOMM, Aug. 2014.<br>[41] <strong>Apache Hadoop Project</strong>. <a href=\"http://hadoop.apache.org/\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/</a>, 2009.<br>[42] <strong>Hadoop MapReduce Next Generation – Capacity Scheduler</strong>. <a href=\"http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html\" target=\"_blank\" rel=\"external\">http://hadoop.apache.org/docs/r2.2.0/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html</a>, 2013.<br>[43] J. Hamilton. <strong>On designing and deploying internet-scale services</strong>. In Proc. Large Installation System Administration Conf. (LISA), pages 231–242, Dallas, TX, USA, Nov. 2007.<br>[44] P. Helland. <strong>Cosmos: big data and big challenges</strong>. <a href=\"http://research.microsoft.com/en-us/events/fs2011/helland_cosmos_big_data_and_big_challenges.pdf\" target=\"_blank\" rel=\"external\">http://research.microsoft.com/en-us/events/fs2011/ helland_cosmos_big_data_and_big_challenges.pdf</a>, 2011.<br>[45] B. Hindman, A. Konwinski, M. Zaharia, A. Ghodsi, A. Joseph, R. Katz, S. Shenker, and I. Stoica. <strong>Mesos: a platform for fine-grained resource sharing in the data center</strong>. In Proc. USENIX Symp. on Networked Systems Design and Implementation (NSDI), 2011.<br>[46] <strong>IBM Platform Computing</strong>. <a href=\"http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/index.html\" target=\"_blank\" rel=\"external\">http://www-03.ibm.com/systems/technicalcomputing/platformcomputing/products/clustermanager/ index.html</a>.<br>[47] S. Iqbal, R. Gupta, and Y.-C. Fang. <strong>Planning considerations for job scheduling in HPC clusters</strong> Dell Power Solutions, Feb. 2005.<br>[48] M. Isaard. <strong>Autopilot: Automatic data center management</strong> ACM SIGOPS Operating Systems Review, 41(2), 2007.<br>[49] M. Isard, V. Prabhakaran, J. Currey, U. Wieder, K. Talwar, and A. Goldberg. <strong>Quincy: fair scheduling for distributed computing clusters</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), 2009.<br>[50] D. B. Jackson, Q. Snell, and M. J. <strong>Clement. Core algorithms of the Maui scheduler</strong> In Proc. Int’l Workshop on Job Scheduling Strategies for Parallel Processing, pages 87–102. Springer-Verlag, 2001.<br>[51] M. Kambadur, T. Moseley, R. Hank, and M. A. Kim. <strong>Measuring interference between live datacenter applications</strong> In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), Salt Lake City, UT, Nov. 2012.<br>[52] S. Kavulya, J. Tan, R. Gandhi, and P. Narasimhan. <strong>An analysis of traces from a production MapReduce cluster</strong> In Proc. IEEE/ACM Int’l Symp. on Cluster, Cloud and Grid Computing (CCGrid), pages 94–103, 2010.<br>[53] <strong>Kubernetes</strong>. <a href=\"http://kubernetes.io\" target=\"_blank\" rel=\"external\">http://kubernetes.io</a>, Aug. 2014.<br>[54] <strong>Kernel Based Virtual Machine</strong>. <a href=\"http://www.linux-kvm.org\" target=\"_blank\" rel=\"external\">http://www.linux-kvm.org</a>.<br>[55] L. Lamport. <strong>The part-time parliament</strong> ACM Trans. on Computer Systems, 16(2):133–169, May 1998.<br>[56] J. Leverich and C. Kozyrakis. <strong>Reconciling high server utilization and sub-millisecond quality-of-service</strong> In Proc. European Conf. on Computer Systems (EuroSys), page 4, 2014.<br>[57] Z. Liu and S. Cho. <strong>Characterizing machines and workloads on a Google cluster</strong> In Proc. Int’l Workshop on Scheduling and Resource Management for Parallel and Distributed Systems (SRMPDS), Pittsburgh, PA, USA, Sept. 2012.<br>[58] <strong>Google LMCTFY project (let me contain that for you)</strong>. <a href=\"http://github.com/google/lmctfy\" target=\"_blank\" rel=\"external\">http://github.com/google/lmctfy</a>, 2014.<br>[59] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn, N. Leiser, and G. Czajkowski. <strong>Pregel: a system for large-scale graph processing</strong> In Proc. ACM SIGMOD Conference, pages 135–146, Indianapolis, IA, USA, 2010.<br>[60] J. Mars, L. Tang, R. Hundt, K. Skadron, and M. L. Soffa. <strong>Bubble-Up: increasing utilization in modern warehouse scale computers via sensible co-locations</strong> In Proc. Int’l Symp. on Microarchitecture (Micro), Porto Alegre, Brazil, 2011.<br>[61] S. Melnik, A. Gubarev, J. J. Long, G. Romer, S. Shivakumar, M. Tolton, and T. Vassilakis. <strong>Dremel: interactive analysis of web-scale datasets</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 330–339, Singapore, Sept. 2010.<br>[62] P. Menage. <strong>Linux control groups</strong>. <a href=\"http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt\" target=\"_blank\" rel=\"external\">http://www.kernel.org/doc/Documentation/cgroups/cgroups.txt</a>, 2007–2014.<br>[63] A. K. Mishra, J. L. Hellerstein, W. Cirne, and C. R. Das. <strong>Towards characterizing cloud backend workloads: insights from Google compute clusters</strong> ACM SIGMETRICS Performance Evaluation Review, 37:34–41, Mar. 2010.<br>[64] A. Narayanan. <strong>Tupperware: containerized deployment at Facebook</strong>. <a href=\"http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook\" target=\"_blank\" rel=\"external\">http://www.slideshare.net/dotCloud/tupperware-containerized-deployment-at-facebook</a>, June 2014.<br>[65] K. Ousterhout, P. Wendell, M. Zaharia, and I. Stoica. <strong>Sparrow: distributed, low latency scheduling</strong> In Proc. ACM Symp. on Operating Systems Principles (SOSP), pages 69–84, Farminton, PA, USA, 2013.<br>[66] D. C. Parkes, A. D. Procaccia, and N. Shah. <strong>Beyond Dominant Resource Fairness: extensions, limitations, and indivisibilities</strong> In Proc. Electronic Commerce, pages 808–825, Valencia, Spain, 2012.<br>[67] <strong>Protocol buffers</strong>. <a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\" rel=\"external\">https://developers.google.com/protocol-buffers/</a>, and <a href=\"https://github.com/google/protobuf/\" target=\"_blank\" rel=\"external\">https://github.com/google/protobuf/</a>, 2014.<br>[68] C. Reiss, A. Tumanov, G. Ganger, R. Katz, and M. Kozuch. <strong>Heterogeneity and dynamicity of clouds at scale: Google trace analysis</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.<br>[69] M. Schwarzkopf, A. Konwinski, M. Abd-El-Malek, and J. Wilkes. <strong>Omega: flexible, scalable schedulers for large compute clusters</strong> In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.<br>[70] B. Sharma, V. Chudnovsky, J. L. Hellerstein, R. Rifaat, and C. R. Das. <strong>Modeling and synthesizing task placement constraints in Google compute clusters</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), pages 3:1–3:14, Cascais, Portugal, Oct. 2011.<br>[71] E. Shmueli and D. G. Feitelson. <strong>On simulation and design of parallel-systems schedulers: are we doing the right thing?</strong> IEEE Trans. on Parallel and Distributed Systems, 20(7):983–996, July 2009.<br>[72] A. Singh, M. Korupolu, and D. Mohapatra. <strong>Server-storage virtualization: integration and load balancing in data centers</strong> In Proc. Int’l Conf. for High Performance Computing, Networking, Storage and Analysis (SC), pages 53:1–53:12, Austin, TX, USA, 2008.<br>[73] <strong>Apache Spark Project</strong>. <a href=\"http://spark.apache.org/\" target=\"_blank\" rel=\"external\">http://spark.apache.org/</a>, 2014.<br>[74] A. Tumanov, J. Cipar, M. A. Kozuch, and G. R. Ganger. <strong>Alsched: algebraic scheduling of mixed workloads in heterogeneous clouds</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), San Jose, CA, USA, Oct. 2012.<br>[75] P. Turner, B. Rao, and N. Rao. <strong>CPU bandwidth control for CFS</strong> In Proc. Linux Symposium, pages 245–254, July 2010.<br>[76] V. K. Vavilapalli, A. C. Murthy, C. Douglas, S. Agarwal, M. Konar, R. Evans, T. Graves, J. Lowe, H. Shah, S. Seth, B. Saha, C. Curino, O. O’Malley, S. Radia, B. Reed, and E. Baldeschwieler. <strong>Apache Hadoop YARN: Yet Another Resource Negotiator</strong> In Proc. ACM Symp. on Cloud Computing (SoCC), Santa Clara, CA, USA, 2013.<br>[77] <strong>VMware VCloud Suite</strong>. <a href=\"http://www.vmware.com/products/vcloud-suite/\" target=\"_blank\" rel=\"external\">http://www.vmware.com/products/vcloud-suite/</a>.<br>[78] A. Verma, M. Korupolu, and J. Wilkes. <strong>Evaluating job packing in warehouse-scale computing</strong> In IEEE Cluster, pages 48–56, Madrid, Spain, Sept. 2014.<br>[79] W. Whitt. <strong>Open and closed models for networks of queues</strong> AT&amp;T Bell Labs Technical Journal, 63(9), Nov. 1984.<br>[80] J. Wilkes. <strong>More Google cluster data</strong>. <a href=\"http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html\" target=\"_blank\" rel=\"external\">http://googleresearch.blogspot.com/2011/11/more-google-cluster-data.html</a>, Nov. 2011.<br>[81] Y. Zhai, X. Zhang, S. Eranian, L. Tang, and J. Mars. <strong>HaPPy: Hyperthread-aware power profiling dynamically</strong> In Proc. USENIX Annual Technical Conf. (USENIX ATC), pages 211–217, Philadelphia, PA, USA, June 2014. USENIX Association.<br>[82] Q. Zhang, J. Hellerstein, and R. Boutaba. <strong>Characterizing task usage shapes in Google’s compute clusters</strong> In Proc. Int’l Workshop on Large-Scale Distributed Systems and Middleware (LADIS), 2011.<br>[83] X. Zhang, E. Tune, R. Hagmann, R. Jnagal, V. Gokhale, and J. Wilkes. <strong>CPI2: CPU performance isolation for shared compute clusters</strong> In Proc. European Conf. on Computer Systems (EuroSys), Prague, Czech Republic, 2013.<br>[84] Z. Zhang, C. Li, Y. Tao, R. Yang, H. Tang, and J. Xu. <strong>Fuxi: a fault-tolerant resource management and job scheduling system at internet scale</strong> In Proc. Int’l Conf. on Very Large Data Bases (VLDB), pages 1393–1404. VLDB Endowment Inc., Sept. 2014.<br>[85] Michael Litzkow, Miron Livny, and Matt Mutka. <strong>Condor - A Hunter of Idle Workstations</strong> In Proc. Int’l Conf. on Distributed Computing Systems (ICDCS) , pages 104-111, June 1988.<br>[86] Rajesh Raman, Miron Livny, and Marvin Solomon. <strong>Matchmaking: Distributed Resource Management for High Throughput Computing</strong> In Proc. Int’l Symp. on High Performance Distributed Computing (HPDC) , Chicago, IL, USA, July 1998.    </p>"},{"title":"CentOS 7安装TensorFlow GPU深度学习环境","date":"2017-12-03T16:00:00.000Z","_content":"\n在CentOS 7上安装Nvidia GTX 1080 Ti显卡的驱动，以及TensorFlow GPU等深度学习开发环境。\n就这么突然，跟深度学习扯上边了；-)\n\n-----\n<!--more-->\n\n上周老板突然说要给机房的Dell服务器分别装两个显卡，让我去看一下，然后把支持GPU的深度学习开发环境搭起来。装显卡是供应商的一个小哥动手的，基本顺利，遇到的小问题是电源供电不足，需要改一下iDrac中的电源设置，将服务器的两路电源互为备用模式改为两路同时供电，这样功率才够跑两个显卡。\n\n网上一搜，就有不少CentOS上搭环境的文章了，但 1）相关开源项目发展太快，2）不同需求的用户可以有针对性的简化配置过程，所以我把集群上实测过的步骤记录下来。因为自己完全是门外汉，所以还没有涉及具体的深度学习知识。\n\n# 简介\n网上相关文章的步骤大多是先安装驱动，再安装CUDA，还需要安装C++编译器（g++或msvc），再安装cuDNN库，最后通过`pip`或`conda`再安装tensorflow。[TensorFlow官网上的安装说明](https://www.tensorflow.org/install/install_linux)以及 [Nvidia官网上的安装说明](https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/)亦是如此。\n\nCUDA（Compute Unified Device Architecture，统一计算架构）是针对GPU计算加速的开发工具包，就像Windows SDK，或者JDK一样，一些深度学习库（比如TensorFlow）的底层是C++调用的CUDA库，它们提供给深度学习开发者的多是 Python 包装过的接口。一般的开发者直接用这些Python库就可以设计出多种多样的深度学习模型，不再需要跟CUDA打交道。\n\n如果**不需要从源码编译TensorFlow**，就没必要安装NVIDIA官网上的那个一个多GB的CUDA包和cuDNN库。直接通过<del>`pip`或</del>`conda`安装的`tensorflow-gpu`库就自带了对应版本的cuda动态链接库，包括 **libnvrtc-builtins.so，libnvrtc.so，libnvToolsExt.so，libnvvm.so，libcudart.so，libcublas.so，libcudnn.so，libcurand.so，libcufft.so，libcusolver.so，libcusparse.so** 等，还有mkl库（Linux的是`.so`文件，Windows的是`.dll`文件）。\n\n> 注意，见下面关于`pip`和`conda`的小节。\n\n最近（2017-12-4）Nvidia官网上的CUDA版本已经是9.0，而TensorFlow 1.4 使用的是cuda 8.0，cuDNN则是6.0，python又有2.7、3.5、3.6版。各种版本组合起来还有点麻烦呢。我们先从显卡驱动开始。\n\n# 安装显卡驱动\n先看看显卡硬件是不是安装好了，执行`lspci | grep NVIDIA`，可见已经安装了两个GeForce GTX 1080 Ti显卡：\n```\n[root@n170 ~]# lspci | grep NVIDIA\n03:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)\n03:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)\n82:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)\n82:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)\n```\n\n然后安装驱动：\n```\n# 参考：https://www.dedoimedo.com/computers/centos-7-nvidia-second.html\n# 及 https://www.youtube.com/watch?v=C9Yf71qh0i4\n\nsudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\nsudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm\nsudo yum install   nvidia-detect  # 这个命令的输入就是 kmod-nvidia，所以不安装也可以。。。\nsudo yum install $(nvida-detect)\nsudo yum install   kmod-nvidia\nsudo reboot # 重启是必须的\n```\n\n> Ubuntu的命令是\n```\n# 参考：https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/\n\nsudo add-apt-repository ppa:graphics-drivers/ppa \nsudo apt update\nsudo apt install nvidia- # 敲到 nvidia- 后按一下Tab键，稍等一会，会列出补全项，显示目前最新的是387，\n# 就是说完整的命令是\n\nsudo apt install nvidia-387\n\n# 注意，不要选择 378 版，否则会造成无限重试登录\n# 安装后也要重启系统\n```\n\n重启后查看驱动是否安装正确，执行`nvidia-smi`（还可以执行`watch -n 1 nvidia-smi`持续监控）：\n```\n[root@n170 ~]# nvidia-smi\nMon Dec  4 16:03:57 2017       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 384.98                 Driver Version: 384.98                    |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|===============================+======================+======================|\n|   0  GeForce GTX 108...  Off  | 00000000:03:00.0 Off |                  N/A |\n|  0%   29C    P8     8W / 250W |      0MiB / 11172MiB |      0%      Default |\n+-------------------------------+----------------------+----------------------+\n|   1  GeForce GTX 108...  Off  | 00000000:82:00.0 Off |                  N/A |\n|  0%   30C    P8     9W / 250W |      0MiB / 11172MiB |      0%      Default |\n+-------------------------------+----------------------+----------------------+\n                                                                               \n+-----------------------------------------------------------------------------+\n| Processes:                                                       GPU Memory |\n|  GPU       PID   Type   Process name                             Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n```\n\n还可以执行`cat /proc/driver/nvidia/version`\n```\n[root@n170 ~]# cat /proc/driver/nvidia/version \nNVRM version: NVIDIA UNIX x86_64 Kernel Module  384.98  Thu Oct 26 15:16:01 PDT 2017\nGCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)\n```\n\n`gpustat`是一个输出格式比较简单的工具，通过`pip install gpustat`安装后，输出格式如下（其中n170是机器名）：\n```\n[root@n170 ~]# gpustat\nn170  Mon Dec  4 16:07:10 2017\n[0] GeForce GTX 1080 Ti | 28'C,   0 % |     0 / 11172 MB |\n[1] GeForce GTX 1080 Ti | 31'C,   0 % |     0 / 11172 MB |\n```\n\n# 安装 Anaconda 和 Python 3.6\n这里选择的Python版本是3.6，但不是从Python官网或yum安装的，而是Anaconda集成环境内置的版本，这个集成环境还有`conda`包管理器，`jupyter notebook`和`numpy`，`pandas`等一些常用的包。\n\nAnaconda官网下载页是[https://www.anaconda.com/download/] ，不过我们从清华的镜像站下载，这样下载速度快一点[https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh] 。虽然这个安装文件后缀是`.sh`，但实际的二进制安装文件都打包在里面了，有525MB。\n\n安装过程需要用到`bzip2`，先安装一下`sudo yum install -y bzip2`\n执行 `bash Anaconda3-5.0.1-Linux-x86_64.sh` 开始安装，敲回车显示 license agreement ，敲几次空格翻到底，然后输入`yes`接受协议，再敲回车，安装到默认的路径`$HOME/anaconda3`，如果这个路径已经存在，就会安装失败，需要删掉或另选路径。\n安装脚本还会在`.bashrc`的`PATH`环境变量加上安装路径。安装结束后，执行`source .bashrc`，更新`PATH`环境变量，这时系统的`python`命令已经变成Anaconda安装的Python 3.6了（因为安装程序把`$HOME/anaconda3/bin`加在了`PATH`最前面）。\n\n> 更改`conda`源：执行\n`conda config --add channels 'https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/'`\n`conda config --set show_channel_urls yes`\n这两个命令其实是把配置项写到了`~/.condarc`文件，还可以在这里设置http代理：\n```\nchannels:\n  - defaults\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nshow_channel_urls: true\n\nproxy_servers:\n    http:  http://127.0.0.1:1080\n    https: http://127.0.0.1:1080\n\nssl_verify: False\n```\n\n# 安装 TensorFlow\n\n执行 `conda install tensorflow-gpu`，注意，安装的版本是 `1.3.0-py36cuda8.0cudnn6.0_1` ，不是最新的`1.4.0`版，不过好处是开箱即用，就这句命令就搞定了。cuda相关的动态库都已经安装在了`$HOME/anaconda3/lib`。\n\n执行一下官网的测试例子：\n```\n[root@n170 ~]# python\nPython 3.6.2 |Anaconda custom (64-bit)| (default, Sep 22 2017, 02:03:08) \n[GCC 7.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import tensorflow as tf\n>>> hello = tf.constant('Hello, TensorFlow!')\n>>> sess = tf.Session()\n>>> print(sess.run(hello))\nb'Hello, TensorFlow!'\n>>> with tf.Session():\n...     a=tf.constant([1.0, 1.0, 1.0, 1.0])\n...     b=tf.constant(2.0, shape=[4])\n...     out=tf.add(a,b)\n...     print(\"result:\",out.eval())\n... \nresult: [ 3.  3.  3.  3.]\n```\n\nOK，下面就要开始学习深度学习模型了。。。\n\n> TensorFlow禁用没有使用sse编译的Warning，需添加环境变量 `export TF_CPP_MIN_LOG_LEVEL=2`\n> 参考：https://github.com/tensorflow/tensorflow/issues/8037\n\n-----\n\n# 在docker容器中的TensorFlow环境\n\n需要安装`nvidia-container-runtime`插件，才能正确运行支持GPU的容器。参考：[https://github.com/NVIDIA/nvidia-docker]。\n\n>注意，安装过程会 **覆盖** `/etc/docker/daemon.json` 配置文件！需要提前备份。\n\n安装步骤是：\n```\ncurl -s -L https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo | tee /etc/yum.repos.d/nvidia-docker.repo\n\nyum install -y nvidia-docker2\npkill -SIGHUP dockerd\n```\n\n安装后的`/etc/docker/daemon.json` 如下（阿里云的仓库镜像是后来添加的）：\n```\n[root@n170 ~]# cat /etc/docker/daemon.json\n{\n    \"registry-mirrors\": [\"https://lmigye0h.mirror.aliyuncs.com\"],\n    \"runtimes\": {\n        \"nvidia\": {\n            \"path\": \"/usr/bin/nvidia-container-runtime\",\n            \"runtimeArgs\": []\n        }\n    }\n}\n```\n\n其中增加了`nvidia-container-runtime`这个运行时插件，这是`nvidia-docker` v2 的实现方式了，运行一个容器验证一下：\n```\nnvidia-docker run --rm nvidia/cuda nvidia-smi\nnvidia-docker run --rm -e NVIDIA_VISIBLE_DEVICES=1 nvidia/cuda nvidia-smi\n```\n\n其中环境变量`NVIDIA_VISIBLE_DEVICES`是指定GPU设备的可见性，可以是 0,1,... 这样逗号分隔的一个或多个GPU id，也可以是all或none。\n参考：https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices\n\n其实`nvidia-docker`只是一个包装脚本，实际执行的命令是`docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi` 。\n\n至于TensorFlow的容器，执行\n`docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu`\n\n这个镜像有3.36GB。8888端口是jupyter notebook的，6006是tensorboard的端口，因为我的这台机器的8888端口被占用了，所以映射到了8000。\n容器启动后，会输出jupyter notebook的访问token，在浏览器输入主机的IP（假设为2.2.2.170）和映射端口号（这里是8000，不是默认的8888），即\nhttp://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba \n就会打开jupyter notebook，里面有三个TensorFlow入门介绍的ipynb文件，这样就可以编辑运行Python代码了。\n\n```\n[root@n170 ~]# docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu\n[I 03:08:12.136 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret\n[W 03:08:12.159 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.\n[I 03:08:12.165 NotebookApp] Serving notebooks from local directory: /notebooks\n[I 03:08:12.165 NotebookApp] 0 active kernels\n[I 03:08:12.165 NotebookApp] The Jupyter Notebook is running at:\n[I 03:08:12.165 NotebookApp] http://[all ip addresses on your system]:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\n[I 03:08:12.165 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 03:08:12.166 NotebookApp] \n    \n    Copy/paste this URL into your browser when you connect for the first time,\n    to login with a token:\n        http://localhost:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\n\n[root@n170 ~]# # 按 Ctrl + p, q 键退出容器交互终端，容器仍在后台运行\n```\n\n> Anaconda 中也有jupyter notebook，在主机执行命令`jupyter notebook`就会运行后台服务，并启动浏览器打开页面。\n> 默认只能允许localhost访问，如果需要设置别的机器也可以通过主机的IP地址访问notebook，可以参考 [http://jupyter-notebook.readthedocs.io/en/stable/public_server.html] 。\n\n> notebook中用matplotlib画图，如果不想写`plt.show()`，可以在代码前加上`%matplotlib inline`指令，这样执行`plt.plot(...)`就会输出图形。\n\n# pip 和 cuda\n\n如果不是按上面小节的步骤使用`conda`，就要按照教程的步骤，先安装cuda了。\n\n> pip换源，在文件`$HOME/.pip/pip.conf`中添加\n```\n[global]\ntrusted-host =  mirrors.tuna.tsinghua.edu.cn\nindex-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple\n ```\n\n没有安装cuda，直接执行`pip install tensorflow-gpu`，取决于系统的Python版本，不论2.7，3.5或3.6版，都可以安装对应1.4.0版本，但执行上面的测试例子，就会报错：\n```\n... ...\nImportError: libcublas.so.8.0: cannot open shared object file: No such file or directory\n... ...\n```\n\n就是说找不到cuda的动态库。\n\n> 前面也提到了，其实cuda类似JDK，但Nvidia没有把cuda的动态库打包单独提供（类似JRE）。\n> `conda`自己打包了需要的动态库（cudatoolkit，cudnn），可以一键安装，但`pip`就没有这么贴心了，需要安装完整版的cuda SDK。\n\n需要下载的文件和具体安装步骤可见[https://developer.nvidia.com/cuda-downloads] ，目前Nvidia官网提供的是cuda 9.0（不知向前兼容性如何），旧版cuda的下载链接是[https://developer.nvidia.com/cuda-toolkit-archive] ，还要注册一下，然后下载并安装cuDNN的库。\n\n如果之前没有安装显卡驱动的话，按上面官网的介绍，以为上面的步骤会把cuda 9.0和内核驱动一起安装上，而且确实安装了名为`nvidia-kmod`的包，但重启后执行`nvidia-smi`，发现并没有安装成功，不知是什么问题。\n所以还是要按照更前面小节的步骤从elrepo安装`kmod-nvidia`包，不过安装过程会有包冲突，需要根据提示信息卸载：\n```\nsudo yum erase 1:nvidia-kmod-384.81-2.el7.x86_64\nsudo yum erase 1:xorg-x11-drv-nvidia-384.81-1.el7.x86_64\nsudo yum-config-manager --disable cuda-9-0-local\n```\n\n之后再重新执行安装`kmod-nvidia`的命令，重启后验证安装是否正确。再增加环境变量 \n`export LD_LIBRARY_PATH=/usr/local/cuda/lib64/:$LD_LIBRARY_PATH` \nTensorFlow应该就可以找到需要的动态库了。\n\n# 深度学习框架\n\n参考：[https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software]\n\n比较常见的几个框架有：\n+ Tensorflow : Google的项目，参考TensorFlow OSDI`2016的论文，设计目标是在大规模集群和异构硬件（GPU，TPU，ASIC等）上支持深度学习网络的训练和应用\n+ MXNet：由[CMU的李沐博士](https://www.cs.cmu.edu/~muli/) ，[华盛顿大学的陈天齐博士](https://homes.cs.washington.edu/~tqchen/) 等开发的项目，他还有一篇博客介绍了[MXNet设计和实现](http://mli.github.io/2015/12/03/mxnet-overview/) 。目前是Apache的孵化项目，Amazon也在推广MXNet（李沐博士在Amazon工作）。在MXNet的基础上，他们还发布了[更灵活的前端Gluon（胶子）](http://mp.weixin.qq.com/s/_9aY-7aTZDOjeWFKntLnXA) 和[更可拓展的后端NNVM compiler](https://zhuanlan.zhihu.com/p/29914989)\n+ Cognitive Toolkit（CNTK）：这是微软的深度学习项目\n+ Theano：蒙特利尔大学MILA实验室开发的项目，2017年11月15日发布1.0版后就不再继续开发\n+ PyTorch：是基于Lua的Torch项目的Python版本，由Facebook开发\n+ Caffe2，Caffe：是由[UC Berkeley的贾扬清博士](http://daggerfs.com) 开发的，他已经在Facebook工作，所以Caffe2也是Facebook的一个项目\n+ Keras：这个项目是对一些深度学习项目的更高层抽象和统一包装，官方支持的后端有TensorFlow，CNTK和Theano，有些深度学习项目也会提供对Keras的支持。当然，有的项目，像PyTorch，本身的抽象就比较高层，与Keras相当，另外像MXNet自己也有类似的前端Gluon。\n\n从Wiki上的比较列表来看，对深度学习框架的关注点主要有：是否支持GPU加速，支持分布式集群，自动推导梯度，支持的网络类型（CNN，RNN等），是否有预先训练的模型等。\n问了两位搞机器学习方向的同学，他们觉得TensorFlow偏底层，工程化，不如PyTorch写代码直观，Keras虽然理念很好，但性能上还差一点。他们目前还是用单机的GPU来训练模型，跑一次也要不少时间，但还没有准备搞TensorFlow那种分布式计算集群。\n\n对DNN的了解太少了，要抓紧时间啊！\n","source":"_posts/setup-tensorflow-gpu-centos7.md","raw":"\ntitle: CentOS 7安装TensorFlow GPU深度学习环境\ncategory: [cloud]\ntags: \ndate: 2017-12-04\n---\n\n在CentOS 7上安装Nvidia GTX 1080 Ti显卡的驱动，以及TensorFlow GPU等深度学习开发环境。\n就这么突然，跟深度学习扯上边了；-)\n\n-----\n<!--more-->\n\n上周老板突然说要给机房的Dell服务器分别装两个显卡，让我去看一下，然后把支持GPU的深度学习开发环境搭起来。装显卡是供应商的一个小哥动手的，基本顺利，遇到的小问题是电源供电不足，需要改一下iDrac中的电源设置，将服务器的两路电源互为备用模式改为两路同时供电，这样功率才够跑两个显卡。\n\n网上一搜，就有不少CentOS上搭环境的文章了，但 1）相关开源项目发展太快，2）不同需求的用户可以有针对性的简化配置过程，所以我把集群上实测过的步骤记录下来。因为自己完全是门外汉，所以还没有涉及具体的深度学习知识。\n\n# 简介\n网上相关文章的步骤大多是先安装驱动，再安装CUDA，还需要安装C++编译器（g++或msvc），再安装cuDNN库，最后通过`pip`或`conda`再安装tensorflow。[TensorFlow官网上的安装说明](https://www.tensorflow.org/install/install_linux)以及 [Nvidia官网上的安装说明](https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/)亦是如此。\n\nCUDA（Compute Unified Device Architecture，统一计算架构）是针对GPU计算加速的开发工具包，就像Windows SDK，或者JDK一样，一些深度学习库（比如TensorFlow）的底层是C++调用的CUDA库，它们提供给深度学习开发者的多是 Python 包装过的接口。一般的开发者直接用这些Python库就可以设计出多种多样的深度学习模型，不再需要跟CUDA打交道。\n\n如果**不需要从源码编译TensorFlow**，就没必要安装NVIDIA官网上的那个一个多GB的CUDA包和cuDNN库。直接通过<del>`pip`或</del>`conda`安装的`tensorflow-gpu`库就自带了对应版本的cuda动态链接库，包括 **libnvrtc-builtins.so，libnvrtc.so，libnvToolsExt.so，libnvvm.so，libcudart.so，libcublas.so，libcudnn.so，libcurand.so，libcufft.so，libcusolver.so，libcusparse.so** 等，还有mkl库（Linux的是`.so`文件，Windows的是`.dll`文件）。\n\n> 注意，见下面关于`pip`和`conda`的小节。\n\n最近（2017-12-4）Nvidia官网上的CUDA版本已经是9.0，而TensorFlow 1.4 使用的是cuda 8.0，cuDNN则是6.0，python又有2.7、3.5、3.6版。各种版本组合起来还有点麻烦呢。我们先从显卡驱动开始。\n\n# 安装显卡驱动\n先看看显卡硬件是不是安装好了，执行`lspci | grep NVIDIA`，可见已经安装了两个GeForce GTX 1080 Ti显卡：\n```\n[root@n170 ~]# lspci | grep NVIDIA\n03:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)\n03:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)\n82:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)\n82:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)\n```\n\n然后安装驱动：\n```\n# 参考：https://www.dedoimedo.com/computers/centos-7-nvidia-second.html\n# 及 https://www.youtube.com/watch?v=C9Yf71qh0i4\n\nsudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\nsudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm\nsudo yum install   nvidia-detect  # 这个命令的输入就是 kmod-nvidia，所以不安装也可以。。。\nsudo yum install $(nvida-detect)\nsudo yum install   kmod-nvidia\nsudo reboot # 重启是必须的\n```\n\n> Ubuntu的命令是\n```\n# 参考：https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/\n\nsudo add-apt-repository ppa:graphics-drivers/ppa \nsudo apt update\nsudo apt install nvidia- # 敲到 nvidia- 后按一下Tab键，稍等一会，会列出补全项，显示目前最新的是387，\n# 就是说完整的命令是\n\nsudo apt install nvidia-387\n\n# 注意，不要选择 378 版，否则会造成无限重试登录\n# 安装后也要重启系统\n```\n\n重启后查看驱动是否安装正确，执行`nvidia-smi`（还可以执行`watch -n 1 nvidia-smi`持续监控）：\n```\n[root@n170 ~]# nvidia-smi\nMon Dec  4 16:03:57 2017       \n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 384.98                 Driver Version: 384.98                    |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|===============================+======================+======================|\n|   0  GeForce GTX 108...  Off  | 00000000:03:00.0 Off |                  N/A |\n|  0%   29C    P8     8W / 250W |      0MiB / 11172MiB |      0%      Default |\n+-------------------------------+----------------------+----------------------+\n|   1  GeForce GTX 108...  Off  | 00000000:82:00.0 Off |                  N/A |\n|  0%   30C    P8     9W / 250W |      0MiB / 11172MiB |      0%      Default |\n+-------------------------------+----------------------+----------------------+\n                                                                               \n+-----------------------------------------------------------------------------+\n| Processes:                                                       GPU Memory |\n|  GPU       PID   Type   Process name                             Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n```\n\n还可以执行`cat /proc/driver/nvidia/version`\n```\n[root@n170 ~]# cat /proc/driver/nvidia/version \nNVRM version: NVIDIA UNIX x86_64 Kernel Module  384.98  Thu Oct 26 15:16:01 PDT 2017\nGCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)\n```\n\n`gpustat`是一个输出格式比较简单的工具，通过`pip install gpustat`安装后，输出格式如下（其中n170是机器名）：\n```\n[root@n170 ~]# gpustat\nn170  Mon Dec  4 16:07:10 2017\n[0] GeForce GTX 1080 Ti | 28'C,   0 % |     0 / 11172 MB |\n[1] GeForce GTX 1080 Ti | 31'C,   0 % |     0 / 11172 MB |\n```\n\n# 安装 Anaconda 和 Python 3.6\n这里选择的Python版本是3.6，但不是从Python官网或yum安装的，而是Anaconda集成环境内置的版本，这个集成环境还有`conda`包管理器，`jupyter notebook`和`numpy`，`pandas`等一些常用的包。\n\nAnaconda官网下载页是[https://www.anaconda.com/download/] ，不过我们从清华的镜像站下载，这样下载速度快一点[https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh] 。虽然这个安装文件后缀是`.sh`，但实际的二进制安装文件都打包在里面了，有525MB。\n\n安装过程需要用到`bzip2`，先安装一下`sudo yum install -y bzip2`\n执行 `bash Anaconda3-5.0.1-Linux-x86_64.sh` 开始安装，敲回车显示 license agreement ，敲几次空格翻到底，然后输入`yes`接受协议，再敲回车，安装到默认的路径`$HOME/anaconda3`，如果这个路径已经存在，就会安装失败，需要删掉或另选路径。\n安装脚本还会在`.bashrc`的`PATH`环境变量加上安装路径。安装结束后，执行`source .bashrc`，更新`PATH`环境变量，这时系统的`python`命令已经变成Anaconda安装的Python 3.6了（因为安装程序把`$HOME/anaconda3/bin`加在了`PATH`最前面）。\n\n> 更改`conda`源：执行\n`conda config --add channels 'https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/'`\n`conda config --set show_channel_urls yes`\n这两个命令其实是把配置项写到了`~/.condarc`文件，还可以在这里设置http代理：\n```\nchannels:\n  - defaults\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nshow_channel_urls: true\n\nproxy_servers:\n    http:  http://127.0.0.1:1080\n    https: http://127.0.0.1:1080\n\nssl_verify: False\n```\n\n# 安装 TensorFlow\n\n执行 `conda install tensorflow-gpu`，注意，安装的版本是 `1.3.0-py36cuda8.0cudnn6.0_1` ，不是最新的`1.4.0`版，不过好处是开箱即用，就这句命令就搞定了。cuda相关的动态库都已经安装在了`$HOME/anaconda3/lib`。\n\n执行一下官网的测试例子：\n```\n[root@n170 ~]# python\nPython 3.6.2 |Anaconda custom (64-bit)| (default, Sep 22 2017, 02:03:08) \n[GCC 7.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import tensorflow as tf\n>>> hello = tf.constant('Hello, TensorFlow!')\n>>> sess = tf.Session()\n>>> print(sess.run(hello))\nb'Hello, TensorFlow!'\n>>> with tf.Session():\n...     a=tf.constant([1.0, 1.0, 1.0, 1.0])\n...     b=tf.constant(2.0, shape=[4])\n...     out=tf.add(a,b)\n...     print(\"result:\",out.eval())\n... \nresult: [ 3.  3.  3.  3.]\n```\n\nOK，下面就要开始学习深度学习模型了。。。\n\n> TensorFlow禁用没有使用sse编译的Warning，需添加环境变量 `export TF_CPP_MIN_LOG_LEVEL=2`\n> 参考：https://github.com/tensorflow/tensorflow/issues/8037\n\n-----\n\n# 在docker容器中的TensorFlow环境\n\n需要安装`nvidia-container-runtime`插件，才能正确运行支持GPU的容器。参考：[https://github.com/NVIDIA/nvidia-docker]。\n\n>注意，安装过程会 **覆盖** `/etc/docker/daemon.json` 配置文件！需要提前备份。\n\n安装步骤是：\n```\ncurl -s -L https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo | tee /etc/yum.repos.d/nvidia-docker.repo\n\nyum install -y nvidia-docker2\npkill -SIGHUP dockerd\n```\n\n安装后的`/etc/docker/daemon.json` 如下（阿里云的仓库镜像是后来添加的）：\n```\n[root@n170 ~]# cat /etc/docker/daemon.json\n{\n    \"registry-mirrors\": [\"https://lmigye0h.mirror.aliyuncs.com\"],\n    \"runtimes\": {\n        \"nvidia\": {\n            \"path\": \"/usr/bin/nvidia-container-runtime\",\n            \"runtimeArgs\": []\n        }\n    }\n}\n```\n\n其中增加了`nvidia-container-runtime`这个运行时插件，这是`nvidia-docker` v2 的实现方式了，运行一个容器验证一下：\n```\nnvidia-docker run --rm nvidia/cuda nvidia-smi\nnvidia-docker run --rm -e NVIDIA_VISIBLE_DEVICES=1 nvidia/cuda nvidia-smi\n```\n\n其中环境变量`NVIDIA_VISIBLE_DEVICES`是指定GPU设备的可见性，可以是 0,1,... 这样逗号分隔的一个或多个GPU id，也可以是all或none。\n参考：https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices\n\n其实`nvidia-docker`只是一个包装脚本，实际执行的命令是`docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi` 。\n\n至于TensorFlow的容器，执行\n`docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu`\n\n这个镜像有3.36GB。8888端口是jupyter notebook的，6006是tensorboard的端口，因为我的这台机器的8888端口被占用了，所以映射到了8000。\n容器启动后，会输出jupyter notebook的访问token，在浏览器输入主机的IP（假设为2.2.2.170）和映射端口号（这里是8000，不是默认的8888），即\nhttp://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba \n就会打开jupyter notebook，里面有三个TensorFlow入门介绍的ipynb文件，这样就可以编辑运行Python代码了。\n\n```\n[root@n170 ~]# docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu\n[I 03:08:12.136 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret\n[W 03:08:12.159 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.\n[I 03:08:12.165 NotebookApp] Serving notebooks from local directory: /notebooks\n[I 03:08:12.165 NotebookApp] 0 active kernels\n[I 03:08:12.165 NotebookApp] The Jupyter Notebook is running at:\n[I 03:08:12.165 NotebookApp] http://[all ip addresses on your system]:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\n[I 03:08:12.165 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 03:08:12.166 NotebookApp] \n    \n    Copy/paste this URL into your browser when you connect for the first time,\n    to login with a token:\n        http://localhost:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\n\n[root@n170 ~]# # 按 Ctrl + p, q 键退出容器交互终端，容器仍在后台运行\n```\n\n> Anaconda 中也有jupyter notebook，在主机执行命令`jupyter notebook`就会运行后台服务，并启动浏览器打开页面。\n> 默认只能允许localhost访问，如果需要设置别的机器也可以通过主机的IP地址访问notebook，可以参考 [http://jupyter-notebook.readthedocs.io/en/stable/public_server.html] 。\n\n> notebook中用matplotlib画图，如果不想写`plt.show()`，可以在代码前加上`%matplotlib inline`指令，这样执行`plt.plot(...)`就会输出图形。\n\n# pip 和 cuda\n\n如果不是按上面小节的步骤使用`conda`，就要按照教程的步骤，先安装cuda了。\n\n> pip换源，在文件`$HOME/.pip/pip.conf`中添加\n```\n[global]\ntrusted-host =  mirrors.tuna.tsinghua.edu.cn\nindex-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple\n ```\n\n没有安装cuda，直接执行`pip install tensorflow-gpu`，取决于系统的Python版本，不论2.7，3.5或3.6版，都可以安装对应1.4.0版本，但执行上面的测试例子，就会报错：\n```\n... ...\nImportError: libcublas.so.8.0: cannot open shared object file: No such file or directory\n... ...\n```\n\n就是说找不到cuda的动态库。\n\n> 前面也提到了，其实cuda类似JDK，但Nvidia没有把cuda的动态库打包单独提供（类似JRE）。\n> `conda`自己打包了需要的动态库（cudatoolkit，cudnn），可以一键安装，但`pip`就没有这么贴心了，需要安装完整版的cuda SDK。\n\n需要下载的文件和具体安装步骤可见[https://developer.nvidia.com/cuda-downloads] ，目前Nvidia官网提供的是cuda 9.0（不知向前兼容性如何），旧版cuda的下载链接是[https://developer.nvidia.com/cuda-toolkit-archive] ，还要注册一下，然后下载并安装cuDNN的库。\n\n如果之前没有安装显卡驱动的话，按上面官网的介绍，以为上面的步骤会把cuda 9.0和内核驱动一起安装上，而且确实安装了名为`nvidia-kmod`的包，但重启后执行`nvidia-smi`，发现并没有安装成功，不知是什么问题。\n所以还是要按照更前面小节的步骤从elrepo安装`kmod-nvidia`包，不过安装过程会有包冲突，需要根据提示信息卸载：\n```\nsudo yum erase 1:nvidia-kmod-384.81-2.el7.x86_64\nsudo yum erase 1:xorg-x11-drv-nvidia-384.81-1.el7.x86_64\nsudo yum-config-manager --disable cuda-9-0-local\n```\n\n之后再重新执行安装`kmod-nvidia`的命令，重启后验证安装是否正确。再增加环境变量 \n`export LD_LIBRARY_PATH=/usr/local/cuda/lib64/:$LD_LIBRARY_PATH` \nTensorFlow应该就可以找到需要的动态库了。\n\n# 深度学习框架\n\n参考：[https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software]\n\n比较常见的几个框架有：\n+ Tensorflow : Google的项目，参考TensorFlow OSDI`2016的论文，设计目标是在大规模集群和异构硬件（GPU，TPU，ASIC等）上支持深度学习网络的训练和应用\n+ MXNet：由[CMU的李沐博士](https://www.cs.cmu.edu/~muli/) ，[华盛顿大学的陈天齐博士](https://homes.cs.washington.edu/~tqchen/) 等开发的项目，他还有一篇博客介绍了[MXNet设计和实现](http://mli.github.io/2015/12/03/mxnet-overview/) 。目前是Apache的孵化项目，Amazon也在推广MXNet（李沐博士在Amazon工作）。在MXNet的基础上，他们还发布了[更灵活的前端Gluon（胶子）](http://mp.weixin.qq.com/s/_9aY-7aTZDOjeWFKntLnXA) 和[更可拓展的后端NNVM compiler](https://zhuanlan.zhihu.com/p/29914989)\n+ Cognitive Toolkit（CNTK）：这是微软的深度学习项目\n+ Theano：蒙特利尔大学MILA实验室开发的项目，2017年11月15日发布1.0版后就不再继续开发\n+ PyTorch：是基于Lua的Torch项目的Python版本，由Facebook开发\n+ Caffe2，Caffe：是由[UC Berkeley的贾扬清博士](http://daggerfs.com) 开发的，他已经在Facebook工作，所以Caffe2也是Facebook的一个项目\n+ Keras：这个项目是对一些深度学习项目的更高层抽象和统一包装，官方支持的后端有TensorFlow，CNTK和Theano，有些深度学习项目也会提供对Keras的支持。当然，有的项目，像PyTorch，本身的抽象就比较高层，与Keras相当，另外像MXNet自己也有类似的前端Gluon。\n\n从Wiki上的比较列表来看，对深度学习框架的关注点主要有：是否支持GPU加速，支持分布式集群，自动推导梯度，支持的网络类型（CNN，RNN等），是否有预先训练的模型等。\n问了两位搞机器学习方向的同学，他们觉得TensorFlow偏底层，工程化，不如PyTorch写代码直观，Keras虽然理念很好，但性能上还差一点。他们目前还是用单机的GPU来训练模型，跑一次也要不少时间，但还没有准备搞TensorFlow那种分布式计算集群。\n\n对DNN的了解太少了，要抓紧时间啊！\n","slug":"setup-tensorflow-gpu-centos7","published":1,"updated":"2017-12-05T10:05:43.946Z","_id":"cjas90uya00006s4fosn5yf7z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在CentOS 7上安装Nvidia GTX 1080 Ti显卡的驱动，以及TensorFlow GPU等深度学习开发环境。<br>就这么突然，跟深度学习扯上边了；-)</p>\n<hr>\n<a id=\"more\"></a>\n<p>上周老板突然说要给机房的Dell服务器分别装两个显卡，让我去看一下，然后把支持GPU的深度学习开发环境搭起来。装显卡是供应商的一个小哥动手的，基本顺利，遇到的小问题是电源供电不足，需要改一下iDrac中的电源设置，将服务器的两路电源互为备用模式改为两路同时供电，这样功率才够跑两个显卡。</p>\n<p>网上一搜，就有不少CentOS上搭环境的文章了，但 1）相关开源项目发展太快，2）不同需求的用户可以有针对性的简化配置过程，所以我把集群上实测过的步骤记录下来。因为自己完全是门外汉，所以还没有涉及具体的深度学习知识。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>网上相关文章的步骤大多是先安装驱动，再安装CUDA，还需要安装C++编译器（g++或msvc），再安装cuDNN库，最后通过<code>pip</code>或<code>conda</code>再安装tensorflow。<a href=\"https://www.tensorflow.org/install/install_linux\" target=\"_blank\" rel=\"external\">TensorFlow官网上的安装说明</a>以及 <a href=\"https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/\" target=\"_blank\" rel=\"external\">Nvidia官网上的安装说明</a>亦是如此。</p>\n<p>CUDA（Compute Unified Device Architecture，统一计算架构）是针对GPU计算加速的开发工具包，就像Windows SDK，或者JDK一样，一些深度学习库（比如TensorFlow）的底层是C++调用的CUDA库，它们提供给深度学习开发者的多是 Python 包装过的接口。一般的开发者直接用这些Python库就可以设计出多种多样的深度学习模型，不再需要跟CUDA打交道。</p>\n<p>如果<strong>不需要从源码编译TensorFlow</strong>，就没必要安装NVIDIA官网上的那个一个多GB的CUDA包和cuDNN库。直接通过<del><code>pip</code>或</del><code>conda</code>安装的<code>tensorflow-gpu</code>库就自带了对应版本的cuda动态链接库，包括 <strong>libnvrtc-builtins.so，libnvrtc.so，libnvToolsExt.so，libnvvm.so，libcudart.so，libcublas.so，libcudnn.so，libcurand.so，libcufft.so，libcusolver.so，libcusparse.so</strong> 等，还有mkl库（Linux的是<code>.so</code>文件，Windows的是<code>.dll</code>文件）。</p>\n<blockquote>\n<p>注意，见下面关于<code>pip</code>和<code>conda</code>的小节。</p>\n</blockquote>\n<p>最近（2017-12-4）Nvidia官网上的CUDA版本已经是9.0，而TensorFlow 1.4 使用的是cuda 8.0，cuDNN则是6.0，python又有2.7、3.5、3.6版。各种版本组合起来还有点麻烦呢。我们先从显卡驱动开始。</p>\n<h1 id=\"安装显卡驱动\"><a href=\"#安装显卡驱动\" class=\"headerlink\" title=\"安装显卡驱动\"></a>安装显卡驱动</h1><p>先看看显卡硬件是不是安装好了，执行<code>lspci | grep NVIDIA</code>，可见已经安装了两个GeForce GTX 1080 Ti显卡：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# lspci | grep NVIDIA</div><div class=\"line\">03:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)</div><div class=\"line\">03:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)</div><div class=\"line\">82:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)</div><div class=\"line\">82:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)</div></pre></td></tr></table></figure></p>\n<p>然后安装驱动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 参考：https://www.dedoimedo.com/computers/centos-7-nvidia-second.html</div><div class=\"line\"># 及 https://www.youtube.com/watch?v=C9Yf71qh0i4</div><div class=\"line\"></div><div class=\"line\">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</div><div class=\"line\">sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</div><div class=\"line\">sudo yum install   nvidia-detect  # 这个命令的输入就是 kmod-nvidia，所以不安装也可以。。。</div><div class=\"line\">sudo yum install $(nvida-detect)</div><div class=\"line\">sudo yum install   kmod-nvidia</div><div class=\"line\">sudo reboot # 重启是必须的</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Ubuntu的命令是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 参考：https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/</div><div class=\"line\"></div><div class=\"line\">sudo add-apt-repository ppa:graphics-drivers/ppa </div><div class=\"line\">sudo apt update</div><div class=\"line\">sudo apt install nvidia- # 敲到 nvidia- 后按一下Tab键，稍等一会，会列出补全项，显示目前最新的是387，</div><div class=\"line\"># 就是说完整的命令是</div><div class=\"line\"></div><div class=\"line\">sudo apt install nvidia-387</div><div class=\"line\"></div><div class=\"line\"># 注意，不要选择 378 版，否则会造成无限重试登录</div><div class=\"line\"># 安装后也要重启系统</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>重启后查看驱动是否安装正确，执行<code>nvidia-smi</code>（还可以执行<code>watch -n 1 nvidia-smi</code>持续监控）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# nvidia-smi</div><div class=\"line\">Mon Dec  4 16:03:57 2017       </div><div class=\"line\">+-----------------------------------------------------------------------------+</div><div class=\"line\">| NVIDIA-SMI 384.98                 Driver Version: 384.98                    |</div><div class=\"line\">|-------------------------------+----------------------+----------------------+</div><div class=\"line\">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class=\"line\">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class=\"line\">|===============================+======================+======================|</div><div class=\"line\">|   0  GeForce GTX 108...  Off  | 00000000:03:00.0 Off |                  N/A |</div><div class=\"line\">|  0%   29C    P8     8W / 250W |      0MiB / 11172MiB |      0%      Default |</div><div class=\"line\">+-------------------------------+----------------------+----------------------+</div><div class=\"line\">|   1  GeForce GTX 108...  Off  | 00000000:82:00.0 Off |                  N/A |</div><div class=\"line\">|  0%   30C    P8     9W / 250W |      0MiB / 11172MiB |      0%      Default |</div><div class=\"line\">+-------------------------------+----------------------+----------------------+</div><div class=\"line\">                                                                               </div><div class=\"line\">+-----------------------------------------------------------------------------+</div><div class=\"line\">| Processes:                                                       GPU Memory |</div><div class=\"line\">|  GPU       PID   Type   Process name                             Usage      |</div><div class=\"line\">|=============================================================================|</div><div class=\"line\">|  No running processes found                                                 |</div><div class=\"line\">+-----------------------------------------------------------------------------+</div></pre></td></tr></table></figure></p>\n<p>还可以执行<code>cat /proc/driver/nvidia/version</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# cat /proc/driver/nvidia/version </div><div class=\"line\">NVRM version: NVIDIA UNIX x86_64 Kernel Module  384.98  Thu Oct 26 15:16:01 PDT 2017</div><div class=\"line\">GCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</div></pre></td></tr></table></figure></p>\n<p><code>gpustat</code>是一个输出格式比较简单的工具，通过<code>pip install gpustat</code>安装后，输出格式如下（其中n170是机器名）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# gpustat</div><div class=\"line\">n170  Mon Dec  4 16:07:10 2017</div><div class=\"line\">[0] GeForce GTX 1080 Ti | 28&apos;C,   0 % |     0 / 11172 MB |</div><div class=\"line\">[1] GeForce GTX 1080 Ti | 31&apos;C,   0 % |     0 / 11172 MB |</div></pre></td></tr></table></figure></p>\n<h1 id=\"安装-Anaconda-和-Python-3-6\"><a href=\"#安装-Anaconda-和-Python-3-6\" class=\"headerlink\" title=\"安装 Anaconda 和 Python 3.6\"></a>安装 Anaconda 和 Python 3.6</h1><p>这里选择的Python版本是3.6，但不是从Python官网或yum安装的，而是Anaconda集成环境内置的版本，这个集成环境还有<code>conda</code>包管理器，<code>jupyter notebook</code>和<code>numpy</code>，<code>pandas</code>等一些常用的包。</p>\n<p>Anaconda官网下载页是[<a href=\"https://www.anaconda.com/download/\" target=\"_blank\" rel=\"external\">https://www.anaconda.com/download/</a>] ，不过我们从清华的镜像站下载，这样下载速度快一点[<a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh\" target=\"_blank\" rel=\"external\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh</a>] 。虽然这个安装文件后缀是<code>.sh</code>，但实际的二进制安装文件都打包在里面了，有525MB。</p>\n<p>安装过程需要用到<code>bzip2</code>，先安装一下<code>sudo yum install -y bzip2</code><br>执行 <code>bash Anaconda3-5.0.1-Linux-x86_64.sh</code> 开始安装，敲回车显示 license agreement ，敲几次空格翻到底，然后输入<code>yes</code>接受协议，再敲回车，安装到默认的路径<code>$HOME/anaconda3</code>，如果这个路径已经存在，就会安装失败，需要删掉或另选路径。<br>安装脚本还会在<code>.bashrc</code>的<code>PATH</code>环境变量加上安装路径。安装结束后，执行<code>source .bashrc</code>，更新<code>PATH</code>环境变量，这时系统的<code>python</code>命令已经变成Anaconda安装的Python 3.6了（因为安装程序把<code>$HOME/anaconda3/bin</code>加在了<code>PATH</code>最前面）。</p>\n<blockquote>\n<p>更改<code>conda</code>源：执行<br><code>conda config --add channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;</code><br><code>conda config --set show_channel_urls yes</code><br>这两个命令其实是把配置项写到了<code>~/.condarc</code>文件，还可以在这里设置http代理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">channels:</div><div class=\"line\">  - defaults</div><div class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class=\"line\">show_channel_urls: true</div><div class=\"line\"></div><div class=\"line\">proxy_servers:</div><div class=\"line\">    http:  http://127.0.0.1:1080</div><div class=\"line\">    https: http://127.0.0.1:1080</div><div class=\"line\"></div><div class=\"line\">ssl_verify: False</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"安装-TensorFlow\"><a href=\"#安装-TensorFlow\" class=\"headerlink\" title=\"安装 TensorFlow\"></a>安装 TensorFlow</h1><p>执行 <code>conda install tensorflow-gpu</code>，注意，安装的版本是 <code>1.3.0-py36cuda8.0cudnn6.0_1</code> ，不是最新的<code>1.4.0</code>版，不过好处是开箱即用，就这句命令就搞定了。cuda相关的动态库都已经安装在了<code>$HOME/anaconda3/lib</code>。</p>\n<p>执行一下官网的测试例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# python</div><div class=\"line\">Python 3.6.2 |Anaconda custom (64-bit)| (default, Sep 22 2017, 02:03:08) </div><div class=\"line\">[GCC 7.2.0] on linux</div><div class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class=\"line\">&gt;&gt;&gt; import tensorflow as tf</div><div class=\"line\">&gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)</div><div class=\"line\">&gt;&gt;&gt; sess = tf.Session()</div><div class=\"line\">&gt;&gt;&gt; print(sess.run(hello))</div><div class=\"line\">b&apos;Hello, TensorFlow!&apos;</div><div class=\"line\">&gt;&gt;&gt; with tf.Session():</div><div class=\"line\">...     a=tf.constant([1.0, 1.0, 1.0, 1.0])</div><div class=\"line\">...     b=tf.constant(2.0, shape=[4])</div><div class=\"line\">...     out=tf.add(a,b)</div><div class=\"line\">...     print(&quot;result:&quot;,out.eval())</div><div class=\"line\">... </div><div class=\"line\">result: [ 3.  3.  3.  3.]</div></pre></td></tr></table></figure></p>\n<p>OK，下面就要开始学习深度学习模型了。。。</p>\n<blockquote>\n<p>TensorFlow禁用没有使用sse编译的Warning，需添加环境变量 <code>export TF_CPP_MIN_LOG_LEVEL=2</code><br>参考：<a href=\"https://github.com/tensorflow/tensorflow/issues/8037\" target=\"_blank\" rel=\"external\">https://github.com/tensorflow/tensorflow/issues/8037</a></p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中的TensorFlow环境\"><a href=\"#在docker容器中的TensorFlow环境\" class=\"headerlink\" title=\"在docker容器中的TensorFlow环境\"></a>在docker容器中的TensorFlow环境</h1><p>需要安装<code>nvidia-container-runtime</code>插件，才能正确运行支持GPU的容器。参考：[<a href=\"https://github.com/NVIDIA/nvidia-docker]。\" target=\"_blank\" rel=\"external\">https://github.com/NVIDIA/nvidia-docker]。</a></p>\n<blockquote>\n<p>注意，安装过程会 <strong>覆盖</strong> <code>/etc/docker/daemon.json</code> 配置文件！需要提前备份。</p>\n</blockquote>\n<p>安装步骤是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -s -L https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo | tee /etc/yum.repos.d/nvidia-docker.repo</div><div class=\"line\"></div><div class=\"line\">yum install -y nvidia-docker2</div><div class=\"line\">pkill -SIGHUP dockerd</div></pre></td></tr></table></figure></p>\n<p>安装后的<code>/etc/docker/daemon.json</code> 如下（阿里云的仓库镜像是后来添加的）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# cat /etc/docker/daemon.json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;registry-mirrors&quot;: [&quot;https://lmigye0h.mirror.aliyuncs.com&quot;],</div><div class=\"line\">    &quot;runtimes&quot;: &#123;</div><div class=\"line\">        &quot;nvidia&quot;: &#123;</div><div class=\"line\">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</div><div class=\"line\">            &quot;runtimeArgs&quot;: []</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中增加了<code>nvidia-container-runtime</code>这个运行时插件，这是<code>nvidia-docker</code> v2 的实现方式了，运行一个容器验证一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvidia-docker run --rm nvidia/cuda nvidia-smi</div><div class=\"line\">nvidia-docker run --rm -e NVIDIA_VISIBLE_DEVICES=1 nvidia/cuda nvidia-smi</div></pre></td></tr></table></figure></p>\n<p>其中环境变量<code>NVIDIA_VISIBLE_DEVICES</code>是指定GPU设备的可见性，可以是 0,1,… 这样逗号分隔的一个或多个GPU id，也可以是all或none。<br>参考：<a href=\"https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices\" target=\"_blank\" rel=\"external\">https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices</a></p>\n<p>其实<code>nvidia-docker</code>只是一个包装脚本，实际执行的命令是<code>docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</code> 。</p>\n<p>至于TensorFlow的容器，执行<br><code>docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu</code></p>\n<p>这个镜像有3.36GB。8888端口是jupyter notebook的，6006是tensorboard的端口，因为我的这台机器的8888端口被占用了，所以映射到了8000。<br>容器启动后，会输出jupyter notebook的访问token，在浏览器输入主机的IP（假设为2.2.2.170）和映射端口号（这里是8000，不是默认的8888），即<br><a href=\"http://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\" target=\"_blank\" rel=\"external\">http://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</a><br>就会打开jupyter notebook，里面有三个TensorFlow入门介绍的ipynb文件，这样就可以编辑运行Python代码了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu</div><div class=\"line\">[I 03:08:12.136 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret</div><div class=\"line\">[W 03:08:12.159 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.</div><div class=\"line\">[I 03:08:12.165 NotebookApp] Serving notebooks from local directory: /notebooks</div><div class=\"line\">[I 03:08:12.165 NotebookApp] 0 active kernels</div><div class=\"line\">[I 03:08:12.165 NotebookApp] The Jupyter Notebook is running at:</div><div class=\"line\">[I 03:08:12.165 NotebookApp] http://[all ip addresses on your system]:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</div><div class=\"line\">[I 03:08:12.165 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</div><div class=\"line\">[C 03:08:12.166 NotebookApp] </div><div class=\"line\">    </div><div class=\"line\">    Copy/paste this URL into your browser when you connect for the first time,</div><div class=\"line\">    to login with a token:</div><div class=\"line\">        http://localhost:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</div><div class=\"line\"></div><div class=\"line\">[root@n170 ~]# # 按 Ctrl + p, q 键退出容器交互终端，容器仍在后台运行</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Anaconda 中也有jupyter notebook，在主机执行命令<code>jupyter notebook</code>就会运行后台服务，并启动浏览器打开页面。<br>默认只能允许localhost访问，如果需要设置别的机器也可以通过主机的IP地址访问notebook，可以参考 [<a href=\"http://jupyter-notebook.readthedocs.io/en/stable/public_server.html\" target=\"_blank\" rel=\"external\">http://jupyter-notebook.readthedocs.io/en/stable/public_server.html</a>] 。</p>\n<p>notebook中用matplotlib画图，如果不想写<code>plt.show()</code>，可以在代码前加上<code>%matplotlib inline</code>指令，这样执行<code>plt.plot(...)</code>就会输出图形。</p>\n</blockquote>\n<h1 id=\"pip-和-cuda\"><a href=\"#pip-和-cuda\" class=\"headerlink\" title=\"pip 和 cuda\"></a>pip 和 cuda</h1><p>如果不是按上面小节的步骤使用<code>conda</code>，就要按照教程的步骤，先安装cuda了。</p>\n<blockquote>\n<p>pip换源，在文件<code>$HOME/.pip/pip.conf</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">trusted-host =  mirrors.tuna.tsinghua.edu.cn</div><div class=\"line\">index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>没有安装cuda，直接执行<code>pip install tensorflow-gpu</code>，取决于系统的Python版本，不论2.7，3.5或3.6版，都可以安装对应1.4.0版本，但执行上面的测试例子，就会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">... ...</div><div class=\"line\">ImportError: libcublas.so.8.0: cannot open shared object file: No such file or directory</div><div class=\"line\">... ...</div></pre></td></tr></table></figure></p>\n<p>就是说找不到cuda的动态库。</p>\n<blockquote>\n<p>前面也提到了，其实cuda类似JDK，但Nvidia没有把cuda的动态库打包单独提供（类似JRE）。<br><code>conda</code>自己打包了需要的动态库（cudatoolkit，cudnn），可以一键安装，但<code>pip</code>就没有这么贴心了，需要安装完整版的cuda SDK。</p>\n</blockquote>\n<p>需要下载的文件和具体安装步骤可见[<a href=\"https://developer.nvidia.com/cuda-downloads\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cuda-downloads</a>] ，目前Nvidia官网提供的是cuda 9.0（不知向前兼容性如何），旧版cuda的下载链接是[<a href=\"https://developer.nvidia.com/cuda-toolkit-archive\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cuda-toolkit-archive</a>] ，还要注册一下，然后下载并安装cuDNN的库。</p>\n<p>如果之前没有安装显卡驱动的话，按上面官网的介绍，以为上面的步骤会把cuda 9.0和内核驱动一起安装上，而且确实安装了名为<code>nvidia-kmod</code>的包，但重启后执行<code>nvidia-smi</code>，发现并没有安装成功，不知是什么问题。<br>所以还是要按照更前面小节的步骤从elrepo安装<code>kmod-nvidia</code>包，不过安装过程会有包冲突，需要根据提示信息卸载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum erase 1:nvidia-kmod-384.81-2.el7.x86_64</div><div class=\"line\">sudo yum erase 1:xorg-x11-drv-nvidia-384.81-1.el7.x86_64</div><div class=\"line\">sudo yum-config-manager --disable cuda-9-0-local</div></pre></td></tr></table></figure></p>\n<p>之后再重新执行安装<code>kmod-nvidia</code>的命令，重启后验证安装是否正确。再增加环境变量<br><code>export LD_LIBRARY_PATH=/usr/local/cuda/lib64/:$LD_LIBRARY_PATH</code><br>TensorFlow应该就可以找到需要的动态库了。</p>\n<h1 id=\"深度学习框架\"><a href=\"#深度学习框架\" class=\"headerlink\" title=\"深度学习框架\"></a>深度学习框架</h1><p>参考：[<a href=\"https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software</a>]</p>\n<p>比较常见的几个框架有：</p>\n<ul>\n<li>Tensorflow : Google的项目，参考TensorFlow OSDI`2016的论文，设计目标是在大规模集群和异构硬件（GPU，TPU，ASIC等）上支持深度学习网络的训练和应用</li>\n<li>MXNet：由<a href=\"https://www.cs.cmu.edu/~muli/\" target=\"_blank\" rel=\"external\">CMU的李沐博士</a> ，<a href=\"https://homes.cs.washington.edu/~tqchen/\" target=\"_blank\" rel=\"external\">华盛顿大学的陈天齐博士</a> 等开发的项目，他还有一篇博客介绍了<a href=\"http://mli.github.io/2015/12/03/mxnet-overview/\" target=\"_blank\" rel=\"external\">MXNet设计和实现</a> 。目前是Apache的孵化项目，Amazon也在推广MXNet（李沐博士在Amazon工作）。在MXNet的基础上，他们还发布了<a href=\"http://mp.weixin.qq.com/s/_9aY-7aTZDOjeWFKntLnXA\" target=\"_blank\" rel=\"external\">更灵活的前端Gluon（胶子）</a> 和<a href=\"https://zhuanlan.zhihu.com/p/29914989\" target=\"_blank\" rel=\"external\">更可拓展的后端NNVM compiler</a></li>\n<li>Cognitive Toolkit（CNTK）：这是微软的深度学习项目</li>\n<li>Theano：蒙特利尔大学MILA实验室开发的项目，2017年11月15日发布1.0版后就不再继续开发</li>\n<li>PyTorch：是基于Lua的Torch项目的Python版本，由Facebook开发</li>\n<li>Caffe2，Caffe：是由<a href=\"http://daggerfs.com\" target=\"_blank\" rel=\"external\">UC Berkeley的贾扬清博士</a> 开发的，他已经在Facebook工作，所以Caffe2也是Facebook的一个项目</li>\n<li>Keras：这个项目是对一些深度学习项目的更高层抽象和统一包装，官方支持的后端有TensorFlow，CNTK和Theano，有些深度学习项目也会提供对Keras的支持。当然，有的项目，像PyTorch，本身的抽象就比较高层，与Keras相当，另外像MXNet自己也有类似的前端Gluon。</li>\n</ul>\n<p>从Wiki上的比较列表来看，对深度学习框架的关注点主要有：是否支持GPU加速，支持分布式集群，自动推导梯度，支持的网络类型（CNN，RNN等），是否有预先训练的模型等。<br>问了两位搞机器学习方向的同学，他们觉得TensorFlow偏底层，工程化，不如PyTorch写代码直观，Keras虽然理念很好，但性能上还差一点。他们目前还是用单机的GPU来训练模型，跑一次也要不少时间，但还没有准备搞TensorFlow那种分布式计算集群。</p>\n<p>对DNN的了解太少了，要抓紧时间啊！</p>\n","site":{"data":{}},"excerpt":"<p>在CentOS 7上安装Nvidia GTX 1080 Ti显卡的驱动，以及TensorFlow GPU等深度学习开发环境。<br>就这么突然，跟深度学习扯上边了；-)</p>\n<hr>","more":"<p>上周老板突然说要给机房的Dell服务器分别装两个显卡，让我去看一下，然后把支持GPU的深度学习开发环境搭起来。装显卡是供应商的一个小哥动手的，基本顺利，遇到的小问题是电源供电不足，需要改一下iDrac中的电源设置，将服务器的两路电源互为备用模式改为两路同时供电，这样功率才够跑两个显卡。</p>\n<p>网上一搜，就有不少CentOS上搭环境的文章了，但 1）相关开源项目发展太快，2）不同需求的用户可以有针对性的简化配置过程，所以我把集群上实测过的步骤记录下来。因为自己完全是门外汉，所以还没有涉及具体的深度学习知识。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>网上相关文章的步骤大多是先安装驱动，再安装CUDA，还需要安装C++编译器（g++或msvc），再安装cuDNN库，最后通过<code>pip</code>或<code>conda</code>再安装tensorflow。<a href=\"https://www.tensorflow.org/install/install_linux\" target=\"_blank\" rel=\"external\">TensorFlow官网上的安装说明</a>以及 <a href=\"https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/\" target=\"_blank\" rel=\"external\">Nvidia官网上的安装说明</a>亦是如此。</p>\n<p>CUDA（Compute Unified Device Architecture，统一计算架构）是针对GPU计算加速的开发工具包，就像Windows SDK，或者JDK一样，一些深度学习库（比如TensorFlow）的底层是C++调用的CUDA库，它们提供给深度学习开发者的多是 Python 包装过的接口。一般的开发者直接用这些Python库就可以设计出多种多样的深度学习模型，不再需要跟CUDA打交道。</p>\n<p>如果<strong>不需要从源码编译TensorFlow</strong>，就没必要安装NVIDIA官网上的那个一个多GB的CUDA包和cuDNN库。直接通过<del><code>pip</code>或</del><code>conda</code>安装的<code>tensorflow-gpu</code>库就自带了对应版本的cuda动态链接库，包括 <strong>libnvrtc-builtins.so，libnvrtc.so，libnvToolsExt.so，libnvvm.so，libcudart.so，libcublas.so，libcudnn.so，libcurand.so，libcufft.so，libcusolver.so，libcusparse.so</strong> 等，还有mkl库（Linux的是<code>.so</code>文件，Windows的是<code>.dll</code>文件）。</p>\n<blockquote>\n<p>注意，见下面关于<code>pip</code>和<code>conda</code>的小节。</p>\n</blockquote>\n<p>最近（2017-12-4）Nvidia官网上的CUDA版本已经是9.0，而TensorFlow 1.4 使用的是cuda 8.0，cuDNN则是6.0，python又有2.7、3.5、3.6版。各种版本组合起来还有点麻烦呢。我们先从显卡驱动开始。</p>\n<h1 id=\"安装显卡驱动\"><a href=\"#安装显卡驱动\" class=\"headerlink\" title=\"安装显卡驱动\"></a>安装显卡驱动</h1><p>先看看显卡硬件是不是安装好了，执行<code>lspci | grep NVIDIA</code>，可见已经安装了两个GeForce GTX 1080 Ti显卡：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# lspci | grep NVIDIA</div><div class=\"line\">03:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)</div><div class=\"line\">03:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)</div><div class=\"line\">82:00.0 VGA compatible controller: NVIDIA Corporation GP102 [GeForce GTX 1080 Ti] (rev a1)</div><div class=\"line\">82:00.1 Audio device: NVIDIA Corporation GP102 HDMI Audio Controller (rev a1)</div></pre></td></tr></table></figure></p>\n<p>然后安装驱动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 参考：https://www.dedoimedo.com/computers/centos-7-nvidia-second.html</div><div class=\"line\"># 及 https://www.youtube.com/watch?v=C9Yf71qh0i4</div><div class=\"line\"></div><div class=\"line\">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</div><div class=\"line\">sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</div><div class=\"line\">sudo yum install   nvidia-detect  # 这个命令的输入就是 kmod-nvidia，所以不安装也可以。。。</div><div class=\"line\">sudo yum install $(nvida-detect)</div><div class=\"line\">sudo yum install   kmod-nvidia</div><div class=\"line\">sudo reboot # 重启是必须的</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Ubuntu的命令是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 参考：https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/tensorflow/</div><div class=\"line\"></div><div class=\"line\">sudo add-apt-repository ppa:graphics-drivers/ppa </div><div class=\"line\">sudo apt update</div><div class=\"line\">sudo apt install nvidia- # 敲到 nvidia- 后按一下Tab键，稍等一会，会列出补全项，显示目前最新的是387，</div><div class=\"line\"># 就是说完整的命令是</div><div class=\"line\"></div><div class=\"line\">sudo apt install nvidia-387</div><div class=\"line\"></div><div class=\"line\"># 注意，不要选择 378 版，否则会造成无限重试登录</div><div class=\"line\"># 安装后也要重启系统</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>重启后查看驱动是否安装正确，执行<code>nvidia-smi</code>（还可以执行<code>watch -n 1 nvidia-smi</code>持续监控）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# nvidia-smi</div><div class=\"line\">Mon Dec  4 16:03:57 2017       </div><div class=\"line\">+-----------------------------------------------------------------------------+</div><div class=\"line\">| NVIDIA-SMI 384.98                 Driver Version: 384.98                    |</div><div class=\"line\">|-------------------------------+----------------------+----------------------+</div><div class=\"line\">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class=\"line\">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class=\"line\">|===============================+======================+======================|</div><div class=\"line\">|   0  GeForce GTX 108...  Off  | 00000000:03:00.0 Off |                  N/A |</div><div class=\"line\">|  0%   29C    P8     8W / 250W |      0MiB / 11172MiB |      0%      Default |</div><div class=\"line\">+-------------------------------+----------------------+----------------------+</div><div class=\"line\">|   1  GeForce GTX 108...  Off  | 00000000:82:00.0 Off |                  N/A |</div><div class=\"line\">|  0%   30C    P8     9W / 250W |      0MiB / 11172MiB |      0%      Default |</div><div class=\"line\">+-------------------------------+----------------------+----------------------+</div><div class=\"line\">                                                                               </div><div class=\"line\">+-----------------------------------------------------------------------------+</div><div class=\"line\">| Processes:                                                       GPU Memory |</div><div class=\"line\">|  GPU       PID   Type   Process name                             Usage      |</div><div class=\"line\">|=============================================================================|</div><div class=\"line\">|  No running processes found                                                 |</div><div class=\"line\">+-----------------------------------------------------------------------------+</div></pre></td></tr></table></figure></p>\n<p>还可以执行<code>cat /proc/driver/nvidia/version</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# cat /proc/driver/nvidia/version </div><div class=\"line\">NVRM version: NVIDIA UNIX x86_64 Kernel Module  384.98  Thu Oct 26 15:16:01 PDT 2017</div><div class=\"line\">GCC version:  gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC)</div></pre></td></tr></table></figure></p>\n<p><code>gpustat</code>是一个输出格式比较简单的工具，通过<code>pip install gpustat</code>安装后，输出格式如下（其中n170是机器名）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# gpustat</div><div class=\"line\">n170  Mon Dec  4 16:07:10 2017</div><div class=\"line\">[0] GeForce GTX 1080 Ti | 28&apos;C,   0 % |     0 / 11172 MB |</div><div class=\"line\">[1] GeForce GTX 1080 Ti | 31&apos;C,   0 % |     0 / 11172 MB |</div></pre></td></tr></table></figure></p>\n<h1 id=\"安装-Anaconda-和-Python-3-6\"><a href=\"#安装-Anaconda-和-Python-3-6\" class=\"headerlink\" title=\"安装 Anaconda 和 Python 3.6\"></a>安装 Anaconda 和 Python 3.6</h1><p>这里选择的Python版本是3.6，但不是从Python官网或yum安装的，而是Anaconda集成环境内置的版本，这个集成环境还有<code>conda</code>包管理器，<code>jupyter notebook</code>和<code>numpy</code>，<code>pandas</code>等一些常用的包。</p>\n<p>Anaconda官网下载页是[<a href=\"https://www.anaconda.com/download/\" target=\"_blank\" rel=\"external\">https://www.anaconda.com/download/</a>] ，不过我们从清华的镜像站下载，这样下载速度快一点[<a href=\"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh\" target=\"_blank\" rel=\"external\">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.0.1-Linux-x86_64.sh</a>] 。虽然这个安装文件后缀是<code>.sh</code>，但实际的二进制安装文件都打包在里面了，有525MB。</p>\n<p>安装过程需要用到<code>bzip2</code>，先安装一下<code>sudo yum install -y bzip2</code><br>执行 <code>bash Anaconda3-5.0.1-Linux-x86_64.sh</code> 开始安装，敲回车显示 license agreement ，敲几次空格翻到底，然后输入<code>yes</code>接受协议，再敲回车，安装到默认的路径<code>$HOME/anaconda3</code>，如果这个路径已经存在，就会安装失败，需要删掉或另选路径。<br>安装脚本还会在<code>.bashrc</code>的<code>PATH</code>环境变量加上安装路径。安装结束后，执行<code>source .bashrc</code>，更新<code>PATH</code>环境变量，这时系统的<code>python</code>命令已经变成Anaconda安装的Python 3.6了（因为安装程序把<code>$HOME/anaconda3/bin</code>加在了<code>PATH</code>最前面）。</p>\n<blockquote>\n<p>更改<code>conda</code>源：执行<br><code>conda config --add channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;</code><br><code>conda config --set show_channel_urls yes</code><br>这两个命令其实是把配置项写到了<code>~/.condarc</code>文件，还可以在这里设置http代理：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">channels:</div><div class=\"line\">  - defaults</div><div class=\"line\">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class=\"line\">show_channel_urls: true</div><div class=\"line\"></div><div class=\"line\">proxy_servers:</div><div class=\"line\">    http:  http://127.0.0.1:1080</div><div class=\"line\">    https: http://127.0.0.1:1080</div><div class=\"line\"></div><div class=\"line\">ssl_verify: False</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"安装-TensorFlow\"><a href=\"#安装-TensorFlow\" class=\"headerlink\" title=\"安装 TensorFlow\"></a>安装 TensorFlow</h1><p>执行 <code>conda install tensorflow-gpu</code>，注意，安装的版本是 <code>1.3.0-py36cuda8.0cudnn6.0_1</code> ，不是最新的<code>1.4.0</code>版，不过好处是开箱即用，就这句命令就搞定了。cuda相关的动态库都已经安装在了<code>$HOME/anaconda3/lib</code>。</p>\n<p>执行一下官网的测试例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# python</div><div class=\"line\">Python 3.6.2 |Anaconda custom (64-bit)| (default, Sep 22 2017, 02:03:08) </div><div class=\"line\">[GCC 7.2.0] on linux</div><div class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class=\"line\">&gt;&gt;&gt; import tensorflow as tf</div><div class=\"line\">&gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)</div><div class=\"line\">&gt;&gt;&gt; sess = tf.Session()</div><div class=\"line\">&gt;&gt;&gt; print(sess.run(hello))</div><div class=\"line\">b&apos;Hello, TensorFlow!&apos;</div><div class=\"line\">&gt;&gt;&gt; with tf.Session():</div><div class=\"line\">...     a=tf.constant([1.0, 1.0, 1.0, 1.0])</div><div class=\"line\">...     b=tf.constant(2.0, shape=[4])</div><div class=\"line\">...     out=tf.add(a,b)</div><div class=\"line\">...     print(&quot;result:&quot;,out.eval())</div><div class=\"line\">... </div><div class=\"line\">result: [ 3.  3.  3.  3.]</div></pre></td></tr></table></figure></p>\n<p>OK，下面就要开始学习深度学习模型了。。。</p>\n<blockquote>\n<p>TensorFlow禁用没有使用sse编译的Warning，需添加环境变量 <code>export TF_CPP_MIN_LOG_LEVEL=2</code><br>参考：<a href=\"https://github.com/tensorflow/tensorflow/issues/8037\" target=\"_blank\" rel=\"external\">https://github.com/tensorflow/tensorflow/issues/8037</a></p>\n</blockquote>\n<hr>\n<h1 id=\"在docker容器中的TensorFlow环境\"><a href=\"#在docker容器中的TensorFlow环境\" class=\"headerlink\" title=\"在docker容器中的TensorFlow环境\"></a>在docker容器中的TensorFlow环境</h1><p>需要安装<code>nvidia-container-runtime</code>插件，才能正确运行支持GPU的容器。参考：[<a href=\"https://github.com/NVIDIA/nvidia-docker]。\" target=\"_blank\" rel=\"external\">https://github.com/NVIDIA/nvidia-docker]。</a></p>\n<blockquote>\n<p>注意，安装过程会 <strong>覆盖</strong> <code>/etc/docker/daemon.json</code> 配置文件！需要提前备份。</p>\n</blockquote>\n<p>安装步骤是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -s -L https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo | tee /etc/yum.repos.d/nvidia-docker.repo</div><div class=\"line\"></div><div class=\"line\">yum install -y nvidia-docker2</div><div class=\"line\">pkill -SIGHUP dockerd</div></pre></td></tr></table></figure></p>\n<p>安装后的<code>/etc/docker/daemon.json</code> 如下（阿里云的仓库镜像是后来添加的）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# cat /etc/docker/daemon.json</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;registry-mirrors&quot;: [&quot;https://lmigye0h.mirror.aliyuncs.com&quot;],</div><div class=\"line\">    &quot;runtimes&quot;: &#123;</div><div class=\"line\">        &quot;nvidia&quot;: &#123;</div><div class=\"line\">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</div><div class=\"line\">            &quot;runtimeArgs&quot;: []</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中增加了<code>nvidia-container-runtime</code>这个运行时插件，这是<code>nvidia-docker</code> v2 的实现方式了，运行一个容器验证一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvidia-docker run --rm nvidia/cuda nvidia-smi</div><div class=\"line\">nvidia-docker run --rm -e NVIDIA_VISIBLE_DEVICES=1 nvidia/cuda nvidia-smi</div></pre></td></tr></table></figure></p>\n<p>其中环境变量<code>NVIDIA_VISIBLE_DEVICES</code>是指定GPU设备的可见性，可以是 0,1,… 这样逗号分隔的一个或多个GPU id，也可以是all或none。<br>参考：<a href=\"https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices\" target=\"_blank\" rel=\"external\">https://github.com/nvidia/nvidia-container-runtime#nvidia_visible_devices</a></p>\n<p>其实<code>nvidia-docker</code>只是一个包装脚本，实际执行的命令是<code>docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</code> 。</p>\n<p>至于TensorFlow的容器，执行<br><code>docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu</code></p>\n<p>这个镜像有3.36GB。8888端口是jupyter notebook的，6006是tensorboard的端口，因为我的这台机器的8888端口被占用了，所以映射到了8000。<br>容器启动后，会输出jupyter notebook的访问token，在浏览器输入主机的IP（假设为2.2.2.170）和映射端口号（这里是8000，不是默认的8888），即<br><a href=\"http://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba\" target=\"_blank\" rel=\"external\">http://2.2.2.170:8000/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</a><br>就会打开jupyter notebook，里面有三个TensorFlow入门介绍的ipynb文件，这样就可以编辑运行Python代码了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@n170 ~]# docker run --runtime=nvidia -ti --rm -p 8000:8888 -p 6006:6006 tensorflow/tensorflow:latest-gpu</div><div class=\"line\">[I 03:08:12.136 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret</div><div class=\"line\">[W 03:08:12.159 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.</div><div class=\"line\">[I 03:08:12.165 NotebookApp] Serving notebooks from local directory: /notebooks</div><div class=\"line\">[I 03:08:12.165 NotebookApp] 0 active kernels</div><div class=\"line\">[I 03:08:12.165 NotebookApp] The Jupyter Notebook is running at:</div><div class=\"line\">[I 03:08:12.165 NotebookApp] http://[all ip addresses on your system]:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</div><div class=\"line\">[I 03:08:12.165 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</div><div class=\"line\">[C 03:08:12.166 NotebookApp] </div><div class=\"line\">    </div><div class=\"line\">    Copy/paste this URL into your browser when you connect for the first time,</div><div class=\"line\">    to login with a token:</div><div class=\"line\">        http://localhost:8888/?token=79f542ddc22fb567f3c2900c9310f1ce30847d5c5f927cba</div><div class=\"line\"></div><div class=\"line\">[root@n170 ~]# # 按 Ctrl + p, q 键退出容器交互终端，容器仍在后台运行</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Anaconda 中也有jupyter notebook，在主机执行命令<code>jupyter notebook</code>就会运行后台服务，并启动浏览器打开页面。<br>默认只能允许localhost访问，如果需要设置别的机器也可以通过主机的IP地址访问notebook，可以参考 [<a href=\"http://jupyter-notebook.readthedocs.io/en/stable/public_server.html\" target=\"_blank\" rel=\"external\">http://jupyter-notebook.readthedocs.io/en/stable/public_server.html</a>] 。</p>\n<p>notebook中用matplotlib画图，如果不想写<code>plt.show()</code>，可以在代码前加上<code>%matplotlib inline</code>指令，这样执行<code>plt.plot(...)</code>就会输出图形。</p>\n</blockquote>\n<h1 id=\"pip-和-cuda\"><a href=\"#pip-和-cuda\" class=\"headerlink\" title=\"pip 和 cuda\"></a>pip 和 cuda</h1><p>如果不是按上面小节的步骤使用<code>conda</code>，就要按照教程的步骤，先安装cuda了。</p>\n<blockquote>\n<p>pip换源，在文件<code>$HOME/.pip/pip.conf</code>中添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[global]</div><div class=\"line\">trusted-host =  mirrors.tuna.tsinghua.edu.cn</div><div class=\"line\">index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/simple</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>没有安装cuda，直接执行<code>pip install tensorflow-gpu</code>，取决于系统的Python版本，不论2.7，3.5或3.6版，都可以安装对应1.4.0版本，但执行上面的测试例子，就会报错：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">... ...</div><div class=\"line\">ImportError: libcublas.so.8.0: cannot open shared object file: No such file or directory</div><div class=\"line\">... ...</div></pre></td></tr></table></figure></p>\n<p>就是说找不到cuda的动态库。</p>\n<blockquote>\n<p>前面也提到了，其实cuda类似JDK，但Nvidia没有把cuda的动态库打包单独提供（类似JRE）。<br><code>conda</code>自己打包了需要的动态库（cudatoolkit，cudnn），可以一键安装，但<code>pip</code>就没有这么贴心了，需要安装完整版的cuda SDK。</p>\n</blockquote>\n<p>需要下载的文件和具体安装步骤可见[<a href=\"https://developer.nvidia.com/cuda-downloads\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cuda-downloads</a>] ，目前Nvidia官网提供的是cuda 9.0（不知向前兼容性如何），旧版cuda的下载链接是[<a href=\"https://developer.nvidia.com/cuda-toolkit-archive\" target=\"_blank\" rel=\"external\">https://developer.nvidia.com/cuda-toolkit-archive</a>] ，还要注册一下，然后下载并安装cuDNN的库。</p>\n<p>如果之前没有安装显卡驱动的话，按上面官网的介绍，以为上面的步骤会把cuda 9.0和内核驱动一起安装上，而且确实安装了名为<code>nvidia-kmod</code>的包，但重启后执行<code>nvidia-smi</code>，发现并没有安装成功，不知是什么问题。<br>所以还是要按照更前面小节的步骤从elrepo安装<code>kmod-nvidia</code>包，不过安装过程会有包冲突，需要根据提示信息卸载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum erase 1:nvidia-kmod-384.81-2.el7.x86_64</div><div class=\"line\">sudo yum erase 1:xorg-x11-drv-nvidia-384.81-1.el7.x86_64</div><div class=\"line\">sudo yum-config-manager --disable cuda-9-0-local</div></pre></td></tr></table></figure></p>\n<p>之后再重新执行安装<code>kmod-nvidia</code>的命令，重启后验证安装是否正确。再增加环境变量<br><code>export LD_LIBRARY_PATH=/usr/local/cuda/lib64/:$LD_LIBRARY_PATH</code><br>TensorFlow应该就可以找到需要的动态库了。</p>\n<h1 id=\"深度学习框架\"><a href=\"#深度学习框架\" class=\"headerlink\" title=\"深度学习框架\"></a>深度学习框架</h1><p>参考：[<a href=\"https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software\" target=\"_blank\" rel=\"external\">https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software</a>]</p>\n<p>比较常见的几个框架有：</p>\n<ul>\n<li>Tensorflow : Google的项目，参考TensorFlow OSDI`2016的论文，设计目标是在大规模集群和异构硬件（GPU，TPU，ASIC等）上支持深度学习网络的训练和应用</li>\n<li>MXNet：由<a href=\"https://www.cs.cmu.edu/~muli/\" target=\"_blank\" rel=\"external\">CMU的李沐博士</a> ，<a href=\"https://homes.cs.washington.edu/~tqchen/\" target=\"_blank\" rel=\"external\">华盛顿大学的陈天齐博士</a> 等开发的项目，他还有一篇博客介绍了<a href=\"http://mli.github.io/2015/12/03/mxnet-overview/\" target=\"_blank\" rel=\"external\">MXNet设计和实现</a> 。目前是Apache的孵化项目，Amazon也在推广MXNet（李沐博士在Amazon工作）。在MXNet的基础上，他们还发布了<a href=\"http://mp.weixin.qq.com/s/_9aY-7aTZDOjeWFKntLnXA\" target=\"_blank\" rel=\"external\">更灵活的前端Gluon（胶子）</a> 和<a href=\"https://zhuanlan.zhihu.com/p/29914989\" target=\"_blank\" rel=\"external\">更可拓展的后端NNVM compiler</a></li>\n<li>Cognitive Toolkit（CNTK）：这是微软的深度学习项目</li>\n<li>Theano：蒙特利尔大学MILA实验室开发的项目，2017年11月15日发布1.0版后就不再继续开发</li>\n<li>PyTorch：是基于Lua的Torch项目的Python版本，由Facebook开发</li>\n<li>Caffe2，Caffe：是由<a href=\"http://daggerfs.com\" target=\"_blank\" rel=\"external\">UC Berkeley的贾扬清博士</a> 开发的，他已经在Facebook工作，所以Caffe2也是Facebook的一个项目</li>\n<li>Keras：这个项目是对一些深度学习项目的更高层抽象和统一包装，官方支持的后端有TensorFlow，CNTK和Theano，有些深度学习项目也会提供对Keras的支持。当然，有的项目，像PyTorch，本身的抽象就比较高层，与Keras相当，另外像MXNet自己也有类似的前端Gluon。</li>\n</ul>\n<p>从Wiki上的比较列表来看，对深度学习框架的关注点主要有：是否支持GPU加速，支持分布式集群，自动推导梯度，支持的网络类型（CNN，RNN等），是否有预先训练的模型等。<br>问了两位搞机器学习方向的同学，他们觉得TensorFlow偏底层，工程化，不如PyTorch写代码直观，Keras虽然理念很好，但性能上还差一点。他们目前还是用单机的GPU来训练模型，跑一次也要不少时间，但还没有准备搞TensorFlow那种分布式计算集群。</p>\n<p>对DNN的了解太少了，要抓紧时间啊！</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj9s6hmga00009s4fdy053yf9","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmgx000a9s4fzgrloxfm"},{"post_id":"cj9s6hmgq00059s4f3yzvt8hk","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmgy000c9s4fk4eyeg22"},{"post_id":"cj9s6hmgt00079s4f0n9fj7bz","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh0000f9s4f303a4qdn"},{"post_id":"cj9s6hmgf00019s4fubvyf7lw","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh1000h9s4f3umio9vr"},{"post_id":"cj9s6hmgv00089s4fjohqs8ll","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh2000j9s4fjwxi55l8"},{"post_id":"cj9s6hmgy000b9s4firh86gus","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh4000l9s4fupqh81ij"},{"post_id":"cj9s6hmgl00039s4ffs8admn7","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh5000n9s4fj533rk6a"},{"post_id":"cj9s6hmgz000d9s4fbpnq3yyr","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh7000p9s4fqjassrjd"},{"post_id":"cj9s6hmh0000g9s4frocodlyo","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmh8000r9s4f4vfly9qi"},{"post_id":"cj9s6hmgm00049s4fw85z86x7","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmh9000t9s4ffbi3c0l8"},{"post_id":"cj9s6hmh1000i9s4fw6qu90a8","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmha000v9s4fcl19i6vv"},{"post_id":"cj9s6hmh2000k9s4fwggigh48","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmhb000x9s4f0ry74fts"},{"post_id":"cj9s6hmh4000m9s4f6kzbtko3","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhd000z9s4fwnsm6pn3"},{"post_id":"cj9s6hmh5000o9s4fp1jsh6uq","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhd00109s4fkxd7d0kn"},{"post_id":"cj9s6hmh7000q9s4fa77omfb9","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhe00119s4fhcnqj2ou"},{"post_id":"cj9s6hmh9000s9s4f6d04jqz7","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmhe00129s4fy0ges5d7"},{"post_id":"cj9s6hmha000u9s4fafr54216","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhf00139s4fo5xzbokw"},{"post_id":"cj9s6hmhb000w9s4fb2i2hegw","category_id":"cj9s6hmgj00029s4fafs34nd5","_id":"cj9s6hmhf00149s4fsic1fbad"},{"post_id":"cj9s6hmhc000y9s4f4l6omn7q","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhf00159s4f0iytmsb6"},{"post_id":"cj9s6hmhj00169s4fle8xnvvp","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cj9s6hmhk00179s4fmb6qpqei"},{"post_id":"cjas90uya00006s4fosn5yf7z","category_id":"cj9s6hmh0000e9s4fdh18ogks","_id":"cjas90uyj00016s4frrdwevbo"}],"PostTag":[],"Tag":[]}}